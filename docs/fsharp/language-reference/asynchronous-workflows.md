---
title: 异步工作流 (F#)
description: '了解支持在 F # 编程语言以异步方式执行计算执行而不会阻止其他工作的执行。'
ms.date: 05/16/2016
ms.openlocfilehash: 5f7a1a623e143e1bedf51c1a1ed477bb867b280a
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/04/2018
ms.locfileid: "33566358"
---
# <a name="asynchronous-workflows"></a><span data-ttu-id="fbc44-103">异步工作流</span><span class="sxs-lookup"><span data-stu-id="fbc44-103">Asynchronous Workflows</span></span>

> [!NOTE]
<span data-ttu-id="fbc44-104">API 参考链接将转至 MSDN。</span><span class="sxs-lookup"><span data-stu-id="fbc44-104">The API reference link will take you to MSDN.</span></span>  <span data-ttu-id="fbc44-105">Docs.microsoft.com API 参考尚未完成。</span><span class="sxs-lookup"><span data-stu-id="fbc44-105">The docs.microsoft.com API reference is not complete.</span></span>

<span data-ttu-id="fbc44-106">本主题描述 F # 中的支持用于执行计算以异步方式，即，而不会阻止其他工作的执行。</span><span class="sxs-lookup"><span data-stu-id="fbc44-106">This topic describes support in F# for performing computations asynchronously, that is, without blocking execution of other work.</span></span> <span data-ttu-id="fbc44-107">例如，异步计算可用来编写应用程序保持对用户的响应，因为应用程序会执行其他工作的 ui。</span><span class="sxs-lookup"><span data-stu-id="fbc44-107">For example, asynchronous computations can be used to write applications that have UIs that remain responsive to users as the application performs other work.</span></span>

## <a name="syntax"></a><span data-ttu-id="fbc44-108">语法</span><span class="sxs-lookup"><span data-stu-id="fbc44-108">Syntax</span></span>

```fsharp
async { expression }
```

## <a name="remarks"></a><span data-ttu-id="fbc44-109">备注</span><span class="sxs-lookup"><span data-stu-id="fbc44-109">Remarks</span></span>

<span data-ttu-id="fbc44-110">在上述语法中，计算由`expression`设置为异步运行，也就是说，而不会阻止当前计算线程执行异步睡眠操作、 I/O 和其他异步操作时。</span><span class="sxs-lookup"><span data-stu-id="fbc44-110">In the previous syntax, the computation represented by `expression` is set up to run asynchronously, that is, without blocking the current computation thread when asynchronous sleep operations, I/O, and other asynchronous operations are performed.</span></span> <span data-ttu-id="fbc44-111">异步计算通常会在后台线程上启动，同时在当前线程上继续执行。</span><span class="sxs-lookup"><span data-stu-id="fbc44-111">Asynchronous computations are often started on a background thread while execution continues on the current thread.</span></span> <span data-ttu-id="fbc44-112">表达式的类型是`Async<'T>`，其中`'T`是由表达式返回的类型时`return`使用关键字。</span><span class="sxs-lookup"><span data-stu-id="fbc44-112">The type of the expression is `Async<'T>`, where `'T` is the type returned by the expression when the `return` keyword is used.</span></span> <span data-ttu-id="fbc44-113">此类表达式中的代码称为*异步块*，或*异步块*。</span><span class="sxs-lookup"><span data-stu-id="fbc44-113">The code in such an expression is referred to as an *asynchronous block*, or *async block*.</span></span>

<span data-ttu-id="fbc44-114">有多种方法的异步编程，和[ `Async` ](https://msdn.microsoft.com/library/03eb4d12-a01a-4565-a077-5e83f17cf6f7)类提供支持多个方案的方法。</span><span class="sxs-lookup"><span data-stu-id="fbc44-114">There are a variety of ways of programming asynchronously, and the [`Async`](https://msdn.microsoft.com/library/03eb4d12-a01a-4565-a077-5e83f17cf6f7) class provides methods that support several scenarios.</span></span> <span data-ttu-id="fbc44-115">常规方法是创建`Async`表示计算或你想要以异步方式运行的计算并使用触发的函数之一，然后启动这些计算的对象。</span><span class="sxs-lookup"><span data-stu-id="fbc44-115">The general approach is to create `Async` objects that represent the computation or computations that you want to run asynchronously, and then start these computations by using one of the triggering functions.</span></span> <span data-ttu-id="fbc44-116">各种触发函数提供不同的方法来运行异步计算，并使用哪一个取决于是否想要使用当前线程、 后台线程或.NET Framework 任务对象，以及是否有延续在计算完成时，应运行的函数。</span><span class="sxs-lookup"><span data-stu-id="fbc44-116">The various triggering functions provide different ways of running asynchronous computations, and which one you use depends on whether you want to use the current thread, a background thread, or a .NET Framework task object, and whether there are continuation functions that should run when the computation finishes.</span></span> <span data-ttu-id="fbc44-117">例如，若要在当前线程上启动一个异步计算，可以使用[ `Async.StartImmediate` ](https://msdn.microsoft.com/library/2f71d1cc-187f-48cf-ac66-e7fda41c46e3)。</span><span class="sxs-lookup"><span data-stu-id="fbc44-117">For example, to start an asynchronous computation on the current thread, you can use [`Async.StartImmediate`](https://msdn.microsoft.com/library/2f71d1cc-187f-48cf-ac66-e7fda41c46e3).</span></span> <span data-ttu-id="fbc44-118">当你启动一个异步计算从 UI 线程时，就不会阻止处理用户操作的键击和鼠标活动，例如，因此你的应用程序保持响应性的主要事件循环。</span><span class="sxs-lookup"><span data-stu-id="fbc44-118">When you start an asynchronous computation from the UI thread, you do not block the main event loop that processes user actions such as keystrokes and mouse activity, so your application remains responsive.</span></span>

## <a name="asynchronous-binding-by-using-let"></a><span data-ttu-id="fbc44-119">通过使用允许的异步绑定 ！</span><span class="sxs-lookup"><span data-stu-id="fbc44-119">Asynchronous Binding by Using let!</span></span>

<span data-ttu-id="fbc44-120">在异步工作流中，某些表达式和操作是同步的，而有些则旨在异步返回结果的时间计算。</span><span class="sxs-lookup"><span data-stu-id="fbc44-120">In an asynchronous workflow, some expressions and operations are synchronous, and some are longer computations that are designed to return a result asynchronously.</span></span> <span data-ttu-id="fbc44-121">当调用的方法以异步方式，而不是一个普通`let`绑定，你将使用`let!`。</span><span class="sxs-lookup"><span data-stu-id="fbc44-121">When you call a method asynchronously, instead of an ordinary `let` binding, you use `let!`.</span></span> <span data-ttu-id="fbc44-122">效果`let!`旨在使正在执行计算时，继续在其他计算或线程上执行。</span><span class="sxs-lookup"><span data-stu-id="fbc44-122">The effect of `let!` is to enable execution to continue on other computations or threads as the computation is being performed.</span></span> <span data-ttu-id="fbc44-123">之后的右侧`let!`绑定返回时，异步工作流的剩余部分将继续执行。</span><span class="sxs-lookup"><span data-stu-id="fbc44-123">After the right side of the `let!` binding returns, the rest of the asynchronous workflow resumes execution.</span></span>

<span data-ttu-id="fbc44-124">下面的代码显示之间的差异`let`和`let!`。</span><span class="sxs-lookup"><span data-stu-id="fbc44-124">The following code shows the difference between `let` and `let!`.</span></span> <span data-ttu-id="fbc44-125">使用的代码行`let`只需创建为一个对象，你可以在以后运行通过使用，例如，一个异步计算`Async.StartImmediate`或[ `Async.RunSynchronously` ](https://msdn.microsoft.com/library/0a6663a9-50f2-4d38-8bf3-cefd1a51fd6b)。</span><span class="sxs-lookup"><span data-stu-id="fbc44-125">The line of code that uses `let` just creates an asynchronous computation as an object that you can run later by using, for example, `Async.StartImmediate` or [`Async.RunSynchronously`](https://msdn.microsoft.com/library/0a6663a9-50f2-4d38-8bf3-cefd1a51fd6b).</span></span> <span data-ttu-id="fbc44-126">使用的代码行`let!`开始计算，并在结果可用，点执行过程才会继续之前然后挂起线程。</span><span class="sxs-lookup"><span data-stu-id="fbc44-126">The line of code that uses `let!` starts the computation, and then the thread is suspended until the result is available, at which point execution continues.</span></span>

```fsharp
// let just stores the result as an asynchronous operation.
let (result1 : Async<byte[]>) = stream.AsyncRead(bufferSize)
// let! completes the asynchronous operation and returns the data.
let! (result2 : byte[])  = stream.AsyncRead(bufferSize)
```

<span data-ttu-id="fbc44-127">除了`let!`，你可以使用`use!`执行异步绑定。</span><span class="sxs-lookup"><span data-stu-id="fbc44-127">In addition to `let!`, you can use `use!` to perform asynchronous bindings.</span></span> <span data-ttu-id="fbc44-128">之间的差异`let!`和`use!`之间的差异相同`let`和`use`。</span><span class="sxs-lookup"><span data-stu-id="fbc44-128">The difference between `let!` and `use!` is the same as the difference between `let` and `use`.</span></span> <span data-ttu-id="fbc44-129">有关`use!`，在当前范围的结束位置的释放此对象。</span><span class="sxs-lookup"><span data-stu-id="fbc44-129">For `use!`, the object is disposed of at the close of the current scope.</span></span> <span data-ttu-id="fbc44-130">请注意，在当前版本的 F # 语言，`use!`不允许的值初始化为 null，即使`use`未。</span><span class="sxs-lookup"><span data-stu-id="fbc44-130">Note that in the current release of the F# language, `use!` does not allow a value to be initialized to null, even though `use` does.</span></span>

## <a name="asynchronous-primitives"></a><span data-ttu-id="fbc44-131">异步基元</span><span class="sxs-lookup"><span data-stu-id="fbc44-131">Asynchronous Primitives</span></span>

<span data-ttu-id="fbc44-132">执行一个异步任务，并返回结果的方法称为*异步基元*，并这些由专用于`let!`。</span><span class="sxs-lookup"><span data-stu-id="fbc44-132">A method that performs a single asynchronous task and returns the result is called an *asynchronous primitive*, and these are designed specifically for use with `let!`.</span></span> <span data-ttu-id="fbc44-133">多个异步基元都在 F # 核心库中定义。</span><span class="sxs-lookup"><span data-stu-id="fbc44-133">Several asynchronous primitives are defined in the F# core library.</span></span> <span data-ttu-id="fbc44-134">模块中定义为 Web 应用程序的两个此类方法[ `Microsoft.FSharp.Control.WebExtensions` ](https://msdn.microsoft.com/library/95ef17bc-ee3f-44ba-8a11-c90fcf4cf003): [ `WebRequest.AsyncGetResponse` ](https://msdn.microsoft.com/library/09a60c31-e6e2-4b5c-ad23-92a86e50060c)和[ `WebClient.AsyncDownloadString` ](https://msdn.microsoft.com/library/8a85a9b7-f712-4cac-a0ce-0a797f8ea32a)。</span><span class="sxs-lookup"><span data-stu-id="fbc44-134">Two such methods for Web applications are defined in the module [`Microsoft.FSharp.Control.WebExtensions`](https://msdn.microsoft.com/library/95ef17bc-ee3f-44ba-8a11-c90fcf4cf003): [`WebRequest.AsyncGetResponse`](https://msdn.microsoft.com/library/09a60c31-e6e2-4b5c-ad23-92a86e50060c) and [`WebClient.AsyncDownloadString`](https://msdn.microsoft.com/library/8a85a9b7-f712-4cac-a0ce-0a797f8ea32a).</span></span> <span data-ttu-id="fbc44-135">这两个基元从 Web 页上，为其提供 URL 下载数据。</span><span class="sxs-lookup"><span data-stu-id="fbc44-135">Both primitives download data from a Web page, given a URL.</span></span> <span data-ttu-id="fbc44-136">`AsyncGetResponse` 生成`System.Net.WebResponse`对象，和`AsyncDownloadString`生成一个字符串，表示用于网页的 HTML。</span><span class="sxs-lookup"><span data-stu-id="fbc44-136">`AsyncGetResponse` produces a `System.Net.WebResponse` object, and `AsyncDownloadString` produces a string that represents the HTML for a Web page.</span></span>

<span data-ttu-id="fbc44-137">中包含的异步 I/O 操作的几个基元[ `Microsoft.FSharp.Control.CommonExtensions` ](https://msdn.microsoft.com/library/2edb67cb-6814-4a30-849f-b6dbdd042396)模块。</span><span class="sxs-lookup"><span data-stu-id="fbc44-137">Several primitives for asynchronous I/O operations are included in the [`Microsoft.FSharp.Control.CommonExtensions`](https://msdn.microsoft.com/library/2edb67cb-6814-4a30-849f-b6dbdd042396) module.</span></span> <span data-ttu-id="fbc44-138">这些扩展方法的`System.IO.Stream`类[ `Stream.AsyncRead` ](https://msdn.microsoft.com/library/85698aaa-bdda-47e6-abed-3730f59fda5e)和[ `Stream.AsyncWrite` ](https://msdn.microsoft.com/library/1b0a2751-e42a-47e1-bd27-020224adc618)。</span><span class="sxs-lookup"><span data-stu-id="fbc44-138">These extension methods of the `System.IO.Stream` class are [`Stream.AsyncRead`](https://msdn.microsoft.com/library/85698aaa-bdda-47e6-abed-3730f59fda5e) and [`Stream.AsyncWrite`](https://msdn.microsoft.com/library/1b0a2751-e42a-47e1-bd27-020224adc618).</span></span>

<span data-ttu-id="fbc44-139">其他异步基元位于[F # 增强工具](https://fsprojects.github.io/VisualFSharpPowerTools/)。</span><span class="sxs-lookup"><span data-stu-id="fbc44-139">Additional asynchronous primitives are available in the [F# PowerTools](https://fsprojects.github.io/VisualFSharpPowerTools/).</span></span> <span data-ttu-id="fbc44-140">你还可以通过定义其完整的主体括在异步块中的函数编写你自己的异步基元。</span><span class="sxs-lookup"><span data-stu-id="fbc44-140">You can also write your own asynchronous primitives by defining a function whose complete body is enclosed in an async block.</span></span>

<span data-ttu-id="fbc44-141">若要使用的 F # 异步编程模型与其他异步模型设计.NET Framework 中的异步方法，你创建的函数，返回的 F #`Async`对象。</span><span class="sxs-lookup"><span data-stu-id="fbc44-141">To use asynchronous methods in the .NET Framework that are designed for other asynchronous models with the F# asynchronous programming model, you create a function that returns an F# `Async` object.</span></span> <span data-ttu-id="fbc44-142">F # 库具有函数，这可以更方便地执行操作。</span><span class="sxs-lookup"><span data-stu-id="fbc44-142">The F# library has functions that make this easy to do.</span></span>

<span data-ttu-id="fbc44-143">使用异步工作流的一个示例是为了;还有许多其他的方法的文档中[异步类](https://msdn.microsoft.com/library/03eb4d12-a01a-4565-a077-5e83f17cf6f7)。</span><span class="sxs-lookup"><span data-stu-id="fbc44-143">One example of using asynchronous workflows is included here; there are many others in the documentation for the methods of the [Async class](https://msdn.microsoft.com/library/03eb4d12-a01a-4565-a077-5e83f17cf6f7).</span></span>

<span data-ttu-id="fbc44-144">此示例演示如何使用异步工作流来并行执行计算。</span><span class="sxs-lookup"><span data-stu-id="fbc44-144">This example shows how to use asynchronous workflows to perform computations in parallel.</span></span>

<span data-ttu-id="fbc44-145">在下面的代码示例，函数`fetchAsync`获取 Web 请求返回的 HTML 文本。</span><span class="sxs-lookup"><span data-stu-id="fbc44-145">In the following code example, a function `fetchAsync` gets the HTML text returned from a Web request.</span></span> <span data-ttu-id="fbc44-146">`fetchAsync`函数包含异步代码块。</span><span class="sxs-lookup"><span data-stu-id="fbc44-146">The `fetchAsync` function contains an asynchronous block of code.</span></span> <span data-ttu-id="fbc44-147">当绑定由对结果的异步基元，在这种情况下[ `AsyncDownloadString` ](https://msdn.microsoft.com/library/8a85a9b7-f712-4cac-a0ce-0a797f8ea32a)，但仍使 ！</span><span class="sxs-lookup"><span data-stu-id="fbc44-147">When a binding is made to the result of an asynchronous primitive, in this case [`AsyncDownloadString`](https://msdn.microsoft.com/library/8a85a9b7-f712-4cac-a0ce-0a797f8ea32a), let!</span></span> <span data-ttu-id="fbc44-148">而不是让使用。</span><span class="sxs-lookup"><span data-stu-id="fbc44-148">is used instead of let.</span></span>

<span data-ttu-id="fbc44-149">使用函数[ `Async.RunSynchronously` ](https://msdn.microsoft.com/library/0a6663a9-50f2-4d38-8bf3-cefd1a51fd6b)来执行异步操作并等待其结果。</span><span class="sxs-lookup"><span data-stu-id="fbc44-149">You use the function [`Async.RunSynchronously`](https://msdn.microsoft.com/library/0a6663a9-50f2-4d38-8bf3-cefd1a51fd6b) to execute an asynchronous operation and wait for its result.</span></span> <span data-ttu-id="fbc44-150">例如，你可以执行多个异步操作并行使用[ `Async.Parallel` ](https://msdn.microsoft.com/library/aa9b0355-2d55-4858-b943-cbe428de9dc4)函数，`Async.RunSynchronously`函数。</span><span class="sxs-lookup"><span data-stu-id="fbc44-150">As an example, you can execute multiple asynchronous operations in parallel by using the [`Async.Parallel`](https://msdn.microsoft.com/library/aa9b0355-2d55-4858-b943-cbe428de9dc4) function together with the `Async.RunSynchronously` function.</span></span> <span data-ttu-id="fbc44-151">`Async.Parallel`函数的列表`Async`的对象，设置了代码，每个`Async`task 对象以在并行，并返回运行`Async`对象，表示并行计算。</span><span class="sxs-lookup"><span data-stu-id="fbc44-151">The `Async.Parallel` function takes a list of the `Async` objects, sets up the code for each `Async` task object to run in parallel, and returns an `Async` object that represents the parallel computation.</span></span> <span data-ttu-id="fbc44-152">单个操作，情况一样，你调用`Async.RunSynchronously`以开始执行。</span><span class="sxs-lookup"><span data-stu-id="fbc44-152">Just as for a single operation, you call `Async.RunSynchronously` to start the execution.</span></span>

<span data-ttu-id="fbc44-153">`runAll`函数将启动三个并行的异步工作流，并等待，直至它们全部完成。</span><span class="sxs-lookup"><span data-stu-id="fbc44-153">The `runAll` function launches three asynchronous workflows in parallel and waits until they have all completed.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet8003.fs)]

## <a name="see-also"></a><span data-ttu-id="fbc44-154">请参阅</span><span class="sxs-lookup"><span data-stu-id="fbc44-154">See Also</span></span>

[<span data-ttu-id="fbc44-155">F# 语言参考</span><span class="sxs-lookup"><span data-stu-id="fbc44-155">F# Language Reference</span></span>](index.md)

[<span data-ttu-id="fbc44-156">计算表达式</span><span class="sxs-lookup"><span data-stu-id="fbc44-156">Computation Expressions</span></span>](computation-expressions.md)

[<span data-ttu-id="fbc44-157">Control.Async 类</span><span class="sxs-lookup"><span data-stu-id="fbc44-157">Control.Async Class</span></span>](https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.async-class-%5bfsharp%5d)
