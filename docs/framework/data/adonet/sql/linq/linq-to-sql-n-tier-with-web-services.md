---
title: "具有 Web 服务的 LINQ to SQL N 层"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-ado
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 9cb10eb8-957f-4beb-a271-5f682016fed2
caps.latest.revision: "3"
author: douglaslMS
ms.author: douglasl
manager: craigg
ms.workload: dotnet
ms.openlocfilehash: 79b9b1270f99720dec6b6369706f8a2f601d249e
ms.sourcegitcommit: c0dd436f6f8f44dc80dc43b07f6841a00b74b23f
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/19/2018
---
# <a name="linq-to-sql-n-tier-with-web-services"></a><span data-ttu-id="8e353-102">具有 Web 服务的 LINQ to SQL N 层</span><span class="sxs-lookup"><span data-stu-id="8e353-102">LINQ to SQL N-Tier with Web Services</span></span>
[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]<span data-ttu-id="8e353-103">旨在特别针对在如 Web 服务的松耦合数据访问层 (DAL) 的中间层上使用。</span><span class="sxs-lookup"><span data-stu-id="8e353-103"> is designed especially for use on the middle tier in a loosely-coupled data access layer (DAL) such as a Web service.</span></span> <span data-ttu-id="8e353-104">如果表示层为 ASP.NET 网页，则使用 <xref:System.Web.UI.WebControls.LinqDataSource> Web 服务器控件管理用户界面与中间层上的 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] 之间的数据传输。</span><span class="sxs-lookup"><span data-stu-id="8e353-104">If the presentation tier is an ASP.NET Web page, then you use the <xref:System.Web.UI.WebControls.LinqDataSource> Web server control to manage the data transfer between the user interface and [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] on the middle-tier.</span></span> <span data-ttu-id="8e353-105">如果表示层不是 ASP.NET 页，则中间层和表示层都必须执行一些附加工作以管理数据的序列化和反序列化。</span><span class="sxs-lookup"><span data-stu-id="8e353-105">If the presentation tier is not an ASP.NET page, then both the middle-tier and the presentation tier must do some additional work to manage the serialization and deserialization of data.</span></span>  
  
## <a name="setting-up-linq-to-sql-on-the-middle-tier"></a><span data-ttu-id="8e353-106">在中间层上设置 LINQ to SQL</span><span class="sxs-lookup"><span data-stu-id="8e353-106">Setting up LINQ to SQL on the Middle Tier</span></span>  
 <span data-ttu-id="8e353-107">在 Web 服务或 n 层应用程序中，中间层包含数据上下文和实体类。</span><span class="sxs-lookup"><span data-stu-id="8e353-107">In a Web service or n-tier application, the middle tier contains the data context and the entity classes.</span></span> <span data-ttu-id="8e353-108">可以手动创建这些类，或是按照文档中其他部分的说明使用 SQLMetal.exe 或[!INCLUDE[vs_ordesigner_long](../../../../../../includes/vs-ordesigner-long-md.md)]创建。</span><span class="sxs-lookup"><span data-stu-id="8e353-108">You can create these classes manually, or by using either SQLMetal.exe or the [!INCLUDE[vs_ordesigner_long](../../../../../../includes/vs-ordesigner-long-md.md)] as described elsewhere in the documentation.</span></span> <span data-ttu-id="8e353-109">在设计时，您可以选择使实体类可序列化。</span><span class="sxs-lookup"><span data-stu-id="8e353-109">At design time, you have the option to make the entity classes serializable.</span></span> <span data-ttu-id="8e353-110">有关详细信息，请参阅[如何： 使实体可序列化](../../../../../../docs/framework/data/adonet/sql/linq/how-to-make-entities-serializable.md)。</span><span class="sxs-lookup"><span data-stu-id="8e353-110">For more information, see [How to: Make Entities Serializable](../../../../../../docs/framework/data/adonet/sql/linq/how-to-make-entities-serializable.md).</span></span> <span data-ttu-id="8e353-111">也可以选择创建包装要序列化的数据的一组单独类，然后当在 [!INCLUDE[vbteclinq](../../../../../../includes/vbteclinq-md.md)] 查询中返回数据时投射到这些可序列化类型中。</span><span class="sxs-lookup"><span data-stu-id="8e353-111">Another option is to create a separate set of classes that encapsulate the data to be serialized, and then project into those serializable types when you return data in your [!INCLUDE[vbteclinq](../../../../../../includes/vbteclinq-md.md)] queries.</span></span>  
  
 <span data-ttu-id="8e353-112">随后可以使用客户端为进行检索、插入和更新数据而调用的方法来定义接口。</span><span class="sxs-lookup"><span data-stu-id="8e353-112">You then define the interface with the methods that the clients will call to retrieve, insert and update data.</span></span> <span data-ttu-id="8e353-113">这些接口方法包装 [!INCLUDE[vbteclinq](../../../../../../includes/vbteclinq-md.md)] 查询。</span><span class="sxs-lookup"><span data-stu-id="8e353-113">The interface methods wrap your [!INCLUDE[vbteclinq](../../../../../../includes/vbteclinq-md.md)] queries.</span></span> <span data-ttu-id="8e353-114">可以使用任何类型的序列化机制处理远程方法调用和数据的序列化。</span><span class="sxs-lookup"><span data-stu-id="8e353-114">You can use any kind of serialization mechanism to handle the remote method calls and the serialization of data.</span></span> <span data-ttu-id="8e353-115">唯一的要求是如果您的对象模型中具有循环或双向关系（如标准 Northwind 对象模型中的 Customers 与 Orders 之间的关系），则必须使用支持这种关系的序列化程序。</span><span class="sxs-lookup"><span data-stu-id="8e353-115">The only requirement is that if you have cyclic or bi-directional relationships in your object model, such as that between Customers and Orders in the standard Northwind object model, then you must use a serializer that supports it.</span></span> <span data-ttu-id="8e353-116">Windows Communication Foundation (WCF) <xref:System.Runtime.Serialization.DataContractSerializer> 支持双向关系，但是使用非 WCF Web 服务的 XmlSerializer 不支持这种关系。</span><span class="sxs-lookup"><span data-stu-id="8e353-116">The Windows Communication Foundation (WCF) <xref:System.Runtime.Serialization.DataContractSerializer> supports bi-directional relationships but the XmlSerializer that is used with non-WCF Web services does not.</span></span> <span data-ttu-id="8e353-117">如果您选择使用 XmlSerializer，则必须确保您的对象模型没有循环关系。</span><span class="sxs-lookup"><span data-stu-id="8e353-117">If you select to use the XmlSerializer, then you must make sure that your object model has no cyclic relationships.</span></span>  
  
 <span data-ttu-id="8e353-118">有关 Windows Communication Foundation 的详细信息，请参阅[Windows Communication Foundation 服务和 Visual Studio 中的 WCF 数据服务](/visualstudio/data-tools/windows-communication-foundation-services-and-wcf-data-services-in-visual-studio)。</span><span class="sxs-lookup"><span data-stu-id="8e353-118">For more information about Windows Communication Foundation, see [Windows Communication Foundation Services and WCF Data Services in Visual Studio](/visualstudio/data-tools/windows-communication-foundation-services-and-wcf-data-services-in-visual-studio).</span></span>  
  
 <span data-ttu-id="8e353-119">通过使用 <xref:System.Data.Linq.DataContext> 和实体类上的分部类和方法挂钩到 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] 运行时事件，来实现您的业务规则或其他特定于域的逻辑。</span><span class="sxs-lookup"><span data-stu-id="8e353-119">Implement your business rules or other domain-specific logic by using the partial classes and methods on the <xref:System.Data.Linq.DataContext> and entity classes to hook into [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] runtime events.</span></span> <span data-ttu-id="8e353-120">有关详细信息，请参阅[实现 N 层业务逻辑](../../../../../../docs/framework/data/adonet/sql/linq/implementing-business-logic-linq-to-sql.md)。</span><span class="sxs-lookup"><span data-stu-id="8e353-120">For more information, see [Implementing N-Tier Business Logic](../../../../../../docs/framework/data/adonet/sql/linq/implementing-business-logic-linq-to-sql.md).</span></span>  
  
## <a name="defining-the-serializable-types"></a><span data-ttu-id="8e353-121">定义可序列化类型</span><span class="sxs-lookup"><span data-stu-id="8e353-121">Defining the Serializable Types</span></span>  
 <span data-ttu-id="8e353-122">客户端或表示层必须具有将从中间层接收的用于类的类型定义。</span><span class="sxs-lookup"><span data-stu-id="8e353-122">The client or presentation tier must have type definitions for the classes that it will be receiving from the middle tier.</span></span> <span data-ttu-id="8e353-123">这些类型可能为实体类本身，或是仅包装实体类中的特定字段以进行远程处理的特殊类。</span><span class="sxs-lookup"><span data-stu-id="8e353-123">Those types may be the entity classes themselves, or special classes that wrap only certain fields from the entity classes for remoting.</span></span> <span data-ttu-id="8e353-124">在任何情况下，[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] 都完全不涉及表示层获取这些类型定义的方式。</span><span class="sxs-lookup"><span data-stu-id="8e353-124">In any case, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] is completely unconcerned about how the presentation tier acquires those type definitions.</span></span> <span data-ttu-id="8e353-125">例如，表示层可以使用 WCF 自动生成类型，也可以具有在其中定义这些类型的 DLL 的副本，还可以仅定义其自己的类型版本。</span><span class="sxs-lookup"><span data-stu-id="8e353-125">For example, the presentation tier could use WCF to generate the types automatically, or it could have a copy of a DLL in which those types are defined, or it could just define its own versions of the types.</span></span>  
  
## <a name="retrieving-and-inserting-data"></a><span data-ttu-id="8e353-126">检索和插入数据</span><span class="sxs-lookup"><span data-stu-id="8e353-126">Retrieving and Inserting Data</span></span>  
 <span data-ttu-id="8e353-127">中间层会定义一个接口，用于指定表示层访问数据的方式。</span><span class="sxs-lookup"><span data-stu-id="8e353-127">The middle tier defines an interface that specifies how the presentation tier accesses the data.</span></span> <span data-ttu-id="8e353-128">例如 `GetProductByID(int productID)` 或 `GetCustomers()`。</span><span class="sxs-lookup"><span data-stu-id="8e353-128">For example `GetProductByID(int productID)`, or `GetCustomers()`.</span></span> <span data-ttu-id="8e353-129">在中间层上，方法体通常创建 <xref:System.Data.Linq.DataContext> 的新实例，对其一个或多个表执行查询。</span><span class="sxs-lookup"><span data-stu-id="8e353-129">On the middle tier, the method body typically creates a new instance of the <xref:System.Data.Linq.DataContext>, executes a query against one or more of its table.</span></span> <span data-ttu-id="8e353-130">随后中间层会返回结果作为 <xref:System.Collections.Generic.IEnumerable%601>，其中 `T` 为实体类或用于序列化的另一个类型。</span><span class="sxs-lookup"><span data-stu-id="8e353-130">The middle tier then returns the result as an <xref:System.Collections.Generic.IEnumerable%601>, where `T` is either an entity class or another type that is used for serialization.</span></span> <span data-ttu-id="8e353-131">表示层从不直接向中间层发送查询变量，也从不直接从中间层接收查询变量。</span><span class="sxs-lookup"><span data-stu-id="8e353-131">The presentation tier never sends or receives query variables directly to or from the middle tier.</span></span> <span data-ttu-id="8e353-132">这两个层交换值、对象和具体数据的集合。</span><span class="sxs-lookup"><span data-stu-id="8e353-132">The two tiers exchange values, objects, and collections of concrete data.</span></span> <span data-ttu-id="8e353-133">在已接收到一个集合后，如有必要，表示层可以使用 [!INCLUDE[vbteclinq](../../../../../../includes/vbteclinq-md.md)] to Objects 查询该集合。</span><span class="sxs-lookup"><span data-stu-id="8e353-133">After it has received a collection, the presentation tier can use [!INCLUDE[vbteclinq](../../../../../../includes/vbteclinq-md.md)] to Objects to query it if necessary.</span></span>  
  
 <span data-ttu-id="8e353-134">在插入数据时，表示层可以构造一个新的对象并将其发送到中间层，或是使中间层基于其提供的值来构造对象。</span><span class="sxs-lookup"><span data-stu-id="8e353-134">When inserting data, the presentation tier can construct a new object and send it to the middle tier, or it can have the middle tier construct the object based on values that it provides.</span></span> <span data-ttu-id="8e353-135">通常，在 n 层应用程序中检索和插入数据与 2 层应用程序中的过程并无显著差异。</span><span class="sxs-lookup"><span data-stu-id="8e353-135">In general, retrieving and inserting data in n-tier applications does not differ much from the process in 2-tier applications.</span></span> <span data-ttu-id="8e353-136">有关详细信息，请参阅[查询数据库](../../../../../../docs/framework/data/adonet/sql/linq/querying-the-database.md)和[进行和提交数据更改](../../../../../../docs/framework/data/adonet/sql/linq/making-and-submitting-data-changes.md)。</span><span class="sxs-lookup"><span data-stu-id="8e353-136">For more information, see [Querying the Database](../../../../../../docs/framework/data/adonet/sql/linq/querying-the-database.md) and [Making and Submitting Data Changes](../../../../../../docs/framework/data/adonet/sql/linq/making-and-submitting-data-changes.md).</span></span>  
  
## <a name="tracking-changes-for-updates-and-deletes"></a><span data-ttu-id="8e353-137">跟踪更新和删除的更改</span><span class="sxs-lookup"><span data-stu-id="8e353-137">Tracking Changes for Updates and Deletes</span></span>  
 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]<span data-ttu-id="8e353-138"> 支持基于时间戳（也称为 RowVersion）和基于原始值的开放式并发。</span><span class="sxs-lookup"><span data-stu-id="8e353-138"> supports optimistic concurrency based on timestamps (also named RowVersions) and on original values.</span></span> <span data-ttu-id="8e353-139">如果数据库表具有时间戳，则更新和删除几乎不需要在中间层或表示层上进行额外工作。</span><span class="sxs-lookup"><span data-stu-id="8e353-139">If the database tables have timestamps, then updates and deletions require little extra work on either the middle-tier or presentation tier.</span></span> <span data-ttu-id="8e353-140">但是，如果必须使用原始值进行开放式并发检查，则表示层在其进行更新时负责跟踪这些值并将这些值发送回去。</span><span class="sxs-lookup"><span data-stu-id="8e353-140">However, if you must use original values for optimistic concurrency checks, then the presentation tier is responsible for tracking those values and sending them back when it makes updates.</span></span> <span data-ttu-id="8e353-141">这是因为在表示层上对实体所做的更改不会在中间层上进行跟踪。</span><span class="sxs-lookup"><span data-stu-id="8e353-141">This is because changes that were made to entities on the presentation tier are not tracked on the middle tier.</span></span> <span data-ttu-id="8e353-142">实际上，实体的原始检索以及对其所进行的最终更新通常由 <xref:System.Data.Linq.DataContext> 的两个完全独立的实例执行。</span><span class="sxs-lookup"><span data-stu-id="8e353-142">In fact, the original retrieval of an entity, and the eventual update made to it are typically performed by two completely separate instances of the <xref:System.Data.Linq.DataContext>.</span></span>  
  
 <span data-ttu-id="8e353-143">表示层进行的更改越多，跟踪这些更改以及将这些更改打包发送回中间层的过程就越复杂。</span><span class="sxs-lookup"><span data-stu-id="8e353-143">The greater the number of changes that the presentation tier makes, the more complex it becomes to track those changes and package them back to the middle tier.</span></span> <span data-ttu-id="8e353-144">传达更改的机制的实现完全由应用程序负责。</span><span class="sxs-lookup"><span data-stu-id="8e353-144">The implementation of a mechanism for communicating changes is completely up to the application.</span></span> <span data-ttu-id="8e353-145">唯一的要求是必须为 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] 提供进行开放式并发检查所必需的那些原始值。</span><span class="sxs-lookup"><span data-stu-id="8e353-145">The only requirement is that [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] must be given those original values that are required for optimistic concurrency checks.</span></span>  
  
 <span data-ttu-id="8e353-146">有关详细信息，请参阅[数据检索和 CUD 操作在 N 层应用程序 (LINQ to SQL)](../../../../../../docs/framework/data/adonet/sql/linq/data-retrieval-and-cud-operations-in-n-tier-applications.md)。</span><span class="sxs-lookup"><span data-stu-id="8e353-146">For more information, see [Data Retrieval and CUD Operations in N-Tier Applications (LINQ to SQL)](../../../../../../docs/framework/data/adonet/sql/linq/data-retrieval-and-cud-operations-in-n-tier-applications.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8e353-147">请参阅</span><span class="sxs-lookup"><span data-stu-id="8e353-147">See Also</span></span>  
 [<span data-ttu-id="8e353-148">使用 LINQ to SQL 的 N 层和远程应用程序</span><span class="sxs-lookup"><span data-stu-id="8e353-148">N-Tier and Remote Applications with LINQ to SQL</span></span>](../../../../../../docs/framework/data/adonet/sql/linq/n-tier-and-remote-applications-with-linq-to-sql.md)  
 [<span data-ttu-id="8e353-149">NIB: LinqDataSource Web 服务器控件概述</span><span class="sxs-lookup"><span data-stu-id="8e353-149">NIB: LinqDataSource Web Server Control Overview</span></span>](http://msdn.microsoft.com/library/104cfc3f-7385-47d3-8a51-830dfa791136)
