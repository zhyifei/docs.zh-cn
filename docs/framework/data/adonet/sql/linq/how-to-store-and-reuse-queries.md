---
title: 如何：存储和重复使用查询
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: a012bd79-1809-45e3-adea-0229532396cc
ms.openlocfilehash: 1aac20c3f9c421d353938a83b9e321d35abd244e
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/23/2019
ms.locfileid: "62033639"
---
# <a name="how-to-store-and-reuse-queries"></a><span data-ttu-id="b776b-102">如何：存储和重复使用查询</span><span class="sxs-lookup"><span data-stu-id="b776b-102">How to: Store and Reuse Queries</span></span>
<span data-ttu-id="b776b-103">当您的应用程序多次执行结构上相似的查询时，您通常可以通过如下方法提高性能：编译此查询一次，然后用不同的参数执行它若干次。</span><span class="sxs-lookup"><span data-stu-id="b776b-103">When you have an application that executes structurally similar queries many times, you can often increase performance by compiling the query one time and executing it several times with different parameters.</span></span> <span data-ttu-id="b776b-104">例如，应用程序可能需要检索位于特定城市的所有客户，其中此城市是在运行时由用户在窗体中指定的。</span><span class="sxs-lookup"><span data-stu-id="b776b-104">For example, an application might have to retrieve all the customers who are in a particular city, where the city is specified at runtime by the user in a form.</span></span> [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] <span data-ttu-id="b776b-105">支持使用*编译的查询*实现此目的。</span><span class="sxs-lookup"><span data-stu-id="b776b-105">supports the use of *compiled queries* for this purpose.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b776b-106">这种使用模式代表了已编译查询最常见的用途。</span><span class="sxs-lookup"><span data-stu-id="b776b-106">This pattern of usage represents the most common use for compiled queries.</span></span> <span data-ttu-id="b776b-107">也可以使用其他方法。</span><span class="sxs-lookup"><span data-stu-id="b776b-107">Other approaches are possible.</span></span> <span data-ttu-id="b776b-108">例如，已编译查询可以存储为扩展设计器所生成代码的分部类的静态成员。</span><span class="sxs-lookup"><span data-stu-id="b776b-108">For example, compiled queries can be stored as static members on a partial class that extends the code generated by the designer.</span></span>  
  
## <a name="example"></a><span data-ttu-id="b776b-109">示例</span><span class="sxs-lookup"><span data-stu-id="b776b-109">Example</span></span>  
 <span data-ttu-id="b776b-110">在很多情况下，您可能需要跨线程边界重复使用查询。</span><span class="sxs-lookup"><span data-stu-id="b776b-110">In many scenarios you might want to reuse the queries across thread boundaries.</span></span> <span data-ttu-id="b776b-111">在这种情况下，将已编译查询存储在静态变量中特别有效。</span><span class="sxs-lookup"><span data-stu-id="b776b-111">In such cases, storing the compiled queries in static variables is especially effective.</span></span> <span data-ttu-id="b776b-112">下面的代码示例采用设计用于存储已编译查询的 `Queries`，并采用表示强类型化 <xref:System.Data.Linq.DataContext> 的 Northwind 类。</span><span class="sxs-lookup"><span data-stu-id="b776b-112">The following code example assumes a `Queries` class designed to store compiled queries, and assumes a Northwind class that represents a strongly typed <xref:System.Data.Linq.DataContext>.</span></span>  
  
 [!code-csharp[DLinqQuerying#6](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqQuerying/cs/Program.cs#6)]
 [!code-vb[DLinqQuerying#6](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqQuerying/vb/Module1.vb#6)]  
  
 [!code-csharp[DLinqQuerying#7](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqQuerying/cs/Program.cs#7)]
 [!code-vb[DLinqQuerying#7](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqQuerying/vb/Module1.vb#7)]  
  
## <a name="example"></a><span data-ttu-id="b776b-113">示例</span><span class="sxs-lookup"><span data-stu-id="b776b-113">Example</span></span>  
 <span data-ttu-id="b776b-114">目前你无法返回的存储 （存储在静态变量） 查询*匿名类型*，因为类型没有提供作为泛型参数的名称。</span><span class="sxs-lookup"><span data-stu-id="b776b-114">You cannot currently store (in static variables) queries that return an *anonymous type*, because type has no name to provide as a generic argument.</span></span> <span data-ttu-id="b776b-115">下面的示例演示如何创建可表示结果的类型，然后将其用作泛型自变量，从而解决该问题。</span><span class="sxs-lookup"><span data-stu-id="b776b-115">The following example shows how you can work around the issue by creating a type that can represent the result, and then use it as a generic argument.</span></span>  
  
 [!code-csharp[DLinqQuerying#8](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqQuerying/cs/Program.cs#8)]
 [!code-vb[DLinqQuerying#8](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqQuerying/vb/Module1.vb#8)]  
  
## <a name="see-also"></a><span data-ttu-id="b776b-116">请参阅</span><span class="sxs-lookup"><span data-stu-id="b776b-116">See also</span></span>

- <xref:System.Data.Linq.CompiledQuery>
- [<span data-ttu-id="b776b-117">查询概念</span><span class="sxs-lookup"><span data-stu-id="b776b-117">Query Concepts</span></span>](../../../../../../docs/framework/data/adonet/sql/linq/query-concepts.md)
- [<span data-ttu-id="b776b-118">查询数据库</span><span class="sxs-lookup"><span data-stu-id="b776b-118">Querying the Database</span></span>](../../../../../../docs/framework/data/adonet/sql/linq/querying-the-database.md)
