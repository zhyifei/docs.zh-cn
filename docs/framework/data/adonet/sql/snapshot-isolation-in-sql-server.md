---
title: SQL Server 中的快照隔离
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 43ae5dd3-50f5-43a8-8d01-e37a61664176
ms.openlocfilehash: 8313ffc8eef70c1e5efc24b09a160edb7cec1595
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/12/2020
ms.locfileid: "79174259"
---
# <a name="snapshot-isolation-in-sql-server"></a><span data-ttu-id="ddf44-102">SQL Server 中的快照隔离</span><span class="sxs-lookup"><span data-stu-id="ddf44-102">Snapshot Isolation in SQL Server</span></span>
<span data-ttu-id="ddf44-103">快照隔离增强了 OLTP 应用程序的并发性。</span><span class="sxs-lookup"><span data-stu-id="ddf44-103">Snapshot isolation enhances concurrency for OLTP applications.</span></span>  
  
## <a name="understanding-snapshot-isolation-and-row-versioning"></a><span data-ttu-id="ddf44-104">了解快照隔离和行版本控制</span><span class="sxs-lookup"><span data-stu-id="ddf44-104">Understanding Snapshot Isolation and Row Versioning</span></span>  
 <span data-ttu-id="ddf44-105">启用快照隔离后，必须维护每个事务的更新行版本。</span><span class="sxs-lookup"><span data-stu-id="ddf44-105">Once snapshot isolation is enabled, updated row versions for each transaction must be maintained.</span></span>  <span data-ttu-id="ddf44-106">在 SQL Server 2019 之前，这些版本存储在**tempdb**中。</span><span class="sxs-lookup"><span data-stu-id="ddf44-106">Prior to SQL Server 2019, these versions were stored in **tempdb**.</span></span> <span data-ttu-id="ddf44-107">SQL Server 2019 引入了一项新功能，加速数据库恢复 （ADR），它需要自己的一组行版本。</span><span class="sxs-lookup"><span data-stu-id="ddf44-107">SQL Server 2019 introduces a new feature, Accelerated Database Recovery (ADR) which requires its own set of row versions.</span></span>  <span data-ttu-id="ddf44-108">因此，从 SQL Server 2019 起，如果未启用 ADR，则行版本将一如既往保存在**tempdb**中。</span><span class="sxs-lookup"><span data-stu-id="ddf44-108">So, as of SQL Server 2019, if ADR is not enabled, row versions are kept in **tempdb** as always.</span></span>  <span data-ttu-id="ddf44-109">如果启用了 ADR，则所有行版本（都与快照隔离和 ADR 相关）都保存在 ADR 的持久版本存储 （PVS） 中，该版本位于用户指定的文件组中的用户数据库中。</span><span class="sxs-lookup"><span data-stu-id="ddf44-109">If ADR is enabled, then all row versions, both related to snapshot isolation and ADR, are kept in ADR's Persistent Version Store (PVS), which is located in the user database in a filegroup which the user specifies.</span></span> <span data-ttu-id="ddf44-110">唯一的事务序列号标识每个事务，并为每个行版本记录这些唯一的编号。</span><span class="sxs-lookup"><span data-stu-id="ddf44-110">A unique transaction sequence number identifies each transaction, and these unique numbers are recorded for each row version.</span></span> <span data-ttu-id="ddf44-111">事务处理的最新行版本在事务序列号之前有一个序列号。</span><span class="sxs-lookup"><span data-stu-id="ddf44-111">The transaction works with the most recent row versions having a sequence number before the sequence number of the transaction.</span></span> <span data-ttu-id="ddf44-112">事务将忽略在事务开始后创建的新行版本。</span><span class="sxs-lookup"><span data-stu-id="ddf44-112">Newer row versions created after the transaction has begun are ignored by the transaction.</span></span>  
  
 <span data-ttu-id="ddf44-113">术语“快照”反映的事实是，事务中的所有查询都能看到数据库的相同版本或快照，这取决于事务开始时数据库的状态。</span><span class="sxs-lookup"><span data-stu-id="ddf44-113">The term "snapshot" reflects the fact that all queries in the transaction see the same version, or snapshot, of the database, based on the state of the database at the moment in time when the transaction begins.</span></span> <span data-ttu-id="ddf44-114">不会在快照事务中的基础数据行或数据页上获取锁，这样可以执行其他事务，而不会被以前未完成的事务所阻止。</span><span class="sxs-lookup"><span data-stu-id="ddf44-114">No locks are acquired on the underlying data rows or data pages in a snapshot transaction, which permits other transactions to execute without being blocked by a prior uncompleted transaction.</span></span> <span data-ttu-id="ddf44-115">修改数据的事务不会阻止读取数据的事务，并且读取数据的事务不会阻止写入数据的事务，因为在 SQL Server 中，它们通常会在默认的 READ COMMITTED 隔离级别下执行这些操作。</span><span class="sxs-lookup"><span data-stu-id="ddf44-115">Transactions that modify data do not block transactions that read data, and transactions that read data do not block transactions that write data, as they normally would under the default READ COMMITTED isolation level in SQL Server.</span></span> <span data-ttu-id="ddf44-116">这种不会产生阻止的行为也大大降低了复杂事务出现死锁的可能性。</span><span class="sxs-lookup"><span data-stu-id="ddf44-116">This non-blocking behavior also significantly reduces the likelihood of deadlocks for complex transactions.</span></span>  
  
 <span data-ttu-id="ddf44-117">快照隔离使用开放式并发模型。</span><span class="sxs-lookup"><span data-stu-id="ddf44-117">Snapshot isolation uses an optimistic concurrency model.</span></span> <span data-ttu-id="ddf44-118">如果快照事务尝试提交对事务开始后已更改的数据所做的修改，事务将回滚，并引发错误。</span><span class="sxs-lookup"><span data-stu-id="ddf44-118">If a snapshot transaction attempts to commit modifications to data that has changed since the transaction began, the transaction will roll back and an error will be raised.</span></span> <span data-ttu-id="ddf44-119">可以通过对访问要修改的数据的 SELECT 语句使用 UPDLOCK 提示来避免这种情况。</span><span class="sxs-lookup"><span data-stu-id="ddf44-119">You can avoid this by using UPDLOCK hints for SELECT statements that access data to be modified.</span></span> <span data-ttu-id="ddf44-120">有关详细信息，请参阅 SQL Server 联机丛书中的“锁定提示”。</span><span class="sxs-lookup"><span data-stu-id="ddf44-120">See "Locking Hints" in SQL Server Books Online for more information.</span></span>  
  
 <span data-ttu-id="ddf44-121">在事务中使用快照隔离之前，必须通过在数据库上设置 ALLOW_SNAPSHOT_ISOLATION 选项来启用它。</span><span class="sxs-lookup"><span data-stu-id="ddf44-121">Snapshot isolation must be enabled by setting the ALLOW_SNAPSHOT_ISOLATION ON database option before it is used in transactions.</span></span> <span data-ttu-id="ddf44-122">这样将激活在临时数据库 (tempdb) 中存储行版本的机制\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="ddf44-122">This activates the mechanism for storing row versions in the temporary database (**tempdb**).</span></span> <span data-ttu-id="ddf44-123">必须在将快照隔离与 Transact-SQL ALTER DATABASE 语句一起使用的每个数据库中启用快照隔离。</span><span class="sxs-lookup"><span data-stu-id="ddf44-123">You must enable snapshot isolation in each database that uses it with the Transact-SQL ALTER DATABASE statement.</span></span> <span data-ttu-id="ddf44-124">在这方面，快照隔离与传统的隔离级别（READ COMMITTED、REPEATABLE READ、SERIALIZABLE 和 READ UNCOMMITTED）不同，这些级别不需要配置。</span><span class="sxs-lookup"><span data-stu-id="ddf44-124">In this respect, snapshot isolation differs from the traditional isolation levels of READ COMMITTED, REPEATABLE READ, SERIALIZABLE, and READ UNCOMMITTED, which require no configuration.</span></span> <span data-ttu-id="ddf44-125">以下语句激活快照隔离并将默认的 READ COMMITTED 行为替换为快照：</span><span class="sxs-lookup"><span data-stu-id="ddf44-125">The following statements activate snapshot isolation and replace the default READ COMMITTED behavior with SNAPSHOT:</span></span>  
  
```sql  
ALTER DATABASE MyDatabase  
SET ALLOW_SNAPSHOT_ISOLATION ON  
  
ALTER DATABASE MyDatabase  
SET READ_COMMITTED_SNAPSHOT ON  
```  
  
 <span data-ttu-id="ddf44-126">设置 READ_COMMITTED_SNAPSHOT ON 选项后，可以在默认的 READ COMMITTED 隔离级别下访问版本控制行。</span><span class="sxs-lookup"><span data-stu-id="ddf44-126">Setting the READ_COMMITTED_SNAPSHOT ON option allows access to versioned rows under the default READ COMMITTED isolation level.</span></span> <span data-ttu-id="ddf44-127">如果 READ_COMMITTED_SNAPSHOT 选项设置为 OFF，则必须为每个会话显式设置快照隔离级别，以便访问版本控制行。</span><span class="sxs-lookup"><span data-stu-id="ddf44-127">If the READ_COMMITTED_SNAPSHOT option is set to OFF, you must explicitly set the Snapshot isolation level for each session in order to access versioned rows.</span></span>  
  
## <a name="managing-concurrency-with-isolation-levels"></a><span data-ttu-id="ddf44-128">使用隔离级别管理并发性</span><span class="sxs-lookup"><span data-stu-id="ddf44-128">Managing Concurrency with Isolation Levels</span></span>  
 <span data-ttu-id="ddf44-129">执行 Transact-SQL 语句的隔离级别决定了其锁定和行版本控制行为。</span><span class="sxs-lookup"><span data-stu-id="ddf44-129">The isolation level under which a Transact-SQL statement executes determines its locking and row versioning behavior.</span></span> <span data-ttu-id="ddf44-130">隔离级别具有连接范围的作用域，一旦使用 SET TRANSACTION ISOLATION LEVEL 语句为连接设置了隔离级别，它将一直有效，直到关闭连接或设置另一个隔离级别。</span><span class="sxs-lookup"><span data-stu-id="ddf44-130">An isolation level has connection-wide scope, and once set for a connection with the SET TRANSACTION ISOLATION LEVEL statement, it remains in effect until the connection is closed or another isolation level is set.</span></span> <span data-ttu-id="ddf44-131">当连接关闭并返回到池时，将保留上一个 SET TRANSACTION ISOLATION LEVEL 语句的隔离级别。</span><span class="sxs-lookup"><span data-stu-id="ddf44-131">When a connection is closed and returned to the pool, the isolation level from the last SET TRANSACTION ISOLATION LEVEL statement is retained.</span></span> <span data-ttu-id="ddf44-132">重新使用已入池连接的后续连接将使用在连接入池中时生效的隔离级别。</span><span class="sxs-lookup"><span data-stu-id="ddf44-132">Subsequent connections reusing a pooled connection use the isolation level that was in effect at the time the connection is pooled.</span></span>  
  
 <span data-ttu-id="ddf44-133">连接中发出的单个查询可以包含锁提示，这些提示可以修改单个语句或事务的隔离，但不会影响连接的隔离级别。</span><span class="sxs-lookup"><span data-stu-id="ddf44-133">Individual queries issued within a connection can contain lock hints that modify the isolation for a single statement or transaction but do not affect the isolation level of the connection.</span></span> <span data-ttu-id="ddf44-134">在存储过程或函数中设置的隔离级别或锁提示不会更改调用它们的连接的隔离级别，并且仅在存储过程或函数调用的持续时间内有效。</span><span class="sxs-lookup"><span data-stu-id="ddf44-134">Isolation levels or lock hints set in stored procedures or functions do not change the isolation level of the connection that calls them and are in effect only for the duration of the stored procedure or function call.</span></span>  
  
 <span data-ttu-id="ddf44-135">SQL-92 标准中定义了四个隔离级别，这四个隔离级别在早期版本的 SQL Server 中受支持：</span><span class="sxs-lookup"><span data-stu-id="ddf44-135">Four isolation levels defined in the SQL-92 standard were supported in early versions of SQL Server:</span></span>  
  
- <span data-ttu-id="ddf44-136">READ UNCOMMITTED 是限制最少的隔离级别，因为它会忽略其他事务放置的锁。</span><span class="sxs-lookup"><span data-stu-id="ddf44-136">READ UNCOMMITTED is the least restrictive isolation level because it ignores locks placed by other transactions.</span></span> <span data-ttu-id="ddf44-137">在 READ UNCOMMITTED 下执行的事务可以读取其他事务尚未提交的修改数据值；这称为“脏”读。</span><span class="sxs-lookup"><span data-stu-id="ddf44-137">Transactions executing under READ UNCOMMITTED can read modified data values that have not yet been committed by other transactions; these are called "dirty" reads.</span></span>  
  
- <span data-ttu-id="ddf44-138">SQL Server 的默认隔离级别为 READ COMMITTED。</span><span class="sxs-lookup"><span data-stu-id="ddf44-138">READ COMMITTED is the default isolation level for SQL Server.</span></span> <span data-ttu-id="ddf44-139">它通过指定语句不能读取已由其他事务修改但尚未提交的数据值来防止脏读。</span><span class="sxs-lookup"><span data-stu-id="ddf44-139">It prevents dirty reads by specifying that statements cannot read data values that have been modified but not yet committed by other transactions.</span></span> <span data-ttu-id="ddf44-140">其他事务仍然可以在当前事务的各个执行语句之间修改、插入或删除数据，从而产生不可重复读取或“虚拟”数据。</span><span class="sxs-lookup"><span data-stu-id="ddf44-140">Other transactions can still modify, insert, or delete data between executions of individual statements within the current transaction, resulting in non-repeatable reads, or "phantom" data.</span></span>  
  
- <span data-ttu-id="ddf44-141">REPEATABLE READ 是比 READ COMMITTED 更严格的隔离级别。</span><span class="sxs-lookup"><span data-stu-id="ddf44-141">REPEATABLE READ is a more restrictive isolation level than READ COMMITTED.</span></span> <span data-ttu-id="ddf44-142">它包含 READ COMMITTED，另外还指定在当前事务提交之前，任何其他事务都不能修改或删除已由当前事务读取的数据。</span><span class="sxs-lookup"><span data-stu-id="ddf44-142">It encompasses READ COMMITTED and additionally specifies that no other transactions can modify or delete data that has been read by the current transaction until the current transaction commits.</span></span> <span data-ttu-id="ddf44-143">由于读取数据上的共享锁一直保持到事务结束，而不是在每个语句结束时释放，因此并发级别低于 READ COMMITTED。</span><span class="sxs-lookup"><span data-stu-id="ddf44-143">Concurrency is lower than for READ COMMITTED because shared locks on read data are held for the duration of the transaction instead of being released at the end of each statement.</span></span>  
  
- <span data-ttu-id="ddf44-144">SERIALIZABLE 是限制最多的隔离级别，因为它锁定了键的整个范围，并在事务完成之前一直保持锁定状态。</span><span class="sxs-lookup"><span data-stu-id="ddf44-144">SERIALIZABLE is the most restrictive isolation level, because it locks entire ranges of keys and holds the locks until the transaction is complete.</span></span> <span data-ttu-id="ddf44-145">它包含 REPEATABLE READ 并添加了限制，即在事务完成之前，其他事务不能将新行插入到事务已读取的范围中。</span><span class="sxs-lookup"><span data-stu-id="ddf44-145">It encompasses REPEATABLE READ and adds the restriction that other transactions cannot insert new rows into ranges that have been read by the transaction until the transaction is complete.</span></span>  
  
 <span data-ttu-id="ddf44-146">有关详细信息，请参阅[事务锁定和行版本控制指南](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide)。</span><span class="sxs-lookup"><span data-stu-id="ddf44-146">For more information, refer to the [Transaction Locking and Row Versioning Guide](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide).</span></span>  
  
### <a name="snapshot-isolation-level-extensions"></a><span data-ttu-id="ddf44-147">快照隔离级别扩展</span><span class="sxs-lookup"><span data-stu-id="ddf44-147">Snapshot Isolation Level Extensions</span></span>  
 <span data-ttu-id="ddf44-148">SQL Server 通过引入 SNAPSHOT 隔离级别并另外实现了 READ COMMITTED，引入对 SQL-92 隔离级别的扩展。</span><span class="sxs-lookup"><span data-stu-id="ddf44-148">SQL Server introduced extensions to the SQL-92 isolation levels with the introduction of the SNAPSHOT isolation level and an additional implementation of READ COMMITTED.</span></span> <span data-ttu-id="ddf44-149">新的 READ_COMMITTED_SNAPSHOT 隔离级别可以透明的方式替换所有事务的 READ COMMITTED。</span><span class="sxs-lookup"><span data-stu-id="ddf44-149">The READ_COMMITTED_SNAPSHOT isolation level can transparently replace READ COMMITTED for all transactions.</span></span>  
  
- <span data-ttu-id="ddf44-150">快照隔离指定事务内读取的数据永远不会反映其他同步事务所做的更改。</span><span class="sxs-lookup"><span data-stu-id="ddf44-150">SNAPSHOT isolation specifies that data read within a transaction will never reflect changes made by other simultaneous transactions.</span></span> <span data-ttu-id="ddf44-151">事务使用事务开始时存在的数据行版本。</span><span class="sxs-lookup"><span data-stu-id="ddf44-151">The transaction uses the data row versions that exist when the transaction begins.</span></span> <span data-ttu-id="ddf44-152">读取数据时不会对数据进行锁定，因此快照事务不会阻止其他事务写入数据。</span><span class="sxs-lookup"><span data-stu-id="ddf44-152">No locks are placed on the data when it is read, so SNAPSHOT transactions do not block other transactions from writing data.</span></span> <span data-ttu-id="ddf44-153">写入数据的事务也不会阻止快照事务读取数据。</span><span class="sxs-lookup"><span data-stu-id="ddf44-153">Transactions that write data do not block snapshot transactions from reading data.</span></span> <span data-ttu-id="ddf44-154">需要通过设置 ALLOW_SNAPSHOT_ISOLATION 数据库选项启用快照隔离才能使用它。</span><span class="sxs-lookup"><span data-stu-id="ddf44-154">You need to enable snapshot isolation by setting the ALLOW_SNAPSHOT_ISOLATION database option in order to use it.</span></span>  
  
- <span data-ttu-id="ddf44-155">在数据库中启用快照隔离时，READ_COMMITTED_SNAPSHOT 数据库选项确定默认的 READ COMMITTED 隔离级别的行为。</span><span class="sxs-lookup"><span data-stu-id="ddf44-155">The READ_COMMITTED_SNAPSHOT database option determines the behavior of the default READ COMMITTED isolation level when snapshot isolation is enabled in a database.</span></span> <span data-ttu-id="ddf44-156">如果没有显式指定 READ_COMMITTED_SNAPSHOT ON，则 READ COMMITTED 将应用于所有隐式事务。</span><span class="sxs-lookup"><span data-stu-id="ddf44-156">If you do not explicitly specify READ_COMMITTED_SNAPSHOT ON, READ COMMITTED is applied to all implicit transactions.</span></span> <span data-ttu-id="ddf44-157">这会生成与设置 READ_COMMITTED_SNAPSHOT OFF（默认）相同的行为。</span><span class="sxs-lookup"><span data-stu-id="ddf44-157">This produces the same behavior as setting READ_COMMITTED_SNAPSHOT OFF (the default).</span></span> <span data-ttu-id="ddf44-158">如果 READ_COMMITTED_SNAPSHOT OFF 有效，则数据库引擎使用共享锁来强制实施默认隔离级别。</span><span class="sxs-lookup"><span data-stu-id="ddf44-158">When READ_COMMITTED_SNAPSHOT OFF is in effect, the Database Engine uses shared locks to enforce the default isolation level.</span></span> <span data-ttu-id="ddf44-159">如果将 READ_COMMITTED_SNAPSHOT 数据库选项设置为 ON，则数据库引擎将使用行版本控制和快照隔离作为默认值，而不是使用锁来保护数据。</span><span class="sxs-lookup"><span data-stu-id="ddf44-159">If you set the READ_COMMITTED_SNAPSHOT database option to ON, the database engine uses row versioning and snapshot isolation as the default, instead of using locks to protect the data.</span></span>  
  
## <a name="how-snapshot-isolation-and-row-versioning-work"></a><span data-ttu-id="ddf44-160">快照隔离和行版本化的工作原理</span><span class="sxs-lookup"><span data-stu-id="ddf44-160">How Snapshot Isolation and Row Versioning Work</span></span>  
 <span data-ttu-id="ddf44-161">启用 SNAPSHOT 隔离级别后，每次更新行时，SQL Server 数据库引擎在 tempdb 中存储原始行的副本，并为该行添加事务序列号\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="ddf44-161">When the SNAPSHOT isolation level is enabled, each time a row is updated, the SQL Server Database Engine stores a copy of the original row in **tempdb**, and adds a transaction sequence number to the row.</span></span> <span data-ttu-id="ddf44-162">下面是事件发生的顺序：</span><span class="sxs-lookup"><span data-stu-id="ddf44-162">The following is the sequence of events that occurs:</span></span>  
  
- <span data-ttu-id="ddf44-163">将启动新事务，并为其分配事务序列号。</span><span class="sxs-lookup"><span data-stu-id="ddf44-163">A new transaction is initiated, and it is assigned a transaction sequence number.</span></span>  
  
- <span data-ttu-id="ddf44-164">数据库引擎在事务中读取某行，并从 tempdb 中检索其序列号与事务序列号最接近并且小于事务序列号的行版本\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="ddf44-164">The Database Engine reads a row within the transaction and retrieves the row version from **tempdb** whose sequence number is closest to, and lower than, the transaction sequence number.</span></span>  
  
- <span data-ttu-id="ddf44-165">数据库引擎将检查事务序列号是否不在快照事务启动时处于活动状态的未提交事务的事务序列号的列表中。</span><span class="sxs-lookup"><span data-stu-id="ddf44-165">The Database Engine checks to see if the transaction sequence number is not in the list of transaction sequence numbers of the uncommitted transactions active when the snapshot transaction started.</span></span>  
  
- <span data-ttu-id="ddf44-166">事务从 tempdb 中读取自事务开始以来最新的行版本\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="ddf44-166">The transaction reads the version of the row from **tempdb** that was current as of the start of the transaction.</span></span> <span data-ttu-id="ddf44-167">由于这些序列号值将高于事务序列号的值，因此它将看不到在启动事务后插入的新行。</span><span class="sxs-lookup"><span data-stu-id="ddf44-167">It will not see new rows inserted after the transaction was started because those sequence number values will be higher than the value of the transaction sequence number.</span></span>  
  
- <span data-ttu-id="ddf44-168">当前事务将看到事务开始后删除的行，因为 tempdb 中的行版本具有更低的序列号值\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="ddf44-168">The current transaction will see rows that were deleted after the transaction began, because there will be a row version in **tempdb** with a lower sequence number value.</span></span>  
  
 <span data-ttu-id="ddf44-169">快照隔离的最终效果是，事务将看到事务开始时存在的所有数据，而不会对基础表执行或设置任何锁。</span><span class="sxs-lookup"><span data-stu-id="ddf44-169">The net effect of snapshot isolation is that the transaction sees all of the data as it existed at the start of the transaction, without honoring or placing any locks on the underlying tables.</span></span> <span data-ttu-id="ddf44-170">在存在争用的情况下，这可能导致性能改进。</span><span class="sxs-lookup"><span data-stu-id="ddf44-170">This can result in performance improvements in situations where there is contention.</span></span>  
  
 <span data-ttu-id="ddf44-171">快照事务始终使用乐观并发控制，这会保留阻止其他事务更新行的任何锁。</span><span class="sxs-lookup"><span data-stu-id="ddf44-171">A snapshot transaction always uses optimistic concurrency control, withholding any locks that would prevent other transactions from updating rows.</span></span> <span data-ttu-id="ddf44-172">如果快照事务尝试提交对事务开始后更改的行的更新，则将回滚该事务，并引发错误。</span><span class="sxs-lookup"><span data-stu-id="ddf44-172">If a snapshot transaction attempts to commit an update to a row that was changed after the transaction began, the transaction is rolled back, and an error is raised.</span></span>  
  
## <a name="working-with-snapshot-isolation-in-adonet"></a><span data-ttu-id="ddf44-173">在 ADO.NET 中使用快照隔离</span><span class="sxs-lookup"><span data-stu-id="ddf44-173">Working with Snapshot Isolation in ADO.NET</span></span>  
 <span data-ttu-id="ddf44-174"><xref:System.Data.SqlClient.SqlTransaction> 类支持 ADO.NET 中的快照隔离。</span><span class="sxs-lookup"><span data-stu-id="ddf44-174">Snapshot isolation is supported in ADO.NET by the <xref:System.Data.SqlClient.SqlTransaction> class.</span></span> <span data-ttu-id="ddf44-175">如果数据库已启用了快照隔离，但是未配置 READ_COMMITTED_SNAPSHOT ON，必须在调用 <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> 方法时，使用 IsolationLevel.Snapshot 枚举值启动 <xref:System.Data.SqlClient.SqlTransaction>\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="ddf44-175">If a database has been enabled for snapshot isolation but is not configured for READ_COMMITTED_SNAPSHOT ON, you must initiate a <xref:System.Data.SqlClient.SqlTransaction> using the **IsolationLevel.Snapshot** enumeration value when calling the <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> method.</span></span> <span data-ttu-id="ddf44-176">此代码段假定连接是打开的 <xref:System.Data.SqlClient.SqlConnection> 对象。</span><span class="sxs-lookup"><span data-stu-id="ddf44-176">This code fragment assumes that connection is an open <xref:System.Data.SqlClient.SqlConnection> object.</span></span>  
  
```vb  
Dim sqlTran As SqlTransaction = _  
  connection.BeginTransaction(IsolationLevel.Snapshot)  
```  
  
```csharp  
SqlTransaction sqlTran =
  connection.BeginTransaction(IsolationLevel.Snapshot);  
```  
  
### <a name="example"></a><span data-ttu-id="ddf44-177">示例</span><span class="sxs-lookup"><span data-stu-id="ddf44-177">Example</span></span>  
 <span data-ttu-id="ddf44-178">下面的示例演示如何通过尝试访问锁定的数据来表现不同的隔离级别，并且不应在生产代码中使用。</span><span class="sxs-lookup"><span data-stu-id="ddf44-178">The following example demonstrates how the different isolation levels behave by attempting to access locked data, and it is not intended to be used in production code.</span></span>  
  
 <span data-ttu-id="ddf44-179">该代码连接到 SQL Server 中的 AdventureWorks 示例数据库上，并创建一个名为 TestSnapshot 的表，然后插入一行数据\*\*\*\*\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="ddf44-179">The code connects to the **AdventureWorks** sample database in SQL Server and creates a table named **TestSnapshot** and inserts one row of data.</span></span> <span data-ttu-id="ddf44-180">此代码使用 ALTER DATABASE Transact-SQL 语句为数据库启用快照隔离，但不会设置 READ_COMMITTED_SNAPSHOT 选项，而是保留默认的 READ COMMITTED 隔离级别行为。</span><span class="sxs-lookup"><span data-stu-id="ddf44-180">The code uses the ALTER DATABASE Transact-SQL statement to turn on snapshot isolation for the database, but it does not set the READ_COMMITTED_SNAPSHOT option, leaving the default READ COMMITTED isolation-level behavior in effect.</span></span> <span data-ttu-id="ddf44-181">然后，此代码执行以下操作：</span><span class="sxs-lookup"><span data-stu-id="ddf44-181">The code then performs the following actions:</span></span>  
  
- <span data-ttu-id="ddf44-182">它开始 sqlTransaction1（但未完成），后者使用 SERIALIZABLE 隔离级别来启动更新事务。</span><span class="sxs-lookup"><span data-stu-id="ddf44-182">It begins, but does not complete, sqlTransaction1, which uses the SERIALIZABLE isolation level to start an update transaction.</span></span> <span data-ttu-id="ddf44-183">这具有锁定表的效果。</span><span class="sxs-lookup"><span data-stu-id="ddf44-183">This has the effect of locking the table.</span></span>  
  
- <span data-ttu-id="ddf44-184">打开第二个连接，并使用 SNAPSHOT 隔离级别开始第二个事务，读取 TestSnapshot 表中的数据\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="ddf44-184">It opens a second connection and initiates a second transaction using the SNAPSHOT isolation level to read the data in the **TestSnapshot** table.</span></span> <span data-ttu-id="ddf44-185">由于启用了快照隔离，因此此事务可以读取 sqlTransaction1 开始之前已存在的数据。</span><span class="sxs-lookup"><span data-stu-id="ddf44-185">Because snapshot isolation is enabled, this transaction can read the data that existed before sqlTransaction1 started.</span></span>  
  
- <span data-ttu-id="ddf44-186">打开第三个连接，并使用 READ COMMITTED 隔离级别启动一个事务，尝试读取表中的数据。</span><span class="sxs-lookup"><span data-stu-id="ddf44-186">It opens a third connection and initiates a transaction using the READ COMMITTED isolation level to attempt to read the data in the table.</span></span> <span data-ttu-id="ddf44-187">在这种情况下，代码无法读取数据，因为它无法读取第一个事务中放在表上的锁并超时。如果使用 REPEATABLE 读取和 SERIALIZABLE 隔离级别，则也会出现相同的结果，因为这些隔离级别也无法读取第一个事务中放置的锁。</span><span class="sxs-lookup"><span data-stu-id="ddf44-187">In this case, the code cannot read the data because it cannot read past the locks placed on the table in the first transaction and times out. The same result would occur if the REPEATABLE READ and SERIALIZABLE isolation levels were used because these isolation levels also cannot read past the locks placed in the first transaction.</span></span>  
  
- <span data-ttu-id="ddf44-188">打开第四个连接，并使用 READ UNCOMMITTED 隔离级别启动一个事务，该隔离级别对 sqlTransaction1 中未提交的值执行脏读。</span><span class="sxs-lookup"><span data-stu-id="ddf44-188">It opens a fourth connection and initiates a transaction using the READ UNCOMMITTED isolation level, which performs a dirty read of the uncommitted value in sqlTransaction1.</span></span> <span data-ttu-id="ddf44-189">如果未提交第一个事务，则此值可能在数据库中实际上不存在。</span><span class="sxs-lookup"><span data-stu-id="ddf44-189">This value may never actually exist in the database if the first transaction is not committed.</span></span>  
  
- <span data-ttu-id="ddf44-190">回滚第一个事务，并通过删除 TestSnapshot 表以及禁用 AdventureWorks 数据库的快照隔离来进行清理\*\*\*\*\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="ddf44-190">It rolls back the first transaction and cleans up by deleting the **TestSnapshot** table and turning off snapshot isolation for the **AdventureWorks** database.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="ddf44-191">下面的示例使用与关闭连接池相同的连接字符串。</span><span class="sxs-lookup"><span data-stu-id="ddf44-191">The following examples use the same connection string with connection pooling turned off.</span></span> <span data-ttu-id="ddf44-192">如果连接已入池，则重置其隔离级别不会在服务器上重置隔离级别。</span><span class="sxs-lookup"><span data-stu-id="ddf44-192">If a connection is pooled, resetting its isolation level does not reset the isolation level at the server.</span></span> <span data-ttu-id="ddf44-193">因此，使用同一个入池的内部连接的后续连接将会启动，并将其隔离级别设置为已入池连接的隔离级别。</span><span class="sxs-lookup"><span data-stu-id="ddf44-193">As a result, subsequent connections that use the same pooled inner connection start with their isolation levels set to that of the pooled connection.</span></span> <span data-ttu-id="ddf44-194">关闭连接池的另一种方法是为每个连接显式设置隔离级别。</span><span class="sxs-lookup"><span data-stu-id="ddf44-194">An alternative to turning off connection pooling is to set the isolation level explicitly for each connection.</span></span>  
  
 [!code-csharp[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/VB/source.vb#1)]  
  
### <a name="example"></a><span data-ttu-id="ddf44-195">示例</span><span class="sxs-lookup"><span data-stu-id="ddf44-195">Example</span></span>  
 <span data-ttu-id="ddf44-196">下面的示例演示了在修改数据时快照隔离的行为。</span><span class="sxs-lookup"><span data-stu-id="ddf44-196">The following example demonstrates the behavior of snapshot isolation when data is being modified.</span></span> <span data-ttu-id="ddf44-197">此代码执行以下操作：</span><span class="sxs-lookup"><span data-stu-id="ddf44-197">The code performs the following actions:</span></span>  
  
- <span data-ttu-id="ddf44-198">连接到 AdventureWorks 示例数据库并启用 SNAPSHOT 隔离\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="ddf44-198">Connects to the **AdventureWorks** sample database and enables SNAPSHOT isolation.</span></span>  
  
- <span data-ttu-id="ddf44-199">创建一个名为 TestSnapshotUpdate 的表并插入三行示例数据\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="ddf44-199">Creates a table named **TestSnapshotUpdate** and inserts three rows of sample data.</span></span>  
  
- <span data-ttu-id="ddf44-200">使用快照隔离开始 sqlTransaction1，但不完成。</span><span class="sxs-lookup"><span data-stu-id="ddf44-200">Begins, but does not complete, sqlTransaction1 using SNAPSHOT isolation.</span></span> <span data-ttu-id="ddf44-201">在事务中选择三行数据。</span><span class="sxs-lookup"><span data-stu-id="ddf44-201">Three rows of data are selected in the transaction.</span></span>  
  
- <span data-ttu-id="ddf44-202">创建第二个通向 AdventureWorks 的 SqlConnection，并使用 READ COMMITTED 隔离级别创建第二个事务，更新在 sqlTransaction1 中选择的其中一行的值\*\*\*\*\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="ddf44-202">Creates a second **SqlConnection** to **AdventureWorks** and creates a second transaction using the READ COMMITTED isolation level that updates a value in one of the rows selected in sqlTransaction1.</span></span>  
  
- <span data-ttu-id="ddf44-203">提交 sqlTransaction2。</span><span class="sxs-lookup"><span data-stu-id="ddf44-203">Commits sqlTransaction2.</span></span>  
  
- <span data-ttu-id="ddf44-204">返回到 sqlTransaction1 并尝试更新 sqlTransaction1 已提交的同一行。</span><span class="sxs-lookup"><span data-stu-id="ddf44-204">Returns to sqlTransaction1 and attempts to update the same row that sqlTransaction1 already committed.</span></span> <span data-ttu-id="ddf44-205">引发错误 3960，并且自动回滚 sqlTransaction1。</span><span class="sxs-lookup"><span data-stu-id="ddf44-205">Error 3960 is raised, and sqlTransaction1 is rolled back automatically.</span></span> <span data-ttu-id="ddf44-206">控制台窗口中将显示 SqlException.Number 和 SqlException.Message\*\*\*\*\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="ddf44-206">The **SqlException.Number** and **SqlException.Message** are displayed in the Console window.</span></span>  
  
- <span data-ttu-id="ddf44-207">执行清理代码以关闭 AdventureWorks 中的快照隔离并删除 TestSnapshotUpdate 表\*\*\*\*\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="ddf44-207">Executes clean-up code to turn off snapshot isolation in **AdventureWorks** and delete the **TestSnapshotUpdate** table.</span></span>  
  
 [!code-csharp[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/VB/source.vb#1)]  
  
### <a name="using-lock-hints-with-snapshot-isolation"></a><span data-ttu-id="ddf44-208">对快照隔离使用锁提示</span><span class="sxs-lookup"><span data-stu-id="ddf44-208">Using Lock Hints with Snapshot Isolation</span></span>  
 <span data-ttu-id="ddf44-209">在上面的示例中，第一个事务选择数据，第二个事务更新第一个事务完成之前的数据，这将在第一个事务尝试更新同一行时导致更新冲突。</span><span class="sxs-lookup"><span data-stu-id="ddf44-209">In the previous example, the first transaction selects data, and a second transaction updates the data before the first transaction is able to complete, causing an update conflict when the first transaction tries to update the same row.</span></span> <span data-ttu-id="ddf44-210">通过在事务开始时提供锁提示，可以减少长时间运行的快照事务中的更新冲突的可能性。</span><span class="sxs-lookup"><span data-stu-id="ddf44-210">You can reduce the chance of update conflicts in long-running snapshot transactions by supplying lock hints at the beginning of the transaction.</span></span> <span data-ttu-id="ddf44-211">以下 SELECT 语句使用 UPDLOCK 提示来锁定所选行：</span><span class="sxs-lookup"><span data-stu-id="ddf44-211">The following SELECT statement uses the UPDLOCK hint to lock the selected rows:</span></span>  
  
```sql  
SELECT * FROM TestSnapshotUpdate WITH (UPDLOCK)
  WHERE PriKey BETWEEN 1 AND 3  
```  
  
 <span data-ttu-id="ddf44-212">使用 UPDLOCK 锁提示可以阻止任何行尝试在第一个事务完成之前更新行。</span><span class="sxs-lookup"><span data-stu-id="ddf44-212">Using the UPDLOCK lock hint blocks any rows attempting to update the rows before the first transaction completes.</span></span> <span data-ttu-id="ddf44-213">这可确保所选行稍后在事务中更新时不会发生冲突。</span><span class="sxs-lookup"><span data-stu-id="ddf44-213">This guarantees that the selected rows have no conflicts when they are updated later in the transaction.</span></span> <span data-ttu-id="ddf44-214">请参阅 SQL Server 联机丛书中的“锁定提示”。</span><span class="sxs-lookup"><span data-stu-id="ddf44-214">See "Locking Hints" in SQL Server Books Online.</span></span>  
  
 <span data-ttu-id="ddf44-215">如果应用程序有很多冲突，则快照隔离可能不是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="ddf44-215">If your application has many conflicts, snapshot isolation may not be the best choice.</span></span> <span data-ttu-id="ddf44-216">只应在真正需要时使用提示。</span><span class="sxs-lookup"><span data-stu-id="ddf44-216">Hints should only be used when really needed.</span></span> <span data-ttu-id="ddf44-217">应用程序的设计不应使其操作经常依赖于锁提示。</span><span class="sxs-lookup"><span data-stu-id="ddf44-217">Your application should not be designed so that it constantly relies on lock hints for its operation.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ddf44-218">另请参阅</span><span class="sxs-lookup"><span data-stu-id="ddf44-218">See also</span></span>

- [<span data-ttu-id="ddf44-219">SQL Server 和 ADO.NET</span><span class="sxs-lookup"><span data-stu-id="ddf44-219">SQL Server and ADO.NET</span></span>](index.md)
- [<span data-ttu-id="ddf44-220">ADO.NET 概述</span><span class="sxs-lookup"><span data-stu-id="ddf44-220">ADO.NET Overview</span></span>](../ado-net-overview.md)
- [<span data-ttu-id="ddf44-221">事务锁定和行版本控制指南</span><span class="sxs-lookup"><span data-stu-id="ddf44-221">Transaction Locking and Row Versioning Guide</span></span>](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide)
