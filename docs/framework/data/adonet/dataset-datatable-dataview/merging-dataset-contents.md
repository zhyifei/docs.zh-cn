---
title: 合并数据集内容
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: e5e9309a-3ebb-4a9c-9d78-21c4e2bafc5b
ms.openlocfilehash: 38d716552c4a52e01ef803ce197e4d588ed562c3
ms.sourcegitcommit: 6eac9a01ff5d70c6d18460324c016a3612c5e268
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/15/2018
ms.locfileid: "45658790"
---
# <a name="merging-dataset-contents"></a><span data-ttu-id="94a1c-102">合并数据集内容</span><span class="sxs-lookup"><span data-stu-id="94a1c-102">Merging DataSet Contents</span></span>
<span data-ttu-id="94a1c-103">您可以使用 <xref:System.Data.DataSet.Merge%2A> 方法将 <xref:System.Data.DataSet>、<xref:System.Data.DataTable> 或 <xref:System.Data.DataRow> 数组的内容合并到现有的 `DataSet` 中。</span><span class="sxs-lookup"><span data-stu-id="94a1c-103">You can use the <xref:System.Data.DataSet.Merge%2A> method to merge the contents of a <xref:System.Data.DataSet>, <xref:System.Data.DataTable>, or <xref:System.Data.DataRow> array into an existing `DataSet`.</span></span> <span data-ttu-id="94a1c-104">若干因素和选项会影响将新数据合并到现有 `DataSet` 中的方式。</span><span class="sxs-lookup"><span data-stu-id="94a1c-104">Several factors and options affect how new data is merged into an existing `DataSet`.</span></span>  
  
## <a name="primary-keys"></a><span data-ttu-id="94a1c-105">主键</span><span class="sxs-lookup"><span data-stu-id="94a1c-105">Primary Keys</span></span>  
 <span data-ttu-id="94a1c-106">如果从合并接收新数据和架构的表具有主键，则传入数据中的新行将匹配具有与传入数据中的这些行相同 <xref:System.Data.DataRowVersion.Original> 主键值的现有行。</span><span class="sxs-lookup"><span data-stu-id="94a1c-106">If the table receiving new data and schema from a merge has a primary key, new rows from the incoming data are matched with existing rows that have the same <xref:System.Data.DataRowVersion.Original> primary key values as those in the incoming data.</span></span> <span data-ttu-id="94a1c-107">如果传入架构中的列匹配现有架构的相应列，则会修改现有行中的数据。</span><span class="sxs-lookup"><span data-stu-id="94a1c-107">If the columns from the incoming schema match those of the existing schema, the data in the existing rows is modified.</span></span> <span data-ttu-id="94a1c-108">将会忽略或添加与现有架构不匹配的列，具体根据 <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> 参数而定。</span><span class="sxs-lookup"><span data-stu-id="94a1c-108">Columns that do not match the existing schema are either ignored or added based on the <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> parameter.</span></span> <span data-ttu-id="94a1c-109">主键值与任何现有行都不匹配的新行将追加到现有表中。</span><span class="sxs-lookup"><span data-stu-id="94a1c-109">New rows with primary key values that do not match any existing rows are appended to the existing table.</span></span>  
  
 <span data-ttu-id="94a1c-110">如果传入行或现有行的行状态为 <xref:System.Data.DataRowState.Added>，则将使用 <xref:System.Data.DataRowVersion.Current> 行的 `Added` 主键值来匹配他们的主键值，这是因为不存在 `Original` 行版本。</span><span class="sxs-lookup"><span data-stu-id="94a1c-110">If incoming or existing rows have a row state of <xref:System.Data.DataRowState.Added>, their primary key values are matched using the <xref:System.Data.DataRowVersion.Current> primary key value of the `Added` row because no `Original` row version exists.</span></span>  
  
 <span data-ttu-id="94a1c-111">如果传入表和现有表包含一个具有相同名称但不同数据类型的列，将引发异常，并引发 <xref:System.Data.DataSet.MergeFailed> 的 `DataSet` 事件。</span><span class="sxs-lookup"><span data-stu-id="94a1c-111">If an incoming table and an existing table contain a column with the same name but different data types, an exception is thrown and the <xref:System.Data.DataSet.MergeFailed> event of the `DataSet` is raised.</span></span> <span data-ttu-id="94a1c-112">如果传入表和现有表都具有已定义的键，但是主键针对不同的列，将引发异常，并引发 `MergeFailed` 的 `DataSet` 事件。</span><span class="sxs-lookup"><span data-stu-id="94a1c-112">If an incoming table and an existing table both have defined keys, but the primary keys are for different columns, an exception is thrown and the `MergeFailed` event of the `DataSet` is raised.</span></span>  
  
 <span data-ttu-id="94a1c-113">如果从合并中接收新数据的表不具有主键，传入数据中的新行将无法与该表中的现有行匹配，而这些新行则会追加到现有表。</span><span class="sxs-lookup"><span data-stu-id="94a1c-113">If the table receiving new data from a merge does not have a primary key, new rows from the incoming data cannot be matched to existing rows in the table and are instead appended to the existing table.</span></span>  
  
## <a name="table-names-and-namespaces"></a><span data-ttu-id="94a1c-114">表名称和命名空间</span><span class="sxs-lookup"><span data-stu-id="94a1c-114">Table Names and Namespaces</span></span>  
 <span data-ttu-id="94a1c-115">可以选择为 <xref:System.Data.DataTable> 对象分配 <xref:System.Data.DataTable.Namespace%2A> 属性值。</span><span class="sxs-lookup"><span data-stu-id="94a1c-115"><xref:System.Data.DataTable> objects can optionally be assigned a <xref:System.Data.DataTable.Namespace%2A> property value.</span></span> <span data-ttu-id="94a1c-116">如果分配了 <xref:System.Data.DataTable.Namespace%2A> 值，则一个 <xref:System.Data.DataSet> 可以包含多个具有相同 <xref:System.Data.DataTable> 值的 <xref:System.Data.DataTable.TableName%2A> 对象。</span><span class="sxs-lookup"><span data-stu-id="94a1c-116">When <xref:System.Data.DataTable.Namespace%2A> values are assigned, a <xref:System.Data.DataSet> can contain multiple <xref:System.Data.DataTable> objects with the same <xref:System.Data.DataTable.TableName%2A> value.</span></span> <span data-ttu-id="94a1c-117">在合并操作期间，<xref:System.Data.DataTable.TableName%2A> 和 <xref:System.Data.DataTable.Namespace%2A> 都用于标识合并目标。</span><span class="sxs-lookup"><span data-stu-id="94a1c-117">During merge operations, both <xref:System.Data.DataTable.TableName%2A> and <xref:System.Data.DataTable.Namespace%2A> are used to identify the target of a merge.</span></span> <span data-ttu-id="94a1c-118">如果未分配 <xref:System.Data.DataTable.Namespace%2A>，则只使用 <xref:System.Data.DataTable.TableName%2A> 来标识合并目标。</span><span class="sxs-lookup"><span data-stu-id="94a1c-118">If no <xref:System.Data.DataTable.Namespace%2A> has been assigned, only the <xref:System.Data.DataTable.TableName%2A> is used to identify the target of a merge.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94a1c-119">这种行为在 .NET Framework 2.0 版中发生了变化。</span><span class="sxs-lookup"><span data-stu-id="94a1c-119">This behavior changed in version 2.0 of the .NET Framework.</span></span> <span data-ttu-id="94a1c-120">在 1.1 版中，虽然支持命名空间，但会在合并操作过程中被忽略。</span><span class="sxs-lookup"><span data-stu-id="94a1c-120">In version 1.1, namespaces were supported but were ignored during merge operations.</span></span> <span data-ttu-id="94a1c-121">因此，使用 <xref:System.Data.DataSet> 属性值的 <xref:System.Data.DataTable.Namespace%2A> 将具有不同的行为，具体取决于您运行哪个版本的 .NET Framework。</span><span class="sxs-lookup"><span data-stu-id="94a1c-121">For this reason, a <xref:System.Data.DataSet> that uses <xref:System.Data.DataTable.Namespace%2A> property values will have different behaviors depending on which version of the .NET Framework you are running.</span></span> <span data-ttu-id="94a1c-122">例如，假设您有两个 `DataSets`，其中包含具有相同 `DataTables` 属性值但不同 <xref:System.Data.DataTable.TableName%2A> 属性值的 <xref:System.Data.DataTable.Namespace%2A>。</span><span class="sxs-lookup"><span data-stu-id="94a1c-122">For example, suppose you have two `DataSets` containing `DataTables` with the same <xref:System.Data.DataTable.TableName%2A> property values but different <xref:System.Data.DataTable.Namespace%2A> property values.</span></span> <span data-ttu-id="94a1c-123">在 .NET Framework 1.1 版中，在合并两个 <xref:System.Data.DataTable.Namespace%2A> 对象时，将会忽略不同的 <xref:System.Data.DataSet> 名称。</span><span class="sxs-lookup"><span data-stu-id="94a1c-123">In version 1.1 of the .NET Framework, the different <xref:System.Data.DataTable.Namespace%2A> names will be ignored when merging the two <xref:System.Data.DataSet> objects.</span></span> <span data-ttu-id="94a1c-124">但从 2.0 版开始，合并操作会导致在目标 `DataTables` 中创建两个新的 <xref:System.Data.DataSet>。</span><span class="sxs-lookup"><span data-stu-id="94a1c-124">However, starting with version 2.0, merging causes two new `DataTables` to be created in the target <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="94a1c-125">原始的 `DataTables` 将不受合并的影响。</span><span class="sxs-lookup"><span data-stu-id="94a1c-125">The original `DataTables` will be unaffected by the merge.</span></span>  
  
## <a name="preservechanges"></a><span data-ttu-id="94a1c-126">PreserveChanges</span><span class="sxs-lookup"><span data-stu-id="94a1c-126">PreserveChanges</span></span>  
 <span data-ttu-id="94a1c-127">在将 `DataSet`、`DataTable` 或 `DataRow` 数组传递给 `Merge` 方法时，可以包括可选参数用以指定是否在现有 `DataSet` 中保留更改以及如何处理在传入数据中发现的新架构元素。</span><span class="sxs-lookup"><span data-stu-id="94a1c-127">When you pass a `DataSet`, `DataTable`, or `DataRow` array to the `Merge` method, you can include optional parameters that specify whether or not to preserve changes in the existing `DataSet`, and how to handle new schema elements found in the incoming data.</span></span> <span data-ttu-id="94a1c-128">在传入数据后面，这些数据的第一个参数是一个布尔型标志 <xref:System.Data.LoadOption.PreserveChanges>，它指定是否在现有 `DataSet` 中保留更改。</span><span class="sxs-lookup"><span data-stu-id="94a1c-128">The first of these parameters after the incoming data is a Boolean flag, <xref:System.Data.LoadOption.PreserveChanges>, which specifies whether or not to preserve the changes in the existing `DataSet`.</span></span> <span data-ttu-id="94a1c-129">如果 `PreserveChanges` 标志设置为 `true`，则传入值不会覆盖现有行的 `Current` 行版本中的现有值。</span><span class="sxs-lookup"><span data-stu-id="94a1c-129">If the `PreserveChanges` flag is set to `true`, incoming values do not overwrite existing values in the `Current` row version of the existing row.</span></span> <span data-ttu-id="94a1c-130">如果 `PreserveChanges` 标志设置为 `false`，则传入值将覆盖现有行的 `Current` 行版本中的现有值。</span><span class="sxs-lookup"><span data-stu-id="94a1c-130">If the `PreserveChanges` flag is set to `false`, incoming values do overwrite the existing values in the `Current` row version of the existing row.</span></span> <span data-ttu-id="94a1c-131">如果未指定 `PreserveChanges` 标志，默认情况下它将设置为 `false`。</span><span class="sxs-lookup"><span data-stu-id="94a1c-131">If the `PreserveChanges` flag is not specified, it is set to `false` by default.</span></span> <span data-ttu-id="94a1c-132">有关行版本的详细信息，请参阅[行状态和行版本](../../../../../docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)。</span><span class="sxs-lookup"><span data-stu-id="94a1c-132">For more information about row versions, see [Row States and Row Versions](../../../../../docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).</span></span>  
  
 <span data-ttu-id="94a1c-133">如果 `PreserveChanges` 为 `true`，则现有行的 <xref:System.Data.DataRowVersion.Current> 行版本中将保持现有行中的数据，而现有行的 <xref:System.Data.DataRowVersion.Original> 行版本中的数据将由传入行的 `Original` 行版本中的数据覆盖。</span><span class="sxs-lookup"><span data-stu-id="94a1c-133">When `PreserveChanges` is `true`, the data from the existing row is maintained in the <xref:System.Data.DataRowVersion.Current> row version of the existing row, while the data from the <xref:System.Data.DataRowVersion.Original> row version of the existing row is overwritten with the data from the `Original` row version of the incoming row.</span></span> <span data-ttu-id="94a1c-134">现有行的 <xref:System.Data.DataRow.RowState%2A> 设置为 <xref:System.Data.DataRowState.Modified>。</span><span class="sxs-lookup"><span data-stu-id="94a1c-134">The <xref:System.Data.DataRow.RowState%2A> of the existing row is set to <xref:System.Data.DataRowState.Modified>.</span></span> <span data-ttu-id="94a1c-135">存在以下例外：</span><span class="sxs-lookup"><span data-stu-id="94a1c-135">The following exceptions apply:</span></span>  
  
-   <span data-ttu-id="94a1c-136">如果现有行的 `RowState` 为 `Deleted`，则此 `RowState` 将保持为 `Deleted` 而不设置为 `Modified`。</span><span class="sxs-lookup"><span data-stu-id="94a1c-136">If the existing row has a `RowState` of `Deleted`, this `RowState` remains `Deleted` and is not set to `Modified`.</span></span> <span data-ttu-id="94a1c-137">在这种情况下，传入行中的数据将仍然存储在现有行的 `Original` 行版本中，并覆盖现有行的 `Original` 行版本（除非传入行的 `RowState` 为 `Added`）。</span><span class="sxs-lookup"><span data-stu-id="94a1c-137">In this case, the data from the incoming row will still be stored in the `Original` row version of the existing row, overwriting the `Original` row version of the existing row (unless the incoming row has a `RowState` of `Added`).</span></span>  
  
-   <span data-ttu-id="94a1c-138">如果传入行的 `RowState` 为 `Added`，则现有行的 `Original` 行版本中的数据将不会由传入行中的数据覆盖，因为传入行不具有 `Original` 行版本。</span><span class="sxs-lookup"><span data-stu-id="94a1c-138">If the incoming row has a `RowState` of `Added`, the data from the `Original` row version of the existing row will not be overwritten with data from the incoming row, because the incoming row does not have an `Original` row version.</span></span>  
  
 <span data-ttu-id="94a1c-139">如果 `PreserveChanges` 为 `false`，则现有行中的 `Current` 和 `Original` 行版本将都由传入行中的数据覆盖，并且现有行的 `RowState` 将设置为传入行的 `RowState`。</span><span class="sxs-lookup"><span data-stu-id="94a1c-139">When `PreserveChanges` is `false`, both the `Current` and `Original` row versions in the existing row are overwritten with the data from the incoming row, and the `RowState` of the existing row is set to the `RowState` of the incoming row.</span></span> <span data-ttu-id="94a1c-140">存在以下例外：</span><span class="sxs-lookup"><span data-stu-id="94a1c-140">The following exceptions apply:</span></span>  
  
-   <span data-ttu-id="94a1c-141">如果传入行的 `RowState` 为 `Unchanged` 且现有行的 `RowState` 为 `Modified`、`Deleted` 或 `Added`，则现有行的 `RowState` 将设置为 `Modified`。</span><span class="sxs-lookup"><span data-stu-id="94a1c-141">If the incoming row has a `RowState` of `Unchanged` and the existing row has a `RowState` of `Modified`, `Deleted`, or `Added`, the `RowState` of the existing row is set to `Modified`.</span></span>  
  
-   <span data-ttu-id="94a1c-142">如果传入行的 `RowState` 为 `Added` 且现有行的 `RowState` 为 `Unchanged`、`Modified` 或 `Deleted`，则现有行的 `RowState` 将设置为 `Modified`。</span><span class="sxs-lookup"><span data-stu-id="94a1c-142">If the incoming row has a `RowState` of `Added`, and the existing row has a `RowState` of `Unchanged`, `Modified`, or `Deleted`, the `RowState` of the existing row is set to `Modified`.</span></span> <span data-ttu-id="94a1c-143">此外，现有行的 `Original` 行版本中的数据不会由传入行中的数据覆盖，因为传入行不具有 `Original` 行版本。</span><span class="sxs-lookup"><span data-stu-id="94a1c-143">Also, the data from the `Original` row version of the existing row is not overwritten with data from the incoming row, because the incoming row does not have an `Original` row version.</span></span>  
  
## <a name="missingschemaaction"></a><span data-ttu-id="94a1c-144">MissingSchemaAction</span><span class="sxs-lookup"><span data-stu-id="94a1c-144">MissingSchemaAction</span></span>  
 <span data-ttu-id="94a1c-145">您可以使用 <xref:System.Data.MissingSchemaAction> 方法的可选 `Merge` 参数来指定 `Merge` 将如何处理传入数据中不属于现有 `DataSet` 的架构元素。</span><span class="sxs-lookup"><span data-stu-id="94a1c-145">You can use the optional <xref:System.Data.MissingSchemaAction> parameter of the `Merge` method to specify how `Merge` will handle schema elements in the incoming data that are not part of the existing `DataSet`.</span></span>  
  
 <span data-ttu-id="94a1c-146">下表说明用于 `MissingSchemaAction` 的选项。</span><span class="sxs-lookup"><span data-stu-id="94a1c-146">The following table describes the options for `MissingSchemaAction`.</span></span>  
  
|<span data-ttu-id="94a1c-147">MissingSchemaAction 选项</span><span class="sxs-lookup"><span data-stu-id="94a1c-147">MissingSchemaAction option</span></span>|<span data-ttu-id="94a1c-148">描述</span><span class="sxs-lookup"><span data-stu-id="94a1c-148">Description</span></span>|  
|--------------------------------|-----------------|  
|<xref:System.Data.MissingSchemaAction.Add>|<span data-ttu-id="94a1c-149">将新的架构信息添加到 `DataSet` 并用传入值填充新列。</span><span class="sxs-lookup"><span data-stu-id="94a1c-149">Add the new schema information to the `DataSet` and populate the new columns with the incoming values.</span></span> <span data-ttu-id="94a1c-150">这是默认设置。</span><span class="sxs-lookup"><span data-stu-id="94a1c-150">This is the default.</span></span>|  
|<xref:System.Data.MissingSchemaAction.AddWithKey>|<span data-ttu-id="94a1c-151">将新的架构和主键信息添加到 `DataSet` 并用传入值填充新列。</span><span class="sxs-lookup"><span data-stu-id="94a1c-151">Add the new schema and primary key information to the `DataSet` and populate the new columns with the incoming values.</span></span>|  
|<xref:System.Data.MissingSchemaAction.Error>|<span data-ttu-id="94a1c-152">如果遇到不匹配的架构信息，则引发异常。</span><span class="sxs-lookup"><span data-stu-id="94a1c-152">Throw an exception if mismatched schema information is encountered.</span></span>|  
|<xref:System.Data.MissingSchemaAction.Ignore>|<span data-ttu-id="94a1c-153">忽略新的架构信息。</span><span class="sxs-lookup"><span data-stu-id="94a1c-153">Ignore the new schema information.</span></span>|  
  
## <a name="constraints"></a><span data-ttu-id="94a1c-154">约束</span><span class="sxs-lookup"><span data-stu-id="94a1c-154">Constraints</span></span>  
 <span data-ttu-id="94a1c-155">使用 `Merge` 方法时，所有新数据都添加到现有 `DataSet` 之前不会检查约束。</span><span class="sxs-lookup"><span data-stu-id="94a1c-155">With the `Merge` method, constraints are not checked until all new data has been added to the existing `DataSet`.</span></span> <span data-ttu-id="94a1c-156">添加了数据后，会对 `DataSet` 中的当前值实施约束。</span><span class="sxs-lookup"><span data-stu-id="94a1c-156">Once the data has been added, constraints are enforced on the current values in the `DataSet`.</span></span> <span data-ttu-id="94a1c-157">您必须确保您的代码可以处理可能因约束冲突而引发的任何异常。</span><span class="sxs-lookup"><span data-stu-id="94a1c-157">You must ensure that your code handles any exceptions that might be thrown due to constraint violations.</span></span>  
  
 <span data-ttu-id="94a1c-158">设想有这样一种情况：`DataSet` 中的某一现有行是主键值为 1 的 `Unchanged`。</span><span class="sxs-lookup"><span data-stu-id="94a1c-158">Consider a case where an existing row in a `DataSet` is an `Unchanged` row with a primary key value of 1.</span></span> <span data-ttu-id="94a1c-159">在与 `Modified` 主键值为 2 且 `Original` 主键值为 1 的 `Current` 传入行进行合并期间，由于 `Original` 主键值不同，现有行和传入行将被视为不匹配。</span><span class="sxs-lookup"><span data-stu-id="94a1c-159">During a merge operation with a `Modified` incoming row with an `Original` primary key value of 2 and a `Current` primary key value of 1, the existing row and the incoming row are not considered matching because the `Original` primary key values differ.</span></span> <span data-ttu-id="94a1c-160">不过，完成合并和检查完约束后，将会引发一个异常，因为 `Current` 主键值违反了主键列的唯一约束。</span><span class="sxs-lookup"><span data-stu-id="94a1c-160">However, when the merge is completed and constraints are checked, an exception will be thrown because the `Current` primary key values violate the unique constraint for the primary key column.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94a1c-161">在向包含自动递增列（如标识列）的数据库表中插入行时，插入时操作返回的标识列值可能不匹配 `DataSet` 中的值，从而导致追加而不是合并返回的行。</span><span class="sxs-lookup"><span data-stu-id="94a1c-161">When rows are inserted into a database table containing an auto incrementing column such as an identity column, the identity column value returned by the insert may not match the value in the `DataSet`, causing the returned rows to be appended instead of merged.</span></span> <span data-ttu-id="94a1c-162">有关详细信息，请参阅[检索标识或自动编号值](../../../../../docs/framework/data/adonet/retrieving-identity-or-autonumber-values.md)。</span><span class="sxs-lookup"><span data-stu-id="94a1c-162">For more information, see [Retrieving Identity or Autonumber Values](../../../../../docs/framework/data/adonet/retrieving-identity-or-autonumber-values.md).</span></span>  
  
 <span data-ttu-id="94a1c-163">下面的代码示例将两个具有不同架构的 `DataSet` 对象合并成一个 `DataSet`，它具有两个传入 `DataSet` 对象的组合架构。</span><span class="sxs-lookup"><span data-stu-id="94a1c-163">The following code example merges two `DataSet` objects with differents schemas into one `DataSet` with the combined schemas of the two incoming `DataSet` objects.</span></span>  
  
 [!code-csharp[DataWorks DataSet.Merge#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.Merge/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.Merge#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.Merge/VB/source.vb#1)]  
  
 <span data-ttu-id="94a1c-164">下面的代码示例采用带有更新的现有 `DataSet`，并将这些更新传递给 `DataAdapter` 以便在数据源中处理。</span><span class="sxs-lookup"><span data-stu-id="94a1c-164">The following code example takes an existing `DataSet` with updates and passes those updates to a `DataAdapter` to be processed at the data source.</span></span> <span data-ttu-id="94a1c-165">随后将结果合并到原始 `DataSet` 中。</span><span class="sxs-lookup"><span data-stu-id="94a1c-165">The results are then merged into the original `DataSet`.</span></span> <span data-ttu-id="94a1c-166">在拒绝导致错误的更改之后，合并的更改与 `AcceptChanges` 一起提交。</span><span class="sxs-lookup"><span data-stu-id="94a1c-166">After rejecting changes that resulted in an error, the merged changes are committed with `AcceptChanges`.</span></span>  
  
 [!code-csharp[DataWorks DataSet.MergeAcceptChanges#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.MergeAcceptChanges#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/VB/source.vb#1)]  
  
 [!code-csharp[DataWorks DataSet.MergeAcceptChanges#2](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/CS/source.cs#2)]
 [!code-vb[DataWorks DataSet.MergeAcceptChanges#2](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/VB/source.vb#2)]  
  
## <a name="see-also"></a><span data-ttu-id="94a1c-167">请参阅</span><span class="sxs-lookup"><span data-stu-id="94a1c-167">See Also</span></span>  
 [<span data-ttu-id="94a1c-168">数据集、数据表和数据视图</span><span class="sxs-lookup"><span data-stu-id="94a1c-168">DataSets, DataTables, and DataViews</span></span>](../../../../../docs/framework/data/adonet/dataset-datatable-dataview/index.md)  
 [<span data-ttu-id="94a1c-169">行状态和行版本</span><span class="sxs-lookup"><span data-stu-id="94a1c-169">Row States and Row Versions</span></span>](../../../../../docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)  
 [<span data-ttu-id="94a1c-170">DataAdapters 和 DataReaders</span><span class="sxs-lookup"><span data-stu-id="94a1c-170">DataAdapters and DataReaders</span></span>](../../../../../docs/framework/data/adonet/dataadapters-and-datareaders.md)  
 [<span data-ttu-id="94a1c-171">在 ADO.NET 中检索和修改数据</span><span class="sxs-lookup"><span data-stu-id="94a1c-171">Retrieving and Modifying Data in ADO.NET</span></span>](../../../../../docs/framework/data/adonet/retrieving-and-modifying-data.md)  
 [<span data-ttu-id="94a1c-172">检索标识或自动编号值</span><span class="sxs-lookup"><span data-stu-id="94a1c-172">Retrieving Identity or Autonumber Values</span></span>](../../../../../docs/framework/data/adonet/retrieving-identity-or-autonumber-values.md)  
 [<span data-ttu-id="94a1c-173">ADO.NET 托管提供程序和数据集开发人员中心</span><span class="sxs-lookup"><span data-stu-id="94a1c-173">ADO.NET Managed Providers and DataSet Developer Center</span></span>](https://go.microsoft.com/fwlink/?LinkId=217917)
