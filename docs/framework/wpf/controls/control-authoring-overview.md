---
title: 控件创作概述
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- controls [WPF], authoring overview
- authoring overview for controls [WPF]
ms.assetid: 3d864748-cff0-4e63-9b23-d8e5a635b28f
ms.openlocfilehash: 503e9cb0ea0fcfb34b326e80930f5ac829c3b4db
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/23/2019
ms.locfileid: "54585193"
---
# <a name="control-authoring-overview"></a><span data-ttu-id="734af-102">控件创作概述</span><span class="sxs-lookup"><span data-stu-id="734af-102">Control Authoring Overview</span></span>
<span data-ttu-id="734af-103">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 控件模型的扩展性极大地减少了创建新控件的需要。</span><span class="sxs-lookup"><span data-stu-id="734af-103">The extensibility of the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] control model greatly reduces the need to create a new control.</span></span> <span data-ttu-id="734af-104">但在某些情况下，仍可能需要创建自定义控件。</span><span class="sxs-lookup"><span data-stu-id="734af-104">However, in certain cases you may still need to create a custom control.</span></span> <span data-ttu-id="734af-105">本主题讨论可最大限度减少在 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 中创建自定义控件以及其他控件创作模型的需要的功能。</span><span class="sxs-lookup"><span data-stu-id="734af-105">This topic discusses the features that minimize your need to create a custom control and the different control authoring models in [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)].</span></span> <span data-ttu-id="734af-106">本主题还演示如何创建新控件。</span><span class="sxs-lookup"><span data-stu-id="734af-106">This topic also demonstrates how to create a new control.</span></span>  
  
 
  
<a name="when_to_write_a_new_control"></a>   
## <a name="alternatives-to-writing-a-new-control"></a><span data-ttu-id="734af-107">编写新控件的替代方法</span><span class="sxs-lookup"><span data-stu-id="734af-107">Alternatives to Writing a New Control</span></span>  
 <span data-ttu-id="734af-108">以前，如果要通过现有控件获取自定义体验，只能更改控件的标准属性，例如背景色、边框宽度和字号。</span><span class="sxs-lookup"><span data-stu-id="734af-108">Historically, if you wanted to get a customized experience from an existing control, you were limited to changing the standard properties of the control, such as background color, border width, and font size.</span></span> <span data-ttu-id="734af-109">如果希望在这些预定义参数的基础之上扩展控件的外观或行为，则需要创建新控件，常用的方法是继承现有控件并重写负责绘制该控件的方法。</span><span class="sxs-lookup"><span data-stu-id="734af-109">If you wished to extend the appearance or behavior of a control beyond these predefined parameters, you would need to create a new control, usually by inheriting from an existing control and overriding the method responsible for drawing the control.</span></span>  <span data-ttu-id="734af-110">虽然这仍是一种可选方法，但也可以利用 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 的丰富内容模型、样式、模板和触发器来自定义现有的控件。</span><span class="sxs-lookup"><span data-stu-id="734af-110">Although that is still an option, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] enables to you customize existing controls by using its rich content model, styles, templates, and triggers.</span></span> <span data-ttu-id="734af-111">下表提供了一些示例，演示如何在不创建新控件的情况下使用这些功能来实现一致的自定义体验。</span><span class="sxs-lookup"><span data-stu-id="734af-111">The following list gives examples of how these features can be used to create custom and consistent experiences without having to create a new control.</span></span>  
  
-   <span data-ttu-id="734af-112">**丰富内容。**</span><span class="sxs-lookup"><span data-stu-id="734af-112">**Rich Content.**</span></span> <span data-ttu-id="734af-113">很多标准 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 控件都支持丰富内容。</span><span class="sxs-lookup"><span data-stu-id="734af-113">Many of the standard [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] controls support rich content.</span></span> <span data-ttu-id="734af-114">例如，内容属性的<xref:System.Windows.Controls.Button>属于类型<xref:System.Object>，因此理论上的任何内容都可以显示在<xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="734af-114">For example, the content property of a <xref:System.Windows.Controls.Button> is of type <xref:System.Object>, so theoretically anything can be displayed on a <xref:System.Windows.Controls.Button>.</span></span>  <span data-ttu-id="734af-115">若要使按钮显示图像和文本，可以添加的图像和一个<xref:System.Windows.Controls.TextBlock>到<xref:System.Windows.Controls.StackPanel>，并将分配<xref:System.Windows.Controls.StackPanel>到<xref:System.Windows.Controls.ContentControl.Content%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="734af-115">To have a button display an image and text, you can add an image and a <xref:System.Windows.Controls.TextBlock> to a <xref:System.Windows.Controls.StackPanel> and assign the <xref:System.Windows.Controls.StackPanel> to the <xref:System.Windows.Controls.ContentControl.Content%2A> property.</span></span> <span data-ttu-id="734af-116">由于这些控件可以显示 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 视觉元素和任意数据，因此，降低了创建新控件或修改现有控件来支持复杂可视化效果的需求。</span><span class="sxs-lookup"><span data-stu-id="734af-116">Because the controls can display [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] visual elements and arbitrary data, there is less need to create a new control or to modify an existing control to support a complex visualization.</span></span> <span data-ttu-id="734af-117">详细了解的内容模型<xref:System.Windows.Controls.Button>和其他内容中的模型[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]，请参阅[WPF 内容模型](../../../../docs/framework/wpf/controls/wpf-content-model.md)。</span><span class="sxs-lookup"><span data-stu-id="734af-117">For more information about the content model for <xref:System.Windows.Controls.Button> and other content models in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], see [WPF Content Model](../../../../docs/framework/wpf/controls/wpf-content-model.md).</span></span>  
  
-   <span data-ttu-id="734af-118">**样式。**</span><span class="sxs-lookup"><span data-stu-id="734af-118">**Styles.**</span></span> <span data-ttu-id="734af-119">一个<xref:System.Windows.Style>是表示控件的属性的值的集合。</span><span class="sxs-lookup"><span data-stu-id="734af-119">A <xref:System.Windows.Style> is a collection of values that represent properties for a control.</span></span> <span data-ttu-id="734af-120">使用样式可创建所需控件外观和行为的可重用表示形式，而无需编写新控件。</span><span class="sxs-lookup"><span data-stu-id="734af-120">By using styles, you can create a reusable representation of a desired control appearance and behavior without writing a new control.</span></span> <span data-ttu-id="734af-121">例如，假设您希望的所有你<xref:System.Windows.Controls.TextBlock>控件具有红色 Arial 字体，并且字号为 14。</span><span class="sxs-lookup"><span data-stu-id="734af-121">For example, assume that you want all of your <xref:System.Windows.Controls.TextBlock> controls to have red, Arial font with a font size of 14.</span></span> <span data-ttu-id="734af-122">可以创建一个样式作为资源，并相应设置适当属性。</span><span class="sxs-lookup"><span data-stu-id="734af-122">You can create a style as a resource and set the appropriate properties accordingly.</span></span> <span data-ttu-id="734af-123">然后每个<xref:System.Windows.Controls.TextBlock>，您将添加到你的应用程序将具有相同的外观。</span><span class="sxs-lookup"><span data-stu-id="734af-123">Then every <xref:System.Windows.Controls.TextBlock> that you add to your application will have the same appearance.</span></span>  
  
-   <span data-ttu-id="734af-124">**数据模板。**</span><span class="sxs-lookup"><span data-stu-id="734af-124">**Data Templates.**</span></span> <span data-ttu-id="734af-125">一个<xref:System.Windows.DataTemplate>，可以自定义控件上显示数据的方式。</span><span class="sxs-lookup"><span data-stu-id="734af-125">A <xref:System.Windows.DataTemplate> enables you to customize how data is displayed on a control.</span></span> <span data-ttu-id="734af-126">例如，<xref:System.Windows.DataTemplate>可用于指定数据中的显示方式<xref:System.Windows.Controls.ListBox>。</span><span class="sxs-lookup"><span data-stu-id="734af-126">For example, a <xref:System.Windows.DataTemplate> can be used to specify how data is displayed in a <xref:System.Windows.Controls.ListBox>.</span></span>  <span data-ttu-id="734af-127">有关这种情况的示例，请参阅[数据模块化概述](../../../../docs/framework/wpf/data/data-templating-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="734af-127">For an example of this, see [Data Templating Overview](../../../../docs/framework/wpf/data/data-templating-overview.md).</span></span>  <span data-ttu-id="734af-128">除了自定义的数据，外观<xref:System.Windows.DataTemplate>可以包含 UI 元素，后者可提供很大的灵活性在自定义 Ui。</span><span class="sxs-lookup"><span data-stu-id="734af-128">In addition to customizing the appearance of data, a <xref:System.Windows.DataTemplate> can include UI elements, which gives you a lot of flexibility in custom UIs.</span></span>  <span data-ttu-id="734af-129">例如，通过使用<xref:System.Windows.DataTemplate>，可以创建<xref:System.Windows.Controls.ComboBox>中的每个项包含一个复选框。</span><span class="sxs-lookup"><span data-stu-id="734af-129">For example, by using a <xref:System.Windows.DataTemplate>, you can create a <xref:System.Windows.Controls.ComboBox> in which each item contains a check box.</span></span>  
  
-   <span data-ttu-id="734af-130">**控件模板。**</span><span class="sxs-lookup"><span data-stu-id="734af-130">**Control Templates.**</span></span> <span data-ttu-id="734af-131">中的许多控件[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]使用<xref:System.Windows.Controls.ControlTemplate>来定义控件的结构和外观，将控件的外观与控件的功能分隔开来。</span><span class="sxs-lookup"><span data-stu-id="734af-131">Many controls in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] use a <xref:System.Windows.Controls.ControlTemplate> to define the control's structure and appearance, which separates the appearance of a control from the functionality of the control.</span></span> <span data-ttu-id="734af-132">您可以极大地更改控件的外观，通过重新定义其<xref:System.Windows.Controls.ControlTemplate>。</span><span class="sxs-lookup"><span data-stu-id="734af-132">You can drastically change the appearance of a control by redefining its <xref:System.Windows.Controls.ControlTemplate>.</span></span>  <span data-ttu-id="734af-133">例如，假设需要一个看起来像交通信号灯的控件。</span><span class="sxs-lookup"><span data-stu-id="734af-133">For example, suppose you want a control that looks like a stoplight.</span></span> <span data-ttu-id="734af-134">此控件具有简单的用户界面和功能。</span><span class="sxs-lookup"><span data-stu-id="734af-134">This control has a simple user interface and functionality.</span></span>  <span data-ttu-id="734af-135">该控件有三个圆圈，一次只有一个圆圈亮起。</span><span class="sxs-lookup"><span data-stu-id="734af-135">The control is three circles, only one of which can be lit up at a time.</span></span> <span data-ttu-id="734af-136">经过考虑之后，您可能会发现<xref:System.Windows.Controls.RadioButton>提供的功能只选择一个时间，但的默认外观<xref:System.Windows.Controls.RadioButton>完全不像交通信号灯上的灯。</span><span class="sxs-lookup"><span data-stu-id="734af-136">After some reflection, you might realize that a <xref:System.Windows.Controls.RadioButton> offers the functionality of only one being selected at a time, but the default appearance of the <xref:System.Windows.Controls.RadioButton> looks nothing like the lights on a stoplight.</span></span>  <span data-ttu-id="734af-137">因为<xref:System.Windows.Controls.RadioButton>使用的控件模板来定义其外观，很容易重新定义<xref:System.Windows.Controls.ControlTemplate>，使其适合的控件，要求使用单选按钮来制作交通信号灯。</span><span class="sxs-lookup"><span data-stu-id="734af-137">Because the <xref:System.Windows.Controls.RadioButton> uses a control template to define its appearance, it is easy to redefine the <xref:System.Windows.Controls.ControlTemplate> to fit the requirements of the control, and use radio buttons to make your stoplight.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="734af-138">尽管<xref:System.Windows.Controls.RadioButton>可以使用<xref:System.Windows.DataTemplate>、<xref:System.Windows.DataTemplate>不足在此示例中。</span><span class="sxs-lookup"><span data-stu-id="734af-138">Although a <xref:System.Windows.Controls.RadioButton> can use a <xref:System.Windows.DataTemplate>, a <xref:System.Windows.DataTemplate> is not sufficient in this example.</span></span>  <span data-ttu-id="734af-139"><xref:System.Windows.DataTemplate>定义控件的内容的外观。</span><span class="sxs-lookup"><span data-stu-id="734af-139">The <xref:System.Windows.DataTemplate> defines the appearance of the content of a control.</span></span> <span data-ttu-id="734af-140">情况下<xref:System.Windows.Controls.RadioButton>，内容是圆圈，以指示右侧出现的任何内容是否<xref:System.Windows.Controls.RadioButton>处于选中状态。</span><span class="sxs-lookup"><span data-stu-id="734af-140">In the case of a <xref:System.Windows.Controls.RadioButton>, the content is whatever appears to the right of the circle that indicates whether the <xref:System.Windows.Controls.RadioButton> is selected.</span></span>  <span data-ttu-id="734af-141">在交通信号灯的示例中，单选按钮只需要是可“点亮”的圆圈。</span><span class="sxs-lookup"><span data-stu-id="734af-141">In the example of the stoplight, the radio button needs just be a circle that can "light up."</span></span> <span data-ttu-id="734af-142">由于交通信号灯的外观要求很大差异的默认外观<xref:System.Windows.Controls.RadioButton>，有必要重新定义<xref:System.Windows.Controls.ControlTemplate>。</span><span class="sxs-lookup"><span data-stu-id="734af-142">Because the appearance requirement for the stoplight is so different than the default appearance of the <xref:System.Windows.Controls.RadioButton>, it is necessary to redefine the <xref:System.Windows.Controls.ControlTemplate>.</span></span>  <span data-ttu-id="734af-143">一般情况下<xref:System.Windows.DataTemplate>用于定义的内容 （或数据），一个控件，以及一个<xref:System.Windows.Controls.ControlTemplate>用于定义控件的方式。</span><span class="sxs-lookup"><span data-stu-id="734af-143">In general a <xref:System.Windows.DataTemplate> is used for defining the content (or data) of a control, and a <xref:System.Windows.Controls.ControlTemplate> is used for defining how a control is structured.</span></span>  
  
-   <span data-ttu-id="734af-144">**触发器。**</span><span class="sxs-lookup"><span data-stu-id="734af-144">**Triggers.**</span></span> <span data-ttu-id="734af-145">一个<xref:System.Windows.Trigger>，可动态更改的外观和行为的控件，而无需创建一个新的控件。</span><span class="sxs-lookup"><span data-stu-id="734af-145">A <xref:System.Windows.Trigger> allows you to dynamically change the appearance and behavior of a control without creating a new control.</span></span> <span data-ttu-id="734af-146">例如，假设您有多个<xref:System.Windows.Controls.ListBox>应用程序中的控件，并且希望在每个项<xref:System.Windows.Controls.ListBox>在选中时为粗体和红色。</span><span class="sxs-lookup"><span data-stu-id="734af-146">For example, suppose you have multiple <xref:System.Windows.Controls.ListBox> controls in your application and want the items in each <xref:System.Windows.Controls.ListBox> to be bold and red when they are selected.</span></span> <span data-ttu-id="734af-147">在第一个想到的可能是创建继承自类<xref:System.Windows.Controls.ListBox>并重写<xref:System.Windows.Controls.Primitives.Selector.OnSelectionChanged%2A>方法来更改外观，所选的项，但更好的方法是将触发器添加到样式的<xref:System.Windows.Controls.ListBoxItem>更改的外观所选的项。</span><span class="sxs-lookup"><span data-stu-id="734af-147">Your first instinct might be to create a class that inherits from <xref:System.Windows.Controls.ListBox> and override the <xref:System.Windows.Controls.Primitives.Selector.OnSelectionChanged%2A> method to change the appearance of the selected item, but a better approach is to add a trigger to a style of a <xref:System.Windows.Controls.ListBoxItem> that changes the appearance of the selected item.</span></span> <span data-ttu-id="734af-148">触发器可以更改属性值或根据属性值执行操作。</span><span class="sxs-lookup"><span data-stu-id="734af-148">A trigger enables you to change property values or take actions based on the value of a property.</span></span> <span data-ttu-id="734af-149"><xref:System.Windows.EventTrigger>使您能够在事件发生时执行操作。</span><span class="sxs-lookup"><span data-stu-id="734af-149">An <xref:System.Windows.EventTrigger> enables you to take actions when an event occurs.</span></span>  
  
 <span data-ttu-id="734af-150">有关样式、模板和触发器的详细信息，请参阅[样式设置和模板化](../../../../docs/framework/wpf/controls/styling-and-templating.md)。</span><span class="sxs-lookup"><span data-stu-id="734af-150">For more information about styles, templates, and triggers, see [Styling and Templating](../../../../docs/framework/wpf/controls/styling-and-templating.md).</span></span>  
  
 <span data-ttu-id="734af-151">一般情况下，如果控件可以镜像现有控件的功能，但希望该控件具有不同的外观，则应先考虑是否可以使用本节中讨论的某些方法来更改现有控件的外观。</span><span class="sxs-lookup"><span data-stu-id="734af-151">In general, if your control mirrors the functionality of an existing control, but you want the control to look different, you should first consider whether you can use any of the methods discussed in this section to change the existing control's appearance.</span></span>  
  
<a name="models_for_control_authoring"></a>   
## <a name="models-for-control-authoring"></a><span data-ttu-id="734af-152">控件创作模型</span><span class="sxs-lookup"><span data-stu-id="734af-152">Models for Control Authoring</span></span>  
 <span data-ttu-id="734af-153">通过丰富内容模型、样式、模板和触发器，最大程度地减少创建新控件的需要。</span><span class="sxs-lookup"><span data-stu-id="734af-153">The rich content model, styles, templates, and triggers minimize the need for you to create a new control.</span></span> <span data-ttu-id="734af-154">但是，如果确实需要创建新控件，则理解 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中的不同控件创作模型就显得非常重要。</span><span class="sxs-lookup"><span data-stu-id="734af-154">However, if you do need to create a new control, it is important to understand the different control authoring models in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="734af-155">提供三个用于创建控件的常规模型，每个模型都提供不同的功能集和灵活度。</span><span class="sxs-lookup"><span data-stu-id="734af-155">provides three general models for creating a control, each of which provides a different set of features and level of flexibility.</span></span> <span data-ttu-id="734af-156">基类的三个模型都<xref:System.Windows.Controls.UserControl>， <xref:System.Windows.Controls.Control>，和<xref:System.Windows.FrameworkElement>。</span><span class="sxs-lookup"><span data-stu-id="734af-156">The base classes for the three models are <xref:System.Windows.Controls.UserControl>, <xref:System.Windows.Controls.Control>, and <xref:System.Windows.FrameworkElement>.</span></span>  
  
### <a name="deriving-from-usercontrol"></a><span data-ttu-id="734af-157">从 UserControl 派生</span><span class="sxs-lookup"><span data-stu-id="734af-157">Deriving from UserControl</span></span>  
 <span data-ttu-id="734af-158">若要创建的控件中的最简单方法[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]是从派生<xref:System.Windows.Controls.UserControl>。</span><span class="sxs-lookup"><span data-stu-id="734af-158">The simplest way to create a control in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to derive from <xref:System.Windows.Controls.UserControl>.</span></span> <span data-ttu-id="734af-159">当你生成控件的继承<xref:System.Windows.Controls.UserControl>，将添加到现有的组件<xref:System.Windows.Controls.UserControl>，命名组件，并引用中的事件处理程序[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="734af-159">When you build a control that inherits from <xref:System.Windows.Controls.UserControl>, you add existing components to the <xref:System.Windows.Controls.UserControl>, name the components, and reference event handlers in [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)].</span></span> <span data-ttu-id="734af-160">随后可以在代码中引用命名的元素和定义事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="734af-160">You can then reference the named elements and define the event handlers in code.</span></span> <span data-ttu-id="734af-161">此开发模型与用于在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中开发应用程序的模型非常相似。</span><span class="sxs-lookup"><span data-stu-id="734af-161">This development model is very similar to the model used for application development in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>  
  
 <span data-ttu-id="734af-162">如果生成无误，<xref:System.Windows.Controls.UserControl>可以充分利用丰富的内容、 样式和触发器的优势。</span><span class="sxs-lookup"><span data-stu-id="734af-162">If built correctly, a <xref:System.Windows.Controls.UserControl> can take advantage of the benefits of rich content, styles, and triggers.</span></span> <span data-ttu-id="734af-163">但是，如果控件继承自<xref:System.Windows.Controls.UserControl>，使用您的控件的用户将无法再使用<xref:System.Windows.DataTemplate>或<xref:System.Windows.Controls.ControlTemplate>来自定义其外观。</span><span class="sxs-lookup"><span data-stu-id="734af-163">However, if your control inherits from <xref:System.Windows.Controls.UserControl>, people who use your control will not be able to use a <xref:System.Windows.DataTemplate> or <xref:System.Windows.Controls.ControlTemplate> to customize its appearance.</span></span>  <span data-ttu-id="734af-164">必须派生自<xref:System.Windows.Controls.Control>类或其派生类之一 (而不<xref:System.Windows.Controls.UserControl>) 创建支持模板的自定义控件。</span><span class="sxs-lookup"><span data-stu-id="734af-164">It is necessary to derive from the <xref:System.Windows.Controls.Control> class or one of its derived classes (other than <xref:System.Windows.Controls.UserControl>) to create a custom control that supports templates.</span></span>  
  
#### <a name="benefits-of-deriving-from-usercontrol"></a><span data-ttu-id="734af-165">从 UserControl 派生的优点</span><span class="sxs-lookup"><span data-stu-id="734af-165">Benefits of Deriving from UserControl</span></span>  
 <span data-ttu-id="734af-166">请考虑从派生<xref:System.Windows.Controls.UserControl>如果所有以下应用：</span><span class="sxs-lookup"><span data-stu-id="734af-166">Consider deriving from <xref:System.Windows.Controls.UserControl> if all of the following apply:</span></span>  
  
-   <span data-ttu-id="734af-167">希望采用与生成应用程序相似的方法生成控件。</span><span class="sxs-lookup"><span data-stu-id="734af-167">You want to build your control similarly to how you build an application.</span></span>  
  
-   <span data-ttu-id="734af-168">控件仅包含现有组件。</span><span class="sxs-lookup"><span data-stu-id="734af-168">Your control consists only of existing components.</span></span>  
  
-   <span data-ttu-id="734af-169">无需支持复杂的自定义项。</span><span class="sxs-lookup"><span data-stu-id="734af-169">You don't need to support complex customization.</span></span>  
  
### <a name="deriving-from-control"></a><span data-ttu-id="734af-170">从 Control 派生</span><span class="sxs-lookup"><span data-stu-id="734af-170">Deriving from Control</span></span>  
 <span data-ttu-id="734af-171">派生自<xref:System.Windows.Controls.Control>类是使用大多数现有的模型[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]控件。</span><span class="sxs-lookup"><span data-stu-id="734af-171">Deriving from the <xref:System.Windows.Controls.Control> class is the model used by most of the existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] controls.</span></span> <span data-ttu-id="734af-172">当你创建的控件的继承<xref:System.Windows.Controls.Control>类，您通过使用模板定义其外观。</span><span class="sxs-lookup"><span data-stu-id="734af-172">When you create a control that inherits from the <xref:System.Windows.Controls.Control> class, you define its appearance by using templates.</span></span> <span data-ttu-id="734af-173">通过这种方式，可以将运算逻辑从视觉表示形式中分离出来。</span><span class="sxs-lookup"><span data-stu-id="734af-173">By doing so, you separate the operational logic from the visual representation.</span></span> <span data-ttu-id="734af-174">您还可以确保 UI 和逻辑分离而不是事件和避免引用元素中的使用命令和绑定<xref:System.Windows.Controls.ControlTemplate>只要有可能。</span><span class="sxs-lookup"><span data-stu-id="734af-174">You can also ensure the decoupling of the UI and logic by using commands and bindings instead of events and avoiding referencing elements in the <xref:System.Windows.Controls.ControlTemplate> whenever possible.</span></span>  <span data-ttu-id="734af-175">如果 UI 和控件的逻辑正确分离，您的控件的用户可以重新定义控件的<xref:System.Windows.Controls.ControlTemplate>来自定义其外观。</span><span class="sxs-lookup"><span data-stu-id="734af-175">If the UI and logic of your control are properly decoupled, a user of your control can redefine the control's <xref:System.Windows.Controls.ControlTemplate> to customize its appearance.</span></span> <span data-ttu-id="734af-176">尽管生成自定义<xref:System.Windows.Controls.Control>不是作为构造简单<xref:System.Windows.Controls.UserControl>，自定义<xref:System.Windows.Controls.Control>提供最大的灵活性。</span><span class="sxs-lookup"><span data-stu-id="734af-176">Although building a custom <xref:System.Windows.Controls.Control> is not as simple as building a <xref:System.Windows.Controls.UserControl>, a custom <xref:System.Windows.Controls.Control> provides the most flexibility.</span></span>  
  
#### <a name="benefits-of-deriving-from-control"></a><span data-ttu-id="734af-177">从 Control 派生的优点</span><span class="sxs-lookup"><span data-stu-id="734af-177">Benefits of Deriving from Control</span></span>  
 <span data-ttu-id="734af-178">请考虑从派生<xref:System.Windows.Controls.Control>而不是使用<xref:System.Windows.Controls.UserControl>类如果以下任一情况:</span><span class="sxs-lookup"><span data-stu-id="734af-178">Consider deriving from <xref:System.Windows.Controls.Control> instead of using the <xref:System.Windows.Controls.UserControl> class if any of the following apply:</span></span>  
  
-   <span data-ttu-id="734af-179">你想要通过可自定义控件的外观<xref:System.Windows.Controls.ControlTemplate>。</span><span class="sxs-lookup"><span data-stu-id="734af-179">You want the appearance of your control to be customizable via the <xref:System.Windows.Controls.ControlTemplate>.</span></span>  
  
-   <span data-ttu-id="734af-180">希望控件支持不同的主题。</span><span class="sxs-lookup"><span data-stu-id="734af-180">You want your control to support different themes.</span></span>  
  
### <a name="deriving-from-frameworkelement"></a><span data-ttu-id="734af-181">从 FrameworkElement 派生</span><span class="sxs-lookup"><span data-stu-id="734af-181">Deriving from FrameworkElement</span></span>  
 <span data-ttu-id="734af-182">从派生的控件<xref:System.Windows.Controls.UserControl>或<xref:System.Windows.Controls.Control>依赖于组合现有元素。</span><span class="sxs-lookup"><span data-stu-id="734af-182">Controls that derive from <xref:System.Windows.Controls.UserControl> or <xref:System.Windows.Controls.Control> rely upon composing existing elements.</span></span> <span data-ttu-id="734af-183">对于许多方案，这是一个可接受的解决方案，因为任何对象，它继承自<xref:System.Windows.FrameworkElement>可以是<xref:System.Windows.Controls.ControlTemplate>。</span><span class="sxs-lookup"><span data-stu-id="734af-183">For many scenarios, this is an acceptable solution, because any object that inherits from <xref:System.Windows.FrameworkElement> can be in a <xref:System.Windows.Controls.ControlTemplate>.</span></span> <span data-ttu-id="734af-184">但是，某些时候，简单的元素组合不能满足控件的外观需要。</span><span class="sxs-lookup"><span data-stu-id="734af-184">However, there are times when a control's appearance requires more than the functionality of simple element composition.</span></span> <span data-ttu-id="734af-185">对于这些方案，使组件基于<xref:System.Windows.FrameworkElement>是正确的选择。</span><span class="sxs-lookup"><span data-stu-id="734af-185">For these scenarios, basing a component on <xref:System.Windows.FrameworkElement> is the right choice.</span></span>  
  
 <span data-ttu-id="734af-186">有两种标准方法，用于生成<xref:System.Windows.FrameworkElement>-基于组件： 直接呈现和自定义元素组合。</span><span class="sxs-lookup"><span data-stu-id="734af-186">There are two standard methods for building <xref:System.Windows.FrameworkElement>-based components: direct rendering and custom element composition.</span></span> <span data-ttu-id="734af-187">直接呈现涉及重写<xref:System.Windows.UIElement.OnRender%2A>方法<xref:System.Windows.FrameworkElement>，并提供<xref:System.Windows.Media.DrawingContext>显式定义组件视觉对象的操作。</span><span class="sxs-lookup"><span data-stu-id="734af-187">Direct rendering involves overriding the <xref:System.Windows.UIElement.OnRender%2A> method of <xref:System.Windows.FrameworkElement> and providing <xref:System.Windows.Media.DrawingContext> operations that explicitly define the component visuals.</span></span> <span data-ttu-id="734af-188">这是使用的方法<xref:System.Windows.Controls.Image>和<xref:System.Windows.Controls.Border>。</span><span class="sxs-lookup"><span data-stu-id="734af-188">This is the method used by <xref:System.Windows.Controls.Image> and <xref:System.Windows.Controls.Border>.</span></span> <span data-ttu-id="734af-189">自定义元素组合涉及到使用类型的对象<xref:System.Windows.Media.Visual>组件的外观。</span><span class="sxs-lookup"><span data-stu-id="734af-189">Custom element composition involves using objects of type <xref:System.Windows.Media.Visual> to compose the appearance of your component.</span></span> <span data-ttu-id="734af-190">有关示例，请参阅[使用 DrawingVisual 对象](../../../../docs/framework/wpf/graphics-multimedia/using-drawingvisual-objects.md)。</span><span class="sxs-lookup"><span data-stu-id="734af-190">For an example, see [Using DrawingVisual Objects](../../../../docs/framework/wpf/graphics-multimedia/using-drawingvisual-objects.md).</span></span> <span data-ttu-id="734af-191"><xref:System.Windows.Controls.Primitives.Track> 是一个示例中的控件[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]，它使用自定义元素组合。</span><span class="sxs-lookup"><span data-stu-id="734af-191"><xref:System.Windows.Controls.Primitives.Track> is an example of a control in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] that uses custom element composition.</span></span> <span data-ttu-id="734af-192">在同一控件中，也可以混合使用直接呈现和自定义元素组合。</span><span class="sxs-lookup"><span data-stu-id="734af-192">It is also possible to mix direct rendering and custom element composition in the same control.</span></span>  
  
#### <a name="benefits-of-deriving-from-frameworkelement"></a><span data-ttu-id="734af-193">从 FrameworkElement 派生的优点</span><span class="sxs-lookup"><span data-stu-id="734af-193">Benefits of Deriving from FrameworkElement</span></span>  
 <span data-ttu-id="734af-194">请考虑从派生<xref:System.Windows.FrameworkElement>如果以下任一情况:</span><span class="sxs-lookup"><span data-stu-id="734af-194">Consider deriving from <xref:System.Windows.FrameworkElement> if any of the following apply:</span></span>  
  
-   <span data-ttu-id="734af-195">希望对控件的外观进行精确控制，而不仅仅是简单的元素组合提供的效果。</span><span class="sxs-lookup"><span data-stu-id="734af-195">You want to have precise control over the appearance of your control beyond what is provided by simple element composition.</span></span>  
  
-   <span data-ttu-id="734af-196">希望通过定义自己的呈现逻辑来定义控件的外观。</span><span class="sxs-lookup"><span data-stu-id="734af-196">You want to define the appearance of your control by defining your own render logic.</span></span>  
  
-   <span data-ttu-id="734af-197">你想要在超过可能采用的新颖方式组合现有元素<xref:System.Windows.Controls.UserControl>和<xref:System.Windows.Controls.Control>。</span><span class="sxs-lookup"><span data-stu-id="734af-197">You want to compose existing elements in novel ways that go beyond what is possible with <xref:System.Windows.Controls.UserControl> and <xref:System.Windows.Controls.Control>.</span></span>  
  
<a name="control_authoring_basics"></a>   
## <a name="control-authoring-basics"></a><span data-ttu-id="734af-198">控件创作基础知识</span><span class="sxs-lookup"><span data-stu-id="734af-198">Control Authoring Basics</span></span>  
 <span data-ttu-id="734af-199">如前所述，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 的最强大功能之一在于，它能够在不需要创建自定义控件的情况下，不只是通过设置控件的基本属性来更改其外观和行为。</span><span class="sxs-lookup"><span data-stu-id="734af-199">As discussed earlier, one of the most powerful features of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is the ability to go beyond setting basic properties of a control to change its appearance and behavior, yet still not needing to create a custom control.</span></span> <span data-ttu-id="734af-200">样式设置、数据绑定和触发器功能通过 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 属性系统和 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 事件系统实现。</span><span class="sxs-lookup"><span data-stu-id="734af-200">The styling, data binding, and trigger features are made possible by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system and the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event system.</span></span> <span data-ttu-id="734af-201">以下各部分介绍应遵循的一些做法（与创建自定义控件时所用的模型无关），以便自定义控件的用户可以像使用 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 附带的控件一样使用这些功能。</span><span class="sxs-lookup"><span data-stu-id="734af-201">The following sections describe some practices that you should follow, regardless of the model you use to create the custom control, so that users of your custom control can use these features just as they would for a control that is included with [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>  
  
### <a name="use-dependency-properties"></a><span data-ttu-id="734af-202">使用依赖属性</span><span class="sxs-lookup"><span data-stu-id="734af-202">Use Dependency Properties</span></span>  
 <span data-ttu-id="734af-203">当属性为依赖属性时，可以执行以下操作：</span><span class="sxs-lookup"><span data-stu-id="734af-203">When a property is a dependency property, it is possible to do the following:</span></span>  
  
-   <span data-ttu-id="734af-204">在样式中设置该属性。</span><span class="sxs-lookup"><span data-stu-id="734af-204">Set the property in a style.</span></span>  
  
-   <span data-ttu-id="734af-205">将该属性绑定到数据源。</span><span class="sxs-lookup"><span data-stu-id="734af-205">Bind the property to a data source.</span></span>  
  
-   <span data-ttu-id="734af-206">使用动态资源作为该属性的值。</span><span class="sxs-lookup"><span data-stu-id="734af-206">Use a dynamic resource as the property's value.</span></span>  
  
-   <span data-ttu-id="734af-207">对该属性进行动画处理。</span><span class="sxs-lookup"><span data-stu-id="734af-207">Animate the property.</span></span>  
  
 <span data-ttu-id="734af-208">如果希望控件的属性支持以上任一功能，应将该属性实现为依赖属性。</span><span class="sxs-lookup"><span data-stu-id="734af-208">If you want a property of your control to support any of this functionality, you should implement it as a dependency property.</span></span> <span data-ttu-id="734af-209">下面的示例通过执行以下操作定义一个名为 `Value` 的依赖属性：</span><span class="sxs-lookup"><span data-stu-id="734af-209">The following example defines a dependency property named `Value` by doing the following:</span></span>  
  
-   <span data-ttu-id="734af-210">定义<xref:System.Windows.DependencyProperty>名为标识符`ValueProperty`作为`public` `static` `readonly`字段。</span><span class="sxs-lookup"><span data-stu-id="734af-210">Define a <xref:System.Windows.DependencyProperty> identifier named `ValueProperty` as a `public` `static` `readonly` field.</span></span>  
  
-   <span data-ttu-id="734af-211">通过调用属性系统注册的属性名称<xref:System.Windows.DependencyProperty.Register%2A?displayProperty=nameWithType>，以指定以下内容：</span><span class="sxs-lookup"><span data-stu-id="734af-211">Register the property name with the property system, by calling <xref:System.Windows.DependencyProperty.Register%2A?displayProperty=nameWithType>, to specify the following:</span></span>  
  
    -   <span data-ttu-id="734af-212">属性的名称。</span><span class="sxs-lookup"><span data-stu-id="734af-212">The name of the property.</span></span>  
  
    -   <span data-ttu-id="734af-213">属性的类型。</span><span class="sxs-lookup"><span data-stu-id="734af-213">The type of the property.</span></span>  
  
    -   <span data-ttu-id="734af-214">拥有属性的类型。</span><span class="sxs-lookup"><span data-stu-id="734af-214">The type that owns the property.</span></span>  
  
    -   <span data-ttu-id="734af-215">属性的元数据。</span><span class="sxs-lookup"><span data-stu-id="734af-215">The metadata for the property.</span></span> <span data-ttu-id="734af-216">元数据包含该属性的默认值<xref:System.Windows.CoerceValueCallback>和一个<xref:System.Windows.PropertyChangedCallback>。</span><span class="sxs-lookup"><span data-stu-id="734af-216">The metadata contains the property's default value, a <xref:System.Windows.CoerceValueCallback> and a <xref:System.Windows.PropertyChangedCallback>.</span></span>  
  
-   <span data-ttu-id="734af-217">通过实现该属性的 `get` 和 `set` 访问器，定义一个名为 `Value`（与用来注册该依赖属性的名称相同）的 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 包装器属性。</span><span class="sxs-lookup"><span data-stu-id="734af-217">Define a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] wrapper property named `Value`, which is the same name that is used to register the dependency property, by implementing the property's `get` and `set` accessors.</span></span> <span data-ttu-id="734af-218">请注意，`get`并`set`访问器仅调用<xref:System.Windows.DependencyObject.GetValue%2A>和<xref:System.Windows.DependencyObject.SetValue%2A>分别。</span><span class="sxs-lookup"><span data-stu-id="734af-218">Note that the `get` and `set` accessors only call <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> respectively.</span></span> <span data-ttu-id="734af-219">建议依赖项属性的访问器不包含其他逻辑，因为客户端和[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]取值函数和调用可以绕过<xref:System.Windows.DependencyObject.GetValue%2A>和<xref:System.Windows.DependencyObject.SetValue%2A>直接。</span><span class="sxs-lookup"><span data-stu-id="734af-219">It is recommended that the accessors of dependency properties not contain additional logic because clients and [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] can bypass the accessors and call <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> directly.</span></span> <span data-ttu-id="734af-220">例如，如果属性绑定到数据源，则不会调用该属性的 `set` 访问器。</span><span class="sxs-lookup"><span data-stu-id="734af-220">For example, when a property is bound to a data source, the property's `set` accessor is not called.</span></span>  <span data-ttu-id="734af-221">而不是将额外的逻辑添加到 get 和 set 访问器，请使用<xref:System.Windows.ValidateValueCallback>， <xref:System.Windows.CoerceValueCallback>，和<xref:System.Windows.PropertyChangedCallback>委托进行响应或发生更改时检查的值。</span><span class="sxs-lookup"><span data-stu-id="734af-221">Instead of adding additional logic to the get and set accessors, use the <xref:System.Windows.ValidateValueCallback>, <xref:System.Windows.CoerceValueCallback>, and <xref:System.Windows.PropertyChangedCallback> delegates to respond to or check the value when it changes.</span></span>  <span data-ttu-id="734af-222">有关这些回叫的详细信息，请参阅[依赖属性回叫和验证](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)。</span><span class="sxs-lookup"><span data-stu-id="734af-222">For more information on these callbacks, see [Dependency Property Callbacks and Validation](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).</span></span>  
  
-   <span data-ttu-id="734af-223">定义一种方法<xref:System.Windows.CoerceValueCallback>名为`CoerceValue`。</span><span class="sxs-lookup"><span data-stu-id="734af-223">Define a method for the <xref:System.Windows.CoerceValueCallback> named `CoerceValue`.</span></span> <span data-ttu-id="734af-224">`CoerceValue` 确保 `Value` 大于或等于 `MinValue` 且小于或等于 `MaxValue`。</span><span class="sxs-lookup"><span data-stu-id="734af-224">`CoerceValue` ensures that `Value` is greater or equal to `MinValue` and less than or equal to `MaxValue`.</span></span>  
  
-   <span data-ttu-id="734af-225">定义一种方法<xref:System.Windows.PropertyChangedCallback>名为`OnValueChanged`。</span><span class="sxs-lookup"><span data-stu-id="734af-225">Define a method for the <xref:System.Windows.PropertyChangedCallback>, named `OnValueChanged`.</span></span> <span data-ttu-id="734af-226">`OnValueChanged` 创建<xref:System.Windows.RoutedPropertyChangedEventArgs%601>对象，并准备引发`ValueChanged`路由的事件。</span><span class="sxs-lookup"><span data-stu-id="734af-226">`OnValueChanged` creates a <xref:System.Windows.RoutedPropertyChangedEventArgs%601> object and prepares to raise the `ValueChanged` routed event.</span></span> <span data-ttu-id="734af-227">路由事件在下一节中讨论。</span><span class="sxs-lookup"><span data-stu-id="734af-227">Routed events are discussed in the next section.</span></span>  
  
 [!code-csharp[UserControlNumericUpDown#DependencyProperty](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml.cs#dependencyproperty)]
 [!code-vb[UserControlNumericUpDown#DependencyProperty](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDown/visualbasic/numericupdown.xaml.vb#dependencyproperty)]  
  
 <span data-ttu-id="734af-228">有关详细信息，请参阅[自定义依赖属性](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="734af-228">For more information, see [Custom Dependency Properties](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md).</span></span>  
  
### <a name="use-routed-events"></a><span data-ttu-id="734af-229">使用路由事件</span><span class="sxs-lookup"><span data-stu-id="734af-229">Use Routed Events</span></span>  
 <span data-ttu-id="734af-230">就像依赖属性以附加功能扩展 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 属性的概念一样，路由事件扩展标准 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 事件的概念。</span><span class="sxs-lookup"><span data-stu-id="734af-230">Just as dependency properties extend the notion of [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] properties with additional functionality, routed events extend the notion of standard [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] events.</span></span> <span data-ttu-id="734af-231">在创建新的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 控件时，将事件实现为路由事件也是一种好方法，因为路由事件支持以下行为：</span><span class="sxs-lookup"><span data-stu-id="734af-231">When you create a new [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control, it is also good practice to implement your event as a routed event because a routed event supports the following behavior:</span></span>  
  
-   <span data-ttu-id="734af-232">事件可以在多个控件的父级上进行处理。</span><span class="sxs-lookup"><span data-stu-id="734af-232">Events can be handled on a parent of multiple controls.</span></span> <span data-ttu-id="734af-233">如果事件是浮升事件，元素树中的单个父级可订阅该事件。</span><span class="sxs-lookup"><span data-stu-id="734af-233">If an event is a bubbling event, a single parent in the element tree can subscribe to the event.</span></span> <span data-ttu-id="734af-234">然后，应用程序作者可以使用一个处理程序来响应多个控件的该事件。</span><span class="sxs-lookup"><span data-stu-id="734af-234">Then application authors can use one handler to respond to the event of multiple controls.</span></span> <span data-ttu-id="734af-235">例如，如果您的控件是在每个项的一部分<xref:System.Windows.Controls.ListBox>(因为它包含在<xref:System.Windows.DataTemplate>)，应用程序开发人员可以在定义控件的事件的事件处理程序<xref:System.Windows.Controls.ListBox>。</span><span class="sxs-lookup"><span data-stu-id="734af-235">For example, if your control is a part of each item in a <xref:System.Windows.Controls.ListBox> (because it is included in a <xref:System.Windows.DataTemplate>), the application developer can define the event handler for your control's event on the <xref:System.Windows.Controls.ListBox>.</span></span> <span data-ttu-id="734af-236">每当其中任何控件发生该事件时，都会调用该事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="734af-236">Whenever the event occurs on any of the controls, the event handler is called.</span></span>  
  
-   <span data-ttu-id="734af-237">路由的事件可在<xref:System.Windows.EventSetter>，这使应用程序开发人员能够指定的样式中的事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="734af-237">Routed events can be used in an <xref:System.Windows.EventSetter>, which enables application developers to specify the handler of an event within a style.</span></span>  
  
-   <span data-ttu-id="734af-238">路由的事件可在<xref:System.Windows.EventTrigger>，可用于通过对属性进行动画处理[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="734af-238">Routed events can be used in an <xref:System.Windows.EventTrigger>, which is useful for animating properties by using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span> <span data-ttu-id="734af-239">有关详细信息，请参阅 [动画概述](../../../../docs/framework/wpf/graphics-multimedia/animation-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="734af-239">For more information, see [Animation Overview](../../../../docs/framework/wpf/graphics-multimedia/animation-overview.md).</span></span>  
  
 <span data-ttu-id="734af-240">下面的示例通过执行以下操作定义了一个路由事件：</span><span class="sxs-lookup"><span data-stu-id="734af-240">The following example defines a routed event by doing the following:</span></span>  
  
-   <span data-ttu-id="734af-241">定义<xref:System.Windows.RoutedEvent>名为标识符`ValueChangedEvent`作为`public` `static` `readonly`字段。</span><span class="sxs-lookup"><span data-stu-id="734af-241">Define a <xref:System.Windows.RoutedEvent> identifier named `ValueChangedEvent` as a `public` `static` `readonly` field.</span></span>  
  
-   <span data-ttu-id="734af-242">通过调用注册路由的事件<xref:System.Windows.EventManager.RegisterRoutedEvent%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="734af-242">Register the routed event by calling the <xref:System.Windows.EventManager.RegisterRoutedEvent%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="734af-243">该示例在调用时指定以下信息<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>:</span><span class="sxs-lookup"><span data-stu-id="734af-243">The example specifies the following information when it calls <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>:</span></span>  
  
    -   <span data-ttu-id="734af-244">事件名称是 `ValueChanged`。</span><span class="sxs-lookup"><span data-stu-id="734af-244">The name of the event is `ValueChanged`.</span></span>  
  
    -   <span data-ttu-id="734af-245">路由策略是<xref:System.Windows.RoutingStrategy.Bubble>，这意味着首先，调用源 （引发事件的对象） 上的事件处理程序，然后使用上的最近的事件处理程序开始，相继调用源的父元素上的事件处理程序父元素。</span><span class="sxs-lookup"><span data-stu-id="734af-245">The routing strategy is <xref:System.Windows.RoutingStrategy.Bubble>, which means that an event handler on the source (the object that raises the event) is called first, and then event handlers on the source's parent elements are called in succession, starting with the event handler on the closest parent element.</span></span>  
  
    -   <span data-ttu-id="734af-246">事件处理程序的类型是<xref:System.Windows.RoutedPropertyChangedEventHandler%601>、 构造与<xref:System.Decimal>类型。</span><span class="sxs-lookup"><span data-stu-id="734af-246">The type of the event handler is <xref:System.Windows.RoutedPropertyChangedEventHandler%601>, constructed with a <xref:System.Decimal> type.</span></span>  
  
    -   <span data-ttu-id="734af-247">该事件的所属类型为 `NumericUpDown`。</span><span class="sxs-lookup"><span data-stu-id="734af-247">The owning type of the event is `NumericUpDown`.</span></span>  
  
-   <span data-ttu-id="734af-248">声明一个名为 `ValueChanged` 的公共事件，并包含事件访问器声明。</span><span class="sxs-lookup"><span data-stu-id="734af-248">Declare a public event named `ValueChanged` and includes event-accessor declarations.</span></span> <span data-ttu-id="734af-249">此示例调用<xref:System.Windows.UIElement.AddHandler%2A>中`add`访问器声明并<xref:System.Windows.UIElement.RemoveHandler%2A>中`remove`访问器声明，以使用[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]事件服务。</span><span class="sxs-lookup"><span data-stu-id="734af-249">The example calls <xref:System.Windows.UIElement.AddHandler%2A> in the `add` accessor declaration and <xref:System.Windows.UIElement.RemoveHandler%2A> in the `remove` accessor declaration to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event services.</span></span>  
  
-   <span data-ttu-id="734af-250">创建一个名为 `OnValueChanged` 的受保护的虚拟方法，该方法会引发 `ValueChanged` 事件。</span><span class="sxs-lookup"><span data-stu-id="734af-250">Create a protected, virtual method named `OnValueChanged` that raises the `ValueChanged` event.</span></span>  
  
 [!code-csharp[UserControlNumericUpDown#RoutedEvent](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml.cs#routedevent)]
 [!code-vb[UserControlNumericUpDown#RoutedEvent](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDown/visualbasic/numericupdown.xaml.vb#routedevent)]  
  
 <span data-ttu-id="734af-251">有关详细信息，请参阅[路由事件概述](../../../../docs/framework/wpf/advanced/routed-events-overview.md)和[创建自定义路由事件](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md)。</span><span class="sxs-lookup"><span data-stu-id="734af-251">For more information, see [Routed Events Overview](../../../../docs/framework/wpf/advanced/routed-events-overview.md) and [Create a Custom Routed Event](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md).</span></span>  
  
### <a name="use-binding"></a><span data-ttu-id="734af-252">使用绑定</span><span class="sxs-lookup"><span data-stu-id="734af-252">Use Binding</span></span>  
 <span data-ttu-id="734af-253">若要将控件的 UI 与其逻辑分离，请考虑使用数据绑定。</span><span class="sxs-lookup"><span data-stu-id="734af-253">To decouple the UI of your control from its logic, consider using data binding.</span></span> <span data-ttu-id="734af-254">这一点特别重要，如果您通过使用定义控件外观<xref:System.Windows.Controls.ControlTemplate>。</span><span class="sxs-lookup"><span data-stu-id="734af-254">This is particularly important if you define the appearance of your control by using a <xref:System.Windows.Controls.ControlTemplate>.</span></span> <span data-ttu-id="734af-255">使用数据绑定时，或许可以避免在代码中引用 UI 的特定部分。</span><span class="sxs-lookup"><span data-stu-id="734af-255">When you use data binding, you might be able to eliminate the need to reference specific parts of the UI from the code.</span></span> <span data-ttu-id="734af-256">它是一个好办法避免引用中的元素<xref:System.Windows.Controls.ControlTemplate>因为当代码引用中的元素<xref:System.Windows.Controls.ControlTemplate>并<xref:System.Windows.Controls.ControlTemplate>已更改，引用的元素需要包含在新<xref:System.Windows.Controls.ControlTemplate>。</span><span class="sxs-lookup"><span data-stu-id="734af-256">It's a good idea to avoid referencing elements that are in the <xref:System.Windows.Controls.ControlTemplate> because when the code references elements that are in the <xref:System.Windows.Controls.ControlTemplate> and the <xref:System.Windows.Controls.ControlTemplate> is changed, the referenced element needs to be included in the new <xref:System.Windows.Controls.ControlTemplate>.</span></span>  
  
 <span data-ttu-id="734af-257">以下示例更新<xref:System.Windows.Controls.TextBlock>的`NumericUpDown`向它分配一个名称，并且在代码中按名称引用该文本框控件。</span><span class="sxs-lookup"><span data-stu-id="734af-257">The following example updates the <xref:System.Windows.Controls.TextBlock> of the `NumericUpDown` control, assigning a name to it and referencing the textbox by name in code.</span></span>  
  
 [!code-xaml[UserControlNumericUpDownSimple#UIRefMarkup](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDownSimple/CSharp/NumericUpDown.xaml#uirefmarkup)]  
  
 [!code-csharp[UserControlNumericUpDownSimple#UIRefCode](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDownSimple/CSharp/NumericUpDown.xaml.cs#uirefcode)]
 [!code-vb[UserControlNumericUpDownSimple#UIRefCode](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDownSimple/VisualBasic/NumericUpDown.xaml.vb#uirefcode)]  
  
 <span data-ttu-id="734af-258">下面的示例使用绑定来达到相同的目的。</span><span class="sxs-lookup"><span data-stu-id="734af-258">The following example uses binding to accomplish the same thing.</span></span>  
  
 [!code-xaml[UserControlNumericUpDown#Binding](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml#binding)]  
  
 <span data-ttu-id="734af-259">有关数据绑定的详细信息，请参阅[数据绑定概述](../../../../docs/framework/wpf/data/data-binding-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="734af-259">For more information about data binding, see [Data Binding Overview](../../../../docs/framework/wpf/data/data-binding-overview.md).</span></span>  
  
### <a name="design-for-designers"></a><span data-ttu-id="734af-260">设计器的设计</span><span class="sxs-lookup"><span data-stu-id="734af-260">Design for Designers</span></span>  
 <span data-ttu-id="734af-261">若要在 [!INCLUDE[wpfdesigner_current_long](../../../../includes/wpfdesigner-current-long-md.md)] 中获得对自定义 WPF 控件的支持（例如，使用“属性”窗口编辑属性），请遵循以下准则。</span><span class="sxs-lookup"><span data-stu-id="734af-261">To receive support for custom WPF controls in the [!INCLUDE[wpfdesigner_current_long](../../../../includes/wpfdesigner-current-long-md.md)] (for example, property editing with the Properties window), follow these guidelines.</span></span>  <span data-ttu-id="734af-262">有关开发的详细信息[!INCLUDE[wpfdesigner_current_short](../../../../includes/wpfdesigner-current-short-md.md)]，请参阅[Visual Studio 中设计 XAML](/visualstudio/designers/designing-xaml-in-visual-studio)。</span><span class="sxs-lookup"><span data-stu-id="734af-262">For more information on developing for the [!INCLUDE[wpfdesigner_current_short](../../../../includes/wpfdesigner-current-short-md.md)], see [Design XAML in Visual Studio](/visualstudio/designers/designing-xaml-in-visual-studio).</span></span>  
  
#### <a name="dependency-properties"></a><span data-ttu-id="734af-263">依赖项属性</span><span class="sxs-lookup"><span data-stu-id="734af-263">Dependency Properties</span></span>  
 <span data-ttu-id="734af-264">确保实现 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] `get` 和 `set` 访问器，如前面的“使用依赖属性”中所述。</span><span class="sxs-lookup"><span data-stu-id="734af-264">Be sure to implement [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] `get` and `set` accessors as described earlier, in "Use Dependency Properties."</span></span> <span data-ttu-id="734af-265">设计器可以使用包装器来检测某个依赖属性是否存在，但与 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 和控件客户端一样，在获取或设置属性时不需要使用设计器来调用访问器。</span><span class="sxs-lookup"><span data-stu-id="734af-265">Designers may use the wrapper to detect the presence of a dependency property, but they, like [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and clients of the control, are not required to call the accessors when getting or setting the property.</span></span>  
  
#### <a name="attached-properties"></a><span data-ttu-id="734af-266">附加属性</span><span class="sxs-lookup"><span data-stu-id="734af-266">Attached Properties</span></span>  
 <span data-ttu-id="734af-267">应使用以下准则在自定义控件上实现附加属性：</span><span class="sxs-lookup"><span data-stu-id="734af-267">You should implement attached properties on custom controls using the following guidelines:</span></span>  
  
-   <span data-ttu-id="734af-268">具有`public` `static` `readonly` <xref:System.Windows.DependencyProperty>窗体*PropertyName* `Property`创建使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="734af-268">Have a `public` `static` `readonly` <xref:System.Windows.DependencyProperty> of the form *PropertyName*`Property` that was creating using the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method.</span></span> <span data-ttu-id="734af-269">属性名称传递给<xref:System.Windows.DependencyProperty.RegisterAttached%2A>必须匹配*PropertyName*。</span><span class="sxs-lookup"><span data-stu-id="734af-269">The property name that is passed to <xref:System.Windows.DependencyProperty.RegisterAttached%2A> must match *PropertyName*.</span></span>  
  
-   <span data-ttu-id="734af-270">实现一对名为`Set`*属性名称*和`Get`*属性名称*的 `public` `static` CLR 方法。</span><span class="sxs-lookup"><span data-stu-id="734af-270">Implement a pair of `public` `static` CLR methods named `Set`*PropertyName* and `Get`*PropertyName*.</span></span> <span data-ttu-id="734af-271">这两种方法应接受派生自的类<xref:System.Windows.DependencyProperty>作为其第一个参数。</span><span class="sxs-lookup"><span data-stu-id="734af-271">Both methods should accept a class derived from <xref:System.Windows.DependencyProperty> as their first argument.</span></span> <span data-ttu-id="734af-272">`Set`*属性名称*方法还接受其类型与属性的注册数据类型匹配的参数。</span><span class="sxs-lookup"><span data-stu-id="734af-272">The `Set`*PropertyName* method also accepts an argument whose type matches the registered data type for the property.</span></span> <span data-ttu-id="734af-273">`Get`*属性名称* 方法应返回相同类型的值。</span><span class="sxs-lookup"><span data-stu-id="734af-273">The `Get`*PropertyName* method should return a value of the same type.</span></span> <span data-ttu-id="734af-274">如果缺少 `Set`*属性名称*方法，则该属性标记为只读。</span><span class="sxs-lookup"><span data-stu-id="734af-274">If the `Set`*PropertyName* method is missing, the property is marked read-only.</span></span>  
  
-   <span data-ttu-id="734af-275">`Set` *PropertyName*并`Get` *PropertyName*必须直接路由到<xref:System.Windows.DependencyObject.GetValue%2A>和<xref:System.Windows.DependencyObject.SetValue%2A>方法目标依赖对象，分别。</span><span class="sxs-lookup"><span data-stu-id="734af-275">`Set` *PropertyName* and `Get`*PropertyName* must route directly to the <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> methods on the target dependency object, respectively.</span></span> <span data-ttu-id="734af-276">通过调用方法包装器或直接调用目标依赖对象，设计器可以访问附加属性。</span><span class="sxs-lookup"><span data-stu-id="734af-276">Designers may access the attached property by calling through the method wrapper or making a direct call to the target dependency object.</span></span>  
  
 <span data-ttu-id="734af-277">有关附加属性的详细信息，请参阅[附加属性概述](../../../../docs/framework/wpf/advanced/attached-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="734af-277">For more information on attached properties, see [Attached Properties Overview](../../../../docs/framework/wpf/advanced/attached-properties-overview.md).</span></span>  
  
### <a name="define-and-use-shared-resources"></a><span data-ttu-id="734af-278">定义和使用共享资源</span><span class="sxs-lookup"><span data-stu-id="734af-278">Define and Use Shared Resources</span></span>  
 <span data-ttu-id="734af-279">可以将控件包含在应用程序所在的程序集中，也可以将控件打包到可在多个应用程序中使用的单独程序集中。</span><span class="sxs-lookup"><span data-stu-id="734af-279">You can include your control in the same assembly as your application, or you can package your control in a separate assembly that can be used in multiple applications.</span></span> <span data-ttu-id="734af-280">大多数情况下，不管使用什么方法，本主题中讨论的信息都适用。</span><span class="sxs-lookup"><span data-stu-id="734af-280">For the most part, the information discussed in this topic applies regardless of the method you use.</span></span>  <span data-ttu-id="734af-281">但有一处差异值得注意。</span><span class="sxs-lookup"><span data-stu-id="734af-281">There is one difference worth noting, however.</span></span>  <span data-ttu-id="734af-282">将控件放入应用程序所在的程序集中时，可以随意向 App.xaml 文件添加全局资源。</span><span class="sxs-lookup"><span data-stu-id="734af-282">When you put a control in the same assembly as an application, you are free to add global resources to the App.xaml file.</span></span> <span data-ttu-id="734af-283">但只包含控件的程序集不具有<xref:System.Windows.Application>与其相关的对象，因此 App.xaml 文件不可用。</span><span class="sxs-lookup"><span data-stu-id="734af-283">But an assembly that contains only controls does not have an <xref:System.Windows.Application> object associated with it, so an App.xaml file is not available.</span></span>  
  
 <span data-ttu-id="734af-284">当应用程序查找资源时，它会按以下顺序在三个级别进行查找：</span><span class="sxs-lookup"><span data-stu-id="734af-284">When an application looks for a resource, it looks at three levels in the following order:</span></span>  
  
1.  <span data-ttu-id="734af-285">元素级别。</span><span class="sxs-lookup"><span data-stu-id="734af-285">The element level.</span></span>  
  
     <span data-ttu-id="734af-286">系统从引用该资源的元素开始搜索，接着搜索逻辑父级的资源，依此类推，直至到达根元素。</span><span class="sxs-lookup"><span data-stu-id="734af-286">The system starts with the element that references the resource and then searches resources of the logical parent and so forth until the root element is reached.</span></span>  
  
2.  <span data-ttu-id="734af-287">应用程序级别。</span><span class="sxs-lookup"><span data-stu-id="734af-287">The application level.</span></span>  
  
     <span data-ttu-id="734af-288">定义的资源，<xref:System.Windows.Application>对象。</span><span class="sxs-lookup"><span data-stu-id="734af-288">Resources defined by the <xref:System.Windows.Application> object.</span></span>  
  
3.  <span data-ttu-id="734af-289">主题级别。</span><span class="sxs-lookup"><span data-stu-id="734af-289">The theme level.</span></span>  
  
     <span data-ttu-id="734af-290">主题级别的字典存储在名为“Themes”的子文件夹中。</span><span class="sxs-lookup"><span data-stu-id="734af-290">Theme-level dictionaries are stored in a subfolder named Themes.</span></span>  <span data-ttu-id="734af-291">Themes 文件夹中的文件与主题对应。</span><span class="sxs-lookup"><span data-stu-id="734af-291">The files in the Themes folder correspond to themes.</span></span>  <span data-ttu-id="734af-292">例如，可能有 Aero.NormalColor.xaml、Luna.NormalColor.xaml、Royale.NormalColor.xaml 等。</span><span class="sxs-lookup"><span data-stu-id="734af-292">For example, you might have Aero.NormalColor.xaml, Luna.NormalColor.xaml, Royale.NormalColor.xaml, and so on.</span></span>  <span data-ttu-id="734af-293">可能还有一个名为 generic.xaml 的文件。</span><span class="sxs-lookup"><span data-stu-id="734af-293">You can also have a file named generic.xaml.</span></span>  <span data-ttu-id="734af-294">当系统在主题级别查找资源时，它会先在特定于主题的文件中查找相应资源，然后在 generic.xaml 中进行查找。</span><span class="sxs-lookup"><span data-stu-id="734af-294">When the system looks for a resource at the themes level, it first looks for it in the theme-specific file and then looks for it in generic.xaml.</span></span>  
  
 <span data-ttu-id="734af-295">当控件位于独立于应用程序的程序集中时，必须将全局资源放在元素级别或主题级别。</span><span class="sxs-lookup"><span data-stu-id="734af-295">When your control is in an assembly that is separate from the application, you must put your global resources at the element level or at the theme level.</span></span> <span data-ttu-id="734af-296">这两种方法都各有优点。</span><span class="sxs-lookup"><span data-stu-id="734af-296">Both methods have their advantages.</span></span>  
  
#### <a name="defining-resources-at-the-element-level"></a><span data-ttu-id="734af-297">在元素级别定义资源</span><span class="sxs-lookup"><span data-stu-id="734af-297">Defining Resources at the Element Level</span></span>  
 <span data-ttu-id="734af-298">可以通过创建自定义资源字典并将其与控件的资源字典合并，在元素级别定义共享资源。</span><span class="sxs-lookup"><span data-stu-id="734af-298">You can define shared resources at the element level by creating a custom resource dictionary and merging it with your control’s resource dictionary.</span></span>  <span data-ttu-id="734af-299">采用此方法时，可以为资源文件指定任意名称，并且资源文件可以与控件位于同一文件夹中。</span><span class="sxs-lookup"><span data-stu-id="734af-299">When you use this method, you can name your resource file anything you want, and it can be in the same folder as your controls.</span></span> <span data-ttu-id="734af-300">元素级别的资源还可以使用简单字符串作为键。</span><span class="sxs-lookup"><span data-stu-id="734af-300">Resources at the element level can also use simple strings as keys.</span></span> <span data-ttu-id="734af-301">下面的示例创建<xref:System.Windows.Media.LinearGradientBrush>名为 Dictionary1.xaml 的资源文件。</span><span class="sxs-lookup"><span data-stu-id="734af-301">The following example creates a <xref:System.Windows.Media.LinearGradientBrush> resource file named Dictionary1.xaml.</span></span>  
  
 [!code-xaml[SharedResources#1](../../../../samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/Dictionary1.xaml#1)]  
  
 <span data-ttu-id="734af-302">定义字典后，需要将其与控件的资源字典合并。</span><span class="sxs-lookup"><span data-stu-id="734af-302">Once you have defined your dictionary, you need to merge it with your control's resource dictionary.</span></span>  <span data-ttu-id="734af-303">可以使用 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 或代码执行此操作。</span><span class="sxs-lookup"><span data-stu-id="734af-303">You can do this by using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] or code.</span></span>  
  
 <span data-ttu-id="734af-304">下面的示例通过使用 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 合并资源字典。</span><span class="sxs-lookup"><span data-stu-id="734af-304">The following example merges a resource dictionary by using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 [!code-xaml[SharedResources#2](../../../../samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/ShapeResizer.xaml#2)]  
  
 <span data-ttu-id="734af-305">这种方法的缺点是<xref:System.Windows.ResourceDictionary>引用它每次创建对象。</span><span class="sxs-lookup"><span data-stu-id="734af-305">The disadvantage to this approach is that a <xref:System.Windows.ResourceDictionary> object is created each time you reference it.</span></span>  <span data-ttu-id="734af-306">例如，如果您库中有 10 个自定义控件，并通过使用 XAML 来合并每个控件的共享的资源字典，则创建 10 相同<xref:System.Windows.ResourceDictionary>对象。</span><span class="sxs-lookup"><span data-stu-id="734af-306">For example, if you have 10 custom controls in your library and merge the shared resource dictionaries for each control by using XAML, you create 10 identical <xref:System.Windows.ResourceDictionary> objects.</span></span>  <span data-ttu-id="734af-307">您可以避免这种情况创建合并在代码中的资源，并返回结果的静态类<xref:System.Windows.ResourceDictionary>。</span><span class="sxs-lookup"><span data-stu-id="734af-307">You can avoid this by creating a static class that merges the resources in code and returns the resulting <xref:System.Windows.ResourceDictionary>.</span></span>  
  
 <span data-ttu-id="734af-308">下面的示例创建一个返回共享的类<xref:System.Windows.ResourceDictionary>。</span><span class="sxs-lookup"><span data-stu-id="734af-308">The following example creates a class that returns a shared <xref:System.Windows.ResourceDictionary>.</span></span>  
  
 [!code-csharp[SharedResources#3](../../../../samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/SharedDictionaryManager.cs#3)]  
  
 <span data-ttu-id="734af-309">下面的示例先在一个自定义控件的构造函数中将共享资源与该控件的资源合并，然后再调用 `InitializeComponent`。</span><span class="sxs-lookup"><span data-stu-id="734af-309">The following example merges the shared resource with the resources of a custom control in the control's constructor before it calls `InitializeComponent`.</span></span>  <span data-ttu-id="734af-310">因为`SharedDictionaryManager.SharedDictionary`是一个静态属性，<xref:System.Windows.ResourceDictionary>创建仅一次。</span><span class="sxs-lookup"><span data-stu-id="734af-310">Because the `SharedDictionaryManager.SharedDictionary` is a static property, the <xref:System.Windows.ResourceDictionary> is created only once.</span></span> <span data-ttu-id="734af-311">因为资源字典在调用 `InitializeComponent` 前已合并，所以控件可以在它的 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 文件中使用资源。</span><span class="sxs-lookup"><span data-stu-id="734af-311">Because the resource dictionary was merged before `InitializeComponent` was called, the resources are available to the control in its [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] file.</span></span>  
  
 [!code-csharp[SharedResources#4](../../../../samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/ShapeResizer.xaml.cs#4)]  
  
#### <a name="defining-resources-at-the-theme-level"></a><span data-ttu-id="734af-312">在主题级别定义资源</span><span class="sxs-lookup"><span data-stu-id="734af-312">Defining Resources at the Theme Level</span></span>  
 <span data-ttu-id="734af-313">通过 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 可以为不同的 Windows 主题创建资源。</span><span class="sxs-lookup"><span data-stu-id="734af-313">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] enables you to create resources for different Windows themes.</span></span>  <span data-ttu-id="734af-314">作为控件作者，可以为特定主题定义资源，以根据所使用的主题更改控件的外观。</span><span class="sxs-lookup"><span data-stu-id="734af-314">As a control author, you can define a resource for a specific theme to change your control's appearance depending on what theme is in use.</span></span> <span data-ttu-id="734af-315">例如的外观<xref:System.Windows.Controls.Button>在 Windows 经典主题 （Windows 2000 的默认主题） 不同于<xref:System.Windows.Controls.Button>Windows Luna 主题 （Windows XP 的默认主题） 中由于<xref:System.Windows.Controls.Button>使用不同<xref:System.Windows.Controls.ControlTemplate>为每个主题。</span><span class="sxs-lookup"><span data-stu-id="734af-315">For example, the appearance of a <xref:System.Windows.Controls.Button> in the Windows Classic theme (the default theme for Windows 2000) differs from a <xref:System.Windows.Controls.Button> in the Windows Luna theme (the default theme for Windows XP) because the <xref:System.Windows.Controls.Button> uses a different <xref:System.Windows.Controls.ControlTemplate> for each theme.</span></span>  
  
 <span data-ttu-id="734af-316">特定于主题的资源以特定文件名保留在资源字典中。</span><span class="sxs-lookup"><span data-stu-id="734af-316">Resources that are specific to a theme are kept in a resource dictionary with a specific file name.</span></span> <span data-ttu-id="734af-317">这些文件必须位于一个名为 `Themes` 的文件夹中，此文件夹是包含该控件的文件夹的子文件夹。</span><span class="sxs-lookup"><span data-stu-id="734af-317">These files must be in a folder named `Themes` that is a subfolder of the folder that contains the control.</span></span> <span data-ttu-id="734af-318">下表列出了资源字典文件以及与每个文件关联的主题：</span><span class="sxs-lookup"><span data-stu-id="734af-318">The following table lists the resource dictionary files and the theme that is associated with each file:</span></span>  
  
|<span data-ttu-id="734af-319">资源字典文件名</span><span class="sxs-lookup"><span data-stu-id="734af-319">Resource dictionary file name</span></span>|<span data-ttu-id="734af-320">Windows 主题</span><span class="sxs-lookup"><span data-stu-id="734af-320">Windows theme</span></span>|  
|-----------------------------------|-------------------|  
|`Classic.xaml`|<span data-ttu-id="734af-321">Windows XP 中的经典 Windows 9x/2000 外观</span><span class="sxs-lookup"><span data-stu-id="734af-321">Classic Windows 9x/2000 look on Windows XP</span></span>|  
|`Luna.NormalColor.xaml`|<span data-ttu-id="734af-322">Windows XP 上的默认蓝色主题</span><span class="sxs-lookup"><span data-stu-id="734af-322">Default blue theme on Windows XP</span></span>|  
|`Luna.Homestead.xaml`|<span data-ttu-id="734af-323">Windows XP 上的橄榄色主题</span><span class="sxs-lookup"><span data-stu-id="734af-323">Olive theme on Windows XP</span></span>|  
|`Luna.Metallic.xaml`|<span data-ttu-id="734af-324">Windows XP 上的银色主题</span><span class="sxs-lookup"><span data-stu-id="734af-324">Silver theme on Windows XP</span></span>|  
|`Royale.NormalColor.xaml`|<span data-ttu-id="734af-325">Windows XP Media Center Edition 上的默认主题</span><span class="sxs-lookup"><span data-stu-id="734af-325">Default theme on Windows XP Media Center Edition</span></span>|  
|`Aero.NormalColor.xaml`|<span data-ttu-id="734af-326">Windows Vista 上的默认主题</span><span class="sxs-lookup"><span data-stu-id="734af-326">Default theme on Windows Vista</span></span>|  
  
 <span data-ttu-id="734af-327">无需为每一种主题都定义资源。</span><span class="sxs-lookup"><span data-stu-id="734af-327">You do not need to define a resource for every theme.</span></span> <span data-ttu-id="734af-328">如果没有为特定主题定义资源，控件将在 `Classic.xaml` 中检查资源。</span><span class="sxs-lookup"><span data-stu-id="734af-328">If a resource is not defined for a specific theme, then the control checks `Classic.xaml` for the resource.</span></span> <span data-ttu-id="734af-329">如果在与当前主题对应的文件或 `Classic.xaml` 中没有定义资源，控件将使用常规资源，该资源位于名为 `generic.xaml` 的资源字典文件中。</span><span class="sxs-lookup"><span data-stu-id="734af-329">If the resource is not defined in the file that corresponds to the current theme or in `Classic.xaml`, the control uses the generic resource, which is in a resource dictionary file named `generic.xaml`.</span></span>  <span data-ttu-id="734af-330">`generic.xaml` 文件与特定于主题的资源词典文件位于同一文件夹中。</span><span class="sxs-lookup"><span data-stu-id="734af-330">The `generic.xaml` file is located in the same folder as the theme-specific resource dictionary files.</span></span> <span data-ttu-id="734af-331">尽管 `generic.xaml` 不与特定的 Windows 主题对应，但它仍是一个主题级别字典。</span><span class="sxs-lookup"><span data-stu-id="734af-331">Although `generic.xaml` does not correspond to a specific Windows theme, it is still a theme-level dictionary.</span></span>  
  
 <span data-ttu-id="734af-332">[带有主题和 UI 自动化支持的 NumericUpDown 自定义控件示例](https://go.microsoft.com/fwlink/?LinkID=160025)包含两个用于 `NumericUpDown` 控件的资源字典：一个在 generic.xaml 中，另一个在 Luna.NormalColor.xaml 中。</span><span class="sxs-lookup"><span data-stu-id="734af-332">[NumericUpDown Custom Control with Theme and UI Automation Support Sample](https://go.microsoft.com/fwlink/?LinkID=160025) contains two resource dictionaries for the `NumericUpDown` control: one is in generic.xaml and one is in Luna.NormalColor.xaml.</span></span>  <span data-ttu-id="734af-333">可以运行应用程序并在 Windows XP 中的银色主题和另一主题之间切换，以查看这两个控件模板之间的差别。</span><span class="sxs-lookup"><span data-stu-id="734af-333">You can run the application and switch between the Silver theme in Windows XP and another theme to see the difference between the two control templates.</span></span> <span data-ttu-id="734af-334">（如果运行的是 Windows Vista，可以将 Luna.NormalColor.xaml 重命名为 Aero.NormalColor.xaml，然后在两个主题之间切换，例如在 Windows 经典主题和 Windows Vista 的默认主题之间切换。）</span><span class="sxs-lookup"><span data-stu-id="734af-334">(If you are running Windows Vista, you can rename Luna.NormalColor.xaml to Aero.NormalColor.xaml and switch between two themes, such as Windows Classic and the default theme for Windows Vista.)</span></span>  
  
 <span data-ttu-id="734af-335">当将<xref:System.Windows.Controls.ControlTemplate>必须在任何特定于主题资源字典文件，创建控件和调用静态构造函数<xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>方法<xref:System.Windows.FrameworkElement.DefaultStyleKey%2A>，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="734af-335">When you put a <xref:System.Windows.Controls.ControlTemplate> in any of the theme-specific resource dictionary files, you must create a static constructor for your control and call the <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29> method on the <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A>, as shown in the following example.</span></span>  
  
 [!code-csharp[CustomControlNumericUpDownOneProject#StaticConstructor](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDownOneProject/CSharp/NumericUpDown.cs#staticconstructor)]
 [!code-vb[CustomControlNumericUpDownOneProject#StaticConstructor](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDownOneProject/visualbasic/numericupdown.vb#staticconstructor)]  
  
##### <a name="defining-and-referencing-keys-for-theme-resources"></a><span data-ttu-id="734af-336">定义和引用主题资源的键</span><span class="sxs-lookup"><span data-stu-id="734af-336">Defining and Referencing Keys for Theme Resources</span></span>  
 <span data-ttu-id="734af-337">在元素级别定义资源时，可以指定一个字符串作为它的键，然后通过该字符串访问该资源。</span><span class="sxs-lookup"><span data-stu-id="734af-337">When you define a resource at the element level, you can assign a string as its key and access the resource via the string.</span></span> <span data-ttu-id="734af-338">在定义在主题级别的资源时，必须使用<xref:System.Windows.ComponentResourceKey>作为键。</span><span class="sxs-lookup"><span data-stu-id="734af-338">When you define a resource at the theme level, you must use a <xref:System.Windows.ComponentResourceKey> as the key.</span></span>  <span data-ttu-id="734af-339">以下示例定义 generic.xaml 中的资源。</span><span class="sxs-lookup"><span data-stu-id="734af-339">The following example defines a resource in generic.xaml.</span></span>  
  
 [!code-xaml[ThemeResourcesControlLibrary#5](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThemeResourcesControlLibrary/CS/Themes/generic.xaml#5)]  
  
 <span data-ttu-id="734af-340">下面的示例通过指定引用的资源<xref:System.Windows.ComponentResourceKey>作为键。</span><span class="sxs-lookup"><span data-stu-id="734af-340">The following example references the resource by specifying the <xref:System.Windows.ComponentResourceKey> as the key.</span></span>  
  
 [!code-xaml[ThemeResourcesControlLibrary#6](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThemeResourcesControlLibrary/CS/NumericUpDown.xaml#6)]  
  
##### <a name="specifying-the-location-of-theme-resources"></a><span data-ttu-id="734af-341">指定主题资源的位置</span><span class="sxs-lookup"><span data-stu-id="734af-341">Specifying the Location of Theme Resources</span></span>  
 <span data-ttu-id="734af-342">若要找到控件的资源，承载应用程序需要知道相应程序集包含特定于控件的资源。</span><span class="sxs-lookup"><span data-stu-id="734af-342">To find the resources for a control, the hosting application needs to know that the assembly contains control-specific resources.</span></span> <span data-ttu-id="734af-343">您可以实现此目的通过添加<xref:System.Windows.ThemeInfoAttribute>到包含该控件的程序集。</span><span class="sxs-lookup"><span data-stu-id="734af-343">You can accomplish that by adding the <xref:System.Windows.ThemeInfoAttribute> to the assembly that contains the control.</span></span> <span data-ttu-id="734af-344"><xref:System.Windows.ThemeInfoAttribute>已<xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A>属性，它指定泛型资源的位置和一个<xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A>属性，它指定特定于主题的资源的位置。</span><span class="sxs-lookup"><span data-stu-id="734af-344">The <xref:System.Windows.ThemeInfoAttribute> has a <xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A> property that specifies the location of generic resources, and a <xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A> property that specifies the location of the theme-specific resources.</span></span>  
  
 <span data-ttu-id="734af-345">下面的示例设置<xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A>并<xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A>属性设置为<xref:System.Windows.ResourceDictionaryLocation.SourceAssembly>，以指定的通用和特定于主题资源位于控件所在的程序集。</span><span class="sxs-lookup"><span data-stu-id="734af-345">The following example sets the <xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A> and <xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A> properties to <xref:System.Windows.ResourceDictionaryLocation.SourceAssembly>, to specify that the generic and theme-specific resources are in the same assembly as the control.</span></span>  
  
 [!code-csharp[CustomControlNumericUpDown#ThemesSection](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/Properties/AssemblyInfo.cs#themessection)]
 [!code-vb[CustomControlNumericUpDown#ThemesSection](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/my project/assemblyinfo.vb#themessection)]  
  
## <a name="see-also"></a><span data-ttu-id="734af-346">请参阅</span><span class="sxs-lookup"><span data-stu-id="734af-346">See also</span></span>
- [<span data-ttu-id="734af-347">在 Visual Studio 中设计 XAML</span><span class="sxs-lookup"><span data-stu-id="734af-347">Design XAML in Visual Studio</span></span>](/visualstudio/designers/designing-xaml-in-visual-studio)
- [<span data-ttu-id="734af-348">WPF 中的 Pack URI</span><span class="sxs-lookup"><span data-stu-id="734af-348">Pack URIs in WPF</span></span>](../../../../docs/framework/wpf/app-development/pack-uris-in-wpf.md)
- [<span data-ttu-id="734af-349">控件自定义</span><span class="sxs-lookup"><span data-stu-id="734af-349">Control Customization</span></span>](../../../../docs/framework/wpf/controls/control-customization.md)
