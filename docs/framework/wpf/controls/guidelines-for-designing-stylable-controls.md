---
title: 可样式化控件的设计准则
ms.date: 03/30/2017
helpviewer_keywords:
- style design for controls [WPF]
- controls [WPF], style design
ms.assetid: c52dde45-a311-4531-af4c-853371c4d5f4
ms.openlocfilehash: 756cc821b1a9fe20741e390a1fe6e84d12cc6363
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/08/2019
ms.locfileid: "59148156"
---
# <a name="guidelines-for-designing-stylable-controls"></a><span data-ttu-id="a0361-102">可样式化控件的设计准则</span><span class="sxs-lookup"><span data-stu-id="a0361-102">Guidelines for Designing Stylable Controls</span></span>
<span data-ttu-id="a0361-103">本文档概述在设计可方便地样式化和模板化的控件时需要考虑的一组最佳做法。</span><span class="sxs-lookup"><span data-stu-id="a0361-103">This document summarizes a set of best practices to consider when designing a control which you intend to be easily stylable and templatable.</span></span> <span data-ttu-id="a0361-104">在为内置的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 控件集处理主题控件样式时，我们通过大量试验和错误总结出了这组最佳做法。</span><span class="sxs-lookup"><span data-stu-id="a0361-104">We came to this set of best practices through a lot of trial and error while working on the theme control styles for the built-in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control set.</span></span> <span data-ttu-id="a0361-105">我们已经认识到，成功的样式设置不只是设计完善的对象模型的功能，也是样式本身的功能。</span><span class="sxs-lookup"><span data-stu-id="a0361-105">We learned that successful styling is as much a function of a well-designed object model as it is of the style itself.</span></span> <span data-ttu-id="a0361-106">本文档面向控件作者，而不是样式作者。</span><span class="sxs-lookup"><span data-stu-id="a0361-106">The intended audience for this document is the control author, not the style author.</span></span>  
  
  <a name="Terminology"></a>   
## <a name="terminology"></a><span data-ttu-id="a0361-107">术语</span><span class="sxs-lookup"><span data-stu-id="a0361-107">Terminology</span></span>  
 <span data-ttu-id="a0361-108">“样式设置和模板化”是一组技术，控件作者可以通过该组技术将控件的可视化特性延迟到控件的样式和模板。</span><span class="sxs-lookup"><span data-stu-id="a0361-108">"Styling and templating" refer to the suite of technologies that enable a control author to defer the visual aspects of the control to the style and template of the control.</span></span> <span data-ttu-id="a0361-109">这组技术包括：</span><span class="sxs-lookup"><span data-stu-id="a0361-109">This suite of technologies includes:</span></span>  
  
-   <span data-ttu-id="a0361-110">样式（包括属性资源库、触发器和演示图板）。</span><span class="sxs-lookup"><span data-stu-id="a0361-110">Styles (including property setters, triggers, and storyboards).</span></span>  
  
-   <span data-ttu-id="a0361-111">资源。</span><span class="sxs-lookup"><span data-stu-id="a0361-111">Resources.</span></span>  
  
-   <span data-ttu-id="a0361-112">控件模板。</span><span class="sxs-lookup"><span data-stu-id="a0361-112">Control templates.</span></span>  
  
-   <span data-ttu-id="a0361-113">数据模板。</span><span class="sxs-lookup"><span data-stu-id="a0361-113">Data templates.</span></span>  
  
 <span data-ttu-id="a0361-114">有关样式设置和模板化简介，请参阅[样式设置和模板化](styling-and-templating.md)。</span><span class="sxs-lookup"><span data-stu-id="a0361-114">For an introduction to styling and templating, see [Styling and Templating](styling-and-templating.md).</span></span>  
  
<a name="Before_You_Start__Understanding_Your_Control"></a>   
## <a name="before-you-start-understanding-your-control"></a><span data-ttu-id="a0361-115">在开始之前：了解您的控件</span><span class="sxs-lookup"><span data-stu-id="a0361-115">Before You Start: Understanding Your Control</span></span>  
 <span data-ttu-id="a0361-116">在开始阅读这些准则之前，请务必了解并定义了控件的常见用法。</span><span class="sxs-lookup"><span data-stu-id="a0361-116">Before you jump into these guidelines, it is important to understand and have defined the common usage of your control.</span></span> <span data-ttu-id="a0361-117">样式设置公开一组通常不受约束的可能性。</span><span class="sxs-lookup"><span data-stu-id="a0361-117">Styling exposes an often unruly set of possibilities.</span></span> <span data-ttu-id="a0361-118">旨在由许多开发人员在许多应用程序中广泛使用的控件面临着如下挑战：可以使用样式设置对控件的可视化外观进行广泛更改。</span><span class="sxs-lookup"><span data-stu-id="a0361-118">Controls that are written to be used broadly (in many applications, by many developers) face the challenge that styling can be used to make far-reaching changes to the visual appearance of the control.</span></span> <span data-ttu-id="a0361-119">实际上，带样式的控件甚至可能并非控件作者的本意。</span><span class="sxs-lookup"><span data-stu-id="a0361-119">In fact, the styled control may not even resemble the control author's intentions.</span></span> <span data-ttu-id="a0361-120">由于样式设置在本质上可以提供无限的灵活性，因此可以使用“常见用法”这一概念来帮助你限制自己的决定。</span><span class="sxs-lookup"><span data-stu-id="a0361-120">Since the flexibility offered by styling is essentially boundless, you can use the idea of common usage to help you scope your decisions.</span></span>  
  
 <span data-ttu-id="a0361-121">若要了解控件的常见用法，最好考虑控件的价值主张。</span><span class="sxs-lookup"><span data-stu-id="a0361-121">To understand your control's common usage, it's good to think about the value proposition of the control.</span></span> <span data-ttu-id="a0361-122">你的控件能够在表中提供哪些无法由其他控件提供的内容？</span><span class="sxs-lookup"><span data-stu-id="a0361-122">What does your control bring to the table that no other control can offer?</span></span> <span data-ttu-id="a0361-123">常见用法并不表示任何特定的可视化外观，而是表示控件的基本原理和一组有关其用法的合理预期。</span><span class="sxs-lookup"><span data-stu-id="a0361-123">Common usage does not imply any specific visual appearance, but rather the philosophy of the control and a reasonable set of expectations about its usage.</span></span> <span data-ttu-id="a0361-124">了解到这一点，就可以对控件在一般情况下的撰写模型和样式定义行为进行一些假设。</span><span class="sxs-lookup"><span data-stu-id="a0361-124">This understanding allows you to make some assumptions about the composition model and the style-defined behaviors of the control in the common case.</span></span> <span data-ttu-id="a0361-125">情况下<xref:System.Windows.Controls.ComboBox>，例如，了解常见的使用情况不会深入分析任何有关某个特定<xref:System.Windows.Controls.ComboBox>具有圆的角，但能够让你深入了解这一事实，<xref:System.Windows.Controls.ComboBox>可能需要一个弹出窗口和切换是否处于打开状态的一些方法。</span><span class="sxs-lookup"><span data-stu-id="a0361-125">In the case of <xref:System.Windows.Controls.ComboBox>, for example, understanding the common usage won't give you any insight about whether a particular <xref:System.Windows.Controls.ComboBox> has rounded corners, but it will give you insight into the fact that the <xref:System.Windows.Controls.ComboBox> probably needs a pop-up window and some way of toggling whether it is open.</span></span>  
  
<a name="General_Guidelines"></a>   
## <a name="general-guidelines"></a><span data-ttu-id="a0361-126">通用准则</span><span class="sxs-lookup"><span data-stu-id="a0361-126">General Guidelines</span></span>  
  
-   **<span data-ttu-id="a0361-127">不严格实施模板协定。</span><span class="sxs-lookup"><span data-stu-id="a0361-127">Do not strictly enforce template contracts.</span></span>** <span data-ttu-id="a0361-128">控件的模板协定可能包含元素、命令、绑定和触发器，甚至还可以包含必需的或为了使控件正常工作而应当使用的属性设置。</span><span class="sxs-lookup"><span data-stu-id="a0361-128">The template contract of a control might consist of elements, commands, bindings, triggers, or even property settings that are required or expected for a control to function properly.</span></span>  
  
    -   <span data-ttu-id="a0361-129">最大限度地减少协定。</span><span class="sxs-lookup"><span data-stu-id="a0361-129">Minimize contracts as much as possible.</span></span>  
  
    -   <span data-ttu-id="a0361-130">围绕如下预期进行设计：在设计时（即，在使用设计工具时），控件模板通常处于不完整状态。</span><span class="sxs-lookup"><span data-stu-id="a0361-130">Design around the expectation that during design time (that is, when using a design tool) it is common for a control template to be in an incomplete state.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="a0361-131">因此，控件必须要生成这种状态可能是有效的假定条件下，不提供"正在撰写"状态的基础结构。</span><span class="sxs-lookup"><span data-stu-id="a0361-131">does not offer a "composing" state infrastructure, so controls have to be built with the expectation that such a state might be valid.</span></span>  
  
    -   <span data-ttu-id="a0361-132">在没有遵循模板协定的任何方面时，不引发异常。</span><span class="sxs-lookup"><span data-stu-id="a0361-132">Do not throw exceptions when any aspect of a template contract is not followed.</span></span> <span data-ttu-id="a0361-133">按照这一原则，当面板的子级太多或太少时，面板不应引发异常。</span><span class="sxs-lookup"><span data-stu-id="a0361-133">Along these lines, panels should not throw exceptions if they have too many or too few children.</span></span>  
  
-   **<span data-ttu-id="a0361-134">外围功能分解成模板帮助程序元素。</span><span class="sxs-lookup"><span data-stu-id="a0361-134">Factor peripheral functionality into template helper elements.</span></span>** <span data-ttu-id="a0361-135">每个控件都应当将重点放在其核心功能和真正的价值主张上，而且每个控件都应当由控件的常见用法定义。</span><span class="sxs-lookup"><span data-stu-id="a0361-135">Each control should be focused on its core functionality and true value proposition and defined by the control's common usage.</span></span> <span data-ttu-id="a0361-136">为此，请使用模板中的撰写和帮助程序元素实现外围行为和可视化（即，那些不构成控件核心功能的行为和可视化）。</span><span class="sxs-lookup"><span data-stu-id="a0361-136">To that end, use composition and helper elements within the template to enable peripheral behaviors and visualizations, that is, those behaviors and visualizations that do not contribute to the core functionality of the control.</span></span> <span data-ttu-id="a0361-137">帮助程序元素分为三类：</span><span class="sxs-lookup"><span data-stu-id="a0361-137">Helper elements fall into three categories:</span></span>  
  
    -   <span data-ttu-id="a0361-138">**独立**帮助程序类型是以“匿名方式”用在模板中的可重用的公共控件或基元，这意味着帮助程序元素和带样式的控件无法互相识别。</span><span class="sxs-lookup"><span data-stu-id="a0361-138">**Standalone** helper types are public and reusable controls or primitives that are used "anonymously" in a template, meaning that neither the helper element nor the styled control is aware of the other.</span></span> <span data-ttu-id="a0361-139">在技术上，任何元素都可以是匿名类型，但是在此上下文中，该术语描述了那些封装专用功能以实现目标方案的类型。</span><span class="sxs-lookup"><span data-stu-id="a0361-139">Technically, any element can be an anonymous type, but in this context the term describes those types that encapsulate specialized functionality to enable targeted scenarios.</span></span>  
  
    -   <span data-ttu-id="a0361-140">**基于类型的**帮助程序元素是封装专用功能的新类型。</span><span class="sxs-lookup"><span data-stu-id="a0361-140">**Type-based** helper elements are new types that encapsulate specialized functionality.</span></span> <span data-ttu-id="a0361-141">通常，这些元素在设计上比通用控件或基元的功能范围要窄。</span><span class="sxs-lookup"><span data-stu-id="a0361-141">These elements are typically designed with a narrower range of functionality than common controls or primitives.</span></span> <span data-ttu-id="a0361-142">与独立帮助程序元素不同的是，基于类型的帮助程序元素能够识别它们的使用上下文，而且通常必须与包含它们所属模板的控件共享数据。</span><span class="sxs-lookup"><span data-stu-id="a0361-142">Unlike standalone helper elements, type-based helper elements are aware of the context in which they are used and typically must share data with the control to whose template they belong.</span></span>  
  
    -   <span data-ttu-id="a0361-143">**命名的**帮助程序元素是控件应当能够在其模板中根据名称找到的常用控件或基元。</span><span class="sxs-lookup"><span data-stu-id="a0361-143">**Named** helper elements are common controls or primitives that a control expects to find within its template by name.</span></span> <span data-ttu-id="a0361-144">这些元素在模板中具有一个已知的名称，这使得控件能够找到这些元素并以编程方式与之交互。</span><span class="sxs-lookup"><span data-stu-id="a0361-144">These elements are given a well-known name within the template, making it possible for a control to find the element and interact with it programmatically.</span></span> <span data-ttu-id="a0361-145">在任何模板中，都只能有一个具有给定名称的元素。</span><span class="sxs-lookup"><span data-stu-id="a0361-145">There can only be one element with a given name in any template.</span></span>  
  
     <span data-ttu-id="a0361-146">下表显示了由目前的控件样式使用的部分帮助程序元素列表：</span><span class="sxs-lookup"><span data-stu-id="a0361-146">The following table shows helper elements employed by control styles today (this list is not exhaustive):</span></span>  
  
    |<span data-ttu-id="a0361-147">元素</span><span class="sxs-lookup"><span data-stu-id="a0361-147">Element</span></span>|<span data-ttu-id="a0361-148">类型</span><span class="sxs-lookup"><span data-stu-id="a0361-148">Type</span></span>|<span data-ttu-id="a0361-149">通过者</span><span class="sxs-lookup"><span data-stu-id="a0361-149">Used by</span></span>|  
    |-------------|----------|-------------|  
    |<xref:System.Windows.Controls.ContentPresenter>|<span data-ttu-id="a0361-150">基于类型的</span><span class="sxs-lookup"><span data-stu-id="a0361-150">Type-based</span></span>|<xref:System.Windows.Controls.Button><span data-ttu-id="a0361-151"><xref:System.Windows.Controls.CheckBox>， <xref:System.Windows.Controls.RadioButton>，<xref:System.Windows.Controls.Frame>等 (所有<xref:System.Windows.Controls.ContentControl>类型)</span><span class="sxs-lookup"><span data-stu-id="a0361-151">, <xref:System.Windows.Controls.CheckBox>, <xref:System.Windows.Controls.RadioButton>, <xref:System.Windows.Controls.Frame>, and so on (all <xref:System.Windows.Controls.ContentControl> types)</span></span>|  
    |<xref:System.Windows.Controls.ItemsPresenter>|<span data-ttu-id="a0361-152">基于类型的</span><span class="sxs-lookup"><span data-stu-id="a0361-152">Type-based</span></span>|<xref:System.Windows.Controls.ListBox><span data-ttu-id="a0361-153"><xref:System.Windows.Controls.ComboBox>，<xref:System.Windows.Controls.Menu>等 (所有<xref:System.Windows.Controls.ItemsControl>类型)</span><span class="sxs-lookup"><span data-stu-id="a0361-153">, <xref:System.Windows.Controls.ComboBox>, <xref:System.Windows.Controls.Menu>, and so on (all <xref:System.Windows.Controls.ItemsControl> types)</span></span>|  
    |<xref:System.Windows.Controls.Primitives.ToolBarOverflowPanel>|<span data-ttu-id="a0361-154">命名的</span><span class="sxs-lookup"><span data-stu-id="a0361-154">Named</span></span>|<xref:System.Windows.Controls.ToolBar>|  
    |<xref:System.Windows.Controls.Primitives.Popup>|<span data-ttu-id="a0361-155">独立</span><span class="sxs-lookup"><span data-stu-id="a0361-155">Standalone</span></span>|<xref:System.Windows.Controls.ComboBox><span data-ttu-id="a0361-156"><xref:System.Windows.Controls.ToolBar>， <xref:System.Windows.Controls.Menu>， <xref:System.Windows.Controls.ToolTip>，等等</span><span class="sxs-lookup"><span data-stu-id="a0361-156">, <xref:System.Windows.Controls.ToolBar>, <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ToolTip>, and so on</span></span>|  
    |<xref:System.Windows.Controls.Primitives.RepeatButton>|<span data-ttu-id="a0361-157">命名的</span><span class="sxs-lookup"><span data-stu-id="a0361-157">Named</span></span>|<xref:System.Windows.Controls.Slider><span data-ttu-id="a0361-158"><xref:System.Windows.Controls.Primitives.ScrollBar>，等等</span><span class="sxs-lookup"><span data-stu-id="a0361-158">, <xref:System.Windows.Controls.Primitives.ScrollBar>, and so on</span></span>|  
    |<xref:System.Windows.Controls.Primitives.ScrollBar>|<span data-ttu-id="a0361-159">命名的</span><span class="sxs-lookup"><span data-stu-id="a0361-159">Named</span></span>|<xref:System.Windows.Controls.ScrollViewer>|  
    |<xref:System.Windows.Controls.ScrollViewer>|<span data-ttu-id="a0361-160">独立</span><span class="sxs-lookup"><span data-stu-id="a0361-160">Standalone</span></span>|<xref:System.Windows.Controls.ListBox><span data-ttu-id="a0361-161"><xref:System.Windows.Controls.ComboBox>， <xref:System.Windows.Controls.Menu>， <xref:System.Windows.Controls.Frame>，等等</span><span class="sxs-lookup"><span data-stu-id="a0361-161">, <xref:System.Windows.Controls.ComboBox>, <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.Frame>, and so on</span></span>|  
    |<xref:System.Windows.Controls.Primitives.TabPanel>|<span data-ttu-id="a0361-162">独立</span><span class="sxs-lookup"><span data-stu-id="a0361-162">Standalone</span></span>|<xref:System.Windows.Controls.TabControl>|  
    |<xref:System.Windows.Controls.TextBox>|<span data-ttu-id="a0361-163">命名的</span><span class="sxs-lookup"><span data-stu-id="a0361-163">Named</span></span>|<xref:System.Windows.Controls.ComboBox>|  
    |<xref:System.Windows.Controls.Primitives.TickBar>|<span data-ttu-id="a0361-164">基于类型的</span><span class="sxs-lookup"><span data-stu-id="a0361-164">Type-based</span></span>|<xref:System.Windows.Controls.Slider>|  
  
-   <span data-ttu-id="a0361-165">**最大限度地减少帮助程序元素所必需的、特定于用户的绑定或属性设置**。</span><span class="sxs-lookup"><span data-stu-id="a0361-165">**Minimize required user-specified bindings or property settings on helper elements**.</span></span> <span data-ttu-id="a0361-166">通常，帮助程序元素需要某些绑定或属性设置才能在控件模板中正确工作。</span><span class="sxs-lookup"><span data-stu-id="a0361-166">It is common for a helper element to require certain bindings or property settings in order to function properly within the control template.</span></span> <span data-ttu-id="a0361-167">帮助程序元素和模板化控件应当尽可能多地生成这些设置。</span><span class="sxs-lookup"><span data-stu-id="a0361-167">The helper element and templated control should, as much as possible, establish these settings.</span></span> <span data-ttu-id="a0361-168">在设置属性或者建立绑定时，注意不要重写由用户设置的值。</span><span class="sxs-lookup"><span data-stu-id="a0361-168">When setting properties or establishing bindings, care should be taken to not override values set by the user.</span></span> <span data-ttu-id="a0361-169">具体的最佳做法如下所示：</span><span class="sxs-lookup"><span data-stu-id="a0361-169">Specific best practices are as follows:</span></span>  
  
    -   <span data-ttu-id="a0361-170">命名的帮助程序元素应当由父级标识，而且父级应当针对帮助程序元素建立任何必需的设置。</span><span class="sxs-lookup"><span data-stu-id="a0361-170">Named helper elements should be identified by the parent and the parent should establish any required settings on the helper element.</span></span>  
  
    -   <span data-ttu-id="a0361-171">基于类型的帮助程序元素应当直接针对自身建立任何必需的设置。</span><span class="sxs-lookup"><span data-stu-id="a0361-171">Type-based helper elements should establish any required settings directly on themselves.</span></span> <span data-ttu-id="a0361-172">这样做可能需要帮助程序元素查找它在使用时的信息上下文，包括其 `TemplatedParent`（它在使用时的模板的控件类型）。</span><span class="sxs-lookup"><span data-stu-id="a0361-172">Doing this may require the helper element to query for information context in which it is being used, including its `TemplatedParent` (the control type of the template in which it is being used).</span></span> <span data-ttu-id="a0361-173">例如，<xref:System.Windows.Controls.ContentPresenter>会自动将绑定`Content`的属性及其`TemplatedParent`到其<xref:System.Windows.Controls.ContentPresenter.Content%2A>属性中使用时<xref:System.Windows.Controls.ContentControl>派生类型。</span><span class="sxs-lookup"><span data-stu-id="a0361-173">For example, <xref:System.Windows.Controls.ContentPresenter> automatically binds the `Content` property of its `TemplatedParent` to its <xref:System.Windows.Controls.ContentPresenter.Content%2A> property when used in a <xref:System.Windows.Controls.ContentControl> derived type.</span></span>  
  
    -   <span data-ttu-id="a0361-174">独立帮助程序元素不能按这种方式进行优化，这是因为按照定义，帮助程序元素和父级不能相互识别。</span><span class="sxs-lookup"><span data-stu-id="a0361-174">Standalone helper elements cannot be optimized in this way because, by definition, neither the helper element nor the parent knows about the other.</span></span>  
  
-   <span data-ttu-id="a0361-175">**使用 Name 属性标记模板中的元素**。</span><span class="sxs-lookup"><span data-stu-id="a0361-175">**Use the Name property to flag elements within a template**.</span></span> <span data-ttu-id="a0361-176">如果控件需要在样式中查找某个元素才能以编程方式访问它，则该控件应当使用 `Name` 属性和 `FindName` 范例来进行查找。</span><span class="sxs-lookup"><span data-stu-id="a0361-176">A control that needs to find an element in its style in order to access it programmatically should do so using the `Name` property and the `FindName` paradigm.</span></span> <span data-ttu-id="a0361-177">控件不应在未找到所需元素时引发异常，而是应在不提示的情况下禁用需要该元素的功能。</span><span class="sxs-lookup"><span data-stu-id="a0361-177">A control should not throw an exception when an element is not found, but silently and gracefully disable the functionality which required that element.</span></span>  
  
-   **<span data-ttu-id="a0361-178">使用最佳做法来表示控件状态和样式中的行为。</span><span class="sxs-lookup"><span data-stu-id="a0361-178">Use best practices for expressing control state and behavior in a style.</span></span>** <span data-ttu-id="a0361-179">下面按顺序列出了用来表示样式中的控件状态更改和行为的最佳做法。</span><span class="sxs-lookup"><span data-stu-id="a0361-179">The following is an ordered list of best practices for expressing control state changes and behavior in a style.</span></span> <span data-ttu-id="a0361-180">应使用列表上的第一项来实现你的方案。</span><span class="sxs-lookup"><span data-stu-id="a0361-180">You should use the first item on the list that enables your scenario.</span></span>  
  
    1.  <span data-ttu-id="a0361-181">属性绑定。</span><span class="sxs-lookup"><span data-stu-id="a0361-181">Property binding.</span></span> <span data-ttu-id="a0361-182">示例： 绑定之间<xref:System.Windows.Controls.ComboBox.IsDropDownOpen%2A?displayProperty=nameWithType>和<xref:System.Windows.Controls.Primitives.ToggleButton.IsChecked%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="a0361-182">Example: binding between <xref:System.Windows.Controls.ComboBox.IsDropDownOpen%2A?displayProperty=nameWithType> and <xref:System.Windows.Controls.Primitives.ToggleButton.IsChecked%2A?displayProperty=nameWithType>.</span></span>  
  
    2.  <span data-ttu-id="a0361-183">触发的属性更改或属性动画。</span><span class="sxs-lookup"><span data-stu-id="a0361-183">Triggered property changes or property animations.</span></span> <span data-ttu-id="a0361-184">示例： 悬停状态的<xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="a0361-184">Example: the hover state of a <xref:System.Windows.Controls.Button>.</span></span>  
  
    3.  <span data-ttu-id="a0361-185">命令。</span><span class="sxs-lookup"><span data-stu-id="a0361-185">Command.</span></span> <span data-ttu-id="a0361-186">示例： <xref:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand>  /  <xref:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand>中<xref:System.Windows.Controls.Primitives.ScrollBar>。</span><span class="sxs-lookup"><span data-stu-id="a0361-186">Example: <xref:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand> / <xref:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand> in <xref:System.Windows.Controls.Primitives.ScrollBar>.</span></span>  
  
    4.  <span data-ttu-id="a0361-187">独立帮助程序元素。</span><span class="sxs-lookup"><span data-stu-id="a0361-187">Standalone helper elements.</span></span> <span data-ttu-id="a0361-188">示例：<xref:System.Windows.Controls.Primitives.TabPanel>在<xref:System.Windows.Controls.TabControl>。</span><span class="sxs-lookup"><span data-stu-id="a0361-188">Example: <xref:System.Windows.Controls.Primitives.TabPanel> in <xref:System.Windows.Controls.TabControl>.</span></span>  
  
    5.  <span data-ttu-id="a0361-189">基于类型的帮助程序类型。</span><span class="sxs-lookup"><span data-stu-id="a0361-189">Type-based helper types.</span></span> <span data-ttu-id="a0361-190">示例：<xref:System.Windows.Controls.ContentPresenter>中<xref:System.Windows.Controls.Button>，<xref:System.Windows.Controls.Primitives.TickBar>中<xref:System.Windows.Controls.Slider>。</span><span class="sxs-lookup"><span data-stu-id="a0361-190">Example: <xref:System.Windows.Controls.ContentPresenter> in <xref:System.Windows.Controls.Button>, <xref:System.Windows.Controls.Primitives.TickBar> in <xref:System.Windows.Controls.Slider>.</span></span>  
  
    6.  <span data-ttu-id="a0361-191">命名的帮助程序元素。</span><span class="sxs-lookup"><span data-stu-id="a0361-191">Named helper elements.</span></span> <span data-ttu-id="a0361-192">示例：<xref:System.Windows.Controls.TextBox>在<xref:System.Windows.Controls.ComboBox>。</span><span class="sxs-lookup"><span data-stu-id="a0361-192">Example: <xref:System.Windows.Controls.TextBox> in <xref:System.Windows.Controls.ComboBox>.</span></span>  
  
    7.  <span data-ttu-id="a0361-193">命名的帮助程序类型中的冒泡事件。</span><span class="sxs-lookup"><span data-stu-id="a0361-193">Bubbled events from named helper types.</span></span> <span data-ttu-id="a0361-194">如果侦听样式元素中的冒泡事件，应当要求生成该事件的元素能够进行唯一标识。</span><span class="sxs-lookup"><span data-stu-id="a0361-194">If you listen for bubbled events from a style element, you should require that the element generating the event can be uniquely identified.</span></span> <span data-ttu-id="a0361-195">示例：<xref:System.Windows.Controls.Primitives.Thumb>在<xref:System.Windows.Controls.ToolBar>。</span><span class="sxs-lookup"><span data-stu-id="a0361-195">Example: <xref:System.Windows.Controls.Primitives.Thumb> in <xref:System.Windows.Controls.ToolBar>.</span></span>  
  
    8.  <span data-ttu-id="a0361-196">自定义 `OnRender` 行为。</span><span class="sxs-lookup"><span data-stu-id="a0361-196">Custom `OnRender` behavior.</span></span> <span data-ttu-id="a0361-197">示例：<xref:Microsoft.Windows.Themes.ButtonChrome>在<xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="a0361-197">Example: <xref:Microsoft.Windows.Themes.ButtonChrome> in <xref:System.Windows.Controls.Button>.</span></span>  
  
-   <span data-ttu-id="a0361-198">**慎用样式触发器（与模板触发器相对）**。</span><span class="sxs-lookup"><span data-stu-id="a0361-198">**Use style triggers (as opposed to template triggers) sparingly**.</span></span> <span data-ttu-id="a0361-199">影响模板中元素上的属性的触发器必须在模板中声明。</span><span class="sxs-lookup"><span data-stu-id="a0361-199">Triggers that affect properties on elements in the template must be declared in the template.</span></span> <span data-ttu-id="a0361-200">影响控件上的属性的触发器（没有 `TargetName`）可以在样式中声明，除非你知道更改模板还可能会损坏触发器。</span><span class="sxs-lookup"><span data-stu-id="a0361-200">Triggers that affect properties on the control (no `TargetName`) may be declared in the style unless you know that changing the template should also destroy the trigger.</span></span>  
  
-   **<span data-ttu-id="a0361-201">在与现有的样式设置模式保持一致。</span><span class="sxs-lookup"><span data-stu-id="a0361-201">Be consistent with existing styling patterns.</span></span>** <span data-ttu-id="a0361-202">一个问题常常有多种解决办法。</span><span class="sxs-lookup"><span data-stu-id="a0361-202">Many times there are multiple ways to solve a problem.</span></span> <span data-ttu-id="a0361-203">注意尽可能与现有的控件样式设置模式保持一致。</span><span class="sxs-lookup"><span data-stu-id="a0361-203">Be aware of and, when possible, consistent with existing control styling patterns.</span></span> <span data-ttu-id="a0361-204">这一点尤其重要的控件的派生自同一基类型 (例如， <xref:System.Windows.Controls.ContentControl>， <xref:System.Windows.Controls.ItemsControl>， <xref:System.Windows.Controls.Primitives.RangeBase>，依此类推)。</span><span class="sxs-lookup"><span data-stu-id="a0361-204">This is especially important for controls that derive from the same base type (for example, <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ItemsControl>, <xref:System.Windows.Controls.Primitives.RangeBase>, and so on).</span></span>  
  
-   <span data-ttu-id="a0361-205">**在不重新模板化的情况下公开属性来启用常见自定义项方案**。</span><span class="sxs-lookup"><span data-stu-id="a0361-205">**Expose properties to enable common customization scenarios without retemplating**.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="a0361-206">不支持可插入/可自定义的部件，因此控件用户留下的自定义的只有两个方法： 直接设置属性或者使用样式设置属性。</span><span class="sxs-lookup"><span data-stu-id="a0361-206">does not support pluggable/customizable parts, so a control user is left with only two methods of customization: setting properties directly or setting properties using styles.</span></span> <span data-ttu-id="a0361-207">请记住，比较合适的做法是，设置数量有限的属性，使其面向极其常见的高优先级自定义项方案，否则的话，这些方案需要重新模板化。</span><span class="sxs-lookup"><span data-stu-id="a0361-207">With that in mind, it is appropriate to surface a limited number of properties targeted at very common, high-priority customization scenarios which would otherwise require the retemplating.</span></span> <span data-ttu-id="a0361-208">下面是有关何时以及如何启用自定义项方案的最佳方法：</span><span class="sxs-lookup"><span data-stu-id="a0361-208">Here are best practices for when and how to enable customization scenarios:</span></span>  
  
    -   <span data-ttu-id="a0361-209">极其常见的自定义项应当作为属性在控件上公开并由模板使用。</span><span class="sxs-lookup"><span data-stu-id="a0361-209">Very common customizations should be exposed as properties on the control and consumed by the template.</span></span>  
  
    -   <span data-ttu-id="a0361-210">不太常见（尽管并非极少见）的自定义项应当作为附加属性公开并由模板使用。</span><span class="sxs-lookup"><span data-stu-id="a0361-210">Less common (though not rare) customizations should be exposed as attached properties and consumed by the template.</span></span>  
  
    -   <span data-ttu-id="a0361-211">需要对已知但是极少见的自定义项重新模板化，这一点也是可接受的。</span><span class="sxs-lookup"><span data-stu-id="a0361-211">It is acceptable for known but rare customizations to require retemplating.</span></span>  
  
<a name="Theme_Considerations"></a>   
## <a name="theme-considerations"></a><span data-ttu-id="a0361-212">主题注意事项</span><span class="sxs-lookup"><span data-stu-id="a0361-212">Theme Considerations</span></span>  
  
-   <span data-ttu-id="a0361-213">**主题样式应尝试在所有主题中具有一致的属性语义，但不保证能够实现这一点**。</span><span class="sxs-lookup"><span data-stu-id="a0361-213">**Theme styles should attempt to have consistent property semantics across all themes, but make no guarantee**.</span></span> <span data-ttu-id="a0361-214">作为控件文档的一部分，控件应当具有一个描述其属性语义（即控件属性的“含义”）的文档。</span><span class="sxs-lookup"><span data-stu-id="a0361-214">As part of its documentation, your control should have a document describing the control's property semantics, that is, the "meaning" of a property for a control.</span></span> <span data-ttu-id="a0361-215">例如，<xref:System.Windows.Controls.ComboBox>控件应当定义的含义<xref:System.Windows.Controls.Control.Background%2A>属性内的<xref:System.Windows.Controls.ComboBox>。</span><span class="sxs-lookup"><span data-stu-id="a0361-215">For example, the <xref:System.Windows.Controls.ComboBox> control should define the meaning of the <xref:System.Windows.Controls.Control.Background%2A> property within <xref:System.Windows.Controls.ComboBox>.</span></span> <span data-ttu-id="a0361-216">控件的默认样式应当尝试遵循在其文档中的所有主题中定义的语义。</span><span class="sxs-lookup"><span data-stu-id="a0361-216">The default styles for your control should attempt to follow the semantics defined in that document across all themes.</span></span> <span data-ttu-id="a0361-217">另一方面，控件用户应当注意属性语义可能因主题而异。</span><span class="sxs-lookup"><span data-stu-id="a0361-217">Control users, on the other hand, should be aware that property semantics can change from theme to theme.</span></span> <span data-ttu-id="a0361-218">在某些情况下，给定的属性在由特定主题所需的可视化约束下可能无法表示。</span><span class="sxs-lookup"><span data-stu-id="a0361-218">In certain cases, a given property may not be expressible under the visual constraints required by a particular theme.</span></span> <span data-ttu-id="a0361-219">（例如，对于许多控件来说，传统主题没有可以向其应用 `Thickness` 的边框。）</span><span class="sxs-lookup"><span data-stu-id="a0361-219">(The Classic theme, for example, does not have a single border to which `Thickness` can be applied for many controls.)</span></span>  
  
-   <span data-ttu-id="a0361-220">**主题样式不需要在所有主题中具有一致的触发器语义**。</span><span class="sxs-lookup"><span data-stu-id="a0361-220">**Theme styles do not need to have consistent trigger semantics across all themes**.</span></span> <span data-ttu-id="a0361-221">由控件样式通过触发器或动画公开的行为可能因主题而异。</span><span class="sxs-lookup"><span data-stu-id="a0361-221">The behavior exposed by a control style through triggers or animations may vary from theme to theme.</span></span> <span data-ttu-id="a0361-222">控件用户应当注意到，控件不必使用同一个机制在所有主题中实现特定的行为。</span><span class="sxs-lookup"><span data-stu-id="a0361-222">Control users should be aware that a control will not necessarily employ the same mechanism to achieve a particular behavior across all themes.</span></span> <span data-ttu-id="a0361-223">例如，一个主题可以使用动画来表示悬停行为，而另一个主题则可以使用触发器。</span><span class="sxs-lookup"><span data-stu-id="a0361-223">One theme, for example, may use an animation to express hover behavior where another theme uses a trigger.</span></span> <span data-ttu-id="a0361-224">这可能会导致自定义控件上的行为保留出现不一致。</span><span class="sxs-lookup"><span data-stu-id="a0361-224">This can result in inconsistencies in behavior preservation on customized controls.</span></span> <span data-ttu-id="a0361-225">（例如，如果控件的悬停状态使用触发器来表示，则更改背景属性可能不会影响该状态。</span><span class="sxs-lookup"><span data-stu-id="a0361-225">(Changing the background property, for example, might not affect the hover state of the control if that state is expressed using a trigger.</span></span> <span data-ttu-id="a0361-226">但是，如果悬停状态使用动画来实现，则更改背景属性可能会不可挽回地中断动画，从而中断状态过渡。）</span><span class="sxs-lookup"><span data-stu-id="a0361-226">However, if the hover state is implemented using an animation, changing to background could irreparably break the animation and therefore the state transition.)</span></span>  
  
-   <span data-ttu-id="a0361-227">**主题样式不需要在所有主题中具有一致的“布局”语义**。</span><span class="sxs-lookup"><span data-stu-id="a0361-227">**Theme styles do not need to have consistent "layout" semantics across all themes**.</span></span> <span data-ttu-id="a0361-228">例如，默认的样式不需要保证控件将在所有主题中占用同样的大小，也不需要保证控件将在所有主题中具有同样的内容边距/空白。</span><span class="sxs-lookup"><span data-stu-id="a0361-228">For example, the default style does not need to guarantee that a control will occupy the same amount of size in all themes or guarantee that a control will have the same content margins / padding across all themes.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a0361-229">请参阅</span><span class="sxs-lookup"><span data-stu-id="a0361-229">See also</span></span>

- [<span data-ttu-id="a0361-230">样式设置和模板化</span><span class="sxs-lookup"><span data-stu-id="a0361-230">Styling and Templating</span></span>](styling-and-templating.md)
- [<span data-ttu-id="a0361-231">控件创作概述</span><span class="sxs-lookup"><span data-stu-id="a0361-231">Control Authoring Overview</span></span>](control-authoring-overview.md)
