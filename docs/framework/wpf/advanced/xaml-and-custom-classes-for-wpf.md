---
title: XAML 及 WPF 的自定义类
ms.date: 03/30/2017
helpviewer_keywords:
- custom classes in XAML [WPF]
- XAML [WPF], custom classes
- classes [WPF], custom classes in XAML
ms.assetid: e7313137-581e-4a64-8453-d44e15a6164a
ms.openlocfilehash: f6709cad76ff05c3134c8430b36d5f34019b03ca
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/23/2019
ms.locfileid: "54606577"
---
# <a name="xaml-and-custom-classes-for-wpf"></a><span data-ttu-id="43ce5-102">XAML 及 WPF 的自定义类</span><span class="sxs-lookup"><span data-stu-id="43ce5-102">XAML and Custom Classes for WPF</span></span>
<span data-ttu-id="43ce5-103">[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] 框架中实现的 XAML 支持定义任何 [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] 语言的自定义类或结构，然后使用 XAML 标记访问类。</span><span class="sxs-lookup"><span data-stu-id="43ce5-103">XAML as implemented in [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] frameworks supports the ability to define a custom class or structure in any [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] language, and then access that class using XAML markup.</span></span> <span data-ttu-id="43ce5-104">通常通过将自定义类型映射到 XAML 命名空间前缀，可在同一标记文件中混合使用 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 定义类型和自定义类型。</span><span class="sxs-lookup"><span data-stu-id="43ce5-104">You can use a mixture of [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]-defined types and your custom types within the same markup file, typically by mapping the custom types to a XAML namespace prefix.</span></span> <span data-ttu-id="43ce5-105">本主题讨论将自定义类用作 XAML 元素必须满足的要求。</span><span class="sxs-lookup"><span data-stu-id="43ce5-105">This topic discusses the requirements that a custom class must satisfy to be usable as a XAML element.</span></span>  
  
 
  
<a name="Custom_Classes_in_Applications_vs__in_Assemblies"></a>   
## <a name="custom-classes-in-applications-or-assemblies"></a><span data-ttu-id="43ce5-106">应用程序或程序集中的自定义类</span><span class="sxs-lookup"><span data-stu-id="43ce5-106">Custom Classes in Applications or Assemblies</span></span>  
 <span data-ttu-id="43ce5-107">XAML 中使用的自定义类可通过两种不同的方式进行定义：在代码隐藏或其他生成主 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 应用程序的代码内，或者在单独程序集中作为类（例如用作类库的可执行文件或 DLL）。</span><span class="sxs-lookup"><span data-stu-id="43ce5-107">Custom classes that are used in XAML can be defined in two distinct ways: within the code-behind or other code that produces the primary [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] application, or as a class in a separate assembly, such as an executable or DLL used as a class library.</span></span> <span data-ttu-id="43ce5-108">这些方法各有特定的优点和缺点。</span><span class="sxs-lookup"><span data-stu-id="43ce5-108">Each of these approaches has particular advantages and disadvantages.</span></span>  
  
-   <span data-ttu-id="43ce5-109">创建类库的优点在于可在多个不同的应用程序间共享任意此类自定义类。</span><span class="sxs-lookup"><span data-stu-id="43ce5-109">The advantage of creating a class library is that any such custom classes can be shared across many different possible applications.</span></span> <span data-ttu-id="43ce5-110">通过使用单独的库，更易于控制应用程序的版本控制问题，并可简化类创建过程，在此过程中，所需的类用法是作为 XAML 页面上的根元素。</span><span class="sxs-lookup"><span data-stu-id="43ce5-110">A separate library also makes versioning issues of applications easier to control, and simplifies creating a class where the intended class usage is as a root element on a XAML page.</span></span>  
  
-   <span data-ttu-id="43ce5-111">在应用程序中定义自定义类的优点在于此方法相对轻量，可减少在主应用程序可执行文件外引入单独程序集时遇到的部署和测试问题。</span><span class="sxs-lookup"><span data-stu-id="43ce5-111">The advantage of defining the custom classes in the application is that this technique is relatively lightweight and minimizes the deployment and testing issues encountered when you introduce separate assemblies beyond the main application executable.</span></span>  
  
-   <span data-ttu-id="43ce5-112">无论定义在相同还是不同的程序集中，自定义类若要在 XAML 中用作元素，都需要在 CLR 命名空间和 XML 命名空间之间进行映射。</span><span class="sxs-lookup"><span data-stu-id="43ce5-112">Whether defined in the same or different assembly, custom classes need to be mapped between CLR  namespace and XML  namespace in order to be used in XAML as elements.</span></span> <span data-ttu-id="43ce5-113">请参阅 [WPF XAML 的 XAML 命名空间和命名空间映射](../../../../docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="43ce5-113">See [XAML Namespaces and Namespace Mapping for WPF XAML](../../../../docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="Requirements_for_a_Custom_Class_as_a_XAML_Element"></a>   
## <a name="requirements-for-a-custom-class-as-a-xaml-element"></a><span data-ttu-id="43ce5-114">将自定义类用作 XAML 元素的要求</span><span class="sxs-lookup"><span data-stu-id="43ce5-114">Requirements for a Custom Class as a XAML Element</span></span>  
 <span data-ttu-id="43ce5-115">为能够实例化为对象元素，类必须满足以下要求：</span><span class="sxs-lookup"><span data-stu-id="43ce5-115">In order to be able to be instantiated as an object element, your class must meet the following requirements:</span></span>  
  
-   <span data-ttu-id="43ce5-116">自定义类必须是公共的且支持默认（无参数）公共构造函数。</span><span class="sxs-lookup"><span data-stu-id="43ce5-116">Your custom class must be public and support a default (parameterless) public constructor.</span></span> <span data-ttu-id="43ce5-117">（有关结构注释，请参阅下节内容。）</span><span class="sxs-lookup"><span data-stu-id="43ce5-117">(See following section for notes regarding structures.)</span></span>  
  
-   <span data-ttu-id="43ce5-118">自定义类不得为嵌套类。</span><span class="sxs-lookup"><span data-stu-id="43ce5-118">Your custom class must not be a nested class.</span></span> <span data-ttu-id="43ce5-119">嵌套类及其常规 CLR 使用语法中的“点”会干扰其他 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 和/或 XAML 功能（例如附加属性）。</span><span class="sxs-lookup"><span data-stu-id="43ce5-119">Nested classes and the "dot" in their general CLR usage syntax interfere with other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and/or XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="43ce5-120">除启用对象元素语法外，对象定义还会对任何其他将该对象作为值类型的公共属性启用属性元素语法。</span><span class="sxs-lookup"><span data-stu-id="43ce5-120">In addition to enabling object element syntax, your object definition also enables property element syntax for any other public properties that take that object as the value type.</span></span> <span data-ttu-id="43ce5-121">这是因为对象现在可被实例化为对象元素，且可填充此类属性的属性元素值。</span><span class="sxs-lookup"><span data-stu-id="43ce5-121">This is because the object can now be instantiated as an object element and can fill the property element value of such a property.</span></span>  
  
### <a name="structures"></a><span data-ttu-id="43ce5-122">结构</span><span class="sxs-lookup"><span data-stu-id="43ce5-122">Structures</span></span>  
 <span data-ttu-id="43ce5-123">可始终在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 的 XAML 中构造定义为自定义类型的结构。这是因为 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 编译器会对将所有属性值初始化为默认值的结构隐式创建默认构造函数。</span><span class="sxs-lookup"><span data-stu-id="43ce5-123">Structures that you define as custom types are always able to be constructed in XAML  in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] .This is because the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] compilers implicitly create a default constructor for a structure that initializes all property values to their defaults.</span></span> <span data-ttu-id="43ce5-124">某些情况下，结构并不需要默认构造行为和/或对象元素用法。</span><span class="sxs-lookup"><span data-stu-id="43ce5-124">In some cases, the default construction behavior and/or object element usage for a structure is not desirable.</span></span> <span data-ttu-id="43ce5-125">这可能是因为结构需要通过概念方式将值和函数作为联合来填充，其中包含的值可能具有互斥的解释，因而其不存在任何可设置属性。</span><span class="sxs-lookup"><span data-stu-id="43ce5-125">This might be because the structure is intended to fill values and function conceptually as a union, where the values contained might have mutually exclusive interpretations and thus none of its properties are settable.</span></span> <span data-ttu-id="43ce5-126">一个[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]这种结构的示例是<xref:System.Windows.GridLength>。</span><span class="sxs-lookup"><span data-stu-id="43ce5-126">A [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] example of such a structure is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="43ce5-127">通常情况下，此类结构应实现类型转换器，以便可通过属性形式表达值，方法是使用创建结构值的不同解释或模式的字符串约定。</span><span class="sxs-lookup"><span data-stu-id="43ce5-127">Generally, such structures should implement a type converter such that the values can be expressed in attribute form, using string conventions that create the different interpretations or modes of the structure's values.</span></span> <span data-ttu-id="43ce5-128">结构还应通过非默认构造函数对代码构造公开类似的行为。</span><span class="sxs-lookup"><span data-stu-id="43ce5-128">The structure should also expose similar behavior for code construction through a non-default constructor.</span></span>  
  
<a name="Requirements_for_Properties_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-properties-of-a-custom-class-as-xaml-attributes"></a><span data-ttu-id="43ce5-129">将自定义类属性用作 XAML 特性的要求</span><span class="sxs-lookup"><span data-stu-id="43ce5-129">Requirements for Properties of a Custom Class as XAML Attributes</span></span>  
 <span data-ttu-id="43ce5-130">属性必须引用按值类型（例如基元），或者使用特定类型的一个类（此特定类型需具有默认构造函数或 XAML 处理器可访问的专用类型转换器）。</span><span class="sxs-lookup"><span data-stu-id="43ce5-130">Properties must reference a by-value type (such as a primitive), or use a class for type that has either a default constructor or a dedicated type converter that a XAML processor can access.</span></span> <span data-ttu-id="43ce5-131">在 CLR XAML 实现中，XAML 处理器，查找通过语言基元的本机支持或应用程序的此类转换器<xref:System.ComponentModel.TypeConverterAttribute>类型或后备类型定义中的成员</span><span class="sxs-lookup"><span data-stu-id="43ce5-131">In the CLR XAML implementation, XAML processors either find such converters through native support for language primitives, or through application of <xref:System.ComponentModel.TypeConverterAttribute> to a type or member in backing type definitions</span></span>  
  
 <span data-ttu-id="43ce5-132">或者，属性可引用抽象类类型或接口。</span><span class="sxs-lookup"><span data-stu-id="43ce5-132">Alternatively, the property may reference an abstract class type, or an interface.</span></span> <span data-ttu-id="43ce5-133">对于抽象类或接口，XAML 分析的所需条件是必须用实现接口的实际类实例或派生自抽象类的类型实例填充属性值。</span><span class="sxs-lookup"><span data-stu-id="43ce5-133">For abstract classes or interfaces, the expectation for XAML parsing is that the property value must be filled with practical class instances that implement the interface, or instances of types that derive from the abstract class.</span></span>  
  
 <span data-ttu-id="43ce5-134">属性可在抽象类上声明，但仅可在派生自抽象类的实际类上设置。</span><span class="sxs-lookup"><span data-stu-id="43ce5-134">Properties can be declared on an abstract class, but can only be set on practical classes that derive from the abstract class.</span></span> <span data-ttu-id="43ce5-135">这是因为创建类的对象元素需要类上的公共默认构造函数。</span><span class="sxs-lookup"><span data-stu-id="43ce5-135">This is because creating the object element for the class at all requires a public default constructor on the class.</span></span>  
  
### <a name="typeconverter-enabled-attribute-syntax"></a><span data-ttu-id="43ce5-136">启用 TypeConverter 的特性语法</span><span class="sxs-lookup"><span data-stu-id="43ce5-136">TypeConverter Enabled Attribute Syntax</span></span>  
 <span data-ttu-id="43ce5-137">如果提供类级别的专用特性化类型转换器，则应用的类型转换会对需实例化该类型的任何属性启用特性语法。</span><span class="sxs-lookup"><span data-stu-id="43ce5-137">If you provide a dedicated, attributed type converter at the class level, the applied type conversion enables attribute syntax for any property that needs to instantiate that type.</span></span> <span data-ttu-id="43ce5-138">类型转换器不会启用类型的对象元素用法；仅在该类型存在默认构造函数时启用对象元素用法。</span><span class="sxs-lookup"><span data-stu-id="43ce5-138">A type converter does not enable object element usage of the type; only the presence of a default constructor for that type enables object element usage.</span></span> <span data-ttu-id="43ce5-139">因此，启用类型转换器的属性通常不适用于属性语法，除非类型本身也支持对象元素语法。</span><span class="sxs-lookup"><span data-stu-id="43ce5-139">Therefore, properties that are type-converter enabled are generally speaking not usable in property syntax, unless the type itself also supports object element syntax.</span></span> <span data-ttu-id="43ce5-140">此规则存在一个例外，即可指定属性元素语法，但使属性元素包含一个字符串。</span><span class="sxs-lookup"><span data-stu-id="43ce5-140">The exception to this is that you can specify a property element syntax, but have the property element contain a string.</span></span> <span data-ttu-id="43ce5-141">实质上相当于特性语法用法，该使用情况，这类使用情况不常见，除非需要进行更可靠的空白处理的属性值。</span><span class="sxs-lookup"><span data-stu-id="43ce5-141">That usage is really essentially equivalent to an attribute syntax usage, and such a usage is not common unless there is a need for more robust white-space handling of the attribute value.</span></span> <span data-ttu-id="43ce5-142">例如，以下是一个采用字符串的属性元素用法以及一个特性用法等效项：</span><span class="sxs-lookup"><span data-stu-id="43ce5-142">For example, the following is a property element usage that takes a string, and the attribute usage equivalent:</span></span>  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe)]  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE2](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe2)]  
  
 <span data-ttu-id="43ce5-143">属性允许特性语法，但包含的对象元素的属性元素语法不允许使用通过 XAML 的示例包括的各种属性<xref:System.Windows.Input.Cursor>类型。</span><span class="sxs-lookup"><span data-stu-id="43ce5-143">Examples of properties where attribute syntax is allowed but property element syntax that contains an object element is disallowed through XAML are various properties that take the <xref:System.Windows.Input.Cursor> type.</span></span> <span data-ttu-id="43ce5-144"><xref:System.Windows.Input.Cursor>类具有专用的类型转换器<xref:System.Windows.Input.CursorConverter>，但不公开默认构造函数，因此<xref:System.Windows.FrameworkElement.Cursor%2A>属性只能设置通过特性语法即使实际<xref:System.Windows.Input.Cursor>类型是引用类型。</span><span class="sxs-lookup"><span data-stu-id="43ce5-144">The <xref:System.Windows.Input.Cursor> class has a dedicated type converter <xref:System.Windows.Input.CursorConverter>, but does not expose a default constructor, so the <xref:System.Windows.FrameworkElement.Cursor%2A> property can only be set through attribute syntax even though the actual <xref:System.Windows.Input.Cursor> type is a reference type.</span></span>  
  
### <a name="per-property-type-converters"></a><span data-ttu-id="43ce5-145">按属性类型转换器</span><span class="sxs-lookup"><span data-stu-id="43ce5-145">Per-Property Type Converters</span></span>  
 <span data-ttu-id="43ce5-146">或者，属性本身可能声明属性级别的类型转换器。</span><span class="sxs-lookup"><span data-stu-id="43ce5-146">Alternatively, the property itself may declare a type converter at the property level.</span></span> <span data-ttu-id="43ce5-147">这样，"最小语言"作为输入处理传入的字符串值的属性通过实例化内联属性类型的对象<xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>操作根据适当的类型。</span><span class="sxs-lookup"><span data-stu-id="43ce5-147">This enables a "mini language" that instantiates objects of the type of the property inline, by processing incoming string values of the attribute as input for a <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> operation based on the appropriate type.</span></span> <span data-ttu-id="43ce5-148">此操作的目的通常是提供方便的访问器，且这不是在 XAML 中启用属性设置的唯一方式。</span><span class="sxs-lookup"><span data-stu-id="43ce5-148">Typically this is done to provide a convenience accessor, and not as the sole means to enable setting a property in XAML.</span></span> <span data-ttu-id="43ce5-149">但是，如果要使用不提供默认构造函数或特性化类型转换器的现有 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 类型，也可使用特性的类型转换器。</span><span class="sxs-lookup"><span data-stu-id="43ce5-149">However, it is also possible to use type converters for attributes where you want to use existing [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] types that do not supply either a default constructor or an attributed type converter.</span></span> <span data-ttu-id="43ce5-150">从示例[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]API 将某些属性<xref:System.Globalization.CultureInfo>类型。</span><span class="sxs-lookup"><span data-stu-id="43ce5-150">Examples from the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API are certain properties that take the <xref:System.Globalization.CultureInfo> type.</span></span> <span data-ttu-id="43ce5-151">在这种情况下，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]使用现有的 Microsoft.NET Framework<xref:System.Globalization.CultureInfo>类型，以更好地解决兼容性和迁移方案使用在早期版本的框架，但<xref:System.Globalization.CultureInfo>类型不支持所需的构造函数或类型级别的类型转换为直接用作 XAML 属性值。</span><span class="sxs-lookup"><span data-stu-id="43ce5-151">In this case, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] used the existing Microsoft .NET Framework <xref:System.Globalization.CultureInfo> type to better address compatibility and migration scenarios that were used in earlier versions of frameworks, but the <xref:System.Globalization.CultureInfo> type did not support the necessary constructors or type-level type conversion to be usable as a XAML property value directly.</span></span>  
  
 <span data-ttu-id="43ce5-152">每当公开具有 XAML 用法的属性时，特别是对于控件作者，应特别考虑使用依赖属性支持此属性。</span><span class="sxs-lookup"><span data-stu-id="43ce5-152">Whenever you expose a property that has a XAML usage, particularly if you are a control author, you should strongly consider backing that property with a dependency property.</span></span> <span data-ttu-id="43ce5-153">这是如果您使用现有[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]实现的 XAML 处理器，因为可以通过使用提高性能<xref:System.Windows.DependencyProperty>备份。</span><span class="sxs-lookup"><span data-stu-id="43ce5-153">This is particularly true if you use the existing [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] implementation of the XAML processor, because you can improve performance by using <xref:System.Windows.DependencyProperty> backing.</span></span> <span data-ttu-id="43ce5-154">依赖属性将对用户针对 XAML 可访问属性所需的属性公开属性系统功能。</span><span class="sxs-lookup"><span data-stu-id="43ce5-154">A dependency property will expose property system features for your property that users will come to expect for a XAML accessible property.</span></span> <span data-ttu-id="43ce5-155">这包括动画、数据绑定和样式支持等功能。</span><span class="sxs-lookup"><span data-stu-id="43ce5-155">This includes features such as animation, data binding, and style support.</span></span> <span data-ttu-id="43ce5-156">有关详细信息，请参阅[自定义依赖属性](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)和 [XAML 加载和依赖属性](../../../../docs/framework/wpf/advanced/xaml-loading-and-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="43ce5-156">For more information, see [Custom Dependency Properties](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md) and [XAML Loading and Dependency Properties](../../../../docs/framework/wpf/advanced/xaml-loading-and-dependency-properties.md).</span></span>  
  
### <a name="writing-and-attributing-a-type-converter"></a><span data-ttu-id="43ce5-157">编写和特性化类型转换器</span><span class="sxs-lookup"><span data-stu-id="43ce5-157">Writing and Attributing a Type Converter</span></span>  
 <span data-ttu-id="43ce5-158">您偶尔需要编写自定义<xref:System.ComponentModel.TypeConverter>派生的类提供对属性类型的类型转换。</span><span class="sxs-lookup"><span data-stu-id="43ce5-158">You occasionally will need to write a custom <xref:System.ComponentModel.TypeConverter> derived class to provide type conversion for your property type.</span></span> <span data-ttu-id="43ce5-159">有关如何派生和创建可以支持 XAML 用法的类型转换器以及如何将应用的说明<xref:System.ComponentModel.TypeConverterAttribute>，请参阅[TypeConverters 和 XAML](../../../../docs/framework/wpf/advanced/typeconverters-and-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="43ce5-159">For instructions on how to derive from and create a type converter that can support XAML usages, and how to apply the <xref:System.ComponentModel.TypeConverterAttribute>, see [TypeConverters and XAML](../../../../docs/framework/wpf/advanced/typeconverters-and-xaml.md).</span></span>  
  
<a name="Requirements_for_Events_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-xaml-event-handler-attribute-syntax-on-events-of-a-custom-class"></a><span data-ttu-id="43ce5-160">自定义类事件上 XAML 事件处理程序特性语法的要求</span><span class="sxs-lookup"><span data-stu-id="43ce5-160">Requirements for XAML Event Handler Attribute Syntax on Events of a Custom Class</span></span>  
 <span data-ttu-id="43ce5-161">若要用作 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 事件，事件必须在支持默认构造函数的类上或在派生类可访问事件的抽象类上公开为公共事件。</span><span class="sxs-lookup"><span data-stu-id="43ce5-161">To be usable as a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event, the event must be exposed as a public event on a class that supports a default constructor, or on an abstract class where the event can be accessed on derived classes.</span></span> <span data-ttu-id="43ce5-162">以可方便地用作路由事件，你[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]事件应实现显式`add`并`remove`方法，这些添加和删除处理程序方法[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]事件签名并转发到这些处理程序<xref:System.Windows.UIElement.AddHandler%2A>和<xref:System.Windows.UIElement.RemoveHandler%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="43ce5-162">In order to be used conveniently as a routed event, your [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event should implement explicit `add` and `remove` methods, which add and remove handlers for the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event signature and forward those handlers to the <xref:System.Windows.UIElement.AddHandler%2A> and <xref:System.Windows.UIElement.RemoveHandler%2A> methods.</span></span> <span data-ttu-id="43ce5-163">这些方法添加或删除事件所附加到的实例上的路由事件处理程序存储的处理程序。</span><span class="sxs-lookup"><span data-stu-id="43ce5-163">These methods add or remove the handlers to the routed event handler store on the instance that the event is attached to.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="43ce5-164">可以直接为使用的路由事件注册处理程序<xref:System.Windows.UIElement.AddHandler%2A>，并在特意不定义[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]公开路由的事件的事件。</span><span class="sxs-lookup"><span data-stu-id="43ce5-164">It is possible to register handlers directly for routed events using <xref:System.Windows.UIElement.AddHandler%2A>, and to deliberately not define a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event that exposes the routed event.</span></span> <span data-ttu-id="43ce5-165">通常不建议采用此操作，因为事件不会启用 XAML 特性语法用于附加处理程序，并且生成类提供的类型功能的 XAML 视图透明度较低。</span><span class="sxs-lookup"><span data-stu-id="43ce5-165">This is not generally recommended because the event will not enable XAML attribute syntax for attaching handlers, and your resulting class will offer a less transparent XAML view of that type's capabilities.</span></span>  
  
<a name="Collection_Properties"></a>   
## <a name="writing-collection-properties"></a><span data-ttu-id="43ce5-166">编写集合属性</span><span class="sxs-lookup"><span data-stu-id="43ce5-166">Writing Collection Properties</span></span>  
 <span data-ttu-id="43ce5-167">采用集合类型的属性所具有的 XAML 语法使你可指定添加到集合的对象。</span><span class="sxs-lookup"><span data-stu-id="43ce5-167">Properties that take a collection type have a XAML syntax that enables you to specify objects that are added to the collection.</span></span> <span data-ttu-id="43ce5-168">此语法具有两个重要功能。</span><span class="sxs-lookup"><span data-stu-id="43ce5-168">This syntax has two notable features.</span></span>  
  
-   <span data-ttu-id="43ce5-169">无需在对象元素语法中指定作为集合对象的对象。</span><span class="sxs-lookup"><span data-stu-id="43ce5-169">The object that is the collection object does not need to be specified in object element syntax.</span></span> <span data-ttu-id="43ce5-170">无论何时在采用集合类型的 XAML 中指定属性，该集合类型的状态总是隐式。</span><span class="sxs-lookup"><span data-stu-id="43ce5-170">The presence of that collection type is implicit whenever you specify a property in XAML that takes a collection type.</span></span>  
  
-   <span data-ttu-id="43ce5-171">标记中集合属性的子元素经处理后变成集合的成员。</span><span class="sxs-lookup"><span data-stu-id="43ce5-171">Child elements of the collection property in markup are processed to become members of the collection.</span></span> <span data-ttu-id="43ce5-172">对集合成员的代码访问通常通过列表/字典方法（例如 `Add`）或通过索引器执行。</span><span class="sxs-lookup"><span data-stu-id="43ce5-172">Ordinarily, the code access to the members of a collection is performed through list/dictionary methods such as `Add`, or through an indexer.</span></span> <span data-ttu-id="43ce5-173">但 XAML 语法不支持方法和索引器 (异常：XAML 2009 可以支持这些方法，但使用 XAML 2009 会限制可能的 WPF 用法;请参阅[XAML 2009 语言功能](../../../../docs/framework/xaml-services/xaml-2009-language-features.md))。</span><span class="sxs-lookup"><span data-stu-id="43ce5-173">But XAML syntax does not support methods or indexers (exception: XAML 2009 can support methods, but using XAML 2009 restricts the possible WPF usages; see [XAML 2009 Language Features](../../../../docs/framework/xaml-services/xaml-2009-language-features.md)).</span></span> <span data-ttu-id="43ce5-174">对生成元素树而言，集合显然是非常常见的要求，并且你需要某种方法来填充声明 XAML 中的这些集合。</span><span class="sxs-lookup"><span data-stu-id="43ce5-174">Collections are obviously a very common requirement for building a tree of elements, and you need some way to populate these collections in declarative XAML.</span></span> <span data-ttu-id="43ce5-175">因此，通过将集合属性的子元素添加到作为集合属性类型值的集合中来对其进行处理。</span><span class="sxs-lookup"><span data-stu-id="43ce5-175">Therefore, child elements of a collection property are processed by adding them to the collection that is the collection property type value.</span></span>  
  
 <span data-ttu-id="43ce5-176">.NET Framework XAML 服务实现和 WPF XAML 处理器将以下定义用于组成集合属性的项。</span><span class="sxs-lookup"><span data-stu-id="43ce5-176">The .NET Framework XAML Services implementation and thus the WPF XAML processor uses the following definition for what constitutes a collection property.</span></span> <span data-ttu-id="43ce5-177">属性的属性类型必须实现以下项之一：</span><span class="sxs-lookup"><span data-stu-id="43ce5-177">The property type of the property must implement one of the following:</span></span>  
  
-   <span data-ttu-id="43ce5-178">实现<xref:System.Collections.IList>。</span><span class="sxs-lookup"><span data-stu-id="43ce5-178">Implements <xref:System.Collections.IList>.</span></span>  
  
-   <span data-ttu-id="43ce5-179">实现<xref:System.Collections.IDictionary>或泛型等效项 (<xref:System.Collections.Generic.IDictionary%602>)。</span><span class="sxs-lookup"><span data-stu-id="43ce5-179">Implements <xref:System.Collections.IDictionary> or the generic equivalent (<xref:System.Collections.Generic.IDictionary%602>).</span></span>  
  
-   <span data-ttu-id="43ce5-180">派生自<xref:System.Array>(有关在 XAML 中数组的详细信息，请参阅[X:array 标记扩展](../../../../docs/framework/xaml-services/x-array-markup-extension.md)。)</span><span class="sxs-lookup"><span data-stu-id="43ce5-180">Derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../../../docs/framework/xaml-services/x-array-markup-extension.md).)</span></span>  
  
-   <span data-ttu-id="43ce5-181">实现<xref:System.Windows.Markup.IAddChild>(通过定义的接口[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)])。</span><span class="sxs-lookup"><span data-stu-id="43ce5-181">Implements <xref:System.Windows.Markup.IAddChild> (an interface defined by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]).</span></span>  
  
 <span data-ttu-id="43ce5-182">CLR 中这些类型每个都具有 `Add` 方法，创建对象图时，XAML 处理器使用该方法将项添加到基础集合。</span><span class="sxs-lookup"><span data-stu-id="43ce5-182">Each of these types in CLR has an `Add` method, which is used by the XAML processor to add items to the underlying collection when creating the object graph.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="43ce5-183">泛型`List`并`Dictionary`接口 (<xref:System.Collections.Generic.IList%601>并<xref:System.Collections.Generic.IDictionary%602>) 不支持对于集合检测通过[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]XAML 处理器。</span><span class="sxs-lookup"><span data-stu-id="43ce5-183">The generic `List` and `Dictionary` interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processor.</span></span> <span data-ttu-id="43ce5-184">但是，可以使用<xref:System.Collections.Generic.List%601>类作为基类，因为它实现<xref:System.Collections.IList>直接，或<xref:System.Collections.Generic.Dictionary%602>作为基类，因为它实现了<xref:System.Collections.IDictionary>直接。</span><span class="sxs-lookup"><span data-stu-id="43ce5-184">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="43ce5-185">声明采用集合的属性时，请注意类型的新实例中如何实例化此属性值。</span><span class="sxs-lookup"><span data-stu-id="43ce5-185">When you declare a property that takes a collection, be cautious about how that property value is initialized in new instances of the type.</span></span> <span data-ttu-id="43ce5-186">如果不将此属性实现为依赖属性，则使属性使用调用此集合类型构造函数的支持字段已可满足使用需求。</span><span class="sxs-lookup"><span data-stu-id="43ce5-186">If you are not implementing the property as a dependency property, then having the property use a backing field that calls the collection type constructor is adequate.</span></span> <span data-ttu-id="43ce5-187">如果属性为依赖属性，则可能需要将集合属性初始化为默认类型构造函数的一部分。</span><span class="sxs-lookup"><span data-stu-id="43ce5-187">If your property is a dependency property, then you may need to initialize the collection property as part of the default type constructor.</span></span> <span data-ttu-id="43ce5-188">这是因为依赖属性从元数据获取其默认值，而通常不希望集合属性的初始值为静态共享集合。</span><span class="sxs-lookup"><span data-stu-id="43ce5-188">This is because a dependency property takes its default value from metadata, and you typically do not want the initial value of a collection property to be a static, shared collection.</span></span> <span data-ttu-id="43ce5-189">每个包含类型实例应具有一个集合实例。</span><span class="sxs-lookup"><span data-stu-id="43ce5-189">There should be a collection instance per each containing type instance.</span></span> <span data-ttu-id="43ce5-190">有关详细信息，请参阅[自定义依赖属性](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="43ce5-190">For more information, see [Custom Dependency Properties](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md).</span></span>  
  
 <span data-ttu-id="43ce5-191">可为集合属性实现自定义集合类型。</span><span class="sxs-lookup"><span data-stu-id="43ce5-191">You can implement a custom collection type for your collection property.</span></span> <span data-ttu-id="43ce5-192">由于隐式集合属性处理的原因，自定义集合类型无需提供默认构造函数即可隐式用于 XAML 中。</span><span class="sxs-lookup"><span data-stu-id="43ce5-192">Because of implicit collection property treatment, the custom collection type does not need to provide a default constructor in order to be used in XAML implicitly.</span></span> <span data-ttu-id="43ce5-193">但是，可选择为集合类型提供默认构造函数。</span><span class="sxs-lookup"><span data-stu-id="43ce5-193">However, you can optionally provide a default constructor for the collection type.</span></span> <span data-ttu-id="43ce5-194">此做法是有用的。</span><span class="sxs-lookup"><span data-stu-id="43ce5-194">This can be a worthwhile practice.</span></span> <span data-ttu-id="43ce5-195">除非提供默认构造函数，否则无法显式将集合声明为对象元素。</span><span class="sxs-lookup"><span data-stu-id="43ce5-195">Unless you do provide a default constructor, you cannot explicitly declare the collection as an object element.</span></span> <span data-ttu-id="43ce5-196">一些标记作者可能希望看到作为标记样式的显式集合。</span><span class="sxs-lookup"><span data-stu-id="43ce5-196">Some markup authors might prefer to see the explicit collection as a matter of markup style.</span></span> <span data-ttu-id="43ce5-197">此外，创建将集合类型用作属性值的新对象时，默认构造函数可简化初始化要求。</span><span class="sxs-lookup"><span data-stu-id="43ce5-197">Also, a default constructor can simplify the initialization requirements when you create new objects that use your collection type as a property value.</span></span>  
  
<a name="XAMLCONtent"></a>   
## <a name="declaring-xaml-content-properties"></a><span data-ttu-id="43ce5-198">声明 XAML 内容属性</span><span class="sxs-lookup"><span data-stu-id="43ce5-198">Declaring XAML Content Properties</span></span>  
 <span data-ttu-id="43ce5-199">XAML 语言定义 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 内容属性的概念。</span><span class="sxs-lookup"><span data-stu-id="43ce5-199">The XAML language defines the concept of a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] content property.</span></span> <span data-ttu-id="43ce5-200">对象语法中可用的每个类仅可具有一个 XAML 内容属性。</span><span class="sxs-lookup"><span data-stu-id="43ce5-200">Each class that is usable in object syntax can have exactly one XAML content property.</span></span> <span data-ttu-id="43ce5-201">若要将属性声明为 XAML 内容属性为您的类，应用<xref:System.Windows.Markup.ContentPropertyAttribute>为类定义的一部分。</span><span class="sxs-lookup"><span data-stu-id="43ce5-201">To declare a property to be the XAML content property for your class, apply the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of the class definition.</span></span> <span data-ttu-id="43ce5-202">指定作为目标的 XAML 内容属性的名称<xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A>属性中。</span><span class="sxs-lookup"><span data-stu-id="43ce5-202">Specify the name of the intended XAML content property as the <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> in the attribute.</span></span> <span data-ttu-id="43ce5-203">指定的属性是作为字符串名称，不与反射构造如<xref:System.Reflection.PropertyInfo>。</span><span class="sxs-lookup"><span data-stu-id="43ce5-203">The property is specified as a string by name, not as a reflection construct such as <xref:System.Reflection.PropertyInfo>.</span></span>  
  
 <span data-ttu-id="43ce5-204">可将集合属性指定为 XAML 内容属性。</span><span class="sxs-lookup"><span data-stu-id="43ce5-204">You can specify a collection property to be the XAML content property.</span></span> <span data-ttu-id="43ce5-205">这产生一种属性的用法，通过此用法，对象元素可具有一个或多个子元素，不干扰集合对象元素或属性元素标记。</span><span class="sxs-lookup"><span data-stu-id="43ce5-205">This results in a usage for that property whereby the object element can have one or more child elements, without any intervening collection object elements or property element tags.</span></span> <span data-ttu-id="43ce5-206">这些元素被视为 XAML 内容属性的值，并添加到支持集合实例中。</span><span class="sxs-lookup"><span data-stu-id="43ce5-206">These elements are then treated as the value for the XAML content property and added to the backing collection instance.</span></span>  
  
 <span data-ttu-id="43ce5-207">一些现有 XAML 内容属性使用 `Object` 的属性类型。</span><span class="sxs-lookup"><span data-stu-id="43ce5-207">Some existing XAML content properties use the property type of `Object`.</span></span> <span data-ttu-id="43ce5-208">这使 XAML 内容属性可接受基元值如<xref:System.String>和单一引用对象值。</span><span class="sxs-lookup"><span data-stu-id="43ce5-208">This enables a XAML content property that can take primitive values such as a <xref:System.String> as well as taking a single reference object value.</span></span> <span data-ttu-id="43ce5-209">如果按照此模型，类型负责类型确定以及处理可能的类型。</span><span class="sxs-lookup"><span data-stu-id="43ce5-209">If you follow this model, your type is responsible for type determination as well as the handling of possible types.</span></span> <span data-ttu-id="43ce5-210">典型的原因<xref:System.Object>内容类型是为了支持这两个简单的方法，将对象内容添加为字符串 （接收默认演示文稿处理），或添加的高级的方法对象指定非默认演示文稿的内容或其他数据。</span><span class="sxs-lookup"><span data-stu-id="43ce5-210">The typical reason for an <xref:System.Object> content type is to support both a simple means of adding object content as a string (which receives a default presentation treatment), or an advanced means of adding object content that specifies a non-default presentation or additional data.</span></span>  
  
<a name="Serializing"></a>   
## <a name="serializing-xaml"></a><span data-ttu-id="43ce5-211">序列化 XAML</span><span class="sxs-lookup"><span data-stu-id="43ce5-211">Serializing XAML</span></span>  
 <span data-ttu-id="43ce5-212">某些情况下（例如对于控件作者），可能还需要确保任何可在 XAML 中实例化的对象演示文稿也可被序列化到等效的 XAML 标记。</span><span class="sxs-lookup"><span data-stu-id="43ce5-212">For certain scenarios, such as if you are a control author, you may also want to assure that any object representation that can be instantiated in XAML can also be serialized back to equivalent XAML markup.</span></span> <span data-ttu-id="43ce5-213">本主题中未介绍序列化要求。</span><span class="sxs-lookup"><span data-stu-id="43ce5-213">Serialization requirements are not described in this topic.</span></span> <span data-ttu-id="43ce5-214">请参阅[控件创作概述](../../../../docs/framework/wpf/controls/control-authoring-overview.md)和[元素树和序列化](../../../../docs/framework/wpf/advanced/element-tree-and-serialization.md)。</span><span class="sxs-lookup"><span data-stu-id="43ce5-214">See [Control Authoring Overview](../../../../docs/framework/wpf/controls/control-authoring-overview.md) and [Element Tree and Serialization](../../../../docs/framework/wpf/advanced/element-tree-and-serialization.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="43ce5-215">请参阅</span><span class="sxs-lookup"><span data-stu-id="43ce5-215">See also</span></span>
- [<span data-ttu-id="43ce5-216">XAML 概述 (WPF)</span><span class="sxs-lookup"><span data-stu-id="43ce5-216">XAML Overview (WPF)</span></span>](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)
- [<span data-ttu-id="43ce5-217">自定义依赖属性</span><span class="sxs-lookup"><span data-stu-id="43ce5-217">Custom Dependency Properties</span></span>](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)
- [<span data-ttu-id="43ce5-218">控件创作概述</span><span class="sxs-lookup"><span data-stu-id="43ce5-218">Control Authoring Overview</span></span>](../../../../docs/framework/wpf/controls/control-authoring-overview.md)
- [<span data-ttu-id="43ce5-219">基元素概述</span><span class="sxs-lookup"><span data-stu-id="43ce5-219">Base Elements Overview</span></span>](../../../../docs/framework/wpf/advanced/base-elements-overview.md)
- [<span data-ttu-id="43ce5-220">XAML 加载和依赖项属性</span><span class="sxs-lookup"><span data-stu-id="43ce5-220">XAML Loading and Dependency Properties</span></span>](../../../../docs/framework/wpf/advanced/xaml-loading-and-dependency-properties.md)
