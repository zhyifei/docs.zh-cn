---
title: 依赖项属性值优先级
ms.date: 03/30/2017
helpviewer_keywords:
- dependency properties [WPF], classes as owners
- dependency properties [WPF], metadata
- classes [WPF], owners of dependency properties
- metadata [WPF], dependency properties
ms.assetid: 1fbada8e-4867-4ed1-8d97-62c07dad7ebc
ms.openlocfilehash: a9ff3a4f6ac08a0f7ec6dd9fc26bf190f43f3584
ms.sourcegitcommit: 011314e0c8eb4cf4a11d92078f58176c8c3efd2d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/09/2020
ms.locfileid: "77095198"
---
# <a name="dependency-property-value-precedence"></a><span data-ttu-id="2e955-102">依赖项属性值优先级</span><span class="sxs-lookup"><span data-stu-id="2e955-102">Dependency Property Value Precedence</span></span>
<a name="introduction"></a> <span data-ttu-id="2e955-103">本主题说明 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 属性系统的工作机制如何影响依赖属性的值，并介绍应用于属性有效值的属性系统的各方面所依据的优先级。</span><span class="sxs-lookup"><span data-stu-id="2e955-103">This topic explains how the workings of the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] property system can affect the value of a dependency property, and describes the precedence by which aspects of the property system apply to the effective value of a property.</span></span>  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="2e955-104">必备条件</span><span class="sxs-lookup"><span data-stu-id="2e955-104">Prerequisites</span></span>  
 <span data-ttu-id="2e955-105">本主题假定你从 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 类的现有依赖属性的使用者角度了解依赖属性，并且已阅读[依赖属性概述](dependency-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="2e955-105">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes, and have read [Dependency Properties Overview](dependency-properties-overview.md).</span></span> <span data-ttu-id="2e955-106">若要采用本主题中的示例，还应当了解[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] 并知道如何编写 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 应用程序。</span><span class="sxs-lookup"><span data-stu-id="2e955-106">To follow the examples in this topic, you should also understand [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] and know how to write [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications.</span></span>  
  
<a name="intro"></a>   
## <a name="the-wpf-property-system"></a><span data-ttu-id="2e955-107">WPF 属性系统</span><span class="sxs-lookup"><span data-stu-id="2e955-107">The WPF Property System</span></span>  
 <span data-ttu-id="2e955-108">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 属性系统提供一种强大的方法，使得依赖属性的值由多种因素决定，从而实现诸如实时属性验证、后期绑定以及向相关属性发出有关其他属性值发生更改的通知等功能。</span><span class="sxs-lookup"><span data-stu-id="2e955-108">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system offers a powerful way to have the value of dependency properties be determined by a variety of factors, enabling features such as real-time property validation, late binding, and notifying related properties of changes to values for other properties.</span></span> <span data-ttu-id="2e955-109">用来确定依赖属性值的确切顺序和逻辑相当复杂。</span><span class="sxs-lookup"><span data-stu-id="2e955-109">The exact order and logic that is used to determine dependency property values is reasonably complex.</span></span> <span data-ttu-id="2e955-110">了解此顺序有助于避免不必要的属性设置，并且还有可能澄清混淆，使你正确了解为何某些影响或预测依赖属性值的尝试最终却没有得出所期望的值。</span><span class="sxs-lookup"><span data-stu-id="2e955-110">Knowing this order will help you avoid unnecessary property setting, and might also clear up confusion over exactly why some attempt to influence or anticipate a dependency property value did not end up resulting in the value you expected.</span></span>  
  
<a name="multiple_sets"></a>   
## <a name="dependency-properties-might-be-set-in-multiple-places"></a><span data-ttu-id="2e955-111">依赖属性可以在多个位置“设置”</span><span class="sxs-lookup"><span data-stu-id="2e955-111">Dependency Properties Might Be "Set" in Multiple Places</span></span>  
 <span data-ttu-id="2e955-112">下面是 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 的示例，其中相同的属性（<xref:System.Windows.Controls.Control.Background%2A>）具有三个不同的 "设置" 操作，这些操作可能会影响该值。</span><span class="sxs-lookup"><span data-stu-id="2e955-112">The following is example [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] where the same property (<xref:System.Windows.Controls.Control.Background%2A>) has three different "set" operations that might influence the value.</span></span>  
  
 [!code-xaml[PropertiesOvwSupport#DPPrecedence](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#dpprecedence)]  
  
 <span data-ttu-id="2e955-113">这里，你希望应用什么颜色：红色、绿色还是蓝色？</span><span class="sxs-lookup"><span data-stu-id="2e955-113">Here, which color do you expect will apply—red, green, or blue?</span></span>  
  
 <span data-ttu-id="2e955-114">本地属性集在设置时具有最高优先级，动画值和强制除外。</span><span class="sxs-lookup"><span data-stu-id="2e955-114">With the exception of animated values and coercion, local property sets are set at the highest precedence.</span></span> <span data-ttu-id="2e955-115">如果在本地设置某个值，你可以期待该值优先得到应用，甚至期待其优先级高于任何样式或控件模板。</span><span class="sxs-lookup"><span data-stu-id="2e955-115">If you set a value locally you can expect that the value will be honored, even above any styles or control templates.</span></span> <span data-ttu-id="2e955-116">在此示例中，将 <xref:System.Windows.Controls.Control.Background%2A> 设置为 "红色"。</span><span class="sxs-lookup"><span data-stu-id="2e955-116">Here in the example, <xref:System.Windows.Controls.Control.Background%2A> is set to Red locally.</span></span> <span data-ttu-id="2e955-117">因此，在此范围中定义的样式（即使它是一个隐式样式，它将应用于该范围内该类型的所有元素），并不是为 <xref:System.Windows.Controls.Control.Background%2A> 属性提供其值的最高优先级。</span><span class="sxs-lookup"><span data-stu-id="2e955-117">Therefore, the style defined in this scope, even though it is an implicit style that would otherwise apply to all elements of that type in that scope, is not the highest precedence for giving the <xref:System.Windows.Controls.Control.Background%2A> property its value.</span></span>  <span data-ttu-id="2e955-118">如果从该 Button 实例中删除本地值“Red”，样式将获得优先级，而按钮将从该样式中获得 Background 值。</span><span class="sxs-lookup"><span data-stu-id="2e955-118">If you removed the local value of Red from that Button instance, then the style would have precedence and the button would obtain the Background value from the style.</span></span>  <span data-ttu-id="2e955-119">在该样式中，触发器具有优先级，因此当鼠标位于按钮上时，按钮为蓝色，其他情况下则为绿色。</span><span class="sxs-lookup"><span data-stu-id="2e955-119">Within the style, triggers take precedence, so the button will be blue if the mouse is over it, and green otherwise.</span></span>  
  
<a name="listing"></a>   
## <a name="dependency-property-setting-precedence-list"></a><span data-ttu-id="2e955-120">依赖属性设置优先级列表</span><span class="sxs-lookup"><span data-stu-id="2e955-120">Dependency Property Setting Precedence List</span></span>  
 <span data-ttu-id="2e955-121">下面是属性系统在分配依赖属性的运行时值时所使用的最终顺序。</span><span class="sxs-lookup"><span data-stu-id="2e955-121">The following is the definitive order that the property system uses when assigning the run-time values of dependency properties.</span></span> <span data-ttu-id="2e955-122">最高优先级最先列出。</span><span class="sxs-lookup"><span data-stu-id="2e955-122">Highest precedence is listed first.</span></span> <span data-ttu-id="2e955-123">此列表对[依赖属性概述](dependency-properties-overview.md)中的某些一般化内容进行了扩充。</span><span class="sxs-lookup"><span data-stu-id="2e955-123">This list expands on some of the generalizations made in the [Dependency Properties Overview](dependency-properties-overview.md).</span></span>  
  
1. <span data-ttu-id="2e955-124">**属性系统强制。**</span><span class="sxs-lookup"><span data-stu-id="2e955-124">**Property system coercion.**</span></span> <span data-ttu-id="2e955-125">有关强制的详细信息，请参阅本主题后面的[强制、动画和基值](#animations)。</span><span class="sxs-lookup"><span data-stu-id="2e955-125">For details on coercion, see [Coercion, Animation, and Base Value](#animations) later in this topic.</span></span>  
  
2. <span data-ttu-id="2e955-126">**活动动画或具有 Hold 行为的动画。**</span><span class="sxs-lookup"><span data-stu-id="2e955-126">**Active animations, or animations with a Hold behavior.**</span></span> <span data-ttu-id="2e955-127">为了获得任何实用效果，属性的动画必须优先于基（未动画）值，即使该值是在本地设置的也是如此。</span><span class="sxs-lookup"><span data-stu-id="2e955-127">In order to have any practical effect, an animation of a property must be able to have precedence over the base (unanimated) value, even if that value was set locally.</span></span> <span data-ttu-id="2e955-128">有关详细信息，请参阅本主题后面的[强制、动画和基值](#animations)。</span><span class="sxs-lookup"><span data-stu-id="2e955-128">For details, see [Coercion, Animation, and Base Value](#animations) later in this topic.</span></span>  
  
3. <span data-ttu-id="2e955-129">**本地值。**</span><span class="sxs-lookup"><span data-stu-id="2e955-129">**Local value.**</span></span> <span data-ttu-id="2e955-130">本地值可通过 "包装器" 属性的便利性来设置，这也相当于在 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]中设置为属性或属性元素，或通过使用特定实例的属性调用 <xref:System.Windows.DependencyObject.SetValue%2A> API。</span><span class="sxs-lookup"><span data-stu-id="2e955-130">A local value might be set through the convenience of the "wrapper" property, which also equates to setting as an attribute or property element in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], or by a call to the <xref:System.Windows.DependencyObject.SetValue%2A> API using a property of a specific instance.</span></span> <span data-ttu-id="2e955-131">如果使用绑定或资源来设置本地值，则每个值都按照直接设置值的优先级顺序来应用。</span><span class="sxs-lookup"><span data-stu-id="2e955-131">If you set a local value by using a binding or a resource, these each act in the precedence as if a direct value was set.</span></span>  
  
4. <span data-ttu-id="2e955-132">**TemplatedParent 模板属性。**</span><span class="sxs-lookup"><span data-stu-id="2e955-132">**TemplatedParent template properties.**</span></span> <span data-ttu-id="2e955-133">如果元素是作为模板的一部分（<xref:System.Windows.Controls.ControlTemplate> 或 <xref:System.Windows.DataTemplate>）创建的，则该元素具有 <xref:System.Windows.FrameworkElement.TemplatedParent%2A>。</span><span class="sxs-lookup"><span data-stu-id="2e955-133">An element has a <xref:System.Windows.FrameworkElement.TemplatedParent%2A> if it was created as part of a template (a <xref:System.Windows.Controls.ControlTemplate> or <xref:System.Windows.DataTemplate>).</span></span> <span data-ttu-id="2e955-134">有关何时应用此原则的详细信息，请参阅本主题后面的 [TemplatedParent](#templatedparent)。</span><span class="sxs-lookup"><span data-stu-id="2e955-134">For details on when this applies, see [TemplatedParent](#templatedparent) later in this topic.</span></span> <span data-ttu-id="2e955-135">在模板中，按以下优先级顺序应用：</span><span class="sxs-lookup"><span data-stu-id="2e955-135">Within the template, the following precedence applies:</span></span>  
  
    1. <span data-ttu-id="2e955-136"><xref:System.Windows.FrameworkElement.TemplatedParent%2A> 模板中的触发器。</span><span class="sxs-lookup"><span data-stu-id="2e955-136">Triggers from the <xref:System.Windows.FrameworkElement.TemplatedParent%2A> template.</span></span>  
  
    2. <span data-ttu-id="2e955-137"><xref:System.Windows.FrameworkElement.TemplatedParent%2A> 模板中的属性集（通常通过 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 属性）。</span><span class="sxs-lookup"><span data-stu-id="2e955-137">Property sets (typically through [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] attributes) in the <xref:System.Windows.FrameworkElement.TemplatedParent%2A> template.</span></span>  
  
5. <span data-ttu-id="2e955-138">**隐式样式。**</span><span class="sxs-lookup"><span data-stu-id="2e955-138">**Implicit style.**</span></span> <span data-ttu-id="2e955-139">仅应用于 `Style` 属性。</span><span class="sxs-lookup"><span data-stu-id="2e955-139">Applies only to the `Style` property.</span></span> <span data-ttu-id="2e955-140">`Style` 属性是由任何样式资源通过与其类型匹配的键来填充的。</span><span class="sxs-lookup"><span data-stu-id="2e955-140">The `Style` property is filled by any style resource with a key that matches the type of that element.</span></span> <span data-ttu-id="2e955-141">该样式资源必须存在于页面或应用程序中；查找隐式样式资源不会进入到主题中。</span><span class="sxs-lookup"><span data-stu-id="2e955-141">That style resource must exist either in the page or the application; lookup for an implicit style resource does not proceed into the themes.</span></span>  
  
6. <span data-ttu-id="2e955-142">**样式触发器。**</span><span class="sxs-lookup"><span data-stu-id="2e955-142">**Style triggers.**</span></span> <span data-ttu-id="2e955-143">来自页面或应用程序的样式中的触发器（这些样式可以是显式或隐式样式，但不是来自优先级较低的默认样式）。</span><span class="sxs-lookup"><span data-stu-id="2e955-143">The triggers within styles from page or application (these styles might be either explicit or implicit styles, but not from the default styles, which have lower precedence).</span></span>  
  
7. <span data-ttu-id="2e955-144">**模板触发器。**</span><span class="sxs-lookup"><span data-stu-id="2e955-144">**Template triggers.**</span></span> <span data-ttu-id="2e955-145">来自样式中的模板或者直接应用的模板的任何触发器。</span><span class="sxs-lookup"><span data-stu-id="2e955-145">Any trigger from a template within a style, or a directly applied template.</span></span>  
  
8. <span data-ttu-id="2e955-146">**样式资源库。**</span><span class="sxs-lookup"><span data-stu-id="2e955-146">**Style setters.**</span></span> <span data-ttu-id="2e955-147">来自页面或应用程序的样式中的 <xref:System.Windows.Setter> 的值。</span><span class="sxs-lookup"><span data-stu-id="2e955-147">Values from a <xref:System.Windows.Setter> within styles from page or application.</span></span>  
  
9. <span data-ttu-id="2e955-148">**默认（主题）样式。**</span><span class="sxs-lookup"><span data-stu-id="2e955-148">**Default (theme) style.**</span></span> <span data-ttu-id="2e955-149">有关何时应用此样式以及主题样式如何与主题样式中的模板相关的详细信息，请参阅本主题后面的[默认（主题）样式](#themestyles)。</span><span class="sxs-lookup"><span data-stu-id="2e955-149">For details on when this applies, and how theme styles relate to the templates within theme styles, see [Default (Theme) Styles](#themestyles) later in this topic.</span></span> <span data-ttu-id="2e955-150">在默认样式中，按以下优先级顺序应用：</span><span class="sxs-lookup"><span data-stu-id="2e955-150">Within a default style, the following order of precedence applies:</span></span>  
  
    1. <span data-ttu-id="2e955-151">主题样式中的活动触发器。</span><span class="sxs-lookup"><span data-stu-id="2e955-151">Active triggers in the theme style.</span></span>  
  
    2. <span data-ttu-id="2e955-152">主题样式中的资源库。</span><span class="sxs-lookup"><span data-stu-id="2e955-152">Setters in the theme style.</span></span>  
  
10. <span data-ttu-id="2e955-153">**继承。**</span><span class="sxs-lookup"><span data-stu-id="2e955-153">**Inheritance.**</span></span> <span data-ttu-id="2e955-154">有几个依赖属性从父元素向子元素继承值，因此不需要在应用程序中的每个元素上专门设置这些属性。</span><span class="sxs-lookup"><span data-stu-id="2e955-154">A few dependency properties inherit their values from parent element to child elements, such that they need not be set specifically on each element throughout an application.</span></span> <span data-ttu-id="2e955-155">有关详细信息，请参阅[属性值继承](property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="2e955-155">For details see [Property Value Inheritance](property-value-inheritance.md).</span></span>  
  
11. <span data-ttu-id="2e955-156">**来自依赖属性元数据的默认值。**</span><span class="sxs-lookup"><span data-stu-id="2e955-156">**Default value from dependency property metadata.**</span></span> <span data-ttu-id="2e955-157">任何给定的依赖属性都可能有一个默认值，它由该特定属性的属性系统注册来确定。</span><span class="sxs-lookup"><span data-stu-id="2e955-157">Any given dependency property may have a default value as established by the property system registration of that particular property.</span></span> <span data-ttu-id="2e955-158">而且，继承依赖属性的派生类可以选择按照类型重写该元数据（包括默认值）。</span><span class="sxs-lookup"><span data-stu-id="2e955-158">Also, derived classes that inherit a dependency property have the option to override that metadata (including the default value) on a per-type basis.</span></span> <span data-ttu-id="2e955-159">有关详细信息，请参阅[依赖属性元数据](dependency-property-metadata.md)。</span><span class="sxs-lookup"><span data-stu-id="2e955-159">See [Dependency Property Metadata](dependency-property-metadata.md) for more information.</span></span> <span data-ttu-id="2e955-160">因为继承是在默认值之前检查的，所以对于继承的属性，父元素的默认值优先于子元素。</span><span class="sxs-lookup"><span data-stu-id="2e955-160">Because inheritance is checked before default value, for an inherited property, a parent element default value takes precedence over a child element.</span></span>  <span data-ttu-id="2e955-161">因此，如果任何地方都没有设置可继承的属性，将使用在根元素或父元素中指定的默认值，而不是子元素的默认值。</span><span class="sxs-lookup"><span data-stu-id="2e955-161">Consequently, if an inheritable property is not set anywhere, the default value as specified on the root or parent is used instead of the child element default value.</span></span>  
  
<a name="templatedparent"></a>   
## <a name="templatedparent"></a><span data-ttu-id="2e955-162">TemplatedParent</span><span class="sxs-lookup"><span data-stu-id="2e955-162">TemplatedParent</span></span>  
 <span data-ttu-id="2e955-163">TemplatedParent 作为一个优先级项并不应用于在标准应用程序标记中直接声明的元素的任何属性。</span><span class="sxs-lookup"><span data-stu-id="2e955-163">TemplatedParent as a precedence item does not apply to any property of an element that you declare directly in standard application markup.</span></span> <span data-ttu-id="2e955-164">只有对于通过应用模板而产生的可视化树中的子项而言，才存在 TemplatedParent 概念。</span><span class="sxs-lookup"><span data-stu-id="2e955-164">The TemplatedParent concept exists only for child items within a visual tree that come into existence through the application of the template.</span></span> <span data-ttu-id="2e955-165">当属性系统在 <xref:System.Windows.FrameworkElement.TemplatedParent%2A> 模板搜索某个值时，它会搜索创建该元素的模板。</span><span class="sxs-lookup"><span data-stu-id="2e955-165">When the property system searches the <xref:System.Windows.FrameworkElement.TemplatedParent%2A> template for a value, it is searching the template that created that element.</span></span> <span data-ttu-id="2e955-166"><xref:System.Windows.FrameworkElement.TemplatedParent%2A> 模板中的属性值通常的作用就像是在子元素上将其设置为本地值，但这种优先级要低于本地值，因为模板可能会共享。</span><span class="sxs-lookup"><span data-stu-id="2e955-166">The property values from the <xref:System.Windows.FrameworkElement.TemplatedParent%2A> template generally act as if they were set as a local value on the child element, but this lesser precedence versus the local value exists because the templates are potentially shared.</span></span> <span data-ttu-id="2e955-167">有关详细信息，请参阅<xref:System.Windows.FrameworkElement.TemplatedParent%2A>。</span><span class="sxs-lookup"><span data-stu-id="2e955-167">For details, see <xref:System.Windows.FrameworkElement.TemplatedParent%2A>.</span></span>  
  
<a name="style_property"></a>   
## <a name="the-style-property"></a><span data-ttu-id="2e955-168">Style 属性</span><span class="sxs-lookup"><span data-stu-id="2e955-168">The Style Property</span></span>  
 <span data-ttu-id="2e955-169">前面所述的查找顺序适用于所有可能的依赖项属性，但有一个： "<xref:System.Windows.FrameworkElement.Style%2A>" 属性。</span><span class="sxs-lookup"><span data-stu-id="2e955-169">The order of lookup described earlier applies to all possible dependency properties except one: the <xref:System.Windows.FrameworkElement.Style%2A> property.</span></span> <span data-ttu-id="2e955-170"><xref:System.Windows.FrameworkElement.Style%2A> 属性是唯一的，因为它本身无法进行样式化，因此优先项5到8不适用。</span><span class="sxs-lookup"><span data-stu-id="2e955-170">The <xref:System.Windows.FrameworkElement.Style%2A> property is unique in that it cannot itself be styled, so the precedence items 5 through 8 do not apply.</span></span> <span data-ttu-id="2e955-171">此外，不建议对 <xref:System.Windows.FrameworkElement.Style%2A> 进行动画处理或强制（动画 <xref:System.Windows.FrameworkElement.Style%2A> 需要自定义动画类）。</span><span class="sxs-lookup"><span data-stu-id="2e955-171">Also, either animating or coercing <xref:System.Windows.FrameworkElement.Style%2A> is not recommended (and animating <xref:System.Windows.FrameworkElement.Style%2A> would require a custom animation class).</span></span> <span data-ttu-id="2e955-172">这就有三种方法可以设置 <xref:System.Windows.FrameworkElement.Style%2A> 属性：</span><span class="sxs-lookup"><span data-stu-id="2e955-172">This leaves three ways that the <xref:System.Windows.FrameworkElement.Style%2A> property might be set:</span></span>  
  
- <span data-ttu-id="2e955-173">**显式样式。**</span><span class="sxs-lookup"><span data-stu-id="2e955-173">**Explicit style.**</span></span> <span data-ttu-id="2e955-174"><xref:System.Windows.FrameworkElement.Style%2A> 属性是直接设置的。</span><span class="sxs-lookup"><span data-stu-id="2e955-174">The <xref:System.Windows.FrameworkElement.Style%2A> property is set directly.</span></span> <span data-ttu-id="2e955-175">在大多数情况下，样式不是内联定义的，而是作为资源由显式键进行引用的。</span><span class="sxs-lookup"><span data-stu-id="2e955-175">In most scenarios, the style is not defined inline, but instead is referenced as a resource, by explicit key.</span></span> <span data-ttu-id="2e955-176">在这种情况下，Style 属性本身就像本地值（优先级项 3）一样来应用。</span><span class="sxs-lookup"><span data-stu-id="2e955-176">In this case the Style property itself acts as if it were a local value, precedence item 3.</span></span>  
  
- <span data-ttu-id="2e955-177">**隐式样式。**</span><span class="sxs-lookup"><span data-stu-id="2e955-177">**Implicit style.**</span></span> <span data-ttu-id="2e955-178"><xref:System.Windows.FrameworkElement.Style%2A> 属性不是直接设置的。</span><span class="sxs-lookup"><span data-stu-id="2e955-178">The <xref:System.Windows.FrameworkElement.Style%2A> property is not set directly.</span></span> <span data-ttu-id="2e955-179">但是，<xref:System.Windows.FrameworkElement.Style%2A> 在资源查找序列（页、应用程序）的某一级别存在，并使用与要应用样式的类型匹配的资源键进行键控。</span><span class="sxs-lookup"><span data-stu-id="2e955-179">However, the <xref:System.Windows.FrameworkElement.Style%2A> exists at some level in the resource lookup sequence (page, application) and is keyed using a resource key that matches the type the style is to be applied to.</span></span> <span data-ttu-id="2e955-180">在这种情况下，<xref:System.Windows.FrameworkElement.Style%2A> 属性本身按序列中标识为项5的优先级进行。</span><span class="sxs-lookup"><span data-stu-id="2e955-180">In this case, the <xref:System.Windows.FrameworkElement.Style%2A> property itself acts by a precedence identified in the sequence as item 5.</span></span> <span data-ttu-id="2e955-181">通过对 <xref:System.Windows.FrameworkElement.Style%2A> 属性使用 <xref:System.Windows.DependencyPropertyHelper>，并在结果中查找 <xref:System.Windows.BaseValueSource.ImplicitStyleReference>，可以检测到这种情况。</span><span class="sxs-lookup"><span data-stu-id="2e955-181">This condition can be detected by using <xref:System.Windows.DependencyPropertyHelper> against the <xref:System.Windows.FrameworkElement.Style%2A> property and looking for <xref:System.Windows.BaseValueSource.ImplicitStyleReference> in the results.</span></span>  
  
- <span data-ttu-id="2e955-182">**默认样式**，也称为**主题样式。**</span><span class="sxs-lookup"><span data-stu-id="2e955-182">**Default style**, also known as **theme style.**</span></span> <span data-ttu-id="2e955-183">不会直接设置 <xref:System.Windows.FrameworkElement.Style%2A> 属性，实际上会在运行时一直读取为 `null`。</span><span class="sxs-lookup"><span data-stu-id="2e955-183">The <xref:System.Windows.FrameworkElement.Style%2A> property is not set directly, and in fact will read as `null` up until run time.</span></span> <span data-ttu-id="2e955-184">在这种情况下，样式来自作为 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 表示引擎一部分的运行时主题评估。</span><span class="sxs-lookup"><span data-stu-id="2e955-184">In this case, the style comes from the run-time theme evaluation that is part of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] presentation engine.</span></span>  
  
 <span data-ttu-id="2e955-185">对于不在主题中的隐式样式，类型必须完全匹配-a `MyButton` `Button`派生类将不会为 `Button`隐式使用样式。</span><span class="sxs-lookup"><span data-stu-id="2e955-185">For implicit styles not in themes, the type must match exactly - a `MyButton` `Button`-derived class will not implicitly use a style for `Button`.</span></span>  
  
<a name="themestyles"></a>   
## <a name="default-theme-styles"></a><span data-ttu-id="2e955-186">默认（主题）样式</span><span class="sxs-lookup"><span data-stu-id="2e955-186">Default (Theme) Styles</span></span>  
 <span data-ttu-id="2e955-187">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 附带的每个控件都有一个默认样式。</span><span class="sxs-lookup"><span data-stu-id="2e955-187">Every control that ships with [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] has a default style.</span></span> <span data-ttu-id="2e955-188">默认样式可能因主题而异，这就是默认样式有时候称为主题样式的原因。</span><span class="sxs-lookup"><span data-stu-id="2e955-188">That default style potentially varies by theme, which is why this default style is sometimes referred to as a theme style.</span></span>  
  
 <span data-ttu-id="2e955-189">在控件的默认样式中找到的最重要信息是其控件模板，该模板以主题样式作为其 <xref:System.Windows.Controls.Control.Template%2A> 属性的 setter 存在。</span><span class="sxs-lookup"><span data-stu-id="2e955-189">The most important information that is found within a default style for a control is its control template, which exists in the theme style as a setter for its <xref:System.Windows.Controls.Control.Template%2A> property.</span></span> <span data-ttu-id="2e955-190">如果默认样式中没有模板，自定义样式中没有自定义模板的控件将根本没有可视化外观。</span><span class="sxs-lookup"><span data-stu-id="2e955-190">If there were no template from default styles, a control without a custom template as part of a custom style would have no visual appearance at all.</span></span> <span data-ttu-id="2e955-191">默认样式中的模板为每个控件的可视化外观提供一个基本结构，还定义在模板的可视化树中定义的属性与对应的控件类之间的联系。</span><span class="sxs-lookup"><span data-stu-id="2e955-191">The template from the default style gives the visual appearance of each control a basic structure, and also defines the connections between properties defined in the visual tree of the template and the corresponding control class.</span></span> <span data-ttu-id="2e955-192">每个控件都公开一组属性，这些属性可以影响控件的可视化外观，而无需完全替换模板。</span><span class="sxs-lookup"><span data-stu-id="2e955-192">Each control exposes a set of properties that can influence the visual appearance of the control without completely replacing the template.</span></span> <span data-ttu-id="2e955-193">例如，请考虑 <xref:System.Windows.Controls.Primitives.Thumb> 控件（<xref:System.Windows.Controls.Primitives.ScrollBar>的组件）的默认视觉外观。</span><span class="sxs-lookup"><span data-stu-id="2e955-193">For example, consider the default visual appearance of a <xref:System.Windows.Controls.Primitives.Thumb> control, which is a component of a <xref:System.Windows.Controls.Primitives.ScrollBar>.</span></span>  
  
 <span data-ttu-id="2e955-194"><xref:System.Windows.Controls.Primitives.Thumb> 具有一些可自定义的属性。</span><span class="sxs-lookup"><span data-stu-id="2e955-194">A <xref:System.Windows.Controls.Primitives.Thumb> has certain customizable properties.</span></span> <span data-ttu-id="2e955-195"><xref:System.Windows.Controls.Primitives.Thumb> 的默认模板创建包含多个嵌套 <xref:System.Windows.Controls.Border> 组件的基本结构/可视化树，以创建凹凸效果。</span><span class="sxs-lookup"><span data-stu-id="2e955-195">The default template of a <xref:System.Windows.Controls.Primitives.Thumb> creates a basic structure / visual tree with several nested <xref:System.Windows.Controls.Border> components to create a bevel look.</span></span> <span data-ttu-id="2e955-196">如果要公开作为模板的一部分的属性以便由 <xref:System.Windows.Controls.Primitives.Thumb> 类进行自定义，则该属性必须由模板中的[TemplateBinding](templatebinding-markup-extension.md)公开。</span><span class="sxs-lookup"><span data-stu-id="2e955-196">If a property that is part of the template is intended to be exposed for customization by the <xref:System.Windows.Controls.Primitives.Thumb> class, then that property must be exposed by a [TemplateBinding](templatebinding-markup-extension.md), within the template.</span></span> <span data-ttu-id="2e955-197">在 <xref:System.Windows.Controls.Primitives.Thumb>的情况下，这些边框的各种属性共享模板绑定到属性（如 <xref:System.Windows.Controls.Border.Background%2A> 或 <xref:System.Windows.Controls.Border.BorderThickness%2A>）。</span><span class="sxs-lookup"><span data-stu-id="2e955-197">In the case of <xref:System.Windows.Controls.Primitives.Thumb>, various properties of these borders share a template binding to properties such as <xref:System.Windows.Controls.Border.Background%2A> or <xref:System.Windows.Controls.Border.BorderThickness%2A>.</span></span> <span data-ttu-id="2e955-198">但是其他某些属性或可视化排列被硬编码到控件模板中，或者绑定到直接来自主题的值，除了替换整个模板外，不能对其进行更改。</span><span class="sxs-lookup"><span data-stu-id="2e955-198">But certain other properties or visual arrangements are hard-coded into the control template or are bound to values that come directly from the theme, and cannot be changed short of replacing the entire template.</span></span> <span data-ttu-id="2e955-199">一般而言，如果属性来自模板化的父元素，并且不是通过模板绑定公开的，则不能通过样式进行调整，因为没有简单的方法可以将其设置为目标。</span><span class="sxs-lookup"><span data-stu-id="2e955-199">Generally, if a property comes from a templated parent and is not exposed by a template binding, it cannot be adjusted by styles because there is no easy way to target it.</span></span> <span data-ttu-id="2e955-200">但是，该属性仍然可能受所应用的模板中的属性值继承的影响，或受默认值的影响。</span><span class="sxs-lookup"><span data-stu-id="2e955-200">But that property could still be influenced by property value inheritance in the applied template, or by default value.</span></span>  
  
 <span data-ttu-id="2e955-201">主题样式将类型用作其定义中的键。</span><span class="sxs-lookup"><span data-stu-id="2e955-201">The theme styles use a type as the key in their definitions.</span></span> <span data-ttu-id="2e955-202">但是，当主题应用于给定的元素实例时，将通过检查控件的 <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> 属性来执行主题查找此类型。</span><span class="sxs-lookup"><span data-stu-id="2e955-202">However, when themes are applied to a given element instance, themes lookup for this type is performed by checking the <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> property on a control.</span></span> <span data-ttu-id="2e955-203">这与使用文本类型的隐式样式正好相反。</span><span class="sxs-lookup"><span data-stu-id="2e955-203">This is in contrast to using the literal Type, as implicit styles do.</span></span> <span data-ttu-id="2e955-204">即使执行器没有更改派生类，<xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> 的值也将继承到派生类（更改属性的预期方式不会在属性级别重写它，而是改为在属性元数据中更改其默认值）。</span><span class="sxs-lookup"><span data-stu-id="2e955-204">The value of <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> would inherit to derived classes even if the implementer did not change it (the intended way of changing the property is not to override it at the property level, but to instead change its default value in property metadata).</span></span> <span data-ttu-id="2e955-205">这种间接方式使基类可以为没有样式（或者该样式中没有模板，因此根本没有默认的可视化外观，这一点更为重要）的派生元素定义主题样式。</span><span class="sxs-lookup"><span data-stu-id="2e955-205">This indirection enables base classes to define the theme styles for derived elements that do not otherwise have a style (or more importantly, do not have a template within that style and would thus have no default visual appearance at all).</span></span> <span data-ttu-id="2e955-206">因此，您可以从 <xref:System.Windows.Controls.Button> 派生 `MyButton` 并且仍将获取 <xref:System.Windows.Controls.Button> 默认模板。</span><span class="sxs-lookup"><span data-stu-id="2e955-206">Thus, you can derive `MyButton` from <xref:System.Windows.Controls.Button> and will still get the <xref:System.Windows.Controls.Button> default template.</span></span> <span data-ttu-id="2e955-207">如果你是 `MyButton` 的控件作者并且需要不同的行为，则可以重写 `MyButton` 上的 <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> 的依赖项属性元数据以返回不同的键，然后定义相关主题样式，包括你必须与 `MyButton` 控件打包的 `MyButton` 模板。</span><span class="sxs-lookup"><span data-stu-id="2e955-207">If you were the control author of `MyButton` and you wanted a different behavior, you could override the dependency property metadata for <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> on `MyButton` to return a different key, and then define the relevant theme styles including template for `MyButton` that you must package with your `MyButton` control.</span></span> <span data-ttu-id="2e955-208">有关主题、样式和控件创作的更多详细信息，请参阅[控件创作概述](../controls/control-authoring-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="2e955-208">For more details on themes, styles, and control authoring, see [Control Authoring Overview](../controls/control-authoring-overview.md).</span></span>  
  
<a name="resources"></a>   
## <a name="dynamic-resource-references-and-binding"></a><span data-ttu-id="2e955-209">动态资源引用和绑定</span><span class="sxs-lookup"><span data-stu-id="2e955-209">Dynamic Resource References and Binding</span></span>  
 <span data-ttu-id="2e955-210">动态资源引用和绑定操作遵守其设置位置的优先级。</span><span class="sxs-lookup"><span data-stu-id="2e955-210">Dynamic resource references and binding operations respect the precedence of the location at which they are set.</span></span> <span data-ttu-id="2e955-211">例如，应用于本地值的动态资源作为优先级项 3 进行应用，主题样式中的属性资源库的绑定作为优先级项 9 进行应用，依此类推。</span><span class="sxs-lookup"><span data-stu-id="2e955-211">For example, a dynamic resource applied to a local value acts per precedence item 3, a binding for a property setter within a theme style applies at precedence item 9, and so on.</span></span> <span data-ttu-id="2e955-212">由于动态资源引用和绑定必须都能够从应用程序的运行时状态中获得值，这使确定任何给定属性的属性值优先级的实际处理也将扩展到运行时。</span><span class="sxs-lookup"><span data-stu-id="2e955-212">Because dynamic resource references and binding must both be able to obtain values from the run time state of the application, this entails that the actual process of determining the property value precedence for any given property extends into the run time as well.</span></span>  
  
 <span data-ttu-id="2e955-213">严格来讲，动态资源引用并不是属性系统的一部分，但它们的确具有自己的查找顺序，该顺序与上面列出的序列交互。</span><span class="sxs-lookup"><span data-stu-id="2e955-213">Dynamic resource references are not strictly speaking part of the property system, but they do have a lookup order of their own which interacts with the sequence listed above.</span></span> <span data-ttu-id="2e955-214">[XAML 资源](../../../desktop-wpf/fundamentals/xaml-resources-define.md)中对该优先级进行了更全面的介绍。</span><span class="sxs-lookup"><span data-stu-id="2e955-214">That precedence is documented more thoroughly in the [XAML Resources](../../../desktop-wpf/fundamentals/xaml-resources-define.md).</span></span> <span data-ttu-id="2e955-215">该优先级的基本概括是：元素到页面根元素、应用程序、主题、系统。</span><span class="sxs-lookup"><span data-stu-id="2e955-215">The basic summation of that precedence is: element to page root, application, theme, system.</span></span>  
  
 <span data-ttu-id="2e955-216">动态资源和绑定具有其设置位置的优先级，但是值会延迟。</span><span class="sxs-lookup"><span data-stu-id="2e955-216">Dynamic resources and bindings have the precedence of where they were set, but the value is deferred.</span></span> <span data-ttu-id="2e955-217">这样的一个后果是，如果将动态资源或绑定设置为某个本地值，则对该本地值的任何更改都会完全替换该动态资源或绑定。</span><span class="sxs-lookup"><span data-stu-id="2e955-217">One consequence of this is that if you set a dynamic resource or binding to a local value, any change to the local value replaces the dynamic resource or binding entirely.</span></span> <span data-ttu-id="2e955-218">即使调用 <xref:System.Windows.DependencyObject.ClearValue%2A> 方法来清除本地设置的值，也不会还原动态资源或绑定。</span><span class="sxs-lookup"><span data-stu-id="2e955-218">Even if you call the <xref:System.Windows.DependencyObject.ClearValue%2A> method to clear the locally set value, the dynamic resource or binding will not be restored.</span></span> <span data-ttu-id="2e955-219">事实上，如果对具有动态资源或绑定的属性（没有原义本地值）调用 <xref:System.Windows.DependencyObject.ClearValue%2A>，则 <xref:System.Windows.DependencyObject.ClearValue%2A> 调用也会将其清除。</span><span class="sxs-lookup"><span data-stu-id="2e955-219">In fact, if you call <xref:System.Windows.DependencyObject.ClearValue%2A> on a property that has a dynamic resource or binding in place (with no literal local value), they are cleared by the <xref:System.Windows.DependencyObject.ClearValue%2A> call too.</span></span>  
  
<a name="setcurrentvalue"></a>   
## <a name="setcurrentvalue"></a><span data-ttu-id="2e955-220">SetCurrentValue</span><span class="sxs-lookup"><span data-stu-id="2e955-220">SetCurrentValue</span></span>  
 <span data-ttu-id="2e955-221"><xref:System.Windows.DependencyObject.SetCurrentValue%2A> 方法是设置属性的另一种方法，但它不是优先级顺序。</span><span class="sxs-lookup"><span data-stu-id="2e955-221">The <xref:System.Windows.DependencyObject.SetCurrentValue%2A> method is another way to set a property, but it is not in the order of precedence.</span></span> <span data-ttu-id="2e955-222"><xref:System.Windows.DependencyObject.SetCurrentValue%2A> 使你可以更改属性的值，而无需覆盖先前值的源。</span><span class="sxs-lookup"><span data-stu-id="2e955-222">Instead, <xref:System.Windows.DependencyObject.SetCurrentValue%2A> enables you to change the value of a property without overwriting the source of a previous value.</span></span> <span data-ttu-id="2e955-223">你可以在任何时候想要设置值时使用 <xref:System.Windows.DependencyObject.SetCurrentValue%2A>，而不是将该值赋予本地值的优先级。</span><span class="sxs-lookup"><span data-stu-id="2e955-223">You can use <xref:System.Windows.DependencyObject.SetCurrentValue%2A> any time that you want to set a value without giving that value the precedence of a local value.</span></span> <span data-ttu-id="2e955-224">例如，如果某个属性是由触发器设置的，然后通过 <xref:System.Windows.DependencyObject.SetCurrentValue%2A>向其分配另一个值，则该属性系统仍会考虑该触发器，如果发生触发器的操作，该属性将更改。</span><span class="sxs-lookup"><span data-stu-id="2e955-224">For example, if a property is set by a trigger and then assigned another value via <xref:System.Windows.DependencyObject.SetCurrentValue%2A>, the property system still respects the trigger and the property will change if the trigger’s action occurs.</span></span> <span data-ttu-id="2e955-225"><xref:System.Windows.DependencyObject.SetCurrentValue%2A> 使你可以更改属性的值，而无需为其提供较高优先级的源。</span><span class="sxs-lookup"><span data-stu-id="2e955-225"><xref:System.Windows.DependencyObject.SetCurrentValue%2A> enables you to change the property’s value without giving it a source with a higher precedence.</span></span> <span data-ttu-id="2e955-226">同样，可以使用 <xref:System.Windows.DependencyObject.SetCurrentValue%2A> 更改属性的值，而无需覆盖绑定。</span><span class="sxs-lookup"><span data-stu-id="2e955-226">Likewise, you can use <xref:System.Windows.DependencyObject.SetCurrentValue%2A> to change the value of a property without overwriting a binding.</span></span>  
  
<a name="animations"></a>   
## <a name="coercion-animations-and-base-value"></a><span data-ttu-id="2e955-227">强制、动画和基值</span><span class="sxs-lookup"><span data-stu-id="2e955-227">Coercion, Animations, and Base Value</span></span>  
 <span data-ttu-id="2e955-228">强制和动画都作用于在整个 SDK 中称为 "基值" 的值。</span><span class="sxs-lookup"><span data-stu-id="2e955-228">Coercion and animation both act on a value that is termed as the "base value" throughout this SDK.</span></span> <span data-ttu-id="2e955-229">因此，基值是在各项中通过向上计算一直到第 2 项为止而确定的任何值。</span><span class="sxs-lookup"><span data-stu-id="2e955-229">The base value is thus whatever value is determined through evaluating upwards in the items until item 2 is reached.</span></span>  
  
 <span data-ttu-id="2e955-230">对于动画，如果没有为某些行为指定“From”和“To”值，或者动画在完成时故意还原为基值，那么基值将影响动画值。</span><span class="sxs-lookup"><span data-stu-id="2e955-230">For an animation, the base value can have an effect on the animated value, if that animation does not specify both "From" and "To" for certain behaviors, or if the animation deliberately reverts to the base value when completed.</span></span> <span data-ttu-id="2e955-231">若要了解实际效果，请运行 [From, To, and By Animation Target Values Sample](https://github.com/Microsoft/WPF-Samples/tree/master/Animation/TargetValues)（From、To 和 By 动画目标值示例）。</span><span class="sxs-lookup"><span data-stu-id="2e955-231">To see this in practice, run the [From, To, and By Animation Target Values Sample](https://github.com/Microsoft/WPF-Samples/tree/master/Animation/TargetValues).</span></span> <span data-ttu-id="2e955-232">尝试为示例中的矩形高度设置本地值，使初始本地值不同于动画中的任何“From”值。</span><span class="sxs-lookup"><span data-stu-id="2e955-232">Try setting the local values of the rectangle height in the example, such that the initial local value differs from any "From" in the animation.</span></span> <span data-ttu-id="2e955-233">你会注意到动画立即使用“From”值开始，并在开始后替换基值。</span><span class="sxs-lookup"><span data-stu-id="2e955-233">You will note that the animations start right away using the "From" values and replace the base value once started.</span></span> <span data-ttu-id="2e955-234">动画完成后，可能会指定返回到在动画完成之前找到的值，方法是指定停止 <xref:System.Windows.Media.Animation.FillBehavior>。</span><span class="sxs-lookup"><span data-stu-id="2e955-234">The animation might specify to return to the value found before animation once it is completed by specifying the Stop <xref:System.Windows.Media.Animation.FillBehavior>.</span></span> <span data-ttu-id="2e955-235">然后，根据正常优先级来确定基值。</span><span class="sxs-lookup"><span data-stu-id="2e955-235">Afterwards, normal precedence is used for the base value determination.</span></span>  
  
 <span data-ttu-id="2e955-236">多个动画可能应用于一个属性，而每个动画可能是从值优先级中的不同点进行定义的。</span><span class="sxs-lookup"><span data-stu-id="2e955-236">Multiple animations might be applied to a single property, with each of these animations possibly having been defined from different points in the value precedence.</span></span> <span data-ttu-id="2e955-237">但是，这些动画的值可能会组合起来，而不仅仅是从较高的优先级开始应用动画。</span><span class="sxs-lookup"><span data-stu-id="2e955-237">However, these animations will potentially composite their values, rather than just applying the animation from the higher precedence.</span></span> <span data-ttu-id="2e955-238">这完全取决于动画的定义方式以及进行动画处理的值类型。</span><span class="sxs-lookup"><span data-stu-id="2e955-238">This depends on exactly how the animations are defined, and the type of the value that is being animated.</span></span> <span data-ttu-id="2e955-239">有关对属性进行动画处理的详细信息，请参阅[动画概述](../graphics-multimedia/animation-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="2e955-239">For more information about animating properties, see [Animation Overview](../graphics-multimedia/animation-overview.md).</span></span>  
  
 <span data-ttu-id="2e955-240">强制在最高级别应用。</span><span class="sxs-lookup"><span data-stu-id="2e955-240">Coercion applies at the highest level of all.</span></span> <span data-ttu-id="2e955-241">即使正在运行的动画也会受到值强制的制约。</span><span class="sxs-lookup"><span data-stu-id="2e955-241">Even an already running animation is subject to value coercion.</span></span> <span data-ttu-id="2e955-242">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中的某些现有的依赖属性具有内置的强制行为。</span><span class="sxs-lookup"><span data-stu-id="2e955-242">Certain existing dependency properties in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] have built-in coercion.</span></span> <span data-ttu-id="2e955-243">对于自定义依赖属性，可通过编写 <xref:System.Windows.CoerceValueCallback> 并在创建属性时将回调作为元数据的一部分传递来定义自定义依赖项属性的强制行为。</span><span class="sxs-lookup"><span data-stu-id="2e955-243">For a custom dependency property, you define the coercion behavior for a custom dependency property by writing a <xref:System.Windows.CoerceValueCallback> and passing the callback as part of metadata when you create the property.</span></span> <span data-ttu-id="2e955-244">还可以通过在派生类中重写现有属性的元数据来重写其强制行为。</span><span class="sxs-lookup"><span data-stu-id="2e955-244">You can also override coercion behavior of existing properties by overriding the metadata on that property in a derived class.</span></span> <span data-ttu-id="2e955-245">强制与基值的交互使强制约束就像当时存在这些约束一样进行应用，但基值仍将保留。</span><span class="sxs-lookup"><span data-stu-id="2e955-245">Coercion interacts with the base value in such a way that the constraints on coercion are applied as those constraints exist at the time, but the base value is still retained.</span></span> <span data-ttu-id="2e955-246">因此，如果强制约束后来被解除，强制将返回与基值最接近的值，并且一旦所有约束都解除，强制对属性的影响可能会立即停止。</span><span class="sxs-lookup"><span data-stu-id="2e955-246">Therefore, if constraints in coercion are later lifted, the coercion will return the closest value possible to that base value, and potentially the coercion influence on a property will cease as soon as all constraints are lifted.</span></span> <span data-ttu-id="2e955-247">有关强制行为的详细信息，请参阅[依赖属性回调和验证](dependency-property-callbacks-and-validation.md)。</span><span class="sxs-lookup"><span data-stu-id="2e955-247">For more information about coercion behavior, see [Dependency Property Callbacks and Validation](dependency-property-callbacks-and-validation.md).</span></span>  
  
<a name="triggers"></a>   
## <a name="trigger-behaviors"></a><span data-ttu-id="2e955-248">触发器行为</span><span class="sxs-lookup"><span data-stu-id="2e955-248">Trigger Behaviors</span></span>  
 <span data-ttu-id="2e955-249">控件常常在主题中将触发器行为定义为其默认样式的一部分。</span><span class="sxs-lookup"><span data-stu-id="2e955-249">Controls often define trigger behaviors as part of their default style in themes.</span></span> <span data-ttu-id="2e955-250">为控件设置本地属性可能会阻止触发器从视觉或行为上响应用户驱动的事件。</span><span class="sxs-lookup"><span data-stu-id="2e955-250">Setting local properties on controls might prevent the triggers from being able to respond to user-driven events either visually or behaviorally.</span></span> <span data-ttu-id="2e955-251">属性触发器最常见的用法是用于控件或状态属性，如 <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A>。</span><span class="sxs-lookup"><span data-stu-id="2e955-251">The most common use of a property trigger is for control or state properties such as <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A>.</span></span> <span data-ttu-id="2e955-252">例如，默认情况下，当禁用 <xref:System.Windows.Controls.Button> （<xref:System.Windows.UIElement.IsEnabled%2A> 的触发器 `false`）时，主题样式中的 <xref:System.Windows.Controls.Control.Foreground%2A> 值将导致控件显示为 "灰显"。</span><span class="sxs-lookup"><span data-stu-id="2e955-252">For example, by default when a <xref:System.Windows.Controls.Button> is disabled (trigger for <xref:System.Windows.UIElement.IsEnabled%2A> is `false`) then the <xref:System.Windows.Controls.Control.Foreground%2A> value in the theme style is what causes the control to appear "grayed out".</span></span> <span data-ttu-id="2e955-253">但是，如果您设置了本地 <xref:System.Windows.Controls.Control.Foreground%2A> 值，则即使在此属性触发的情况下，也会在本地属性集的优先级内使正常灰显的颜色无效。</span><span class="sxs-lookup"><span data-stu-id="2e955-253">But if you have set a local <xref:System.Windows.Controls.Control.Foreground%2A> value, that normal gray-out color will be overruled in precedence by your local property set, even in this property-triggered scenario.</span></span> <span data-ttu-id="2e955-254">为具有主题级触发器行为的属性设置值时要倍加小心，并确保不要过度妨碍该控件应有的用户体验。</span><span class="sxs-lookup"><span data-stu-id="2e955-254">Be cautious of setting values for properties that have theme-level trigger behaviors and make sure you are not unduly interfering with the intended user experience for that control.</span></span>  
  
<a name="clearvalue"></a>   
## <a name="clearvalue-and-value-precedence"></a><span data-ttu-id="2e955-255">ClearValue 和值优先级</span><span class="sxs-lookup"><span data-stu-id="2e955-255">ClearValue and Value Precedence</span></span>  
 <span data-ttu-id="2e955-256"><xref:System.Windows.DependencyObject.ClearValue%2A> 方法提供了一个有利方法，用于从在元素上设置的依赖项属性清除任何本地应用的值。</span><span class="sxs-lookup"><span data-stu-id="2e955-256">The <xref:System.Windows.DependencyObject.ClearValue%2A> method provides an expedient means to clear any locally applied value from a dependency property that is set on an element.</span></span> <span data-ttu-id="2e955-257">但是，调用 <xref:System.Windows.DependencyObject.ClearValue%2A> 不能保证在属性注册期间在元数据中建立的默认值为新的有效值。</span><span class="sxs-lookup"><span data-stu-id="2e955-257">However, calling <xref:System.Windows.DependencyObject.ClearValue%2A> is not a guarantee that the default as established in metadata during property registration is the new effective value.</span></span> <span data-ttu-id="2e955-258">值优先级中的所有其他参与者仍然有效。</span><span class="sxs-lookup"><span data-stu-id="2e955-258">All of the other participants in value precedence are still active.</span></span> <span data-ttu-id="2e955-259">只有在本地设置的值才会从优先级序列中删除。</span><span class="sxs-lookup"><span data-stu-id="2e955-259">Only the locally set value has been removed from the precedence sequence.</span></span> <span data-ttu-id="2e955-260">例如，如果对某个属性调用 <xref:System.Windows.DependencyObject.ClearValue%2A>，而该属性也是通过主题样式设置的，则会将主题值应用为新值，而不是基于元数据的默认值。</span><span class="sxs-lookup"><span data-stu-id="2e955-260">For example, if you call <xref:System.Windows.DependencyObject.ClearValue%2A> on a property where that property is also set by a theme style, then the theme value is applied as the new value rather than the metadata-based default.</span></span> <span data-ttu-id="2e955-261">如果要将所有属性值参与者移出进程，并将值设置为已注册的元数据默认值，可以通过查询依赖属性元数据来明确地获取该默认值，然后可以使用默认值在本地设置属性，同时调用 <xref:System.Windows.DependencyObject.SetValue%2A>。</span><span class="sxs-lookup"><span data-stu-id="2e955-261">If you want to take all property value participants out of the process and set the value to the registered metadata default, you can obtain that default value definitively by querying the dependency property metadata, and then you can use the default value to locally set the property with a call to <xref:System.Windows.DependencyObject.SetValue%2A>.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="2e955-262">另请参阅</span><span class="sxs-lookup"><span data-stu-id="2e955-262">See also</span></span>

- <xref:System.Windows.DependencyObject>
- <xref:System.Windows.DependencyProperty>
- [<span data-ttu-id="2e955-263">依赖项属性概述</span><span class="sxs-lookup"><span data-stu-id="2e955-263">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="2e955-264">自定义依赖属性</span><span class="sxs-lookup"><span data-stu-id="2e955-264">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="2e955-265">依赖属性回调和验证</span><span class="sxs-lookup"><span data-stu-id="2e955-265">Dependency Property Callbacks and Validation</span></span>](dependency-property-callbacks-and-validation.md)
