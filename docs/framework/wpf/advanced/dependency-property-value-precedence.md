---
title: 依赖项属性值优先级
ms.date: 03/30/2017
helpviewer_keywords:
- dependency properties [WPF], classes as owners
- dependency properties [WPF], metadata
- classes [WPF], owners of dependency properties
- metadata [WPF], dependency properties
ms.assetid: 1fbada8e-4867-4ed1-8d97-62c07dad7ebc
ms.openlocfilehash: 25dfe63a65c3044837beb26ec6c4eaa772c1df1b
ms.sourcegitcommit: ad99773e5e45068ce03b99518008397e1299e0d1
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/22/2018
ms.locfileid: "46696779"
---
# <a name="dependency-property-value-precedence"></a><span data-ttu-id="f0bc6-102">依赖项属性值优先级</span><span class="sxs-lookup"><span data-stu-id="f0bc6-102">Dependency Property Value Precedence</span></span>
<a name="introduction"></a> <span data-ttu-id="f0bc6-103">本主题说明 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 属性系统的工作机制如何影响依赖属性的值，并介绍应用于属性有效值的属性系统的各方面所依据的优先级。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-103">This topic explains how the workings of the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] property system can affect the value of a dependency property, and describes the precedence by which aspects of the property system apply to the effective value of a property.</span></span>  
    
  
<a name="prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="f0bc6-104">系统必备</span><span class="sxs-lookup"><span data-stu-id="f0bc6-104">Prerequisites</span></span>  
 <span data-ttu-id="f0bc6-105">本主题假定你从 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 类的现有依赖属性的使用者角度了解依赖属性，并且已阅读[依赖属性概述](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-105">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes, and have read [Dependency Properties Overview](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md).</span></span> <span data-ttu-id="f0bc6-106">若要采用本主题中的示例，还应当了解[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] 并知道如何编写 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 应用程序。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-106">To follow the examples in this topic, you should also understand [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] and know how to write [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications.</span></span>  
  
<a name="intro"></a>   
## <a name="the-wpf-property-system"></a><span data-ttu-id="f0bc6-107">WPF 属性系统</span><span class="sxs-lookup"><span data-stu-id="f0bc6-107">The WPF Property System</span></span>  
 <span data-ttu-id="f0bc6-108">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 属性系统提供一种强大的方法，使得依赖属性的值由多种因素决定，从而实现诸如实时属性验证、后期绑定以及向相关属性发出有关其他属性值发生更改的通知等功能。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-108">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system offers a powerful way to have the value of dependency properties be determined by a variety of factors, enabling features such as real-time property validation, late binding, and notifying related properties of changes to values for other properties.</span></span> <span data-ttu-id="f0bc6-109">用来确定依赖属性值的确切顺序和逻辑相当复杂。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-109">The exact order and logic that is used to determine dependency property values is reasonably complex.</span></span> <span data-ttu-id="f0bc6-110">了解此顺序有助于避免不必要的属性设置，并且还有可能澄清混淆，使你正确了解为何某些影响或预测依赖属性值的尝试最终却没有得出所期望的值。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-110">Knowing this order will help you avoid unnecessary property setting, and might also clear up confusion over exactly why some attempt to influence or anticipate a dependency property value did not end up resulting in the value you expected.</span></span>  
  
<a name="multiple_sets"></a>   
## <a name="dependency-properties-might-be-set-in-multiple-places"></a><span data-ttu-id="f0bc6-111">依赖属性可以在多个位置“设置”</span><span class="sxs-lookup"><span data-stu-id="f0bc6-111">Dependency Properties Might Be "Set" in Multiple Places</span></span>  
 <span data-ttu-id="f0bc6-112">下面是示例[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]其中相同的属性 (<xref:System.Windows.Controls.Control.Background%2A>) 具有三个不同"set"可能会影响值的操作。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-112">The following is example [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] where the same property (<xref:System.Windows.Controls.Control.Background%2A>) has three different "set" operations that might influence the value.</span></span>  
  
 [!code-xaml[PropertiesOvwSupport#DPPrecedence](../../../../samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#dpprecedence)]  
  
 <span data-ttu-id="f0bc6-113">这里，你希望应用什么颜色：红色、绿色还是蓝色？</span><span class="sxs-lookup"><span data-stu-id="f0bc6-113">Here, which color do you expect will apply—red, green, or blue?</span></span>  
  
 <span data-ttu-id="f0bc6-114">本地属性集在设置时具有最高优先级，动画值和强制除外。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-114">With the exception of animated values and coercion, local property sets are set at the highest precedence.</span></span> <span data-ttu-id="f0bc6-115">如果在本地设置某个值，你可以期待该值优先得到应用，甚至期待其优先级高于任何样式或控件模板。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-115">If you set a value locally you can expect that the value will be honored, even above any styles or control templates.</span></span> <span data-ttu-id="f0bc6-116">在本示例中<xref:System.Windows.Controls.Control.Background%2A>本地设置为红色。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-116">Here in the example, <xref:System.Windows.Controls.Control.Background%2A> is set to Red locally.</span></span> <span data-ttu-id="f0bc6-117">因此，即使它可能会应用于该作用域中该类型的所有元素的隐式样式定义在此范围内的样式不是为提供的最高优先级<xref:System.Windows.Controls.Control.Background%2A>属性及其值。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-117">Therefore, the style defined in this scope, even though it is an implicit style that would otherwise apply to all elements of that type in that scope, is not the highest precedence for giving the <xref:System.Windows.Controls.Control.Background%2A> property its value.</span></span>  <span data-ttu-id="f0bc6-118">如果从该 Button 实例中删除本地值“Red”，样式将获得优先级，而按钮将从该样式中获得 Background 值。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-118">If you removed the local value of Red from that Button instance, then the style would have precedence and the button would obtain the Background value from the style.</span></span>  <span data-ttu-id="f0bc6-119">在该样式中，触发器具有优先级，因此当鼠标位于按钮上时，按钮为蓝色，其他情况下则为绿色。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-119">Within the style, triggers take precedence, so the button will be blue if the mouse is over it, and green otherwise.</span></span>  
  
<a name="listing"></a>   
## <a name="dependency-property-setting-precedence-list"></a><span data-ttu-id="f0bc6-120">依赖属性设置优先级列表</span><span class="sxs-lookup"><span data-stu-id="f0bc6-120">Dependency Property Setting Precedence List</span></span>  
 <span data-ttu-id="f0bc6-121">下面是属性系统在分配依赖属性的运行时值时所使用的最终顺序。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-121">The following is the definitive order that the property system uses when assigning the run-time values of dependency properties.</span></span> <span data-ttu-id="f0bc6-122">最高优先级最先列出。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-122">Highest precedence is listed first.</span></span> <span data-ttu-id="f0bc6-123">此列表对[依赖属性概述](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)中的某些一般化内容进行了扩充。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-123">This list expands on some of the generalizations made in the [Dependency Properties Overview](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md).</span></span>  
  
1.  <span data-ttu-id="f0bc6-124">**属性系统强制。**</span><span class="sxs-lookup"><span data-stu-id="f0bc6-124">**Property system coercion.**</span></span> <span data-ttu-id="f0bc6-125">有关强制的详细信息，请参阅本主题后面的[强制、动画和基值](#animations)。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-125">For details on coercion, see [Coercion, Animation, and Base Value](#animations) later in this topic.</span></span>  
  
2.  <span data-ttu-id="f0bc6-126">**活动动画或具有 Hold 行为的动画。**</span><span class="sxs-lookup"><span data-stu-id="f0bc6-126">**Active animations, or animations with a Hold behavior.**</span></span> <span data-ttu-id="f0bc6-127">为了获得任何实用效果，属性的动画必须优先于基（未动画）值，即使该值是在本地设置的也是如此。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-127">In order to have any practical effect, an animation of a property must be able to have precedence over the base (unanimated) value, even if that value was set locally.</span></span> <span data-ttu-id="f0bc6-128">有关详细信息，请参阅本主题后面的[强制、动画和基值](#animations)。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-128">For details, see [Coercion, Animation, and Base Value](#animations) later in this topic.</span></span>  
  
3.  <span data-ttu-id="f0bc6-129">**本地值。**</span><span class="sxs-lookup"><span data-stu-id="f0bc6-129">**Local value.**</span></span> <span data-ttu-id="f0bc6-130">可能会通过"包装器"属性，这也相当于为属性或属性元素中设置的方便地设置本地值[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]，或通过调用<xref:System.Windows.DependencyObject.SetValue%2A>[!INCLUDE[TLA#tla_api](../../../../includes/tlasharptla-api-md.md)]使用特定实例的属性。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-130">A local value might be set through the convenience of the "wrapper" property, which also equates to setting as an attribute or property element in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], or by a call to the <xref:System.Windows.DependencyObject.SetValue%2A> [!INCLUDE[TLA#tla_api](../../../../includes/tlasharptla-api-md.md)] using a property of a specific instance.</span></span> <span data-ttu-id="f0bc6-131">如果使用绑定或资源来设置本地值，则每个值都按照直接设置值的优先级顺序来应用。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-131">If you set a local value by using a binding or a resource, these each act in the precedence as if a direct value was set.</span></span>  
  
4.  <span data-ttu-id="f0bc6-132">**TemplatedParent 模板属性。**</span><span class="sxs-lookup"><span data-stu-id="f0bc6-132">**TemplatedParent template properties.**</span></span> <span data-ttu-id="f0bc6-133">元素具有<xref:System.Windows.FrameworkElement.TemplatedParent%2A>如果将其创建为模板的一部分 (<xref:System.Windows.Controls.ControlTemplate>或<xref:System.Windows.DataTemplate>)。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-133">An element has a <xref:System.Windows.FrameworkElement.TemplatedParent%2A> if it was created as part of a template (a <xref:System.Windows.Controls.ControlTemplate> or <xref:System.Windows.DataTemplate>).</span></span> <span data-ttu-id="f0bc6-134">有关何时应用此原则的详细信息，请参阅本主题后面的 [TemplatedParent](#templatedparent)。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-134">For details on when this applies, see [TemplatedParent](#templatedparent) later in this topic.</span></span> <span data-ttu-id="f0bc6-135">在模板中，按以下优先级顺序应用：</span><span class="sxs-lookup"><span data-stu-id="f0bc6-135">Within the template, the following precedence applies:</span></span>  
  
    1.  <span data-ttu-id="f0bc6-136">从触发<xref:System.Windows.FrameworkElement.TemplatedParent%2A>模板。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-136">Triggers from the <xref:System.Windows.FrameworkElement.TemplatedParent%2A> template.</span></span>  
  
    2.  <span data-ttu-id="f0bc6-137">属性集 (通常通过[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]属性) 中<xref:System.Windows.FrameworkElement.TemplatedParent%2A>模板。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-137">Property sets (typically through [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] attributes) in the <xref:System.Windows.FrameworkElement.TemplatedParent%2A> template.</span></span>  
  
5.  <span data-ttu-id="f0bc6-138">**隐式样式。**</span><span class="sxs-lookup"><span data-stu-id="f0bc6-138">**Implicit style.**</span></span> <span data-ttu-id="f0bc6-139">仅应用于 `Style` 属性。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-139">Applies only to the `Style` property.</span></span> <span data-ttu-id="f0bc6-140">`Style` 属性是由任何样式资源通过与其类型匹配的键来填充的。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-140">The `Style` property is filled by any style resource with a key that matches the type of that element.</span></span> <span data-ttu-id="f0bc6-141">该样式资源必须存在于页面或应用程序中；查找隐式样式资源不会进入到主题中。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-141">That style resource must exist either in the page or the application; lookup for an implicit style resource does not proceed into the themes.</span></span>  
  
6.  <span data-ttu-id="f0bc6-142">**样式触发器。**</span><span class="sxs-lookup"><span data-stu-id="f0bc6-142">**Style triggers.**</span></span> <span data-ttu-id="f0bc6-143">来自页面或应用程序的样式中的触发器（这些样式可以是显式或隐式样式，但不是来自优先级较低的默认样式）。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-143">The triggers within styles from page or application (these styles might be either explicit or implicit styles, but not from the default styles, which have lower precedence).</span></span>  
  
7.  <span data-ttu-id="f0bc6-144">**模板触发器。**</span><span class="sxs-lookup"><span data-stu-id="f0bc6-144">**Template triggers.**</span></span> <span data-ttu-id="f0bc6-145">来自样式中的模板或者直接应用的模板的任何触发器。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-145">Any trigger from a template within a style, or a directly applied template.</span></span>  
  
8.  <span data-ttu-id="f0bc6-146">**样式资源库。**</span><span class="sxs-lookup"><span data-stu-id="f0bc6-146">**Style setters.**</span></span> <span data-ttu-id="f0bc6-147">从值<xref:System.Windows.Setter>来自页面或应用程序的样式中。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-147">Values from a <xref:System.Windows.Setter> within styles from page or application.</span></span>  
  
9. <span data-ttu-id="f0bc6-148">**默认（主题）样式。**</span><span class="sxs-lookup"><span data-stu-id="f0bc6-148">**Default (theme) style.**</span></span> <span data-ttu-id="f0bc6-149">有关何时应用此样式以及主题样式如何与主题样式中的模板相关的详细信息，请参阅本主题后面的[默认（主题）样式](#themestyles)。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-149">For details on when this applies, and how theme styles relate to the templates within theme styles, see [Default (Theme) Styles](#themestyles) later in this topic.</span></span> <span data-ttu-id="f0bc6-150">在默认样式中，按以下优先级顺序应用：</span><span class="sxs-lookup"><span data-stu-id="f0bc6-150">Within a default style, the following order of precedence applies:</span></span>  
  
    1.  <span data-ttu-id="f0bc6-151">主题样式中的活动触发器。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-151">Active triggers in the theme style.</span></span>  
  
    2.  <span data-ttu-id="f0bc6-152">主题样式中的资源库。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-152">Setters in the theme style.</span></span>  
  
10. <span data-ttu-id="f0bc6-153">**继承。**</span><span class="sxs-lookup"><span data-stu-id="f0bc6-153">**Inheritance.**</span></span> <span data-ttu-id="f0bc6-154">有几个依赖属性从父元素向子元素继承值，因此不需要在应用程序中的每个元素上专门设置这些属性。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-154">A few dependency properties inherit their values from parent element to child elements, such that they need not be set specifically on each element throughout an application.</span></span> <span data-ttu-id="f0bc6-155">有关详细信息，请参阅[属性值继承](../../../../docs/framework/wpf/advanced/property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-155">For details see [Property Value Inheritance](../../../../docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>  
  
11. <span data-ttu-id="f0bc6-156">**来自依赖属性元数据的默认值。**</span><span class="sxs-lookup"><span data-stu-id="f0bc6-156">**Default value from dependency property metadata.**</span></span> <span data-ttu-id="f0bc6-157">任何给定的依赖属性都可能有一个默认值，它由该特定属性的属性系统注册来确定。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-157">Any given dependency property may have a default value as established by the property system registration of that particular property.</span></span> <span data-ttu-id="f0bc6-158">而且，继承依赖属性的派生类可以选择按照类型重写该元数据（包括默认值）。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-158">Also, derived classes that inherit a dependency property have the option to override that metadata (including the default value) on a per-type basis.</span></span> <span data-ttu-id="f0bc6-159">有关详细信息，请参阅[依赖属性元数据](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md)。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-159">See [Dependency Property Metadata](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md) for more information.</span></span> <span data-ttu-id="f0bc6-160">因为继承是在默认值之前检查的，所以对于继承的属性，父元素的默认值优先于子元素。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-160">Because inheritance is checked before default value, for an inherited property, a parent element default value takes precedence over a child element.</span></span>  <span data-ttu-id="f0bc6-161">因此，如果任何地方都没有设置可继承的属性，将使用在根元素或父元素中指定的默认值，而不是子元素的默认值。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-161">Consequently, if an inheritable property is not set anywhere, the default value as specified on the root or parent is used instead of the child element default value.</span></span>  
  
<a name="templatedparent"></a>   
## <a name="templatedparent"></a><span data-ttu-id="f0bc6-162">TemplatedParent</span><span class="sxs-lookup"><span data-stu-id="f0bc6-162">TemplatedParent</span></span>  
 <span data-ttu-id="f0bc6-163">TemplatedParent 作为一个优先级项并不应用于在标准应用程序标记中直接声明的元素的任何属性。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-163">TemplatedParent as a precedence item does not apply to any property of an element that you declare directly in standard application markup.</span></span> <span data-ttu-id="f0bc6-164">只有对于通过应用模板而产生的可视化树中的子项而言，才存在 TemplatedParent 概念。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-164">The TemplatedParent concept exists only for child items within a visual tree that come into existence through the application of the template.</span></span> <span data-ttu-id="f0bc6-165">当属性系统搜索<xref:System.Windows.FrameworkElement.TemplatedParent%2A>值的模板，就在搜索创建该元素的模板。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-165">When the property system searches the <xref:System.Windows.FrameworkElement.TemplatedParent%2A> template for a value, it is searching the template that created that element.</span></span> <span data-ttu-id="f0bc6-166">属性值从<xref:System.Windows.FrameworkElement.TemplatedParent%2A>模板通常就像它们在子元素上设置本地值一样，但此优先级低于本地值存在，因为模板有可能被共享。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-166">The property values from the <xref:System.Windows.FrameworkElement.TemplatedParent%2A> template generally act as if they were set as a local value on the child element, but this lesser precedence versus the local value exists because the templates are potentially shared.</span></span> <span data-ttu-id="f0bc6-167">有关详细信息，请参阅<xref:System.Windows.FrameworkElement.TemplatedParent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-167">For details, see <xref:System.Windows.FrameworkElement.TemplatedParent%2A>.</span></span>  
  
<a name="style_property"></a>   
## <a name="the-style-property"></a><span data-ttu-id="f0bc6-168">Style 属性</span><span class="sxs-lookup"><span data-stu-id="f0bc6-168">The Style Property</span></span>  
 <span data-ttu-id="f0bc6-169">前面介绍的查找顺序适用于之外的所有可能的依赖关系属性：<xref:System.Windows.FrameworkElement.Style%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-169">The order of lookup described earlier applies to all possible dependency properties except one: the <xref:System.Windows.FrameworkElement.Style%2A> property.</span></span> <span data-ttu-id="f0bc6-170"><xref:System.Windows.FrameworkElement.Style%2A>属性是唯一的因为它不能为自己设置样式，因此优先级项 5 到 8 不适用。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-170">The <xref:System.Windows.FrameworkElement.Style%2A> property is unique in that it cannot itself be styled, so the precedence items 5 through 8 do not apply.</span></span> <span data-ttu-id="f0bc6-171">此外，进行动画处理，或强制<xref:System.Windows.FrameworkElement.Style%2A>建议不要 (和动画处理<xref:System.Windows.FrameworkElement.Style%2A>需要自定义动画类)。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-171">Also, either animating or coercing <xref:System.Windows.FrameworkElement.Style%2A> is not recommended (and animating <xref:System.Windows.FrameworkElement.Style%2A> would require a custom animation class).</span></span> <span data-ttu-id="f0bc6-172">这两种处理均通过三种方式<xref:System.Windows.FrameworkElement.Style%2A>可能设置属性：</span><span class="sxs-lookup"><span data-stu-id="f0bc6-172">This leaves three ways that the <xref:System.Windows.FrameworkElement.Style%2A> property might be set:</span></span>  
  
-   <span data-ttu-id="f0bc6-173">**显式样式。**</span><span class="sxs-lookup"><span data-stu-id="f0bc6-173">**Explicit style.**</span></span> <span data-ttu-id="f0bc6-174"><xref:System.Windows.FrameworkElement.Style%2A>直接设置属性。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-174">The <xref:System.Windows.FrameworkElement.Style%2A> property is set directly.</span></span> <span data-ttu-id="f0bc6-175">在大多数情况下，样式不是内联定义的，而是作为资源由显式键进行引用的。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-175">In most scenarios, the style is not defined inline, but instead is referenced as a resource, by explicit key.</span></span> <span data-ttu-id="f0bc6-176">在这种情况下，Style 属性本身就像本地值（优先级项 3）一样来应用。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-176">In this case the Style property itself acts as if it were a local value, precedence item 3.</span></span>  
  
-   <span data-ttu-id="f0bc6-177">**隐式样式。**</span><span class="sxs-lookup"><span data-stu-id="f0bc6-177">**Implicit style.**</span></span> <span data-ttu-id="f0bc6-178"><xref:System.Windows.FrameworkElement.Style%2A>未直接设置属性。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-178">The <xref:System.Windows.FrameworkElement.Style%2A> property is not set directly.</span></span> <span data-ttu-id="f0bc6-179">但是，<xref:System.Windows.FrameworkElement.Style%2A>资源查找序列 （页面、 应用程序） 中的某级别上存在，并且使用的样式是要应用于的类型匹配的资源键进行键控。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-179">However, the <xref:System.Windows.FrameworkElement.Style%2A> exists at some level in the resource lookup sequence (page, application) and is keyed using a resource key that matches the type the style is to be applied to.</span></span> <span data-ttu-id="f0bc6-180">在这种情况下，<xref:System.Windows.FrameworkElement.Style%2A>属性本身就标识为第 5 项序列中的优先级来。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-180">In this case, the <xref:System.Windows.FrameworkElement.Style%2A> property itself acts by a precedence identified in the sequence as item 5.</span></span> <span data-ttu-id="f0bc6-181">可以通过使用检测到该条件<xref:System.Windows.DependencyPropertyHelper>针对<xref:System.Windows.FrameworkElement.Style%2A>属性，然后查找<xref:System.Windows.BaseValueSource.ImplicitStyleReference>结果中。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-181">This condition can be detected by using <xref:System.Windows.DependencyPropertyHelper> against the <xref:System.Windows.FrameworkElement.Style%2A> property and looking for <xref:System.Windows.BaseValueSource.ImplicitStyleReference> in the results.</span></span>  
  
-   <span data-ttu-id="f0bc6-182">**默认样式**，也称为**主题样式。**</span><span class="sxs-lookup"><span data-stu-id="f0bc6-182">**Default style**, also known as **theme style.**</span></span> <span data-ttu-id="f0bc6-183"><xref:System.Windows.FrameworkElement.Style%2A>属性不直接，设置和实际上将读作`null`直到运行时。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-183">The <xref:System.Windows.FrameworkElement.Style%2A> property is not set directly, and in fact will read as `null` up until run time.</span></span> <span data-ttu-id="f0bc6-184">在这种情况下，样式来自作为 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 表示引擎一部分的运行时主题评估。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-184">In this case, the style comes from the run-time theme evaluation that is part of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] presentation engine.</span></span>  
  
 <span data-ttu-id="f0bc6-185">对于主题中不存在的隐式样式，该类型必须完全-匹配`MyButton``Button`的派生的类不会隐式使用的样式`Button`。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-185">For implicit styles not in themes, the type must match exactly - a `MyButton` `Button`-derived class will not implicitly use a style for `Button`.</span></span>  
  
<a name="themestyles"></a>   
## <a name="default-theme-styles"></a><span data-ttu-id="f0bc6-186">默认（主题）样式</span><span class="sxs-lookup"><span data-stu-id="f0bc6-186">Default (Theme) Styles</span></span>  
 <span data-ttu-id="f0bc6-187">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 附带的每个控件都有一个默认样式。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-187">Every control that ships with [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] has a default style.</span></span> <span data-ttu-id="f0bc6-188">默认样式可能因主题而异，这就是默认样式有时候称为主题样式的原因。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-188">That default style potentially varies by theme, which is why this default style is sometimes referred to as a theme style.</span></span>  
  
 <span data-ttu-id="f0bc6-189">最重要的信息的控件为其控件模板，主题样式中存在的资源作为默认样式中找到其<xref:System.Windows.Controls.Control.Template%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-189">The most important information that is found within a default style for a control is its control template, which exists in the theme style as a setter for its <xref:System.Windows.Controls.Control.Template%2A> property.</span></span> <span data-ttu-id="f0bc6-190">如果默认样式中没有模板，自定义样式中没有自定义模板的控件将根本没有可视化外观。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-190">If there were no template from default styles, a control without a custom template as part of a custom style would have no visual appearance at all.</span></span> <span data-ttu-id="f0bc6-191">默认样式中的模板为每个控件的可视化外观提供一个基本结构，还定义在模板的可视化树中定义的属性与对应的控件类之间的联系。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-191">The template from the default style gives the visual appearance of each control a basic structure, and also defines the connections between properties defined in the visual tree of the template and the corresponding control class.</span></span> <span data-ttu-id="f0bc6-192">每个控件都公开一组属性，这些属性可以影响控件的可视化外观，而无需完全替换模板。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-192">Each control exposes a set of properties that can influence the visual appearance of the control without completely replacing the template.</span></span> <span data-ttu-id="f0bc6-193">例如，考虑的默认可视外观<xref:System.Windows.Controls.Primitives.Thumb>控件，它是一个组件的<xref:System.Windows.Controls.Primitives.ScrollBar>。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-193">For example, consider the default visual appearance of a <xref:System.Windows.Controls.Primitives.Thumb> control, which is a component of a <xref:System.Windows.Controls.Primitives.ScrollBar>.</span></span>  
  
 <span data-ttu-id="f0bc6-194">一个<xref:System.Windows.Controls.Primitives.Thumb>具有某些可自定义属性。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-194">A <xref:System.Windows.Controls.Primitives.Thumb> has certain customizable properties.</span></span> <span data-ttu-id="f0bc6-195">默认模板<xref:System.Windows.Controls.Primitives.Thumb>创建一个基本结构 / 可视化树与多个嵌套<xref:System.Windows.Controls.Border>组件创建凹凸效果的外观。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-195">The default template of a <xref:System.Windows.Controls.Primitives.Thumb> creates a basic structure / visual tree with several nested <xref:System.Windows.Controls.Border> components to create a bevel look.</span></span> <span data-ttu-id="f0bc6-196">如果是模板的一部分属性应为自定义通过公开<xref:System.Windows.Controls.Primitives.Thumb>类，则该属性必须公开[TemplateBinding](../../../../docs/framework/wpf/advanced/templatebinding-markup-extension.md)，模板中。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-196">If a property that is part of the template is intended to be exposed for customization by the <xref:System.Windows.Controls.Primitives.Thumb> class, then that property must be exposed by a [TemplateBinding](../../../../docs/framework/wpf/advanced/templatebinding-markup-extension.md), within the template.</span></span> <span data-ttu-id="f0bc6-197">情况下<xref:System.Windows.Controls.Primitives.Thumb>，这些边界的各种属性共享模板绑定到属性，如<xref:System.Windows.Controls.Border.Background%2A>或<xref:System.Windows.Controls.Border.BorderThickness%2A>。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-197">In the case of <xref:System.Windows.Controls.Primitives.Thumb>, various properties of these borders share a template binding to properties such as <xref:System.Windows.Controls.Border.Background%2A> or <xref:System.Windows.Controls.Border.BorderThickness%2A>.</span></span> <span data-ttu-id="f0bc6-198">但是其他某些属性或可视化排列被硬编码到控件模板中，或者绑定到直接来自主题的值，除了替换整个模板外，不能对其进行更改。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-198">But certain other properties or visual arrangements are hard-coded into the control template or are bound to values that come directly from the theme, and cannot be changed short of replacing the entire template.</span></span> <span data-ttu-id="f0bc6-199">一般而言，如果属性来自模板化的父元素，并且不是通过模板绑定公开的，则不能通过样式进行调整，因为没有简单的方法可以将其设置为目标。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-199">Generally, if a property comes from a templated parent and is not exposed by a template binding, it cannot be adjusted by styles because there is no easy way to target it.</span></span> <span data-ttu-id="f0bc6-200">但是，该属性仍然可能受所应用的模板中的属性值继承的影响，或受默认值的影响。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-200">But that property could still be influenced by property value inheritance in the applied template, or by default value.</span></span>  
  
 <span data-ttu-id="f0bc6-201">主题样式将类型用作其定义中的键。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-201">The theme styles use a type as the key in their definitions.</span></span> <span data-ttu-id="f0bc6-202">但是，当主题应用到给定的元素实例，则此类型的主题查找执行通过检查<xref:System.Windows.FrameworkElement.DefaultStyleKey%2A>控件上的属性。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-202">However, when themes are applied to a given element instance, themes lookup for this type is performed by checking the <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> property on a control.</span></span> <span data-ttu-id="f0bc6-203">这与使用文本类型的隐式样式正好相反。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-203">This is in contrast to using the literal Type, as implicit styles do.</span></span> <span data-ttu-id="f0bc6-204">值<xref:System.Windows.FrameworkElement.DefaultStyleKey%2A>会为派生类继承，即使实施者未更改 （更改属性的方式并不是重写该级别的属性，但到改为其默认值属性元数据中的更改）。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-204">The value of <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> would inherit to derived classes even if the implementer did not change it (the intended way of changing the property is not to override it at the property level, but to instead change its default value in property metadata).</span></span> <span data-ttu-id="f0bc6-205">这种间接方式使基类可以为没有样式（或者该样式中没有模板，因此根本没有默认的可视化外观，这一点更为重要）的派生元素定义主题样式。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-205">This indirection enables base classes to define the theme styles for derived elements that do not otherwise have a style (or more importantly, do not have a template within that style and would thus have no default visual appearance at all).</span></span> <span data-ttu-id="f0bc6-206">因此，可以派生`MyButton`从<xref:System.Windows.Controls.Button>并且仍然能够获得<xref:System.Windows.Controls.Button>默认模板。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-206">Thus, you can derive `MyButton` from <xref:System.Windows.Controls.Button> and will still get the <xref:System.Windows.Controls.Button> default template.</span></span> <span data-ttu-id="f0bc6-207">如果您的控件作者`MyButton`并希望不同的行为，可以重写的依赖项属性元数据<xref:System.Windows.FrameworkElement.DefaultStyleKey%2A>上`MyButton`以返回不同的密钥，然后定义相关主题样式，包括模板有关`MyButton`，则必须使用打包你`MyButton`控件。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-207">If you were the control author of `MyButton` and you wanted a different behavior, you could override the dependency property metadata for <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> on `MyButton` to return a different key, and then define the relevant theme styles including template for `MyButton` that you must package with your `MyButton` control.</span></span> <span data-ttu-id="f0bc6-208">有关主题、样式和控件创作的更多详细信息，请参阅[控件创作概述](../../../../docs/framework/wpf/controls/control-authoring-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-208">For more details on themes, styles, and control authoring, see [Control Authoring Overview](../../../../docs/framework/wpf/controls/control-authoring-overview.md).</span></span>  
  
<a name="resources"></a>   
## <a name="dynamic-resource-references-and-binding"></a><span data-ttu-id="f0bc6-209">动态资源引用和绑定</span><span class="sxs-lookup"><span data-stu-id="f0bc6-209">Dynamic Resource References and Binding</span></span>  
 <span data-ttu-id="f0bc6-210">动态资源引用和绑定操作遵守其设置位置的优先级。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-210">Dynamic resource references and binding operations respect the precedence of the location at which they are set.</span></span> <span data-ttu-id="f0bc6-211">例如，应用于本地值的动态资源作为优先级项 3 进行应用，主题样式中的属性资源库的绑定作为优先级项 9 进行应用，依此类推。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-211">For example, a dynamic resource applied to a local value acts per precedence item 3, a binding for a property setter within a theme style applies at precedence item 9, and so on.</span></span> <span data-ttu-id="f0bc6-212">由于动态资源引用和绑定必须都能够从应用程序的运行时状态中获得值，这使确定任何给定属性的属性值优先级的实际处理也将扩展到运行时。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-212">Because dynamic resource references and binding must both be able to obtain values from the run time state of the application, this entails that the actual process of determining the property value precedence for any given property extends into the run time as well.</span></span>  
  
 <span data-ttu-id="f0bc6-213">严格来讲，动态资源引用并不是属性系统的一部分，但它们的确具有自己的查找顺序，该顺序与上面列出的序列交互。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-213">Dynamic resource references are not strictly speaking part of the property system, but they do have a lookup order of their own which interacts with the sequence listed above.</span></span> <span data-ttu-id="f0bc6-214">[XAML 资源](../../../../docs/framework/wpf/advanced/xaml-resources.md)中对该优先级进行了更全面的介绍。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-214">That precedence is documented more thoroughly in the [XAML Resources](../../../../docs/framework/wpf/advanced/xaml-resources.md).</span></span> <span data-ttu-id="f0bc6-215">该优先级的基本概括是：元素到页面根元素、应用程序、主题、系统。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-215">The basic summation of that precedence is: element to page root, application, theme, system.</span></span>  
  
 <span data-ttu-id="f0bc6-216">动态资源和绑定具有其设置位置的优先级，但是值会延迟。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-216">Dynamic resources and bindings have the precedence of where they were set, but the value is deferred.</span></span> <span data-ttu-id="f0bc6-217">这样的一个后果是，如果将动态资源或绑定设置为某个本地值，则对该本地值的任何更改都会完全替换该动态资源或绑定。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-217">One consequence of this is that if you set a dynamic resource or binding to a local value, any change to the local value replaces the dynamic resource or binding entirely.</span></span> <span data-ttu-id="f0bc6-218">即使你调用<xref:System.Windows.DependencyObject.ClearValue%2A>方法以清除本地设置将不会还原值、 动态资源或绑定。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-218">Even if you call the <xref:System.Windows.DependencyObject.ClearValue%2A> method to clear the locally set value, the dynamic resource or binding will not be restored.</span></span> <span data-ttu-id="f0bc6-219">事实上，如果您调用<xref:System.Windows.DependencyObject.ClearValue%2A>他们清除的操作 （使用任何文本的本地值） 中具有动态资源或绑定的属性，<xref:System.Windows.DependencyObject.ClearValue%2A>调用过。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-219">In fact, if you call <xref:System.Windows.DependencyObject.ClearValue%2A> on a property that has a dynamic resource or binding in place (with no literal local value), they are cleared by the <xref:System.Windows.DependencyObject.ClearValue%2A> call too.</span></span>  
  
<a name="setcurrentvalue"></a>   
## <a name="setcurrentvalue"></a><span data-ttu-id="f0bc6-220">SetCurrentValue</span><span class="sxs-lookup"><span data-stu-id="f0bc6-220">SetCurrentValue</span></span>  
 <span data-ttu-id="f0bc6-221"><xref:System.Windows.DependencyObject.SetCurrentValue%2A>方法是另一种方法来设置属性，但它不具有优先级顺序。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-221">The <xref:System.Windows.DependencyObject.SetCurrentValue%2A> method is another way to set a property, but it is not in the order of precedence.</span></span> <span data-ttu-id="f0bc6-222">相反， <xref:System.Windows.DependencyObject.SetCurrentValue%2A> ，您可以更改属性的值而不会覆盖以前值的源。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-222">Instead, <xref:System.Windows.DependencyObject.SetCurrentValue%2A> enables you to change the value of a property without overwriting the source of a previous value.</span></span> <span data-ttu-id="f0bc6-223">可以使用<xref:System.Windows.DependencyObject.SetCurrentValue%2A>任何你想要设置一个值，而无需向该值提供某个本地值的优先级的时间。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-223">You can use <xref:System.Windows.DependencyObject.SetCurrentValue%2A> any time that you want to set a value without giving that value the precedence of a local value.</span></span> <span data-ttu-id="f0bc6-224">例如，如果属性是通过触发器设置，然后分配另一个值，通过<xref:System.Windows.DependencyObject.SetCurrentValue%2A>、 属性系统仍将遵循该触发器和触发器的操作时，该属性将更改。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-224">For example, if a property is set by a trigger and then assigned another value via <xref:System.Windows.DependencyObject.SetCurrentValue%2A>, the property system still respects the trigger and the property will change if the trigger’s action occurs.</span></span> <span data-ttu-id="f0bc6-225"><xref:System.Windows.DependencyObject.SetCurrentValue%2A> 可以更改属性的值，而向其提供具有较高优先级的源。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-225"><xref:System.Windows.DependencyObject.SetCurrentValue%2A> enables you to change the property’s value without giving it a source with a higher precedence.</span></span> <span data-ttu-id="f0bc6-226">同样，可以使用<xref:System.Windows.DependencyObject.SetCurrentValue%2A>不覆盖绑定的情况下更改属性的值。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-226">Likewise, you can use <xref:System.Windows.DependencyObject.SetCurrentValue%2A> to change the value of a property without overwriting a binding.</span></span>  
  
<a name="animations"></a>   
## <a name="coercion-animations-and-base-value"></a><span data-ttu-id="f0bc6-227">强制、动画和基值</span><span class="sxs-lookup"><span data-stu-id="f0bc6-227">Coercion, Animations, and Base Value</span></span>  
 <span data-ttu-id="f0bc6-228">强制和动画在本 [!INCLUDE[TLA2#tla_sdk](../../../../includes/tla2sharptla-sdk-md.md)] 中都作用于称为“基值”的值。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-228">Coercion and animation both act on a value that is termed as the "base value" throughout this [!INCLUDE[TLA2#tla_sdk](../../../../includes/tla2sharptla-sdk-md.md)].</span></span> <span data-ttu-id="f0bc6-229">因此，基值是在各项中通过向上计算一直到第 2 项为止而确定的任何值。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-229">The base value is thus whatever value is determined through evaluating upwards in the items until item 2 is reached.</span></span>  
  
 <span data-ttu-id="f0bc6-230">对于动画，如果没有为某些行为指定“From”和“To”值，或者动画在完成时故意还原为基值，那么基值将影响动画值。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-230">For an animation, the base value can have an effect on the animated value, if that animation does not specify both "From" and "To" for certain behaviors, or if the animation deliberately reverts to the base value when completed.</span></span> <span data-ttu-id="f0bc6-231">若要了解实际效果，请运行 [From, To, and By Animation Target Values Sample](https://go.microsoft.com/fwlink/?LinkID=159988)（From、To 和 By 动画目标值示例）。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-231">To see this in practice, run the [From, To, and By Animation Target Values Sample](https://go.microsoft.com/fwlink/?LinkID=159988).</span></span> <span data-ttu-id="f0bc6-232">尝试为示例中的矩形高度设置本地值，使初始本地值不同于动画中的任何“From”值。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-232">Try setting the local values of the rectangle height in the example, such that the initial local value differs from any "From" in the animation.</span></span> <span data-ttu-id="f0bc6-233">你会注意到动画立即使用“From”值开始，并在开始后替换基值。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-233">You will note that the animations start right away using the "From" values and replace the base value once started.</span></span> <span data-ttu-id="f0bc6-234">可以指定要返回到是指定 Stop 完成后，在动画之前找到的值<xref:System.Windows.Media.Animation.FillBehavior>。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-234">The animation might specify to return to the value found before animation once it is completed by specifying the Stop <xref:System.Windows.Media.Animation.FillBehavior>.</span></span> <span data-ttu-id="f0bc6-235">然后，根据正常优先级来确定基值。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-235">Afterwards, normal precedence is used for the base value determination.</span></span>  
  
 <span data-ttu-id="f0bc6-236">多个动画可能应用于一个属性，而每个动画可能是从值优先级中的不同点进行定义的。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-236">Multiple animations might be applied to a single property, with each of these animations possibly having been defined from different points in the value precedence.</span></span> <span data-ttu-id="f0bc6-237">但是，这些动画的值可能会组合起来，而不仅仅是从较高的优先级开始应用动画。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-237">However, these animations will potentially composite their values, rather than just applying the animation from the higher precedence.</span></span> <span data-ttu-id="f0bc6-238">这完全取决于动画的定义方式以及进行动画处理的值类型。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-238">This depends on exactly how the animations are defined, and the type of the value that is being animated.</span></span> <span data-ttu-id="f0bc6-239">有关对属性进行动画处理的详细信息，请参阅[动画概述](../../../../docs/framework/wpf/graphics-multimedia/animation-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-239">For more information about animating properties, see [Animation Overview](../../../../docs/framework/wpf/graphics-multimedia/animation-overview.md).</span></span>  
  
 <span data-ttu-id="f0bc6-240">强制在最高级别应用。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-240">Coercion applies at the highest level of all.</span></span> <span data-ttu-id="f0bc6-241">即使正在运行的动画也会受到值强制的制约。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-241">Even an already running animation is subject to value coercion.</span></span> <span data-ttu-id="f0bc6-242">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中的某些现有的依赖属性具有内置的强制行为。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-242">Certain existing dependency properties in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] have built-in coercion.</span></span> <span data-ttu-id="f0bc6-243">通过编写自定义依赖项属性，定义自定义依赖属性的强制行为<xref:System.Windows.CoerceValueCallback>和元数据的一部分传递回叫来创建该属性时。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-243">For a custom dependency property, you define the coercion behavior for a custom dependency property by writing a <xref:System.Windows.CoerceValueCallback> and passing the callback as part of metadata when you create the property.</span></span> <span data-ttu-id="f0bc6-244">还可以通过在派生类中重写现有属性的元数据来重写其强制行为。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-244">You can also override coercion behavior of existing properties by overriding the metadata on that property in a derived class.</span></span> <span data-ttu-id="f0bc6-245">强制与基值的交互使强制约束就像当时存在这些约束一样进行应用，但基值仍将保留。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-245">Coercion interacts with the base value in such a way that the constraints on coercion are applied as those constraints exist at the time, but the base value is still retained.</span></span> <span data-ttu-id="f0bc6-246">因此，如果强制约束后来被解除，强制将返回与基值最接近的值，并且一旦所有约束都解除，强制对属性的影响可能会立即停止。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-246">Therefore, if constraints in coercion are later lifted, the coercion will return the closest value possible to that base value, and potentially the coercion influence on a property will cease as soon as all constraints are lifted.</span></span> <span data-ttu-id="f0bc6-247">有关强制行为的详细信息，请参阅[依赖属性回调和验证](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-247">For more information about coercion behavior, see [Dependency Property Callbacks and Validation](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).</span></span>  
  
<a name="triggers"></a>   
## <a name="trigger-behaviors"></a><span data-ttu-id="f0bc6-248">触发器行为</span><span class="sxs-lookup"><span data-stu-id="f0bc6-248">Trigger Behaviors</span></span>  
 <span data-ttu-id="f0bc6-249">控件常常在主题中将触发器行为定义为其默认样式的一部分。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-249">Controls often define trigger behaviors as part of their default style in themes.</span></span> <span data-ttu-id="f0bc6-250">为控件设置本地属性可能会阻止触发器从视觉或行为上响应用户驱动的事件。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-250">Setting local properties on controls might prevent the triggers from being able to respond to user-driven events either visually or behaviorally.</span></span> <span data-ttu-id="f0bc6-251">属性触发器的最常见用途是为控件或状态属性，例如<xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A>。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-251">The most common use of a property trigger is for control or state properties such as <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A>.</span></span> <span data-ttu-id="f0bc6-252">例如，默认情况下时<xref:System.Windows.Controls.Button>已禁用 (针对触发<xref:System.Windows.UIElement.IsEnabled%2A>是`false`) 则<xref:System.Windows.Controls.Control.Foreground%2A>主题样式中的值是什么导致控件"灰显"。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-252">For example, by default when a <xref:System.Windows.Controls.Button> is disabled (trigger for <xref:System.Windows.UIElement.IsEnabled%2A> is `false`) then the <xref:System.Windows.Controls.Control.Foreground%2A> value in the theme style is what causes the control to appear "grayed out".</span></span> <span data-ttu-id="f0bc6-253">但是，如果设置了本地<xref:System.Windows.Controls.Control.Foreground%2A>值，普通灰显颜色将优先级中无效的本地属性集，即使在此属性触发的方案。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-253">But if you have set a local <xref:System.Windows.Controls.Control.Foreground%2A> value, that normal gray-out color will be overruled in precedence by your local property set, even in this property-triggered scenario.</span></span> <span data-ttu-id="f0bc6-254">为具有主题级触发器行为的属性设置值时要倍加小心，并确保不要过度妨碍该控件应有的用户体验。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-254">Be cautious of setting values for properties that have theme-level trigger behaviors and make sure you are not unduly interfering with the intended user experience for that control.</span></span>  
  
<a name="clearvalue"></a>   
## <a name="clearvalue-and-value-precedence"></a><span data-ttu-id="f0bc6-255">ClearValue 和值优先级</span><span class="sxs-lookup"><span data-stu-id="f0bc6-255">ClearValue and Value Precedence</span></span>  
 <span data-ttu-id="f0bc6-256"><xref:System.Windows.DependencyObject.ClearValue%2A>方法提供了一个有利的途径来清除任何本地应用的值从一个元素设置的依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-256">The <xref:System.Windows.DependencyObject.ClearValue%2A> method provides an expedient means to clear any locally applied value from a dependency property that is set on an element.</span></span> <span data-ttu-id="f0bc6-257">但是，调用<xref:System.Windows.DependencyObject.ClearValue%2A>并不保证数据的默认值为元数据中建立在注册过程，是的新生效值。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-257">However, calling <xref:System.Windows.DependencyObject.ClearValue%2A> is not a guarantee that the default as established in metadata during property registration is the new effective value.</span></span> <span data-ttu-id="f0bc6-258">值优先级中的所有其他参与者仍然有效。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-258">All of the other participants in value precedence are still active.</span></span> <span data-ttu-id="f0bc6-259">只有在本地设置的值才会从优先级序列中删除。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-259">Only the locally set value has been removed from the precedence sequence.</span></span> <span data-ttu-id="f0bc6-260">例如，如果您调用<xref:System.Windows.DependencyObject.ClearValue%2A>属性也由主题样式中，设置该属性，然后为新值而不是基于元数据的默认应用的主题值上。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-260">For example, if you call <xref:System.Windows.DependencyObject.ClearValue%2A> on a property where that property is also set by a theme style, then the theme value is applied as the new value rather than the metadata-based default.</span></span> <span data-ttu-id="f0bc6-261">如果你想要获取进程外的所有属性值参与者并将值设置为已注册的元数据默认值，则可以获取默认值明确通过查询依赖属性元数据，然后可以本地使用的默认值将通过调用属性设置<xref:System.Windows.DependencyObject.SetValue%2A>。</span><span class="sxs-lookup"><span data-stu-id="f0bc6-261">If you want to take all property value participants out of the process and set the value to the registered metadata default, you can obtain that default value definitively by querying the dependency property metadata, and then you can use the default value to locally set the property with a call to <xref:System.Windows.DependencyObject.SetValue%2A>.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f0bc6-262">请参阅</span><span class="sxs-lookup"><span data-stu-id="f0bc6-262">See Also</span></span>  
 <xref:System.Windows.DependencyObject>  
 <xref:System.Windows.DependencyProperty>  
 [<span data-ttu-id="f0bc6-263">依赖项属性概述</span><span class="sxs-lookup"><span data-stu-id="f0bc6-263">Dependency Properties Overview</span></span>](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)  
 [<span data-ttu-id="f0bc6-264">自定义依赖属性</span><span class="sxs-lookup"><span data-stu-id="f0bc6-264">Custom Dependency Properties</span></span>](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)  
 [<span data-ttu-id="f0bc6-265">依赖属性回调和验证</span><span class="sxs-lookup"><span data-stu-id="f0bc6-265">Dependency Property Callbacks and Validation</span></span>](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)
