---
title: 属性值继承
ms.date: 03/30/2017
helpviewer_keywords:
- inheritance [WPF], property values
- value inheritance [WPF]
- properties [WPF], value inheritance
ms.assetid: d7c338f9-f2bf-48ed-832c-7be58ac390e4
ms.openlocfilehash: e6b16bc3fc482e0f640f8b2d083392e6f94de618
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/23/2019
ms.locfileid: "54520577"
---
# <a name="property-value-inheritance"></a><span data-ttu-id="1bcc7-102">属性值继承</span><span class="sxs-lookup"><span data-stu-id="1bcc7-102">Property Value Inheritance</span></span>
<span data-ttu-id="1bcc7-103">属性值继承是 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 属性系统的一项功能。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-103">Property value inheritance is a feature of the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] property system.</span></span> <span data-ttu-id="1bcc7-104">属性值继承使元素树中的子元素可以从父元素获取特定属性的值，并继承该值，就如同它是在最近的父元素中任意位置设置的一样。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-104">Property value inheritance enables child elements in a tree of elements to obtain the value of a particular property from parent elements, inheriting that value as it was set anywhere in the nearest parent element.</span></span> <span data-ttu-id="1bcc7-105">父元素可能也已通过属性值继承获得了其值，因此系统有可能一直递归到页面根。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-105">The parent element might also have obtained its value through property value inheritance, so the system potentially recurses all the way to the page root.</span></span> <span data-ttu-id="1bcc7-106">属性值继承不是默认属性系统行为；属性必须用特定的元数据设置来建立，以便使该属性对子元素启动属性值继承。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-106">Property value inheritance is not the default property system behavior; a property must be established with a particular metadata setting in order to cause that property to initiate property value inheritance on child elements.</span></span>  
  

  
<a name="Property_Value_Inheritance_is_Containment_Inheritance"></a>   
## <a name="property-value-inheritance-is-containment-inheritance"></a><span data-ttu-id="1bcc7-107">属性值继承是内含继承</span><span class="sxs-lookup"><span data-stu-id="1bcc7-107">Property Value Inheritance Is Containment Inheritance</span></span>  
 <span data-ttu-id="1bcc7-108">此处作为术语的“继承”与类型和常规的面向对象的编程中提到的继承并非完全相同的概念，后者指派生类从其基类继承成员定义。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-108">"Inheritance" as a term here is not quite the same concept as inheritance in the context of types and general object-oriented programming, where derived classes inherit member definitions from their base classes.</span></span> <span data-ttu-id="1bcc7-109">继承的这一含义在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中也适用：当在代码中用作元素且公开为成员时，各基类中定义的属性将公开为 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 派生类的特性。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-109">That meaning of inheritance is also active in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]: properties defined in various base classes are exposed as attributes for derived [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] classes when used as elements, and exposed as members for code.</span></span> <span data-ttu-id="1bcc7-110">属性值继承则是关于属性值如何基于元素树中的父子关系从一个元素继承到另一个元素。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-110">Property value inheritance is particularly about how property values can inherit from one element to another on the basis of the parent-child relationships within a tree of elements.</span></span> <span data-ttu-id="1bcc7-111">如果在 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 标记中定义应用程序时将元素嵌套在其他元素中，则该元素树在此种情况下最直接可见。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-111">That tree of elements is most directly visible when nesting elements inside other elements as you define applications in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] markup.</span></span> <span data-ttu-id="1bcc7-112">还可以通过向其他对象的指定集合中添加对象来以编程方式创建对象树，在运行时，属性值继承在完成树中以相同方式工作。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-112">Trees of objects can also be created programmatically by adding objects to designated collections of other objects, and property value inheritance works the same way in the finished tree at run time.</span></span>  
  
<a name="Practical_Applications_of_Property_Value_Inheritance"></a>   
## <a name="practical-applications-of-property-value-inheritance"></a><span data-ttu-id="1bcc7-113">属性值继承的实际应用</span><span class="sxs-lookup"><span data-stu-id="1bcc7-113">Practical Applications of Property Value Inheritance</span></span>  
 <span data-ttu-id="1bcc7-114">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA#tla_api#plural](../../../../includes/tlasharptla-apisharpplural-md.md)] 包括几个启用属性继承的属性。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-114">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA#tla_api#plural](../../../../includes/tlasharptla-apisharpplural-md.md)] include several properties that have property inheritance enabled.</span></span> <span data-ttu-id="1bcc7-115">通常，使用这些属性的情况是当涉及到一个属性，每页可以仅对该属性设置一次，但是该属性还是某个基元素类的成员，因此还存在于大多数子元素中。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-115">Typically, the scenario for these is that they involve a property where it is appropriate that the property be set only once per page, but where that property is also a member of one of the base element classes and thus would also exist on most of the child elements.</span></span> <span data-ttu-id="1bcc7-116">例如，<xref:System.Windows.FrameworkElement.FlowDirection%2A>属性控制哪个方向流动内容应提供程序并在页面上的排列。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-116">For example, the <xref:System.Windows.FrameworkElement.FlowDirection%2A> property controls which direction flowed content should be presented and arranged on the page.</span></span> <span data-ttu-id="1bcc7-117">通常做法是在所有子元素中以一致的方式处理文本流概念。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-117">Typically, you want the text flow concept to be handled consistently throughout all child elements.</span></span> <span data-ttu-id="1bcc7-118">如果用户或环境操作因某种原因在元素树的某一层重置了流方向，则流方向通常会在整个树中重置。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-118">If flow direction were for some reason reset in some level of the element tree by user or environment action, it should typically be reset throughout.</span></span> <span data-ttu-id="1bcc7-119">当<xref:System.Windows.FrameworkElement.FlowDirection%2A>属性进行继承，值仅需要设置或重置的每个页面在应用程序中需要演示的元素树中级别的一次。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-119">When the <xref:System.Windows.FrameworkElement.FlowDirection%2A> property is made to inherit, the value need only be set or reset once at the level in the element tree that encompasses the presentation needs of each page in the application.</span></span> <span data-ttu-id="1bcc7-120">即使是最初的默认值也将按照这种方式继承。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-120">Even the initial default value will inherit in this way.</span></span> <span data-ttu-id="1bcc7-121">在需有意混用流方向的极罕见情况下，属性值继承模型也仍允许个别元素重置该值。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-121">The property value inheritance model still enables individual elements to reset the value for the rare cases where having a mix of flow directions is intentional.</span></span>  
  
<a name="Making_a_Custom_Property_Inheritable"></a>   
## <a name="making-a-custom-property-inheritable"></a><span data-ttu-id="1bcc7-122">使自定义属性可继承</span><span class="sxs-lookup"><span data-stu-id="1bcc7-122">Making a Custom Property Inheritable</span></span>  
 <span data-ttu-id="1bcc7-123">通过更改自定义属性的元数据，还可以使自己的自定义属性可继承。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-123">By changing a custom property's metadata, you can also make your own custom properties inheritable.</span></span> <span data-ttu-id="1bcc7-124">但是，请注意，将属性指定为可继承需要考虑到性能问题。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-124">Note, however, that designating a property as inheritable does have some performance considerations.</span></span> <span data-ttu-id="1bcc7-125">如果该属性没有已建立的本地值或通过样式、模板或数据绑定获取的值，则可继承的属性会将赋予它的属性值提供给逻辑树中的所有子元素。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-125">In cases where that property does not have an established local value, or a value obtained through styles, templates, or data binding, an inheritable property provides its assigned property values to all child elements in the logical tree.</span></span>  
  
 <span data-ttu-id="1bcc7-126">为了让属性参与值继承，请按照[注册附加属性](../../../../docs/framework/wpf/advanced/how-to-register-an-attached-property.md)中所述创建自定义附加属性。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-126">To make a property participate in value inheritance, create a custom attached property, as described in [Register an Attached Property](../../../../docs/framework/wpf/advanced/how-to-register-an-attached-property.md).</span></span> <span data-ttu-id="1bcc7-127">注册元数据属性 (<xref:System.Windows.FrameworkPropertyMetadata>) 并在该元数据内的选项设置中指定"Inherits"选项。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-127">Register the property with metadata (<xref:System.Windows.FrameworkPropertyMetadata>) and specify the "Inherits" option in the options settings within that metadata.</span></span> <span data-ttu-id="1bcc7-128">同时确保该属性已建立了默认值，因为该值现将继承。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-128">Also make sure that the property has an established default value, because that value will now inherit.</span></span> <span data-ttu-id="1bcc7-129">尽管已将该属性注册为附加属性，可能还需像对“非附加”依赖项属性一样，为所有者类型上的 get/set 访问创建属性“包装”。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-129">Although you registered the property as attached, you might also want to create a property "wrapper" for get/set access on the owner type, just as you would for an "nonattached" dependency property.</span></span> <span data-ttu-id="1bcc7-130">这样做之后，可继承的属性可以设置所有者类型或派生的类型上使用直接属性包装或它可以在任何使用附加的属性语法设置<xref:System.Windows.DependencyObject>。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-130">After doing so, the inheritable property can either be set by using the direct property wrapper on the owner type or derived types, or it can be set by using the attached property syntax on any <xref:System.Windows.DependencyObject>.</span></span>  
  
 <span data-ttu-id="1bcc7-131">附加的属性是从概念上讲类似于全局属性;您可以检查任何值<xref:System.Windows.DependencyObject>并获取有效结果。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-131">Attached properties are conceptually similar to global properties; you can check for the value on any <xref:System.Windows.DependencyObject> and get a valid result.</span></span> <span data-ttu-id="1bcc7-132">附加属性的典型方案是在子元素上设置属性值和该方案会更为有效，如果有问题的属性是将始终作为附加属性的每个元素隐式存在一个附加的属性 (<xref:System.Windows.DependencyObject>) 在树中。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-132">The typical scenario for attached properties is to set property values on child elements, and that scenario is more effective if the property in question is an attached property that is always implicitly present as an attached property on each element (<xref:System.Windows.DependencyObject>) in the tree.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1bcc7-133">尽管属性值继承看起来对非附加依赖项属性有效，但通过运行时树中特定元素边界的非附加属性的继承行为并未定义。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-133">Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the run-time tree is undefined.</span></span> <span data-ttu-id="1bcc7-134">始终使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>来注册您在其中指定的属性<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>元数据中。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-134">Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata.</span></span>  
  
<a name="InheritanceContext"></a>   
## <a name="inheriting-property-values-across-tree-boundaries"></a><span data-ttu-id="1bcc7-135">跨树边界继承属性值</span><span class="sxs-lookup"><span data-stu-id="1bcc7-135">Inheriting Property Values Across Tree Boundaries</span></span>  
 <span data-ttu-id="1bcc7-136">属性继承通过遍历元素树来工作。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-136">Property inheritance works by traversing a tree of elements.</span></span> <span data-ttu-id="1bcc7-137">此树通常与逻辑树并行。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-137">This tree is often parallel to the logical tree.</span></span> <span data-ttu-id="1bcc7-138">但是，每当您包括 WPF 核心级别对象中的标记，用于定义元素树，如<xref:System.Windows.Media.Brush>，已创建一个不连续的逻辑树。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-138">However, whenever you include a WPF core-level object in the markup that defines an element tree, such as a <xref:System.Windows.Media.Brush>, you have created a discontinuous logical tree.</span></span> <span data-ttu-id="1bcc7-139">真正的逻辑树不会从概念上讲扩展通过<xref:System.Windows.Media.Brush>，因为逻辑树是 WPF 框架级别概念。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-139">A true logical tree does not conceptually extend through the <xref:System.Windows.Media.Brush>, because the logical tree is a WPF framework-level concept.</span></span> <span data-ttu-id="1bcc7-140">您可以看到这反映在结果中使用的方法时<xref:System.Windows.LogicalTreeHelper>。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-140">You can see this reflected in the results when using the methods of <xref:System.Windows.LogicalTreeHelper>.</span></span> <span data-ttu-id="1bcc7-141">但是，属性值继承可填补此间隙逻辑树中的，并且只要可继承的属性注册为附加的属性，而且没有有意的继承阻止边界可以仍可通过继承的值，(例如<xref:System.Windows.Controls.Frame>) 遇到。</span><span class="sxs-lookup"><span data-stu-id="1bcc7-141">However, property value inheritance can bridge this gap in the logical tree and can still pass inherited values through, so long as the inheritable property was registered as an attached property and no deliberate inheritance-blocking boundary (such as a <xref:System.Windows.Controls.Frame>) is encountered.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1bcc7-142">请参阅</span><span class="sxs-lookup"><span data-stu-id="1bcc7-142">See also</span></span>
- [<span data-ttu-id="1bcc7-143">依赖属性元数据</span><span class="sxs-lookup"><span data-stu-id="1bcc7-143">Dependency Property Metadata</span></span>](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md)
- [<span data-ttu-id="1bcc7-144">附加属性概述</span><span class="sxs-lookup"><span data-stu-id="1bcc7-144">Attached Properties Overview</span></span>](../../../../docs/framework/wpf/advanced/attached-properties-overview.md)
- [<span data-ttu-id="1bcc7-145">依赖项属性值优先级</span><span class="sxs-lookup"><span data-stu-id="1bcc7-145">Dependency Property Value Precedence</span></span>](../../../../docs/framework/wpf/advanced/dependency-property-value-precedence.md)
