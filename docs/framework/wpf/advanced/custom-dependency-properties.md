---
title: 自定义依赖项属性
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- implementing [WPF], wrappers
- registering properties [WPF]
- properties [WPF], metadata
- metadata [WPF], for properties
- custom dependency properties [WPF]
- properties [WPF], registering
- wrappers [WPF], implementing
- dependency properties [WPF], custom
ms.assetid: e6bfcfac-b10d-4f58-9f77-a864c2a2938f
ms.openlocfilehash: 8e3ac7207a5ef05b94e97f005ecd17d5078669a4
ms.sourcegitcommit: 22be09204266253d45ece46f51cc6f080f2b3fd6
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/07/2019
ms.locfileid: "73740884"
---
# <a name="custom-dependency-properties"></a><span data-ttu-id="a5f75-102">自定义依赖项属性</span><span class="sxs-lookup"><span data-stu-id="a5f75-102">Custom Dependency Properties</span></span>

<span data-ttu-id="a5f75-103">本主题介绍了 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 应用程序开发者和组件作者想要创建自定义依赖属性的原因，并介绍了一些可以提高属性的性能、可用性或通用性的实现步骤以及实现选项。</span><span class="sxs-lookup"><span data-stu-id="a5f75-103">This topic describes the reasons that [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] application developers and component authors might want to create custom dependency property, and describes the implementation steps as well as some implementation options that can improve performance, usability, or versatility of the property.</span></span>

<a name="prerequisites"></a>

## <a name="prerequisites"></a><span data-ttu-id="a5f75-104">Prerequisites</span><span class="sxs-lookup"><span data-stu-id="a5f75-104">Prerequisites</span></span>

<span data-ttu-id="a5f75-105">本主题假设你作为 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 类的现有依赖属性的使用者已经对依赖属性有所了解，并且已经阅读了[依赖属性概述](dependency-properties-overview.md)主题。</span><span class="sxs-lookup"><span data-stu-id="a5f75-105">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](dependency-properties-overview.md) topic.</span></span> <span data-ttu-id="a5f75-106">若要理解本主题中的示例，还应当了解 [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] 并知道如何编写 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 应用程序。</span><span class="sxs-lookup"><span data-stu-id="a5f75-106">In order to follow the examples in this topic, you should also understand [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] and know how to write [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications.</span></span>

<a name="whatis"></a>

## <a name="what-is-a-dependency-property"></a><span data-ttu-id="a5f75-107">什么是依赖属性？</span><span class="sxs-lookup"><span data-stu-id="a5f75-107">What Is a Dependency Property?</span></span>

<span data-ttu-id="a5f75-108">您可以通过将其实现为依赖属性，使其成为公共语言运行时（CLR）属性，以支持样式设置、数据绑定、继承、动画和默认值。</span><span class="sxs-lookup"><span data-stu-id="a5f75-108">You can enable what would otherwise be a common language runtime (CLR) property to support styling, data binding, inheritance, animations, and default values by implementing it as a dependency property.</span></span> <span data-ttu-id="a5f75-109">依赖属性是通过调用 <xref:System.Windows.DependencyProperty.Register%2A> 方法（或 <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>）注册到 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 属性系统并且由 <xref:System.Windows.DependencyProperty> 标识符字段支持的属性。</span><span class="sxs-lookup"><span data-stu-id="a5f75-109">Dependency properties are properties that are registered with the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system by calling the <xref:System.Windows.DependencyProperty.Register%2A> method (or <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>), and that are backed by a <xref:System.Windows.DependencyProperty> identifier field.</span></span> <span data-ttu-id="a5f75-110">依赖项属性只能由 <xref:System.Windows.DependencyObject> 类型使用，但在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 类层次结构中 <xref:System.Windows.DependencyObject> 非常高，因此 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中提供的大多数类都可以支持依赖属性。</span><span class="sxs-lookup"><span data-stu-id="a5f75-110">Dependency properties can be used only by <xref:System.Windows.DependencyObject> types, but <xref:System.Windows.DependencyObject> is quite high in the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] class hierarchy, so the majority of classes available in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] can support dependency properties.</span></span> <span data-ttu-id="a5f75-111">有关依赖属性以及在此 SDK 中描述它们的一些术语和约定的详细信息，请参阅[依赖属性概述](dependency-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="a5f75-111">For more information about dependency properties and some of the terminology and conventions used for describing them in this SDK, see [Dependency Properties Overview](dependency-properties-overview.md).</span></span>

<a name="example_dp"></a>

## <a name="examples-of-dependency-properties"></a><span data-ttu-id="a5f75-112">依赖属性示例</span><span class="sxs-lookup"><span data-stu-id="a5f75-112">Examples of Dependency Properties</span></span>

<span data-ttu-id="a5f75-113">在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 类上实现的依赖属性的示例包括 <xref:System.Windows.Controls.Control.Background%2A> 属性、<xref:System.Windows.FrameworkElement.Width%2A> 属性和 <xref:System.Windows.Controls.TextBox.Text%2A> 属性，等等。</span><span class="sxs-lookup"><span data-stu-id="a5f75-113">Examples of dependency properties that are implemented on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes include the <xref:System.Windows.Controls.Control.Background%2A> property, the <xref:System.Windows.FrameworkElement.Width%2A> property, and the <xref:System.Windows.Controls.TextBox.Text%2A> property, among many others.</span></span> <span data-ttu-id="a5f75-114">类公开的每个依赖项属性都具有一个对应的公共静态字段，该字段类型 <xref:System.Windows.DependencyProperty> 在同一类上公开。</span><span class="sxs-lookup"><span data-stu-id="a5f75-114">Each dependency property exposed by a class has a corresponding public static field of type <xref:System.Windows.DependencyProperty> exposed on that same class.</span></span> <span data-ttu-id="a5f75-115">这是依赖属性的标识符。</span><span class="sxs-lookup"><span data-stu-id="a5f75-115">This is the identifier for the dependency property.</span></span> <span data-ttu-id="a5f75-116">此标识符的命名约定为：依赖属性名称后面加上字符串 `Property`。</span><span class="sxs-lookup"><span data-stu-id="a5f75-116">The identifier is named using a convention: the name of the dependency property with the string `Property` appended to it.</span></span> <span data-ttu-id="a5f75-117">例如，"<xref:System.Windows.Controls.Control.Background%2A>" 属性的相应 <xref:System.Windows.DependencyProperty> 标识符 "字段为" <xref:System.Windows.Controls.Control.BackgroundProperty>"。</span><span class="sxs-lookup"><span data-stu-id="a5f75-117">For example, the corresponding <xref:System.Windows.DependencyProperty> identifier field for the <xref:System.Windows.Controls.Control.Background%2A> property is <xref:System.Windows.Controls.Control.BackgroundProperty>.</span></span> <span data-ttu-id="a5f75-118">该标识符存储有关已注册的依赖属性的信息，以后会将该标识符用于涉及依赖属性的其他操作，例如调用 <xref:System.Windows.DependencyObject.SetValue%2A>。</span><span class="sxs-lookup"><span data-stu-id="a5f75-118">The identifier stores the information about the dependency property as it was registered, and the identifier is then used later for other operations involving the dependency property, such as calling <xref:System.Windows.DependencyObject.SetValue%2A>.</span></span>

<span data-ttu-id="a5f75-119">如[依赖属性概述](dependency-properties-overview.md)中所述，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中的所有依赖属性（大多数附加属性除外）也是 CLR 属性，因为 "包装器" 实现。</span><span class="sxs-lookup"><span data-stu-id="a5f75-119">As mentioned in the [Dependency Properties Overview](dependency-properties-overview.md), all dependency properties in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] (except most attached properties) are also CLR properties because of the "wrapper" implementation.</span></span> <span data-ttu-id="a5f75-120">因此，可以从代码中获取或设置依赖属性，方法是调用定义包装的 CLR 访问器，方法与使用其他 CLR 属性的方式相同。</span><span class="sxs-lookup"><span data-stu-id="a5f75-120">Therefore, from code, you can get or set dependency properties by calling CLR accessors that define the wrappers in the same manner that you would use other CLR properties.</span></span> <span data-ttu-id="a5f75-121">作为已建立的依赖项属性的使用者，通常不使用 <xref:System.Windows.DependencyObject> 方法 <xref:System.Windows.DependencyObject.GetValue%2A> 和 <xref:System.Windows.DependencyObject.SetValue%2A>，这是基础属性系统的连接点。</span><span class="sxs-lookup"><span data-stu-id="a5f75-121">As a consumer of established dependency properties, you do not typically use the <xref:System.Windows.DependencyObject> methods <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A>, which are the connection point to the underlying property system.</span></span> <span data-ttu-id="a5f75-122">相反，CLR 属性的现有实现已在属性的 `get` 和 `set` 包装实现中调用 <xref:System.Windows.DependencyObject.GetValue%2A> 和 <xref:System.Windows.DependencyObject.SetValue%2A>，并相应地使用标识符字段。</span><span class="sxs-lookup"><span data-stu-id="a5f75-122">Rather, the existing implementation of the CLR properties will have already called <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> within the `get` and `set` wrapper implementations of the property, using the identifier field appropriately.</span></span> <span data-ttu-id="a5f75-123">若要自己实现自定义依赖属性，则需要使用类似的方法定义包装器。</span><span class="sxs-lookup"><span data-stu-id="a5f75-123">If you are implementing a custom dependency property yourself, then you will be defining the wrapper in a similar way.</span></span>

<a name="backing_with_dp"></a>

## <a name="when-should-you-implement-a-dependency-property"></a><span data-ttu-id="a5f75-124">应该何时实现依赖属性？</span><span class="sxs-lookup"><span data-stu-id="a5f75-124">When Should You Implement a Dependency Property?</span></span>

<span data-ttu-id="a5f75-125">实现类的属性时，只要类派生自 <xref:System.Windows.DependencyObject>，就可以选择使用 <xref:System.Windows.DependencyProperty> 标识符来备份属性，从而使其成为依赖属性。</span><span class="sxs-lookup"><span data-stu-id="a5f75-125">When you implement a property on a class, so long as your class derives from <xref:System.Windows.DependencyObject>, you have the option to back your property with a <xref:System.Windows.DependencyProperty> identifier and thus to make it a dependency property.</span></span> <span data-ttu-id="a5f75-126">不必总是将属性实现为依赖属性，这不一定合适，具体取决于方案需要。</span><span class="sxs-lookup"><span data-stu-id="a5f75-126">Having your property be a dependency property is not always necessary or appropriate, and will depend on your scenario needs.</span></span> <span data-ttu-id="a5f75-127">有时，使用私有字段支持属性的通常方法已足够满足需求。</span><span class="sxs-lookup"><span data-stu-id="a5f75-127">Sometimes, the typical technique of backing your property with a private field is adequate.</span></span> <span data-ttu-id="a5f75-128">但是，如果要使属性支持以下一个或多个 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 功能，则应该将属性实现为依赖属性：</span><span class="sxs-lookup"><span data-stu-id="a5f75-128">However, you should implement your property as a dependency property whenever you want your property to support one or more of the following [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] capabilities:</span></span>

- <span data-ttu-id="a5f75-129">需要可以在样式中设置属性。</span><span class="sxs-lookup"><span data-stu-id="a5f75-129">You want your property to be settable in a style.</span></span> <span data-ttu-id="a5f75-130">有关详细信息，请参阅[样式设置和模板化](../controls/styling-and-templating.md)。</span><span class="sxs-lookup"><span data-stu-id="a5f75-130">For more information, see [Styling and Templating](../controls/styling-and-templating.md).</span></span>

- <span data-ttu-id="a5f75-131">需要属性支持数据绑定。</span><span class="sxs-lookup"><span data-stu-id="a5f75-131">You want your property to support data binding.</span></span> <span data-ttu-id="a5f75-132">有关数据绑定依赖属性的详细信息，请参阅[绑定两个控件的属性](../data/how-to-bind-the-properties-of-two-controls.md)。</span><span class="sxs-lookup"><span data-stu-id="a5f75-132">For more information about data binding dependency properties, see [Bind the Properties of Two Controls](../data/how-to-bind-the-properties-of-two-controls.md).</span></span>

- <span data-ttu-id="a5f75-133">需要可以使用动态资源引用设置属性。</span><span class="sxs-lookup"><span data-stu-id="a5f75-133">You want your property to be settable with a dynamic resource reference.</span></span> <span data-ttu-id="a5f75-134">有关详细信息，请参阅 [XAML 资源](../../../desktop-wpf/fundamentals/xaml-resources-define.md)。</span><span class="sxs-lookup"><span data-stu-id="a5f75-134">For more information, see [XAML Resources](../../../desktop-wpf/fundamentals/xaml-resources-define.md).</span></span>

- <span data-ttu-id="a5f75-135">需要从元素树中的父元素自动继承属性值。</span><span class="sxs-lookup"><span data-stu-id="a5f75-135">You want to inherit a property value automatically from a parent element in the element tree.</span></span> <span data-ttu-id="a5f75-136">在这种情况下，请使用 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 方法进行注册，即使你还创建了用于 CLR 访问的属性包装。</span><span class="sxs-lookup"><span data-stu-id="a5f75-136">In this case, register with the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method, even if you also create a property wrapper for CLR access.</span></span> <span data-ttu-id="a5f75-137">有关详细信息，请参阅[属性值继承](property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="a5f75-137">For more information, see [Property Value Inheritance](property-value-inheritance.md).</span></span>

- <span data-ttu-id="a5f75-138">需要属性可以进行动画处理。</span><span class="sxs-lookup"><span data-stu-id="a5f75-138">You want your property to be animatable.</span></span> <span data-ttu-id="a5f75-139">有关详细信息，请参阅 [动画概述](../graphics-multimedia/animation-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="a5f75-139">For more information, see [Animation Overview](../graphics-multimedia/animation-overview.md).</span></span>

- <span data-ttu-id="a5f75-140">需要属性系统在先前的值因属性系统、环境或用户执行的操作而发生更改，或者因读取和使用样式而发生更改时进行报告。</span><span class="sxs-lookup"><span data-stu-id="a5f75-140">You want the property system to report when the previous value of the property has been changed by actions taken by the property system, the environment, or the user, or by reading and using styles.</span></span> <span data-ttu-id="a5f75-141">通过使用属性元素据，属性可以指定回调方法，每次属性系统确定属性值已明确改动时将调用此回调方法。</span><span class="sxs-lookup"><span data-stu-id="a5f75-141">By using property metadata, your property can specify a callback method that will be invoked each time the property system determines that your property value was definitively changed.</span></span> <span data-ttu-id="a5f75-142">与此相关的一个概念是属性值强制转换。</span><span class="sxs-lookup"><span data-stu-id="a5f75-142">A related concept is property value coercion.</span></span> <span data-ttu-id="a5f75-143">有关详细信息，请参阅[依赖属性回调和验证](dependency-property-callbacks-and-validation.md)。</span><span class="sxs-lookup"><span data-stu-id="a5f75-143">For more information, see [Dependency Property Callbacks and Validation](dependency-property-callbacks-and-validation.md).</span></span>

- <span data-ttu-id="a5f75-144">需要使用同时也被 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 进程使用的已建立的元数据约定，例如报告更改属性值是否应需要布局系统重新安排元素的可视内容。</span><span class="sxs-lookup"><span data-stu-id="a5f75-144">You want to use established metadata conventions that are also used by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] processes, such as reporting whether changing a property value should require the layout system to recompose the visuals for an element.</span></span> <span data-ttu-id="a5f75-145">或者需要能够使用元素据替代，以便派生类可以更改基于元数据的特性，例如默认值。</span><span class="sxs-lookup"><span data-stu-id="a5f75-145">Or you want to be able to use metadata overrides so that derived classes can change metadata-based characteristics such as the default value.</span></span>

- <span data-ttu-id="a5f75-146">您希望使用自定义控件的属性来接收 Visual Studio WPF 设计器支持，如 "**属性**" 窗口编辑。</span><span class="sxs-lookup"><span data-stu-id="a5f75-146">You want properties of a custom control to receive Visual Studio WPF Designer support, such as **Properties** window editing.</span></span> <span data-ttu-id="a5f75-147">有关详细信息，请参阅[控件创作概述](../controls/control-authoring-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="a5f75-147">For more information, see [Control Authoring Overview](../controls/control-authoring-overview.md).</span></span>

<span data-ttu-id="a5f75-148">检查这些方案时，还应考虑是否可以通过替代现有依赖属性的元素据而不是通过实现一个全新的属性来实现方案。</span><span class="sxs-lookup"><span data-stu-id="a5f75-148">When you examine these scenarios, you should also consider whether you can achieve your scenario by overriding the metadata of an existing dependency property, rather than implementing a completely new property.</span></span> <span data-ttu-id="a5f75-149">元素据替代是否可行取决于方案以及方案与现有的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 依赖属性和类中的实现的相似度。</span><span class="sxs-lookup"><span data-stu-id="a5f75-149">Whether a metadata override is practical depends on your scenario and how closely that scenario resembles the implementation in existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] dependency properties and classes.</span></span> <span data-ttu-id="a5f75-150">有关替代现有属性上的元素据的详细信息，请参阅[依赖属性元素据](dependency-property-metadata.md)。</span><span class="sxs-lookup"><span data-stu-id="a5f75-150">For more information about overriding metadata on existing properties, see [Dependency Property Metadata](dependency-property-metadata.md).</span></span>

<a name="checklist"></a>

## <a name="checklist-for-defining-a-dependency-property"></a><span data-ttu-id="a5f75-151">定义依赖属性的检查清单</span><span class="sxs-lookup"><span data-stu-id="a5f75-151">Checklist for Defining a Dependency Property</span></span>

<span data-ttu-id="a5f75-152">定义依赖属性包含 4 个不同的概念。</span><span class="sxs-lookup"><span data-stu-id="a5f75-152">Defining a dependency property consists of four distinct concepts.</span></span> <span data-ttu-id="a5f75-153">这些概念并不一定是严格的过程步骤，因为其中一些概念在实现中会被合并为一行代码：</span><span class="sxs-lookup"><span data-stu-id="a5f75-153">These concepts are not necessarily strict procedural steps, because some of these end up being combined as single lines of code in the implementation:</span></span>

- <span data-ttu-id="a5f75-154">（可选）创建依赖属性的属性元素据。</span><span class="sxs-lookup"><span data-stu-id="a5f75-154">(Optional) Create property metadata for the dependency property.</span></span>

- <span data-ttu-id="a5f75-155">在属性系统中注册属性名称，并指定所有者类型和属性值类型。</span><span class="sxs-lookup"><span data-stu-id="a5f75-155">Register the property name with the property system, specifying an owner type and the type of the property value.</span></span> <span data-ttu-id="a5f75-156">此外，还应指定属性元素据（如果用到）。</span><span class="sxs-lookup"><span data-stu-id="a5f75-156">Also specify the property metadata, if used.</span></span>

- <span data-ttu-id="a5f75-157">将 <xref:System.Windows.DependencyProperty> 标识符定义为所有者类型上的 `public` `static` `readonly` 字段。</span><span class="sxs-lookup"><span data-stu-id="a5f75-157">Define a <xref:System.Windows.DependencyProperty> identifier as a `public` `static` `readonly` field on the owner type.</span></span>

- <span data-ttu-id="a5f75-158">定义一个 CLR "包装器" 属性，该属性的名称与依赖项属性的名称匹配。</span><span class="sxs-lookup"><span data-stu-id="a5f75-158">Define a CLR "wrapper" property whose name matches the name of the dependency property.</span></span> <span data-ttu-id="a5f75-159">实现 CLR "包装器" 属性的 `get`，并 `set` 访问器连接到支持它的依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="a5f75-159">Implement the CLR "wrapper" property's `get` and `set` accessors to connect with the dependency property that backs it.</span></span>

<a name="registering"></a>

### <a name="registering-the-property-with-the-property-system"></a><span data-ttu-id="a5f75-160">在属性系统中注册属性</span><span class="sxs-lookup"><span data-stu-id="a5f75-160">Registering the Property with the Property System</span></span>

<span data-ttu-id="a5f75-161">为使属性成为依赖属性，必须在属性系统维护的表中注册该属性，并为属性指定一个唯一标识符。此唯一标识符会用作后续属性系统操作的限定符。</span><span class="sxs-lookup"><span data-stu-id="a5f75-161">In order for your property to be a dependency property, you must register that property into a table maintained by the property system, and give it a unique identifier that is used as the qualifier for later property system operations.</span></span> <span data-ttu-id="a5f75-162">这些操作可能是内部操作，也可能是你自己的代码调用属性系统 Api。</span><span class="sxs-lookup"><span data-stu-id="a5f75-162">These operations might be internal operations, or your own code calling property system APIs.</span></span> <span data-ttu-id="a5f75-163">若要注册属性，请在类（类中，但在任何成员定义之外）的正文中调用 <xref:System.Windows.DependencyProperty.Register%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="a5f75-163">To register the property, you call the <xref:System.Windows.DependencyProperty.Register%2A> method within the body of your class (inside the class, but outside of any member definitions).</span></span> <span data-ttu-id="a5f75-164">"标识符" 字段也由 <xref:System.Windows.DependencyProperty.Register%2A> 方法调用提供，作为返回值。</span><span class="sxs-lookup"><span data-stu-id="a5f75-164">The identifier field is also provided by the <xref:System.Windows.DependencyProperty.Register%2A> method call, as the return value.</span></span> <span data-ttu-id="a5f75-165"><xref:System.Windows.DependencyProperty.Register%2A> 调用在其他成员定义之外完成的原因是，使用此返回值分配和创建 `public` `static` <xref:System.Windows.DependencyProperty> 类型 `readonly` 字段字段作为类的一部分。</span><span class="sxs-lookup"><span data-stu-id="a5f75-165">The reason that the <xref:System.Windows.DependencyProperty.Register%2A> call is done outside of other member definitions is because you use this return value to assign and create a `public` `static` `readonly` field of type <xref:System.Windows.DependencyProperty> as part of your class.</span></span> <span data-ttu-id="a5f75-166">此字段会作为依赖属性的标识符。</span><span class="sxs-lookup"><span data-stu-id="a5f75-166">This field becomes the identifier for your dependency property.</span></span>

[!code-csharp[WPFAquariumSln#RegisterAG](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerag)]
[!code-vb[WPFAquariumSln#RegisterAG](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerag)]

<a name="nameconventions"></a>

### <a name="dependency-property-name-conventions"></a><span data-ttu-id="a5f75-167">依赖属性命名约定</span><span class="sxs-lookup"><span data-stu-id="a5f75-167">Dependency Property Name Conventions</span></span>

<span data-ttu-id="a5f75-168">必需完全遵循已有的依赖属性命名约定，例外情况除外。</span><span class="sxs-lookup"><span data-stu-id="a5f75-168">There are established naming conventions regarding dependency properties that you must follow in all but exceptional circumstances.</span></span>

<span data-ttu-id="a5f75-169">依赖属性本身将有一个基本名称 "AquariumGraphic"，如本示例所示，它作为 <xref:System.Windows.DependencyProperty.Register%2A>的第一个参数。</span><span class="sxs-lookup"><span data-stu-id="a5f75-169">The dependency property itself will have a basic name, "AquariumGraphic" as in this example, which is given as the first parameter of <xref:System.Windows.DependencyProperty.Register%2A>.</span></span> <span data-ttu-id="a5f75-170">此名称在每个注册类型内必须唯一。</span><span class="sxs-lookup"><span data-stu-id="a5f75-170">That name must be unique within each registering type.</span></span> <span data-ttu-id="a5f75-171">通过基类型继承的依赖属性会被视为注册类型的已有部分；无法再次注册已继承属性的名称。</span><span class="sxs-lookup"><span data-stu-id="a5f75-171">Dependency properties inherited through base types are considered to be already part of the registering type; names of inherited properties cannot be registered again.</span></span> <span data-ttu-id="a5f75-172">但是，即使不继承依赖属性，也有方法可将类添加为依赖属性的所有者；有关详细信息，请参阅[依赖属性元素据](dependency-property-metadata.md)。</span><span class="sxs-lookup"><span data-stu-id="a5f75-172">However, there is a technique for adding a class as owner of a dependency property even when that dependency property is not inherited; for details, see [Dependency Property Metadata](dependency-property-metadata.md).</span></span>

<span data-ttu-id="a5f75-173">创建标识符字段时，按注册时的属性名称命名此字段，再加上后缀 `Property`。</span><span class="sxs-lookup"><span data-stu-id="a5f75-173">When you create the identifier field, name this field by the name of the property as you registered it, plus the suffix `Property`.</span></span> <span data-ttu-id="a5f75-174">此字段是依赖项属性的标识符，稍后会将其用作 <xref:System.Windows.DependencyObject.SetValue%2A> 的输入，并将其作为你将在包装中进行的 <xref:System.Windows.DependencyObject.GetValue%2A> 调用的输入，由你自己的代码访问属性，由属性系统支持的任何外部代码访问，并可能会 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 处理器。</span><span class="sxs-lookup"><span data-stu-id="a5f75-174">This field is your identifier for the dependency property, and it will be used later as an input for the <xref:System.Windows.DependencyObject.SetValue%2A> and <xref:System.Windows.DependencyObject.GetValue%2A> calls you will make in the wrappers, by any other code access to the property by your own code, by any external code access you allow, by the property system, and potentially by [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processors.</span></span>

> [!NOTE]
> <span data-ttu-id="a5f75-175">在类的主体中定义依赖属性是典型的实现，但也可以在类静态构造函数中定义依赖属性。</span><span class="sxs-lookup"><span data-stu-id="a5f75-175">Defining the dependency property in the class body is the typical implementation, but it is also possible to define a dependency property in the class static constructor.</span></span> <span data-ttu-id="a5f75-176">需要多行代码来初始化依赖属性时，此方法会很有用。</span><span class="sxs-lookup"><span data-stu-id="a5f75-176">This approach might make sense if you need more than one line of code to initialize the dependency property.</span></span>

<a name="wrapper1"></a>

### <a name="implementing-the-wrapper"></a><span data-ttu-id="a5f75-177">实现“包装器”</span><span class="sxs-lookup"><span data-stu-id="a5f75-177">Implementing the "Wrapper"</span></span>

<span data-ttu-id="a5f75-178">包装实现应在 `get` 实现中调用 <xref:System.Windows.DependencyObject.GetValue%2A>，并在 `set` 实现中 <xref:System.Windows.DependencyObject.SetValue%2A> （最初的注册调用和字段在此处显示）。</span><span class="sxs-lookup"><span data-stu-id="a5f75-178">Your wrapper implementation should call <xref:System.Windows.DependencyObject.GetValue%2A> in the `get` implementation, and <xref:System.Windows.DependencyObject.SetValue%2A> in the `set` implementation (the original registration call and field are shown here too for clarity).</span></span>

<span data-ttu-id="a5f75-179">除异常情况以外，包装实现只能分别执行 <xref:System.Windows.DependencyObject.GetValue%2A> 和 <xref:System.Windows.DependencyObject.SetValue%2A> 操作。</span><span class="sxs-lookup"><span data-stu-id="a5f75-179">In all but exceptional circumstances, your wrapper implementations should perform only the <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> actions, respectively.</span></span> <span data-ttu-id="a5f75-180">其原因请参阅 [XAML 加载和依赖属性](xaml-loading-and-dependency-properties.md)主题。</span><span class="sxs-lookup"><span data-stu-id="a5f75-180">The reason for this is discussed in the topic [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>

<span data-ttu-id="a5f75-181">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 类上提供的所有现有公共依赖属性都使用这一简单的包装器实现模型；大多数情况下，依赖属性工作原理的复杂性本质上在于它是属性系统的行为，还是通过其他概念（例如强制转换或通过属性元数据进行的属性更改回调）实现的行为。</span><span class="sxs-lookup"><span data-stu-id="a5f75-181">All existing public dependency properties that are provided on the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes use this simple wrapper implementation model; most of the complexity of how dependency properties work is either inherently a behavior of the property system, or is implemented through other concepts such as coercion or property change callbacks through property metadata.</span></span>

[!code-csharp[WPFAquariumSln#AGWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#agwithwrapper)]
[!code-vb[WPFAquariumSln#AGWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#agwithwrapper)]

<span data-ttu-id="a5f75-182">同样，按照约定，包装属性的名称必须与所选的名称相同，并指定为注册该属性的 <xref:System.Windows.DependencyProperty.Register%2A> 调用的第一个参数。</span><span class="sxs-lookup"><span data-stu-id="a5f75-182">Again, by convention, the name of the wrapper property must be the same as the name chosen and given as first parameter of the <xref:System.Windows.DependencyProperty.Register%2A> call that registered the property.</span></span> <span data-ttu-id="a5f75-183">如果属性不遵从此约定，尽管不一定会禁用所有可能的用法，但你会遇到几个比较突出的问题：</span><span class="sxs-lookup"><span data-stu-id="a5f75-183">If your property does not follow the convention, this does not necessarily disable all possible uses, but you will encounter several notable issues:</span></span>

- <span data-ttu-id="a5f75-184">样式和模板的某些方面不起作用。</span><span class="sxs-lookup"><span data-stu-id="a5f75-184">Certain aspects of styles and templates will not work.</span></span>

- <span data-ttu-id="a5f75-185">大多数工具和设计器必须依赖命名约定，才能正确序列化 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 或在每个属性级别提供设计器环境帮助。</span><span class="sxs-lookup"><span data-stu-id="a5f75-185">Most tools and designers must rely on the naming conventions to properly serialize [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], or to provide designer environment assistance at a per-property level.</span></span>

- <span data-ttu-id="a5f75-186">处理特性值时，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 加载程序的会完全跳过包装器，并依赖于命名约定。</span><span class="sxs-lookup"><span data-stu-id="a5f75-186">The current implementation of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] loader bypasses the wrappers entirely, and relies on the naming convention when processing attribute values.</span></span> <span data-ttu-id="a5f75-187">有关详细信息，请参阅 [XAML 加载和依赖属性](xaml-loading-and-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="a5f75-187">For more information, see [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>

<a name="metadata"></a>

### <a name="property-metadata-for-a-new-dependency-property"></a><span data-ttu-id="a5f75-188">新依赖属性的属性元数据</span><span class="sxs-lookup"><span data-stu-id="a5f75-188">Property Metadata for a New Dependency Property</span></span>

<span data-ttu-id="a5f75-189">注册依赖属性时，通过属性系统进行注册会创建一个存储属性特征的元素据对象。</span><span class="sxs-lookup"><span data-stu-id="a5f75-189">When you register a dependency property, the registration through the property system creates a metadata object that stores property characteristics.</span></span> <span data-ttu-id="a5f75-190">其中的许多特性都具有默认值，如果将属性注册到 <xref:System.Windows.DependencyProperty.Register%2A>的简单签名，则会设置这些默认值。</span><span class="sxs-lookup"><span data-stu-id="a5f75-190">Many of these characteristics have defaults that are set if the property is registered with the simple signatures of <xref:System.Windows.DependencyProperty.Register%2A>.</span></span> <span data-ttu-id="a5f75-191">其他签名 <xref:System.Windows.DependencyProperty.Register%2A> 允许您在注册属性时指定所需的元数据。</span><span class="sxs-lookup"><span data-stu-id="a5f75-191">Other signatures of <xref:System.Windows.DependencyProperty.Register%2A> allow you to specify the metadata that you want as you register the property.</span></span> <span data-ttu-id="a5f75-192">为依赖属性使用的最常见元数据是为其使用默认值。该默认值适用于使用此属性的新实例。</span><span class="sxs-lookup"><span data-stu-id="a5f75-192">The most common metadata given for dependency properties is to give them a default value that is applied on new instances that use the property.</span></span>

<span data-ttu-id="a5f75-193">如果创建的依赖属性存在于 <xref:System.Windows.FrameworkElement>的派生类中，则可以使用更专用的元数据类 <xref:System.Windows.FrameworkPropertyMetadata> 而不是基 <xref:System.Windows.PropertyMetadata> 类。</span><span class="sxs-lookup"><span data-stu-id="a5f75-193">If you are creating a dependency property that exists on a derived class of <xref:System.Windows.FrameworkElement>, you can use the more specialized metadata class <xref:System.Windows.FrameworkPropertyMetadata> rather than the base <xref:System.Windows.PropertyMetadata> class.</span></span> <span data-ttu-id="a5f75-194"><xref:System.Windows.FrameworkPropertyMetadata> 类的构造函数有多个签名，你可以在其中组合指定各种元数据特征。</span><span class="sxs-lookup"><span data-stu-id="a5f75-194">The constructor for the <xref:System.Windows.FrameworkPropertyMetadata> class has several signatures where you can specify various metadata characteristics in combination.</span></span> <span data-ttu-id="a5f75-195">如果只想指定默认值，请使用采用 <xref:System.Object>类型的单个参数的签名。</span><span class="sxs-lookup"><span data-stu-id="a5f75-195">If you want to specify the default value only, use the signature that takes a single parameter of type <xref:System.Object>.</span></span> <span data-ttu-id="a5f75-196">将该对象参数传递为你的属性的特定于类型的默认值（提供的默认值必须为你作为 <xref:System.Windows.DependencyProperty.Register%2A> 调用中的 `propertyType` 参数提供的类型）。</span><span class="sxs-lookup"><span data-stu-id="a5f75-196">Pass that object parameter as a type-specific default value for your property (the default value provided must be the type you provided as the `propertyType` parameter in the <xref:System.Windows.DependencyProperty.Register%2A> call).</span></span>

<span data-ttu-id="a5f75-197">对于 <xref:System.Windows.FrameworkPropertyMetadata>，还可以指定属性的元数据选项标志。</span><span class="sxs-lookup"><span data-stu-id="a5f75-197">For <xref:System.Windows.FrameworkPropertyMetadata>, you can also specify metadata option flags for your property.</span></span> <span data-ttu-id="a5f75-198">注册后这些标记会转换为属性元素据上的不同属性，并用于将某些条件传送给布局引擎等其他进程。</span><span class="sxs-lookup"><span data-stu-id="a5f75-198">These flags are converted into discrete properties on the property metadata after registration and are used to communicate certain conditionals to other processes such as the layout engine.</span></span>

#### <a name="setting-appropriate-metadata-flags"></a><span data-ttu-id="a5f75-199">设置合适的元数据标记</span><span class="sxs-lookup"><span data-stu-id="a5f75-199">Setting Appropriate Metadata Flags</span></span>

- <span data-ttu-id="a5f75-200">如果您的属性（或其值的更改）影响 [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)]，特别影响布局系统应如何调整页面中元素的大小或呈现元素，请设置以下一个或多个标志： <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure>、<xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender>。</span><span class="sxs-lookup"><span data-stu-id="a5f75-200">If your property (or changes in its value) affects the [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)], and in particular affects how the layout system should size or render your element in a page, set one or more of the following flags: <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure>, <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange>, <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender>.</span></span>

  - <span data-ttu-id="a5f75-201"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure> 指示对此属性的更改需要更改 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 呈现，其中包含对象在父项中可能需要更多或更少的空间。</span><span class="sxs-lookup"><span data-stu-id="a5f75-201"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure> indicates that a change to this property requires a change to [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] rendering where the containing object might require more or less space within the parent.</span></span> <span data-ttu-id="a5f75-202">例如，“宽度”属性应该设置此标记。</span><span class="sxs-lookup"><span data-stu-id="a5f75-202">For example, a "Width" property should have this flag set.</span></span>

  - <span data-ttu-id="a5f75-203"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange> 指示对此属性的更改需要更改 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 呈现，这通常不需要在专用空间中进行更改，而是指示空间中的位置已更改。</span><span class="sxs-lookup"><span data-stu-id="a5f75-203"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange> indicates that a change to this property requires a change to [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] rendering that typically does not require a change in the dedicated space, but does indicate that the positioning within the space has changed.</span></span> <span data-ttu-id="a5f75-204">例如，“对齐”属性应该设置此标记。</span><span class="sxs-lookup"><span data-stu-id="a5f75-204">For example, an "Alignment" property should have this flag set.</span></span>

  - <span data-ttu-id="a5f75-205"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender> 指示发生了其他一些更改，这些更改不会影响布局和度量值，但需要其他呈现。</span><span class="sxs-lookup"><span data-stu-id="a5f75-205"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender> indicates that some other change has occurred that will not affect layout and measure, but does require another render.</span></span> <span data-ttu-id="a5f75-206">更改现有元素的颜色的属性便是一个示例，例如“背景”。</span><span class="sxs-lookup"><span data-stu-id="a5f75-206">An example would be a property that changes a color of an existing element, such as "Background".</span></span>

  - <span data-ttu-id="a5f75-207">对属性系统或布局回调进行自己的替代实现时，这些标记通常用作元数据中的协议。</span><span class="sxs-lookup"><span data-stu-id="a5f75-207">These flags are often used as a protocol in metadata for your own override implementations of property system or layout callbacks.</span></span> <span data-ttu-id="a5f75-208">例如，如果实例的任何属性报告值更改并在其元数据中具有 `true` <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>，则可以使用 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 回调来调用 <xref:System.Windows.UIElement.InvalidateArrange%2A>。</span><span class="sxs-lookup"><span data-stu-id="a5f75-208">For instance, you might have an <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> callback that will call <xref:System.Windows.UIElement.InvalidateArrange%2A> if any property of the instance reports a value change and has <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> as `true` in its metadata.</span></span>

- <span data-ttu-id="a5f75-209">超出上述所需大小时，某些属性可能会影响所含父元素的呈现特征。</span><span class="sxs-lookup"><span data-stu-id="a5f75-209">Some properties may affect the rendering characteristics of the containing parent element, in ways above and beyond the changes in required size mentioned above.</span></span> <span data-ttu-id="a5f75-210">例如，在流文档模型中使用的 <xref:System.Windows.Documents.Paragraph.MinOrphanLines%2A> 属性，其中对该属性的更改可以更改包含该段落的流文档的总体呈现。</span><span class="sxs-lookup"><span data-stu-id="a5f75-210">An example is the <xref:System.Windows.Documents.Paragraph.MinOrphanLines%2A> property used in the flow document model, where changes to that property can change the overall rendering of the flow document that contains the paragraph.</span></span> <span data-ttu-id="a5f75-211">使用 <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentArrange> 或 <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentMeasure> 来识别您自己的属性中的相似事例。</span><span class="sxs-lookup"><span data-stu-id="a5f75-211">Use <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentArrange> or <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentMeasure> to identify similar cases in your own properties.</span></span>

- <span data-ttu-id="a5f75-212">默认情况下，依赖属性支持数据绑定。</span><span class="sxs-lookup"><span data-stu-id="a5f75-212">By default, dependency properties support data binding.</span></span> <span data-ttu-id="a5f75-213">在无实际的数据绑定方案或大型对象的数据绑定性能构成问题的情况下，可有意禁用数据绑定。</span><span class="sxs-lookup"><span data-stu-id="a5f75-213">You can deliberately disable data binding, for cases where there is no realistic scenario for data binding, or where performance in data binding for a large object is recognized as a problem.</span></span>

- <span data-ttu-id="a5f75-214">默认情况下，依赖属性 <xref:System.Windows.Data.Binding.Mode%2A> 的数据绑定默认为 <xref:System.Windows.Data.BindingMode.OneWay>。</span><span class="sxs-lookup"><span data-stu-id="a5f75-214">By default, data binding <xref:System.Windows.Data.Binding.Mode%2A> for dependency properties defaults to <xref:System.Windows.Data.BindingMode.OneWay>.</span></span> <span data-ttu-id="a5f75-215">您始终可以将绑定更改为每个绑定实例 <xref:System.Windows.Data.BindingMode.TwoWay>;有关详细信息，请参阅[指定绑定的方向](../data/how-to-specify-the-direction-of-the-binding.md)。</span><span class="sxs-lookup"><span data-stu-id="a5f75-215">You can always change the binding to be <xref:System.Windows.Data.BindingMode.TwoWay> per binding instance; for details, see [Specify the Direction of the Binding](../data/how-to-specify-the-direction-of-the-binding.md).</span></span> <span data-ttu-id="a5f75-216">但作为依赖属性作者，你可以选择在默认情况下将属性用于 <xref:System.Windows.Data.BindingMode.TwoWay> 绑定模式。</span><span class="sxs-lookup"><span data-stu-id="a5f75-216">But as the dependency property author, you can choose to make the property use <xref:System.Windows.Data.BindingMode.TwoWay> binding mode by default.</span></span> <span data-ttu-id="a5f75-217"><xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A?displayProperty=nameWithType>了现有依赖属性的示例;此属性的方案是 <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> 设置逻辑和 <xref:System.Windows.Controls.MenuItem> 的组合与默认主题样式交互。</span><span class="sxs-lookup"><span data-stu-id="a5f75-217">An example of an existing dependency property is <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A?displayProperty=nameWithType>; the scenario for this property is that the <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> setting logic and the compositing of <xref:System.Windows.Controls.MenuItem> interact with the default theme style.</span></span> <span data-ttu-id="a5f75-218"><xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> 属性逻辑使用数据绑定来根据其他状态属性和方法调用来维护属性的状态。</span><span class="sxs-lookup"><span data-stu-id="a5f75-218">The <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> property logic uses data binding natively to maintain the state of the property in accordance to other state properties and method calls.</span></span> <span data-ttu-id="a5f75-219">默认情况下，绑定 <xref:System.Windows.Data.BindingMode.TwoWay> 的另一个示例属性为 <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="a5f75-219">Another example property that binds <xref:System.Windows.Data.BindingMode.TwoWay> by default is <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=nameWithType>.</span></span>

- <span data-ttu-id="a5f75-220">还可以通过设置 <xref:System.Windows.FrameworkPropertyMetadataOptions.Inherits> 标志来启用自定义依赖属性中的属性继承。</span><span class="sxs-lookup"><span data-stu-id="a5f75-220">You can also enable property inheritance in a custom dependency property by setting the <xref:System.Windows.FrameworkPropertyMetadataOptions.Inherits> flag.</span></span> <span data-ttu-id="a5f75-221">在父元素和子元素具有相同属性的情况中，属性继承非常有用，它可以使子元素将该特定属性值设置为与父元素设置的值相同。</span><span class="sxs-lookup"><span data-stu-id="a5f75-221">Property inheritance is useful for a scenario where parent elements and child elements have a property in common, and it makes sense for the child elements to have that particular property value set to the same value as the parent set it.</span></span> <span data-ttu-id="a5f75-222">示例可 <xref:System.Windows.FrameworkElement.DataContext%2A>可继承属性，该属性用于绑定操作，以便为数据呈现启用重要的主-从方案。</span><span class="sxs-lookup"><span data-stu-id="a5f75-222">An example inheritable property is <xref:System.Windows.FrameworkElement.DataContext%2A>, which is used for binding operations to enable the important master-detail scenario for data presentation.</span></span> <span data-ttu-id="a5f75-223">通过使 <xref:System.Windows.FrameworkElement.DataContext%2A> 可继承，任何子元素也会继承该数据上下文。</span><span class="sxs-lookup"><span data-stu-id="a5f75-223">By making <xref:System.Windows.FrameworkElement.DataContext%2A> inheritable, any child elements inherit that data context also.</span></span> <span data-ttu-id="a5f75-224">因为使用了属性值继承，你可以在页面或应用程序根目录上指定数据上下文，而无需对所有可能子元素中的绑定重新指定上下文。</span><span class="sxs-lookup"><span data-stu-id="a5f75-224">Because of property value inheritance, you can specify a data context at the page or application root, and do not need to respecify it for bindings in all possible child elements.</span></span> <span data-ttu-id="a5f75-225"><xref:System.Windows.FrameworkElement.DataContext%2A> 也是一个很好的示例，用于说明继承重写默认值，但它始终可以在任何特定的子元素上本地设置;有关详细信息，请参阅对[分层数据使用主-从模式](../data/how-to-use-the-master-detail-pattern-with-hierarchical-data.md)。</span><span class="sxs-lookup"><span data-stu-id="a5f75-225"><xref:System.Windows.FrameworkElement.DataContext%2A> is also a good example to illustrate that inheritance overrides the default value, but it can always be set locally on any particular child element; for details, see [Use the Master-Detail Pattern with Hierarchical Data](../data/how-to-use-the-master-detail-pattern-with-hierarchical-data.md).</span></span> <span data-ttu-id="a5f75-226">属性值继承确实可能存在性能成本，因此应谨慎使用；有关详细信息，请参阅[属性值继承](property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="a5f75-226">Property value inheritance does have a possible performance cost, and thus should be used sparingly; for details, see [Property Value Inheritance](property-value-inheritance.md).</span></span>

- <span data-ttu-id="a5f75-227">将 <xref:System.Windows.FrameworkPropertyMetadataOptions.Journal> 标志设置为，以指示是否应检测依赖属性或导航日记服务使用依赖属性。</span><span class="sxs-lookup"><span data-stu-id="a5f75-227">Set the <xref:System.Windows.FrameworkPropertyMetadataOptions.Journal> flag to indicate if your dependency property should be detected or used by navigation journaling services.</span></span> <span data-ttu-id="a5f75-228">例如 <xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A> 属性;导航日志记录历史记录时，选择控件中选定的任何项都应保留。</span><span class="sxs-lookup"><span data-stu-id="a5f75-228">An example is the <xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A> property; any item selected in a selection control should be persisted when the journaling history is navigated.</span></span>

<a name="RODP"></a>

## <a name="read-only-dependency-properties"></a><span data-ttu-id="a5f75-229">只读依赖项属性</span><span class="sxs-lookup"><span data-stu-id="a5f75-229">Read-Only Dependency Properties</span></span>

<span data-ttu-id="a5f75-230">可以定义只读的依赖属性。</span><span class="sxs-lookup"><span data-stu-id="a5f75-230">You can define a dependency property that is read-only.</span></span> <span data-ttu-id="a5f75-231">但是，为何将属性定义为只读的情况略有不同，其过程与在属性系统中注册属性并公开标识符相同。</span><span class="sxs-lookup"><span data-stu-id="a5f75-231">However, the scenarios for why you might define your property as read-only are somewhat different, as is the procedure for registering them with the property system and exposing the identifier.</span></span> <span data-ttu-id="a5f75-232">有关详细信息，请参阅[只读依赖属性](read-only-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="a5f75-232">For more information, see [Read-Only Dependency Properties](read-only-dependency-properties.md).</span></span>

<a name="CTDP"></a>

## <a name="collection-type-dependency-properties"></a><span data-ttu-id="a5f75-233">集合类型依赖项属性</span><span class="sxs-lookup"><span data-stu-id="a5f75-233">Collection-Type Dependency Properties</span></span>

<span data-ttu-id="a5f75-234">集合类型依赖属性要考虑一些其他实现问题。</span><span class="sxs-lookup"><span data-stu-id="a5f75-234">Collection-type dependency properties have some additional implementation issues to consider.</span></span> <span data-ttu-id="a5f75-235">有关详细信息，请参阅[集合类型依赖属性](collection-type-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="a5f75-235">For details, see [Collection-Type Dependency Properties](collection-type-dependency-properties.md).</span></span>

<a name="SecurityC"></a>

## <a name="dependency-property-security-considerations"></a><span data-ttu-id="a5f75-236">依赖属性安全注意事项</span><span class="sxs-lookup"><span data-stu-id="a5f75-236">Dependency Property Security Considerations</span></span>

<span data-ttu-id="a5f75-237">依赖属性应声明为公共属性。</span><span class="sxs-lookup"><span data-stu-id="a5f75-237">Dependency properties should be declared as public properties.</span></span> <span data-ttu-id="a5f75-238">依赖属性标识符字段应声明为公共静态字段。</span><span class="sxs-lookup"><span data-stu-id="a5f75-238">Dependency property identifier fields should be declared as public static fields.</span></span> <span data-ttu-id="a5f75-239">即使您尝试声明其他访问级别（如受保护），也始终可以通过标识符与属性系统 Api 一起访问依赖属性。</span><span class="sxs-lookup"><span data-stu-id="a5f75-239">Even if you attempt to declare other access levels (such as protected), a dependency property can always be accessed through the identifier in combination with the property system APIs.</span></span> <span data-ttu-id="a5f75-240">即使是受保护的标识符字段也可能是可访问的，因为元数据报告或值确定 Api 是属性系统的一部分，如 <xref:System.Windows.LocalValueEnumerator>。</span><span class="sxs-lookup"><span data-stu-id="a5f75-240">Even a protected identifier field is potentially accessible because of metadata reporting or value determination APIs that are part of the property system, such as <xref:System.Windows.LocalValueEnumerator>.</span></span> <span data-ttu-id="a5f75-241">有关详细信息，请参阅[依赖属性的安全性](dependency-property-security.md)。</span><span class="sxs-lookup"><span data-stu-id="a5f75-241">For more information, see [Dependency Property Security](dependency-property-security.md).</span></span>

<a name="DPCtor"></a>

## <a name="dependency-properties-and-class-constructors"></a><span data-ttu-id="a5f75-242">依赖属性和类构造函数</span><span class="sxs-lookup"><span data-stu-id="a5f75-242">Dependency Properties and Class Constructors</span></span>

<span data-ttu-id="a5f75-243">托管代码编程（通常通过FxCop 等代码分析工具强制执行）的一般原则是：类构造函数不应调用虚方法。</span><span class="sxs-lookup"><span data-stu-id="a5f75-243">There is a general principle in managed code programming (often enforced by code analysis tools such as FxCop) that class constructors should not call virtual methods.</span></span> <span data-ttu-id="a5f75-244">这是因为构造函数可以作为派生的类构造函数的基本初始化来调用，并且可能会在所构造的对象实例不完全初始化状态下通过构造函数输入虚方法。</span><span class="sxs-lookup"><span data-stu-id="a5f75-244">This is because constructors can be called as base initialization of a derived class constructor, and entering the virtual method through the constructor might occur at an incomplete initialization state of the object instance being constructed.</span></span> <span data-ttu-id="a5f75-245">当从已从 <xref:System.Windows.DependencyObject>派生的任何类派生时，应注意属性系统本身在内部调用并公开了虚方法。</span><span class="sxs-lookup"><span data-stu-id="a5f75-245">When you derive from any class that already derives from <xref:System.Windows.DependencyObject>, you should be aware that the property system itself calls and exposes virtual methods internally.</span></span> <span data-ttu-id="a5f75-246">这些虚方法属于 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 属性系统服务。</span><span class="sxs-lookup"><span data-stu-id="a5f75-246">These virtual methods are part of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system services.</span></span> <span data-ttu-id="a5f75-247">替代方法会使派生类参与值确定。</span><span class="sxs-lookup"><span data-stu-id="a5f75-247">Overriding the methods enables derived classes to participate in value determination.</span></span> <span data-ttu-id="a5f75-248">为避免运行时初始化出现潜在问题，，不应该在类的构造函数中设置依赖属性值，除非遵循特定的构造函数模式进行操作。</span><span class="sxs-lookup"><span data-stu-id="a5f75-248">To avoid potential issues with runtime initialization, you should not set dependency property values within constructors of classes, unless you follow a very specific constructor pattern.</span></span> <span data-ttu-id="a5f75-249">有关详细信息，请参阅 [DependencyObject 的安全构造函数模式](safe-constructor-patterns-for-dependencyobjects.md)。</span><span class="sxs-lookup"><span data-stu-id="a5f75-249">For details, see [Safe Constructor Patterns for DependencyObjects](safe-constructor-patterns-for-dependencyobjects.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="a5f75-250">请参阅</span><span class="sxs-lookup"><span data-stu-id="a5f75-250">See also</span></span>

- [<span data-ttu-id="a5f75-251">依赖项属性概述</span><span class="sxs-lookup"><span data-stu-id="a5f75-251">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="a5f75-252">依赖属性元数据</span><span class="sxs-lookup"><span data-stu-id="a5f75-252">Dependency Property Metadata</span></span>](dependency-property-metadata.md)
- [<span data-ttu-id="a5f75-253">控件创作概述</span><span class="sxs-lookup"><span data-stu-id="a5f75-253">Control Authoring Overview</span></span>](../controls/control-authoring-overview.md)
- [<span data-ttu-id="a5f75-254">集合类型依赖属性</span><span class="sxs-lookup"><span data-stu-id="a5f75-254">Collection-Type Dependency Properties</span></span>](collection-type-dependency-properties.md)
- [<span data-ttu-id="a5f75-255">依赖属性的安全性</span><span class="sxs-lookup"><span data-stu-id="a5f75-255">Dependency Property Security</span></span>](dependency-property-security.md)
- [<span data-ttu-id="a5f75-256">XAML 加载和依赖项属性</span><span class="sxs-lookup"><span data-stu-id="a5f75-256">XAML Loading and Dependency Properties</span></span>](xaml-loading-and-dependency-properties.md)
- [<span data-ttu-id="a5f75-257">DependencyObject 的安全构造函数模式</span><span class="sxs-lookup"><span data-stu-id="a5f75-257">Safe Constructor Patterns for DependencyObjects</span></span>](safe-constructor-patterns-for-dependencyobjects.md)
