---
title: "在 Win32 和 WPF 之间共享消息循环"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- Win32 code [WPF], sharing message loops
- message loops [WPF]
- sharing message loops [WPF]
- interoperability [WPF], Win32
ms.assetid: 39ee888c-e5ec-41c8-b11f-7b851a554442
caps.latest.revision: "10"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.openlocfilehash: dcf8baa87038bc5625d46968b39d759daae25cbc
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/21/2017
---
# <a name="sharing-message-loops-between-win32-and-wpf"></a><span data-ttu-id="4e3cb-102">在 Win32 和 WPF 之间共享消息循环</span><span class="sxs-lookup"><span data-stu-id="4e3cb-102">Sharing Message Loops Between Win32 and WPF</span></span>
<span data-ttu-id="4e3cb-103">本主题介绍如何实现与互操作的消息循环[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]，通过使用现有消息中的循环公开<xref:System.Windows.Threading.Dispatcher>或通过创建单独的消息循环上[!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)]侧的互操作代码。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-103">This topic describes how to implement a message loop for interoperation with [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], either by using existing message loop exposure in <xref:System.Windows.Threading.Dispatcher> or by creating a separate message loop on the [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] side of your interoperation code.</span></span>  
  
## <a name="componentdispatcher-and-the-message-loop"></a><span data-ttu-id="4e3cb-104">ComponentDispatcher 和消息循环</span><span class="sxs-lookup"><span data-stu-id="4e3cb-104">ComponentDispatcher and the Message Loop</span></span>  
 <span data-ttu-id="4e3cb-105">间的互操作和键盘事件支持的一般方案是实现<xref:System.Windows.Interop.IKeyboardInputSink>，或从已实现的类的子类化<xref:System.Windows.Interop.IKeyboardInputSink>，如<xref:System.Windows.Interop.HwndSource>或<xref:System.Windows.Interop.HwndHost>。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-105">A normal scenario for interoperation and keyboard event support is to implement <xref:System.Windows.Interop.IKeyboardInputSink>, or to subclass from classes that already implement <xref:System.Windows.Interop.IKeyboardInputSink>, such as <xref:System.Windows.Interop.HwndSource> or <xref:System.Windows.Interop.HwndHost>.</span></span> <span data-ttu-id="4e3cb-106">但是，键盘接收器支持不能解决你可能必须发送和接收跨互操作边界的消息时的所有可能的消息循环需求。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-106">However, keyboard sink support does not address all possible message loop needs you might have when sending and receiving messages across your interoperation boundaries.</span></span> <span data-ttu-id="4e3cb-107">若要帮助正式化应用程序消息循环的体系结构，[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]提供<xref:System.Windows.Interop.ComponentDispatcher>类，该类定义消息循环，以按照简单协议。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-107">To help formalize an application message loop architecture, [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] provides the <xref:System.Windows.Interop.ComponentDispatcher> class, which defines a simple protocol for a message loop to follow.</span></span>  
  
 <span data-ttu-id="4e3cb-108"><xref:System.Windows.Interop.ComponentDispatcher>是一个静态类，公开多个成员。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-108"><xref:System.Windows.Interop.ComponentDispatcher> is a static class that exposes several members.</span></span> <span data-ttu-id="4e3cb-109">每个方法的作用域是隐式绑定到调用的线程。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-109">The scope of each method is implicitly tied to the calling thread.</span></span> <span data-ttu-id="4e3cb-110">消息循环必须调用其中一些[!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]在关键时刻 （如在下一节中定义）。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-110">A message loop must call some of those [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] at critical times (as defined in the next section).</span></span>  
  
 <span data-ttu-id="4e3cb-111"><xref:System.Windows.Interop.ComponentDispatcher>提供 （例如键盘接收器中） 的其他组件可以侦听的事件。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-111"><xref:System.Windows.Interop.ComponentDispatcher> provides events that other components (such as the keyboard sink) can listen for.</span></span> <span data-ttu-id="4e3cb-112"><xref:System.Windows.Threading.Dispatcher>类调用所有相应<xref:System.Windows.Interop.ComponentDispatcher>恰当的顺序的方法。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-112">The <xref:System.Windows.Threading.Dispatcher> class calls all the appropriate <xref:System.Windows.Interop.ComponentDispatcher> methods in an appropriate sequence.</span></span> <span data-ttu-id="4e3cb-113">如果你要实现您自己的消息循环，你的代码负责调用<xref:System.Windows.Interop.ComponentDispatcher>以类似的方式的方法。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-113">If you are implementing your own message loop, your code is responsible for calling <xref:System.Windows.Interop.ComponentDispatcher> methods in a similar fashion.</span></span>  
  
 <span data-ttu-id="4e3cb-114">调用<xref:System.Windows.Interop.ComponentDispatcher>在线程上的方法将仅调用在该线程注册的事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-114">Calling <xref:System.Windows.Interop.ComponentDispatcher> methods on a thread will only invoke event handlers that were registered on that thread.</span></span>  
  
## <a name="writing-message-loops"></a><span data-ttu-id="4e3cb-115">写入消息循环</span><span class="sxs-lookup"><span data-stu-id="4e3cb-115">Writing Message Loops</span></span>  
 <span data-ttu-id="4e3cb-116">下面是清单<xref:System.Windows.Interop.ComponentDispatcher>如果你编写您自己的消息循环将使用的成员：</span><span class="sxs-lookup"><span data-stu-id="4e3cb-116">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you write your own message loop:</span></span>  
  
-   <span data-ttu-id="4e3cb-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>： 您的消息循环应调用此成员以指示该线程是模式。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: your message loop should call this to indicate that the thread is modal.</span></span>  
  
-   <span data-ttu-id="4e3cb-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>： 您的消息循环应调用此成员以指示线程已还原为非模式线程。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>:your message loop should call this to indicate that the thread has reverted to nonmodal.</span></span>  
  
-   <span data-ttu-id="4e3cb-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>： 您的消息循环应调用此成员，则指示<xref:System.Windows.Interop.ComponentDispatcher>应引发<xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>事件。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>: your message loop should call this to indicate that <xref:System.Windows.Interop.ComponentDispatcher> should raise the <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> event.</span></span> <span data-ttu-id="4e3cb-120"><xref:System.Windows.Interop.ComponentDispatcher>不会引发<xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>如果<xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>是`true`，但也可以选择消息循环调用<xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>即使<xref:System.Windows.Interop.ComponentDispatcher>无法响应在模式状态。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-120"><xref:System.Windows.Interop.ComponentDispatcher> will not raise <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> if <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> is `true`, but message loops may choose to call <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> even if <xref:System.Windows.Interop.ComponentDispatcher> cannot respond to it while in modal state.</span></span>  
  
-   <span data-ttu-id="4e3cb-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>： 您的消息循环应调用它表示一条新消息是否可用。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: your message loop should call this to indicate that a new message is available.</span></span> <span data-ttu-id="4e3cb-122">返回值指示是否为侦听器<xref:System.Windows.Interop.ComponentDispatcher>处理事件的消息。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-122">The return value indicates whether a listener to a <xref:System.Windows.Interop.ComponentDispatcher> event handled the message.</span></span> <span data-ttu-id="4e3cb-123">如果<xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>返回`true`（处理），调度程序应进行任何进一步的消息。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-123">If <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> returns `true` (handled), the dispatcher should do nothing further with the message.</span></span> <span data-ttu-id="4e3cb-124">如果返回值为`false`，调度程序需要调用[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]函数`TranslateMessage`，然后调用`DispatchMessage`。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-124">If the return value is `false`, the dispatcher is expected to call the [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] function `TranslateMessage`, then call `DispatchMessage`.</span></span>  
  
## <a name="using-componentdispatcher-and-existing-message-handling"></a><span data-ttu-id="4e3cb-125">使用 ComponentDispatcher 和现有消息处理</span><span class="sxs-lookup"><span data-stu-id="4e3cb-125">Using ComponentDispatcher and Existing Message Handling</span></span>  
 <span data-ttu-id="4e3cb-126">下面是清单<xref:System.Windows.Interop.ComponentDispatcher>成员将使用如果依赖于固有[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]消息循环。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-126">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you rely on the inherent [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] message loop.</span></span>  
  
-   <span data-ttu-id="4e3cb-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>： 返回应用程序是否已进入模式状态 （例如，模式的消息循环已推送）。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: returns whether the application has gone modal (e.g., a modal message loop has been pushed).</span></span> <span data-ttu-id="4e3cb-128"><xref:System.Windows.Interop.ComponentDispatcher>可以跟踪此状态，因为该类维护的计数<xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>和<xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>从消息循环的调用。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-128"><xref:System.Windows.Interop.ComponentDispatcher> can track this state because the class maintains a count of <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> and <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> calls from the message loop.</span></span>  
  
-   <span data-ttu-id="4e3cb-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>和<xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>事件遵循标准规则进行委托调用。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> and <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> events follow the standard rules for delegate invocations.</span></span> <span data-ttu-id="4e3cb-130">未指定顺序调用委托和即使第一个将该消息标记为已处理调用所有委托。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-130">Delegates are invoked in an unspecified order, and all delegates are invoked even if the first one marks the message as handled.</span></span>  
  
-   <span data-ttu-id="4e3cb-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>： 指示执行空闲处理适当和有效时间 （没有其他挂起消息线程）。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: indicates an appropriate and efficient time to do idle processing (there are no other pending messages for the thread).</span></span> <span data-ttu-id="4e3cb-132"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>将不会引发如果线程是模式。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-132"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> will not be raised if the thread is modal.</span></span>  
  
-   <span data-ttu-id="4e3cb-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>： 引发的所有消息泵处理的消息。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: raised for all messages that the message pump processes.</span></span>  
  
-   <span data-ttu-id="4e3cb-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>： 为期间尚未处理的所有消息引发<xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: raised for all messages that were not handled during <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>.</span></span>  
  
 <span data-ttu-id="4e3cb-135">则认为该消息后的处理的如果<xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>事件或<xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>事件，`handled`通过在事件数据中的引用传递的参数是`true`。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-135">A message is considered handled if after the <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> event or <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> event, the `handled` parameter passed by reference in event data is `true`.</span></span> <span data-ttu-id="4e3cb-136">事件处理程序应忽略该消息，如果`handled`是`true`，因为这意味着不同的处理程序首先处理该消息。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-136">Event handlers should ignore the message if `handled` is `true`, because that means the different handler handled the message first.</span></span> <span data-ttu-id="4e3cb-137">这两个事件的事件处理程序可以修改该消息。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-137">Event handlers to both events may modify the message.</span></span> <span data-ttu-id="4e3cb-138">调度程序应调度修改后的消息而非原始不变的消息。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-138">The dispatcher should dispatch the modified message and not the original unchanged message.</span></span> <span data-ttu-id="4e3cb-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>传递到所有的侦听器，但体系结构的意图是仅包含目标的消息应从该处调用代码以响应消息的 HWND 的顶级窗口。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is delivered to all listeners, but the architectural intention is that only the top-level window containing the HWND at which the messages targeted should invoke code in response to the message.</span></span>  
  
## <a name="how-hwndsource-treats-componentdispatcher-events"></a><span data-ttu-id="4e3cb-140">HwndSource 如何处理 ComponentDispatcher 事件</span><span class="sxs-lookup"><span data-stu-id="4e3cb-140">How HwndSource Treats ComponentDispatcher Events</span></span>  
 <span data-ttu-id="4e3cb-141">如果<xref:System.Windows.Interop.HwndSource>为顶级窗口 （没有父级 HWND），它将注册<xref:System.Windows.Interop.ComponentDispatcher>。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-141">If the <xref:System.Windows.Interop.HwndSource> is a top-level window (no parent HWND), it will register with <xref:System.Windows.Interop.ComponentDispatcher>.</span></span> <span data-ttu-id="4e3cb-142">如果<xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>引发时，如果消息是否适用于<xref:System.Windows.Interop.HwndSource>或子窗口<xref:System.Windows.Interop.HwndSource>调用其<xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>， <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>，<xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A>键盘接收器序列。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-142">If <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is raised, and if the message is intended for the <xref:System.Windows.Interop.HwndSource> or child windows, <xref:System.Windows.Interop.HwndSource> calls its <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> keyboard sink sequence.</span></span>  
  
 <span data-ttu-id="4e3cb-143">如果<xref:System.Windows.Interop.HwndSource>不是顶级窗口 （具有父 HWND），不将任何处理。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-143">If the <xref:System.Windows.Interop.HwndSource> is not a top-level window (has a parent HWND), there will be no handling.</span></span> <span data-ttu-id="4e3cb-144">只有顶级窗口应执行的处理，且存在预计会具有键盘接收器支持的最上层窗口作为任何互操作方案的一部分。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-144">Only the top level window is expected to do the handling, and there is expected to be a top level window with keyboard sink support as part of any interoperation scenario.</span></span>  
  
 <span data-ttu-id="4e3cb-145">如果<xref:System.Windows.Interop.HwndHost.WndProc%2A>上<xref:System.Windows.Interop.HwndSource>调用而无需首先调用相应的键盘接收器方法，你的应用程序将接收更高的级别的键盘事件如<xref:System.Windows.UIElement.KeyDown>。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-145">If <xref:System.Windows.Interop.HwndHost.WndProc%2A> on an <xref:System.Windows.Interop.HwndSource> is called without an appropriate keyboard sink method being called first, your application will receive the higher level keyboard events such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="4e3cb-146">但是，任何键盘接收器方法将不调用，从而避开了所需的键盘输入的模型功能，例如访问密钥支持。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-146">However, no keyboard sink methods will be called, which circumvents desirable keyboard input model features such as access key support.</span></span> <span data-ttu-id="4e3cb-147">这可能是因为消息循环没有正确上通知相关线程<xref:System.Windows.Interop.ComponentDispatcher>，或因为父 HWND 未调用正确键盘接收器响应。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-147">This might happen because the message loop did not properly notify the relevant thread on the <xref:System.Windows.Interop.ComponentDispatcher>, or because the parent HWND did not invoke the proper keyboard sink responses.</span></span>  
  
 <span data-ttu-id="4e3cb-148">如果通过使用添加挂钩，该消息将转到键盘接收器一条消息可能不为 HWND 会发送<xref:System.Windows.Interop.HwndSource.AddHook%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-148">A message that goes to the keyboard sink might not be sent to the HWND if you added hooks for that message by using the <xref:System.Windows.Interop.HwndSource.AddHook%2A> method.</span></span> <span data-ttu-id="4e3cb-149">消息可能已处理在消息泵级别直接而未提交给`DispatchMessage`函数。</span><span class="sxs-lookup"><span data-stu-id="4e3cb-149">The message might have been handled at the message pump level directly and not submitted to the `DispatchMessage` function.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="4e3cb-150">另请参阅</span><span class="sxs-lookup"><span data-stu-id="4e3cb-150">See Also</span></span>  
 <xref:System.Windows.Interop.ComponentDispatcher>  
 <xref:System.Windows.Interop.IKeyboardInputSink>  
 [<span data-ttu-id="4e3cb-151">WPF 和 Win32 互操作</span><span class="sxs-lookup"><span data-stu-id="4e3cb-151">WPF and Win32 Interoperation</span></span>](../../../../docs/framework/wpf/advanced/wpf-and-win32-interoperation.md)  
 [<span data-ttu-id="4e3cb-152">线程模型</span><span class="sxs-lookup"><span data-stu-id="4e3cb-152">Threading Model</span></span>](../../../../docs/framework/wpf/advanced/threading-model.md)  
 [<span data-ttu-id="4e3cb-153">输入概述</span><span class="sxs-lookup"><span data-stu-id="4e3cb-153">Input Overview</span></span>](../../../../docs/framework/wpf/advanced/input-overview.md)
