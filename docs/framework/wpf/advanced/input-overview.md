---
title: 输入概述
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- commands [WPF]
- input [WPF], overview
- keyboard focus [WPF]
- keyboard input [WPF]
- touch events [WPF]
- event routing [WPF]
- touch input [WPF]
- manipulation [WPF]
- logical focus [WPF]
- stylus input [WPF]
- text input [WPF]
- input events [WPF], handling
- WPF [WPF], input overview
- manipulation events [WPF]
- mouse input [WPF]
- mouse capture [WPF]
- focus [WPF]
- mouse position [WPF]
ms.assetid: ee5258b7-6567-415a-9b1c-c0cbe46e79ef
ms.openlocfilehash: a90c74542c1a6604ed27d37f882385b67402dd92
ms.sourcegitcommit: eff6adb61852369ab690f3f047818c90580e7eb1
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/07/2019
ms.locfileid: "72005030"
---
# <a name="input-overview"></a><span data-ttu-id="72759-102">输入概述</span><span class="sxs-lookup"><span data-stu-id="72759-102">Input Overview</span></span>
<a name="introduction"></a><span data-ttu-id="72759-103">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 子系统提供了一个功能强大的 API，用于获取各种设备（包括鼠标、键盘、触摸和触笔）的输入。</span><span class="sxs-lookup"><span data-stu-id="72759-103">The [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] subsystem provides a powerful API for obtaining input from a variety of devices, including the mouse, keyboard, touch, and stylus.</span></span> <span data-ttu-id="72759-104">本主题介绍了 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 提供的服务，并说明了输入系统的体系结构。</span><span class="sxs-lookup"><span data-stu-id="72759-104">This topic describes the services provided by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and explains the architecture of the input systems.</span></span>

<a name="input_api"></a>
## <a name="input-api"></a><span data-ttu-id="72759-105">输入 API</span><span class="sxs-lookup"><span data-stu-id="72759-105">Input API</span></span>
 <span data-ttu-id="72759-106">主要的输入 API 公开内容在基本元素类上： <xref:System.Windows.UIElement>、<xref:System.Windows.ContentElement>、<xref:System.Windows.FrameworkElement>和 <xref:System.Windows.FrameworkContentElement>。</span><span class="sxs-lookup"><span data-stu-id="72759-106">The primary input API exposure is found on the base element classes: <xref:System.Windows.UIElement>, <xref:System.Windows.ContentElement>, <xref:System.Windows.FrameworkElement>, and <xref:System.Windows.FrameworkContentElement>.</span></span>  <span data-ttu-id="72759-107">有关基元素的详细信息，请参阅[基元素概述](base-elements-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="72759-107">For more information about the base elements, see [Base Elements Overview](base-elements-overview.md).</span></span>  <span data-ttu-id="72759-108">这些类提供有关输入事件（例如按键、鼠标按钮、鼠标滚轮、鼠标移动、焦点管理和鼠标捕获等）的功能。</span><span class="sxs-lookup"><span data-stu-id="72759-108">These classes provide functionality for input events related to key presses, mouse buttons, mouse wheel, mouse movement, focus management, and mouse capture, to name a few.</span></span> <span data-ttu-id="72759-109">通过将输入 API 放在基元素上，而不是将所有输入事件视为一项服务，输入体系结构使输入事件可以通过 UI 中的特定对象来提供，并支持一个事件路由方案，使多个元素具有 opportunity 来处理输入事件。</span><span class="sxs-lookup"><span data-stu-id="72759-109">By placing the input API on the base elements, rather than treating all input events as a service, the input architecture enables the input events to be sourced by a particular object in the UI, and to support an event routing scheme whereby more than one element has an opportunity to handle an input event.</span></span> <span data-ttu-id="72759-110">许多输入事件都具有与之相关联的一对事件。</span><span class="sxs-lookup"><span data-stu-id="72759-110">Many input events have a pair of events associated with them.</span></span>  <span data-ttu-id="72759-111">例如，键按下事件与 <xref:System.Windows.Input.Keyboard.KeyDown> 和 <xref:System.Windows.Input.Keyboard.PreviewKeyDown> 事件关联。</span><span class="sxs-lookup"><span data-stu-id="72759-111">For example, the key down event is associated with the <xref:System.Windows.Input.Keyboard.KeyDown> and <xref:System.Windows.Input.Keyboard.PreviewKeyDown> events.</span></span>  <span data-ttu-id="72759-112">这些事件的区别在于它们如何路由至目标元素。</span><span class="sxs-lookup"><span data-stu-id="72759-112">The difference in these events is in how they are routed to the target element.</span></span>  <span data-ttu-id="72759-113">预览事件将元素树从根元素到目标元素向下进行隧道操作。</span><span class="sxs-lookup"><span data-stu-id="72759-113">Preview events tunnel down the element tree from the root element to the target element.</span></span>  <span data-ttu-id="72759-114">冒泡事件从目标元素到根元素向上进行冒泡操作。</span><span class="sxs-lookup"><span data-stu-id="72759-114">Bubbling events bubble up from the target element to the root element.</span></span>  <span data-ttu-id="72759-115">本概述后面部分和[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]路由事件概述[中更详细地讨论了 ](routed-events-overview.md) 中的事件路由。</span><span class="sxs-lookup"><span data-stu-id="72759-115">Event routing in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is discussed in more detail later in this overview and in the [Routed Events Overview](routed-events-overview.md).</span></span>

### <a name="keyboard-and-mouse-classes"></a><span data-ttu-id="72759-116">键盘和鼠标类</span><span class="sxs-lookup"><span data-stu-id="72759-116">Keyboard and Mouse Classes</span></span>
 <span data-ttu-id="72759-117">除了基本元素类上的输入 API 外，<xref:System.Windows.Input.Keyboard> 类和 <xref:System.Windows.Input.Mouse> 类还提供了用于使用键盘和鼠标输入的其他 API。</span><span class="sxs-lookup"><span data-stu-id="72759-117">In addition to the input API on the base element classes, the <xref:System.Windows.Input.Keyboard> class and <xref:System.Windows.Input.Mouse> classes provide additional API for working with keyboard and mouse input.</span></span>

 <span data-ttu-id="72759-118"><xref:System.Windows.Input.Keyboard> 类的输入 API 示例是 <xref:System.Windows.Input.Keyboard.Modifiers%2A> 属性，该属性返回当前按下的 <xref:System.Windows.Input.ModifierKeys> 和 <xref:System.Windows.Input.Keyboard.IsKeyDown%2A> 方法，该方法确定是否按下了指定的键。</span><span class="sxs-lookup"><span data-stu-id="72759-118">Examples of input API on the <xref:System.Windows.Input.Keyboard> class are the <xref:System.Windows.Input.Keyboard.Modifiers%2A> property, which returns the <xref:System.Windows.Input.ModifierKeys> currently pressed, and the <xref:System.Windows.Input.Keyboard.IsKeyDown%2A> method, which determines whether a specified key is pressed.</span></span>

 <span data-ttu-id="72759-119">下面的示例使用 <xref:System.Windows.Input.Keyboard.GetKeyStates%2A> 方法来确定 <xref:System.Windows.Input.Key> 是否处于关闭状态。</span><span class="sxs-lookup"><span data-stu-id="72759-119">The following example uses the <xref:System.Windows.Input.Keyboard.GetKeyStates%2A> method to determine if a <xref:System.Windows.Input.Key> is in the down state.</span></span>

 [!code-csharp[keyargssnippetsample#KeyEventArgsKeyBoardGetKeyStates](~/samples/snippets/csharp/VS_Snippets_Wpf/KeyArgsSnippetSample/CSharp/Window1.xaml.cs#keyeventargskeyboardgetkeystates)]
 [!code-vb[keyargssnippetsample#KeyEventArgsKeyBoardGetKeyStates](~/samples/snippets/visualbasic/VS_Snippets_Wpf/KeyArgsSnippetSample/visualbasic/window1.xaml.vb#keyeventargskeyboardgetkeystates)]

 <span data-ttu-id="72759-120"><xref:System.Windows.Input.Mouse> 类中的输入 API 的示例 <xref:System.Windows.Input.Mouse.MiddleButton%2A>，用于获取鼠标中键的状态 <xref:System.Windows.Input.Mouse.DirectlyOver%2A>，后者用于获取鼠标指针当前悬停的元素。</span><span class="sxs-lookup"><span data-stu-id="72759-120">Examples of input API on the <xref:System.Windows.Input.Mouse> class are <xref:System.Windows.Input.Mouse.MiddleButton%2A>, which obtains the state of the middle mouse button, and <xref:System.Windows.Input.Mouse.DirectlyOver%2A>, which gets the element the mouse pointer is currently over.</span></span>

 <span data-ttu-id="72759-121">下面的示例确定鼠标上的 <xref:System.Windows.Input.Mouse.LeftButton%2A> 是否处于 <xref:System.Windows.Input.MouseButtonState.Pressed> 状态。</span><span class="sxs-lookup"><span data-stu-id="72759-121">The following example determines whether the <xref:System.Windows.Input.Mouse.LeftButton%2A> on the mouse is in the <xref:System.Windows.Input.MouseButtonState.Pressed> state.</span></span>

 [!code-csharp[mouserelatedsnippets#MouseRelatedSnippetsGetLeftButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetleftbuttonmouse)]
 [!code-vb[mouserelatedsnippets#MouseRelatedSnippetsGetLeftButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetleftbuttonmouse)]

 <span data-ttu-id="72759-122">本概述中更详细地介绍了 <xref:System.Windows.Input.Mouse> 和 <xref:System.Windows.Input.Keyboard> 类。</span><span class="sxs-lookup"><span data-stu-id="72759-122">The <xref:System.Windows.Input.Mouse> and <xref:System.Windows.Input.Keyboard> classes are covered in more detail throughout this overview.</span></span>

### <a name="stylus-input"></a><span data-ttu-id="72759-123">触笔输入</span><span class="sxs-lookup"><span data-stu-id="72759-123">Stylus Input</span></span>
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="72759-124">具有对 <xref:System.Windows.Input.Stylus>的集成支持。</span><span class="sxs-lookup"><span data-stu-id="72759-124">has integrated support for the <xref:System.Windows.Input.Stylus>.</span></span>  <span data-ttu-id="72759-125"><xref:System.Windows.Input.Stylus> 是 Tablet PC 流行的笔输入。</span><span class="sxs-lookup"><span data-stu-id="72759-125">The <xref:System.Windows.Input.Stylus> is a pen input made popular by the Tablet PC.</span></span>  [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="72759-126">应用程序可以通过使用鼠标 API 将触笔视为鼠标，但 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 还会公开使用类似于键盘和鼠标的模型的触笔设备抽象。</span><span class="sxs-lookup"><span data-stu-id="72759-126">applications can treat the stylus as a mouse by using the mouse API, but [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] also exposes a stylus device abstraction that use a model similar to the keyboard and mouse.</span></span>  <span data-ttu-id="72759-127">与触笔相关的所有 Api 都包含 "触笔" 一词。</span><span class="sxs-lookup"><span data-stu-id="72759-127">All stylus-related APIs contain the word "Stylus".</span></span>

 <span data-ttu-id="72759-128">由于触笔可充当鼠标，因此仅支持鼠标输入的应用程序仍可以自动获得一定程度的触笔支持。</span><span class="sxs-lookup"><span data-stu-id="72759-128">Because the stylus can act as a mouse, applications that support only mouse input can still obtain some level of stylus support automatically.</span></span> <span data-ttu-id="72759-129">以这种方式使用触笔时，应用程序有能力处理相应的触笔事件，然后处理相应的鼠标事件。</span><span class="sxs-lookup"><span data-stu-id="72759-129">When the stylus is used in such a manner, the application is given the opportunity to handle the appropriate stylus event and then handles the corresponding mouse event.</span></span> <span data-ttu-id="72759-130">此外，通过触笔设备抽象也可以使用墨迹输入等较高级别的服务。</span><span class="sxs-lookup"><span data-stu-id="72759-130">In addition, higher-level services such as ink input are also available through the stylus device abstraction.</span></span>  <span data-ttu-id="72759-131">有关墨迹输入的详细信息，请参阅[墨迹入门](getting-started-with-ink.md)。</span><span class="sxs-lookup"><span data-stu-id="72759-131">For more information about ink as input, see [Getting Started with Ink](getting-started-with-ink.md).</span></span>

<a name="event_routing"></a>
## <a name="event-routing"></a><span data-ttu-id="72759-132">事件路由</span><span class="sxs-lookup"><span data-stu-id="72759-132">Event Routing</span></span>
 <span data-ttu-id="72759-133"><xref:System.Windows.FrameworkElement> 可以在其内容模型中包含其他元素作为子元素，从而形成元素树。</span><span class="sxs-lookup"><span data-stu-id="72759-133">A <xref:System.Windows.FrameworkElement> can contain other elements as child elements in its content model, forming a tree of elements.</span></span>  <span data-ttu-id="72759-134">在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中，父元素可以通过处理事件来参与定向到其子元素或其他后代的输入。</span><span class="sxs-lookup"><span data-stu-id="72759-134">In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], the parent element can participate in input directed to its child elements or other descendants by handing events.</span></span> <span data-ttu-id="72759-135">这特别适合于从较小的控件中生成控件，该过程称为“控件组合”或“合成”。</span><span class="sxs-lookup"><span data-stu-id="72759-135">This is especially useful for building controls out of smaller controls, a process known as "control composition" or "compositing."</span></span> <span data-ttu-id="72759-136">有关元素树以及元素树如何与事件路由关联的详细信息，请参阅 [WPF 中的树](trees-in-wpf.md)。</span><span class="sxs-lookup"><span data-stu-id="72759-136">For more information about element trees and how element trees relate to event routes, see [Trees in WPF](trees-in-wpf.md).</span></span>

 <span data-ttu-id="72759-137">事件路由是将事件转发到多个元素的过程，以便使路由中的特定对象或元素可以选择对已由其他元素指明来源的事件提供重要响应（通过处理）。</span><span class="sxs-lookup"><span data-stu-id="72759-137">Event routing is the process of forwarding events to multiple elements, so that a particular object or element along the route can choose to offer a significant response (through handling) to an event that might have been sourced by a different element.</span></span>  <span data-ttu-id="72759-138">路由事件使用三种路由机制的其中一种：直接、浮升和隧道。</span><span class="sxs-lookup"><span data-stu-id="72759-138">Routed events use one of three routing mechanisms: direct, bubbling, and tunneling.</span></span>  <span data-ttu-id="72759-139">在直接路由中，源元素是收到通知的唯一元素，事件不会路由至任何其他元素。</span><span class="sxs-lookup"><span data-stu-id="72759-139">In direct routing, the source element is the only element notified, and the event is not routed to any other elements.</span></span> <span data-ttu-id="72759-140">但是，直接路由事件仍会提供一些附加功能，这些功能仅适用于路由事件，而不是标准 CLR 事件。</span><span class="sxs-lookup"><span data-stu-id="72759-140">However, the direct routed event still offers some additional capabilities that are only present for routed events as opposed to standard CLR events.</span></span> <span data-ttu-id="72759-141">浮升操作在元素树中向上进行，首先通知指明了事件来源的第一个元素，然后是父元素等等。</span><span class="sxs-lookup"><span data-stu-id="72759-141">Bubbling works up the element tree by first notifying the element that sourced the event, then the parent element, and so on.</span></span>  <span data-ttu-id="72759-142">隧道操作从元素树的根开始，然后向下进行，以原始的源元素结束。</span><span class="sxs-lookup"><span data-stu-id="72759-142">Tunneling starts at the root of the element tree and works down, ending with the original source element.</span></span>  <span data-ttu-id="72759-143">有关路由事件的详细信息，请参阅[路由事件概述](routed-events-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="72759-143">For more information about routed events, see [Routed Events Overview](routed-events-overview.md).</span></span>

 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="72759-144">输入事件通常成对出现，由一个隧道事件和一个冒泡事件组成。</span><span class="sxs-lookup"><span data-stu-id="72759-144">input events generally come in pairs that consists of a tunneling event and a bubbling event.</span></span>  <span data-ttu-id="72759-145">隧道事件与冒泡事件的不同之处在于它有“预览”前缀。</span><span class="sxs-lookup"><span data-stu-id="72759-145">Tunneling events are distinguished from bubbling events with the "Preview" prefix.</span></span>  <span data-ttu-id="72759-146">例如，<xref:System.Windows.Input.Mouse.PreviewMouseMove> 是鼠标移动事件的隧道版本，<xref:System.Windows.Input.Mouse.MouseMove> 是此事件的冒泡版本。</span><span class="sxs-lookup"><span data-stu-id="72759-146">For instance, <xref:System.Windows.Input.Mouse.PreviewMouseMove> is the tunneling version of a mouse move event and <xref:System.Windows.Input.Mouse.MouseMove> is the bubbling version of this event.</span></span> <span data-ttu-id="72759-147">此事件配对是在元素级别实现的一种约定，不是 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 事件系统的固有功能。</span><span class="sxs-lookup"><span data-stu-id="72759-147">This event pairing is a convention that is implemented at the element level and is not an inherent capability of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event system.</span></span> <span data-ttu-id="72759-148">有关详细信息，请参阅[路由事件概述](routed-events-overview.md)中的 WPF 输入事件部分。</span><span class="sxs-lookup"><span data-stu-id="72759-148">For details, see the WPF Input Events section in [Routed Events Overview](routed-events-overview.md).</span></span>

<a name="handling_input_events"></a>
## <a name="handling-input-events"></a><span data-ttu-id="72759-149">处理输入事件</span><span class="sxs-lookup"><span data-stu-id="72759-149">Handling Input Events</span></span>
 <span data-ttu-id="72759-150">若要在元素上接收输入，必须将事件处理程序与该特定事件关联。</span><span class="sxs-lookup"><span data-stu-id="72759-150">To receive input on an element, an event handler must be associated with that particular event.</span></span>  <span data-ttu-id="72759-151">在 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 中，这很简单：将事件的名称作为要侦听此事件的元素的特性进行引用。</span><span class="sxs-lookup"><span data-stu-id="72759-151">In [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] this is straightforward: you reference the name of the event as an attribute of the element that will be listening for this event.</span></span>  <span data-ttu-id="72759-152">然后，根据委托，将特性的值设置为所定义的事件处理程序的名称。</span><span class="sxs-lookup"><span data-stu-id="72759-152">Then, you set the value of the attribute to the name of the event handler that you define, based on a delegate.</span></span>  <span data-ttu-id="72759-153">事件处理程序必须用代码（如） C#编写，并且可以包含在代码隐藏文件中。</span><span class="sxs-lookup"><span data-stu-id="72759-153">The event handler must be written in code such as C# and can be included in a code-behind file.</span></span>

 <span data-ttu-id="72759-154">当操作系统报告发生键操作时，如果键盘焦点正处在元素上，则将发生键盘事件。</span><span class="sxs-lookup"><span data-stu-id="72759-154">Keyboard events occur when the operating system reports key actions that occur while keyboard focus is on an element.</span></span> <span data-ttu-id="72759-155">鼠标和触笔事件分别分为两类：报告指针位置相对于元素的变化的事件，和报告设备按钮状态的变化的事件。</span><span class="sxs-lookup"><span data-stu-id="72759-155">Mouse and stylus events each fall into two categories: events that report changes in pointer position relative to the element, and events that report changes in the state of device buttons.</span></span>

### <a name="keyboard-input-event-example"></a><span data-ttu-id="72759-156">键盘输入事件示例</span><span class="sxs-lookup"><span data-stu-id="72759-156">Keyboard Input Event Example</span></span>
 <span data-ttu-id="72759-157">以下示例侦听按下向左键的操作。</span><span class="sxs-lookup"><span data-stu-id="72759-157">The following example listens for a left arrow key press.</span></span>  <span data-ttu-id="72759-158">创建具有 <xref:System.Windows.Controls.Button>的 <xref:System.Windows.Controls.StackPanel>。</span><span class="sxs-lookup"><span data-stu-id="72759-158">A <xref:System.Windows.Controls.StackPanel> is created that has a <xref:System.Windows.Controls.Button>.</span></span>  <span data-ttu-id="72759-159">用于侦听按下箭头键的事件处理程序是否附加到了 <xref:System.Windows.Controls.Button> 的实例。</span><span class="sxs-lookup"><span data-stu-id="72759-159">An event handler to listen for the left arrow key press is attached to the <xref:System.Windows.Controls.Button> instance.</span></span>

 <span data-ttu-id="72759-160">该示例的第一部分创建 <xref:System.Windows.Controls.StackPanel> 和 <xref:System.Windows.Controls.Button> 并附加 <xref:System.Windows.UIElement.KeyDown>的事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="72759-160">The first section of the example creates the <xref:System.Windows.Controls.StackPanel> and the <xref:System.Windows.Controls.Button> and attaches the event handler for the <xref:System.Windows.UIElement.KeyDown>.</span></span>

 [!code-xaml[InputOvw#Input_OvwKeyboardExampleXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#input_ovwkeyboardexamplexaml)]

 [!code-csharp[InputOvw#Input_OvwKeyboardExampleUICodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml.cs#input_ovwkeyboardexampleuicodebehind)]
 [!code-vb[InputOvw#Input_OvwKeyboardExampleUICodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InputOvw/VisualBasic/Page1.xaml.vb#input_ovwkeyboardexampleuicodebehind)]

 <span data-ttu-id="72759-161">第二部分用代码编写，定义了事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="72759-161">The second section is written in code and defines the event handler.</span></span>  <span data-ttu-id="72759-162">按下向左键并 <xref:System.Windows.Controls.Button> 具有键盘焦点时，处理程序将运行并更改 <xref:System.Windows.Controls.Button> 的 <xref:System.Windows.Controls.Control.Background%2A> 颜色。</span><span class="sxs-lookup"><span data-stu-id="72759-162">When the left arrow key is pressed and the <xref:System.Windows.Controls.Button> has keyboard focus, the handler runs and the <xref:System.Windows.Controls.Control.Background%2A> color of the <xref:System.Windows.Controls.Button> is changed.</span></span>  <span data-ttu-id="72759-163">如果按下了该键但它不是左箭头键，则 <xref:System.Windows.Controls.Button> 的 <xref:System.Windows.Controls.Control.Background%2A> 颜色会改回其起始颜色。</span><span class="sxs-lookup"><span data-stu-id="72759-163">If the key is pressed, but it is not the left arrow key, the <xref:System.Windows.Controls.Control.Background%2A> color of the <xref:System.Windows.Controls.Button> is changed back to its starting color.</span></span>

 [!code-csharp[InputOvw#Input_OvwKeyboardExampleHandlerCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml.cs#input_ovwkeyboardexamplehandlercodebehind)]
 [!code-vb[InputOvw#Input_OvwKeyboardExampleHandlerCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InputOvw/VisualBasic/Page1.xaml.vb#input_ovwkeyboardexamplehandlercodebehind)]

### <a name="mouse-input-event-example"></a><span data-ttu-id="72759-164">鼠标输入事件示例</span><span class="sxs-lookup"><span data-stu-id="72759-164">Mouse Input Event Example</span></span>
 <span data-ttu-id="72759-165">在下面的示例中，当鼠标指针进入 <xref:System.Windows.Controls.Button>时，<xref:System.Windows.Controls.Button> 的 <xref:System.Windows.Controls.Control.Background%2A> 颜色会发生更改。</span><span class="sxs-lookup"><span data-stu-id="72759-165">In the following example, the <xref:System.Windows.Controls.Control.Background%2A> color of a <xref:System.Windows.Controls.Button> is changed when the mouse pointer enters the <xref:System.Windows.Controls.Button>.</span></span>  <span data-ttu-id="72759-166">当鼠标离开 <xref:System.Windows.Controls.Button>时，将还原 <xref:System.Windows.Controls.Control.Background%2A> 颜色。</span><span class="sxs-lookup"><span data-stu-id="72759-166">The <xref:System.Windows.Controls.Control.Background%2A> color is restored when the mouse leaves the <xref:System.Windows.Controls.Button>.</span></span>

 <span data-ttu-id="72759-167">该示例的第一部分创建 <xref:System.Windows.Controls.StackPanel> 和 <xref:System.Windows.Controls.Button> 控件，并将 <xref:System.Windows.UIElement.MouseEnter> 和 <xref:System.Windows.UIElement.MouseLeave> 事件的事件处理程序附加到 <xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="72759-167">The first section of the example creates the <xref:System.Windows.Controls.StackPanel> and the <xref:System.Windows.Controls.Button> control and attaches the event handlers for the <xref:System.Windows.UIElement.MouseEnter> and <xref:System.Windows.UIElement.MouseLeave> events to the <xref:System.Windows.Controls.Button>.</span></span>

 [!code-xaml[InputOvw#Input_OvwMouseExampleXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#input_ovwmouseexamplexaml)]

 [!code-csharp[InputOvw#Input_OvwMouseExampleUICodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml.cs#input_ovwmouseexampleuicodebehind)]
 [!code-vb[InputOvw#Input_OvwMouseExampleUICodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InputOvw/VisualBasic/Page1.xaml.vb#input_ovwmouseexampleuicodebehind)]

 <span data-ttu-id="72759-168">该示例的第二部分用代码编写，定义了事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="72759-168">The second section of the example is written in code and defines the event handlers.</span></span>  <span data-ttu-id="72759-169">当鼠标进入 <xref:System.Windows.Controls.Button>时，<xref:System.Windows.Controls.Button> 的 <xref:System.Windows.Controls.Control.Background%2A> 颜色将更改为 <xref:System.Windows.Media.Brushes.SlateGray%2A>。</span><span class="sxs-lookup"><span data-stu-id="72759-169">When the mouse enters the <xref:System.Windows.Controls.Button>, the <xref:System.Windows.Controls.Control.Background%2A> color of the <xref:System.Windows.Controls.Button> is changed to <xref:System.Windows.Media.Brushes.SlateGray%2A>.</span></span>  <span data-ttu-id="72759-170">当鼠标离开 <xref:System.Windows.Controls.Button>时，<xref:System.Windows.Controls.Button> 的 <xref:System.Windows.Controls.Control.Background%2A> 颜色会改回 <xref:System.Windows.Media.Brushes.AliceBlue%2A>。</span><span class="sxs-lookup"><span data-stu-id="72759-170">When the mouse leaves the <xref:System.Windows.Controls.Button>, the <xref:System.Windows.Controls.Control.Background%2A> color of the <xref:System.Windows.Controls.Button> is changed back to <xref:System.Windows.Media.Brushes.AliceBlue%2A>.</span></span>

 [!code-csharp[InputOvw#Input_OvwMouseExampleEneterHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml.cs#input_ovwmouseexampleeneterhandler)]
 [!code-vb[InputOvw#Input_OvwMouseExampleEneterHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InputOvw/VisualBasic/Page1.xaml.vb#input_ovwmouseexampleeneterhandler)]

 [!code-csharp[InputOvw#Input_OvwMouseExampleLeaveHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml.cs#input_ovwmouseexampleleavehandler)]
 [!code-vb[InputOvw#Input_OvwMouseExampleLeaveHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InputOvw/VisualBasic/Page1.xaml.vb#input_ovwmouseexampleleavehandler)]

<a name="text_input"></a>
## <a name="text-input"></a><span data-ttu-id="72759-171">文本输入</span><span class="sxs-lookup"><span data-stu-id="72759-171">Text Input</span></span>
 <span data-ttu-id="72759-172"><xref:System.Windows.ContentElement.TextInput> 事件使你能够以与设备无关的方式侦听文本输入。</span><span class="sxs-lookup"><span data-stu-id="72759-172">The <xref:System.Windows.ContentElement.TextInput> event enables you to listen for text input in a device-independent manner.</span></span> <span data-ttu-id="72759-173">键盘是文本输入的主要方式，但通过语音、手写和其他输入设备也可以生成文本输入。</span><span class="sxs-lookup"><span data-stu-id="72759-173">The keyboard is the primary means of text input, but speech, handwriting, and other input devices can generate text input also.</span></span>

 <span data-ttu-id="72759-174">对于键盘输入，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 首先将相应的 <xref:System.Windows.ContentElement.KeyDown>发送 /<xref:System.Windows.ContentElement.KeyUp> 事件。</span><span class="sxs-lookup"><span data-stu-id="72759-174">For keyboard input, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] first sends the appropriate <xref:System.Windows.ContentElement.KeyDown>/<xref:System.Windows.ContentElement.KeyUp> events.</span></span> <span data-ttu-id="72759-175">如果未处理这些事件，并且该键是文本（而不是方向箭头或函数键等控制键），则会引发 <xref:System.Windows.ContentElement.TextInput> 事件。</span><span class="sxs-lookup"><span data-stu-id="72759-175">If those events are not handled and the key is textual (rather than a control key such as directional arrows or function keys), then a <xref:System.Windows.ContentElement.TextInput> event is raised.</span></span>  <span data-ttu-id="72759-176"><xref:System.Windows.ContentElement.KeyDown>/<xref:System.Windows.ContentElement.KeyUp> 和 <xref:System.Windows.ContentElement.TextInput> 事件之间并不总是有一种简单的一对一映射，因为多个击键可以生成一个文本输入字符，而单个击键可以生成多个字符的字符串。</span><span class="sxs-lookup"><span data-stu-id="72759-176">There is not always a simple one-to-one mapping between <xref:System.Windows.ContentElement.KeyDown>/<xref:System.Windows.ContentElement.KeyUp> and <xref:System.Windows.ContentElement.TextInput> events because multiple keystrokes can generate a single character of text input and single keystrokes can generate multi-character strings.</span></span>  <span data-ttu-id="72759-177">对于中文、日语和韩语等语言，使用输入法编辑器（Ime）在其相应的字母表中生成成千上万个可能的字符时尤其如此。</span><span class="sxs-lookup"><span data-stu-id="72759-177">This is especially true for languages such as Chinese, Japanese, and Korean which use Input Method Editors (IMEs) to generate the thousands of possible characters in their corresponding alphabets.</span></span>

 <span data-ttu-id="72759-178">当 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] /<xref:System.Windows.ContentElement.KeyDown> 事件发送 <xref:System.Windows.ContentElement.KeyUp>时，如果击键可能成为 <xref:System.Windows.Input.KeyEventArgs.Key%2A> 事件的一部分（例如，按下 ALT + S），<xref:System.Windows.Input.Key.System?displayProperty=nameWithType> 将设置为 <xref:System.Windows.ContentElement.TextInput>。</span><span class="sxs-lookup"><span data-stu-id="72759-178">When [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] sends a <xref:System.Windows.ContentElement.KeyUp>/<xref:System.Windows.ContentElement.KeyDown> event, <xref:System.Windows.Input.KeyEventArgs.Key%2A> is set to <xref:System.Windows.Input.Key.System?displayProperty=nameWithType> if the keystrokes could become part of a <xref:System.Windows.ContentElement.TextInput> event (if ALT+S is pressed, for example).</span></span> <span data-ttu-id="72759-179">这允许 <xref:System.Windows.ContentElement.KeyDown> 事件处理程序中的代码检查 <xref:System.Windows.Input.Key.System?displayProperty=nameWithType>，如果找到，则为随后引发的 <xref:System.Windows.ContentElement.TextInput> 事件的处理程序保留处理。</span><span class="sxs-lookup"><span data-stu-id="72759-179">This allows code in a <xref:System.Windows.ContentElement.KeyDown> event handler to check for <xref:System.Windows.Input.Key.System?displayProperty=nameWithType> and, if found, leave processing for the handler of the subsequently raised <xref:System.Windows.ContentElement.TextInput> event.</span></span> <span data-ttu-id="72759-180">在这些情况下，可以使用 <xref:System.Windows.Input.TextCompositionEventArgs> 参数的各种属性来确定原始击键。</span><span class="sxs-lookup"><span data-stu-id="72759-180">In these cases, the various properties of the <xref:System.Windows.Input.TextCompositionEventArgs> argument can be used to determine the original keystrokes.</span></span> <span data-ttu-id="72759-181">同样，如果输入法处于活动状态，<xref:System.Windows.Input.Key> 的值为 <xref:System.Windows.Input.Key.ImeProcessed?displayProperty=nameWithType>，<xref:System.Windows.Input.KeyEventArgs.ImeProcessedKey%2A> 将提供原始击键或击键。</span><span class="sxs-lookup"><span data-stu-id="72759-181">Similarly, if an IME is active, <xref:System.Windows.Input.Key> has the value of <xref:System.Windows.Input.Key.ImeProcessed?displayProperty=nameWithType>, and <xref:System.Windows.Input.KeyEventArgs.ImeProcessedKey%2A> gives the original keystroke or keystrokes.</span></span>

 <span data-ttu-id="72759-182">下面的示例为 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 事件定义处理程序，并为 <xref:System.Windows.UIElement.KeyDown> 事件定义处理程序。</span><span class="sxs-lookup"><span data-stu-id="72759-182">The following example defines a handler for the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event and a handler for the <xref:System.Windows.UIElement.KeyDown> event.</span></span>

 <span data-ttu-id="72759-183">第一段代码或标记创建用户界面。</span><span class="sxs-lookup"><span data-stu-id="72759-183">The first segment of code or markup creates the user interface.</span></span>

 [!code-xaml[InputOvw#Input_OvwTextInputXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#input_ovwtextinputxaml)]

 [!code-csharp[InputOvw#Input_OvwTextInputUICodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml.cs#input_ovwtextinputuicodebehind)]
 [!code-vb[InputOvw#Input_OvwTextInputUICodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InputOvw/VisualBasic/Page1.xaml.vb#input_ovwtextinputuicodebehind)]

 <span data-ttu-id="72759-184">第二段代码包含事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="72759-184">The second segment of code contains the event handlers.</span></span>

 [!code-csharp[InputOvw#Input_OvwTextInputHandlersCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml.cs#input_ovwtextinputhandlerscodebehind)]
 [!code-vb[InputOvw#Input_OvwTextInputHandlersCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InputOvw/VisualBasic/Page1.xaml.vb#input_ovwtextinputhandlerscodebehind)]

 <span data-ttu-id="72759-185">由于输入事件向上冒泡事件路由，因此 <xref:System.Windows.Controls.StackPanel> 接收输入，而不考虑哪个元素具有键盘焦点。</span><span class="sxs-lookup"><span data-stu-id="72759-185">Because input events bubble up the event route, the <xref:System.Windows.Controls.StackPanel> receives the input regardless of which element has keyboard focus.</span></span> <span data-ttu-id="72759-186"><xref:System.Windows.Controls.TextBox> 控件将先得到通知，并且仅当 <xref:System.Windows.Controls.TextBox> 未处理输入时，才调用 `OnTextInputKeyDown` 处理程序。</span><span class="sxs-lookup"><span data-stu-id="72759-186">The <xref:System.Windows.Controls.TextBox> control is notified first and the `OnTextInputKeyDown` handler is called only if the <xref:System.Windows.Controls.TextBox> did not handle the input.</span></span> <span data-ttu-id="72759-187">如果使用 <xref:System.Windows.UIElement.PreviewKeyDown> 事件而不是 <xref:System.Windows.UIElement.KeyDown> 事件，则首先调用 `OnTextInputKeyDown` 处理程序。</span><span class="sxs-lookup"><span data-stu-id="72759-187">If the <xref:System.Windows.UIElement.PreviewKeyDown> event is used instead of the <xref:System.Windows.UIElement.KeyDown> event, the `OnTextInputKeyDown` handler is called first.</span></span>

 <span data-ttu-id="72759-188">在此示例中，处理逻辑写入了两次，分别针对 CTRL+O和按钮的单击事件。</span><span class="sxs-lookup"><span data-stu-id="72759-188">In this example, the handling logic is written two times—one time for CTRL+O, and again for button's click event.</span></span> <span data-ttu-id="72759-189">使用命令，而不是直接处理输入事件，可简化此过程。</span><span class="sxs-lookup"><span data-stu-id="72759-189">This can be simplified by using commands, instead of handling the input events directly.</span></span>  <span data-ttu-id="72759-190">本概述和[命令概述](commanding-overview.md)中将讨论这些命令。</span><span class="sxs-lookup"><span data-stu-id="72759-190">Commands are discussed in this overview and in [Commanding Overview](commanding-overview.md).</span></span>

<a name="touch_and_manipulation"></a>
## <a name="touch-and-manipulation"></a><span data-ttu-id="72759-191">触摸和操作</span><span class="sxs-lookup"><span data-stu-id="72759-191">Touch and Manipulation</span></span>
 <span data-ttu-id="72759-192">Windows 7 操作系统中的新硬件和 API 使应用程序能够同时接收来自多个触控的输入。</span><span class="sxs-lookup"><span data-stu-id="72759-192">New hardware and API in the Windows 7 operating system provide applications the ability to receive input from multiple touches simultaneously.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="72759-193">通过在触摸发生时引发事件，从而使应用程序能够以类似于响应其他输入（例如鼠标或键盘）的方式来检测和响应触摸设备。</span><span class="sxs-lookup"><span data-stu-id="72759-193">enables applications to detect and respond to touch in a manner similar to responding to other input, such as the mouse or keyboard, by raising events when touch occurs.</span></span>

 <span data-ttu-id="72759-194">发生触摸时，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 将公开两种类型的事件：触摸事件和操作事件。</span><span class="sxs-lookup"><span data-stu-id="72759-194">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] exposes two types of events when touch occurs: touch events and manipulation events.</span></span> <span data-ttu-id="72759-195">触摸事件提供有关触摸屏上每个手指及其移动的原始数据。</span><span class="sxs-lookup"><span data-stu-id="72759-195">Touch events provide raw data about each finger on a touchscreen and its movement.</span></span> <span data-ttu-id="72759-196">操作事件将输入解释为特定操作。</span><span class="sxs-lookup"><span data-stu-id="72759-196">Manipulation events interpret the input as certain actions.</span></span> <span data-ttu-id="72759-197">本部分将讨论这两种类型的事件。</span><span class="sxs-lookup"><span data-stu-id="72759-197">Both types of events are discussed in this section.</span></span>

### <a name="prerequisites"></a><span data-ttu-id="72759-198">先决条件</span><span class="sxs-lookup"><span data-stu-id="72759-198">Prerequisites</span></span>
 <span data-ttu-id="72759-199">需要以下组件才能开发响应触摸的应用程序。</span><span class="sxs-lookup"><span data-stu-id="72759-199">You need the following components to develop an application that responds to touch.</span></span>

- <span data-ttu-id="72759-200">Visual Studio 2010。</span><span class="sxs-lookup"><span data-stu-id="72759-200">Visual Studio 2010.</span></span>

- <span data-ttu-id="72759-201">Windows 7。</span><span class="sxs-lookup"><span data-stu-id="72759-201">Windows 7.</span></span>

- <span data-ttu-id="72759-202">支持 Windows 触控的设备，如触摸屏。</span><span class="sxs-lookup"><span data-stu-id="72759-202">A device, such as a touchscreen, that supports Windows Touch.</span></span>

### <a name="terminology"></a><span data-ttu-id="72759-203">术语</span><span class="sxs-lookup"><span data-stu-id="72759-203">Terminology</span></span>
 <span data-ttu-id="72759-204">讨论触摸时使用了以下术语。</span><span class="sxs-lookup"><span data-stu-id="72759-204">The following terms are used when touch is discussed.</span></span>

- <span data-ttu-id="72759-205">**触摸**是 Windows 7 可识别的一种用户输入。</span><span class="sxs-lookup"><span data-stu-id="72759-205">**Touch** is a type of user input that is recognized by Windows 7.</span></span> <span data-ttu-id="72759-206">通常，将手指放在触敏式屏幕上会触发触摸。</span><span class="sxs-lookup"><span data-stu-id="72759-206">Usually, touch is initiated by putting fingers on a touch-sensitive screen.</span></span> <span data-ttu-id="72759-207">请注意，如果设备仅将手指的位置和移动转换为鼠标输入，则笔记本电脑上常用的触摸板等设备不支持触摸。</span><span class="sxs-lookup"><span data-stu-id="72759-207">Note that devices such as a touchpad that is common on laptop computers do not support touch if the device merely converts the finger's position and movement as mouse input.</span></span>

- <span data-ttu-id="72759-208">**多点触摸**是同时发生在多个点上的触摸。</span><span class="sxs-lookup"><span data-stu-id="72759-208">**Multitouch** is touch that occurs from more than one point simultaneously.</span></span> <span data-ttu-id="72759-209">Windows 7 和 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 支持多点触摸。</span><span class="sxs-lookup"><span data-stu-id="72759-209">Windows 7 and [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] supports multitouch.</span></span> <span data-ttu-id="72759-210">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 文档中每当论及触摸时，相关概念均适用于多点触摸。</span><span class="sxs-lookup"><span data-stu-id="72759-210">Whenever touch is discussed in the documentation for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], the concepts apply to multitouch.</span></span>

- <span data-ttu-id="72759-211">当触摸被解释为应用于对象的实际操作时，就发生了**操作**。</span><span class="sxs-lookup"><span data-stu-id="72759-211">A **manipulation** occurs when touch is interpreted as a physical action that is applied to an object.</span></span> <span data-ttu-id="72759-212">在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中，操作事件将输入解释为转换、扩展或旋转操作。</span><span class="sxs-lookup"><span data-stu-id="72759-212">In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], manipulation events interpret input as a translation, expansion, or rotation manipulation.</span></span>

- <span data-ttu-id="72759-213">`touch device` 表示产生触摸输入的设备，例如触摸屏上的一根手指。</span><span class="sxs-lookup"><span data-stu-id="72759-213">A `touch device` represents a device that produces touch input, such as a single finger on a touchscreen.</span></span>

### <a name="controls-that-respond-to-touch"></a><span data-ttu-id="72759-214">响应触摸的控件</span><span class="sxs-lookup"><span data-stu-id="72759-214">Controls that Respond to Touch</span></span>
 <span data-ttu-id="72759-215">如果以下控件的内容延伸到视图之外，则可以通过在控件上拖动手指来滚动该控件。</span><span class="sxs-lookup"><span data-stu-id="72759-215">The following controls can be scrolled by dragging a finger across the control if it has content that is scrolled out of view.</span></span>

- <xref:System.Windows.Controls.ComboBox>

- <xref:System.Windows.Controls.ContextMenu>

- <xref:System.Windows.Controls.DataGrid>

- <xref:System.Windows.Controls.ListBox>

- <xref:System.Windows.Controls.ListView>

- <xref:System.Windows.Controls.MenuItem>

- <xref:System.Windows.Controls.TextBox>

- <xref:System.Windows.Controls.ToolBar>

- <xref:System.Windows.Controls.TreeView>

 <span data-ttu-id="72759-216"><xref:System.Windows.Controls.ScrollViewer> 定义 <xref:System.Windows.Controls.ScrollViewer.PanningMode%2A?displayProperty=nameWithType> 附加属性，使您可以指定是否水平、垂直、同时启用触控平移。</span><span class="sxs-lookup"><span data-stu-id="72759-216">The <xref:System.Windows.Controls.ScrollViewer> defines the <xref:System.Windows.Controls.ScrollViewer.PanningMode%2A?displayProperty=nameWithType> attached property that enables you to specify whether touch panning is enabled horizontally, vertically, both, or neither.</span></span> <span data-ttu-id="72759-217"><xref:System.Windows.Controls.ScrollViewer.PanningDeceleration%2A?displayProperty=nameWithType> 属性指定当用户将手指从触摸屏上提起时，滚动速度变慢的速度。</span><span class="sxs-lookup"><span data-stu-id="72759-217">The <xref:System.Windows.Controls.ScrollViewer.PanningDeceleration%2A?displayProperty=nameWithType> property specifies how quickly the scrolling slows down when the user lifts the finger from the touchscreen.</span></span> <span data-ttu-id="72759-218"><xref:System.Windows.Controls.ScrollViewer.PanningRatio%2A?displayProperty=nameWithType> 附加属性指定滚动偏移与转换操作偏移的比率。</span><span class="sxs-lookup"><span data-stu-id="72759-218">The <xref:System.Windows.Controls.ScrollViewer.PanningRatio%2A?displayProperty=nameWithType> attached property specifies the ratio of scrolling offset to translate manipulation offset.</span></span>

### <a name="touch-events"></a><span data-ttu-id="72759-219">触摸事件</span><span class="sxs-lookup"><span data-stu-id="72759-219">Touch Events</span></span>
 <span data-ttu-id="72759-220">基类（<xref:System.Windows.UIElement>、<xref:System.Windows.UIElement3D>和 <xref:System.Windows.ContentElement>）定义了您可以订阅的事件，以便您的应用程序响应触摸。</span><span class="sxs-lookup"><span data-stu-id="72759-220">The base classes, <xref:System.Windows.UIElement>, <xref:System.Windows.UIElement3D>, and <xref:System.Windows.ContentElement>, define events that you can subscribe to so your application will respond to touch.</span></span> <span data-ttu-id="72759-221">当应用程序将触摸解释为操作对象以外的其他操作时，触摸事件非常有用。</span><span class="sxs-lookup"><span data-stu-id="72759-221">Touch events are useful when your application interprets touch as something other than manipulating an object.</span></span> <span data-ttu-id="72759-222">例如，使用户能够以一个或多个手指绘制的应用程序将订阅触摸事件。</span><span class="sxs-lookup"><span data-stu-id="72759-222">For example, an application that enables a user to draw with one or more fingers would subscribe to touch events.</span></span>

 <span data-ttu-id="72759-223">所有三个类都定义了以下事件，其行为类似，而无论定义类是什么。</span><span class="sxs-lookup"><span data-stu-id="72759-223">All three classes define the following events, which behave similarly, regardless of the defining class.</span></span>

- <xref:System.Windows.UIElement.TouchDown>

- <xref:System.Windows.UIElement.TouchMove>

- <xref:System.Windows.UIElement.TouchUp>

- <xref:System.Windows.UIElement.TouchEnter>

- <xref:System.Windows.UIElement.TouchLeave>

- <xref:System.Windows.UIElement.PreviewTouchDown>

- <xref:System.Windows.UIElement.PreviewTouchMove>

- <xref:System.Windows.UIElement.PreviewTouchUp>

- <xref:System.Windows.UIElement.GotTouchCapture>

- <xref:System.Windows.UIElement.LostTouchCapture>

 <span data-ttu-id="72759-224">像键盘和鼠标事件一样，触摸事件也是路由事件。</span><span class="sxs-lookup"><span data-stu-id="72759-224">Like keyboard and mouse events, the touch events are routed events.</span></span> <span data-ttu-id="72759-225">以 `Preview` 开头的事件是隧道事件，以 `Touch` 开头的事件是冒泡事件。</span><span class="sxs-lookup"><span data-stu-id="72759-225">The events that begin with `Preview` are tunneling events and the events that begin with `Touch` are bubbling events.</span></span> <span data-ttu-id="72759-226">有关路由事件的详细信息，请参阅[路由事件概述](routed-events-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="72759-226">For more information about routed events, see [Routed Events Overview](routed-events-overview.md).</span></span> <span data-ttu-id="72759-227">处理这些事件时，可以通过调用 <xref:System.Windows.Input.TouchEventArgs.GetTouchPoint%2A> 或 <xref:System.Windows.Input.TouchEventArgs.GetIntermediateTouchPoints%2A> 方法来获取输入的相对于任何元素的位置。</span><span class="sxs-lookup"><span data-stu-id="72759-227">When you handle these events, you can get the position of the input, relative to any element, by calling the <xref:System.Windows.Input.TouchEventArgs.GetTouchPoint%2A> or <xref:System.Windows.Input.TouchEventArgs.GetIntermediateTouchPoints%2A> method.</span></span>

 <span data-ttu-id="72759-228">为了理解触控事件之间的交互，请考虑以下这种情况：用户将一个手指放在元素上，在该元素中移动手指，然后将手指从该元素上移开。</span><span class="sxs-lookup"><span data-stu-id="72759-228">To understand the interaction among the touch events, consider the scenario where a user puts one finger on an element, moves the finger in the element, and then lifts the finger from the element.</span></span> <span data-ttu-id="72759-229">下图显示了冒泡事件的执行（为简单起见，省略了隧道事件）。</span><span class="sxs-lookup"><span data-stu-id="72759-229">The following illustration shows the execution of the bubbling events (the tunneling events are omitted for simplicity).</span></span>

 <span data-ttu-id="72759-230">![触摸事件的序列。](./media/ndp-touchevents.png "NDP_TouchEvents")触摸事件</span><span class="sxs-lookup"><span data-stu-id="72759-230">![The sequence of touch events.](./media/ndp-touchevents.png "NDP_TouchEvents") Touch events</span></span>

 <span data-ttu-id="72759-231">下列内容描述了上图中的事件顺序。</span><span class="sxs-lookup"><span data-stu-id="72759-231">The following list describes the sequence of the events in the preceding illustration.</span></span>

1. <span data-ttu-id="72759-232">当用户将手指放在元素上时，<xref:System.Windows.UIElement.TouchEnter> 事件发生一次。</span><span class="sxs-lookup"><span data-stu-id="72759-232">The <xref:System.Windows.UIElement.TouchEnter> event occurs one time when the user puts a finger on the element.</span></span>

2. <span data-ttu-id="72759-233"><xref:System.Windows.UIElement.TouchDown> 事件发生一次。</span><span class="sxs-lookup"><span data-stu-id="72759-233">The <xref:System.Windows.UIElement.TouchDown> event occurs one time.</span></span>

3. <span data-ttu-id="72759-234">当用户在元素中移动手指时，<xref:System.Windows.UIElement.TouchMove> 事件发生多次。</span><span class="sxs-lookup"><span data-stu-id="72759-234">The <xref:System.Windows.UIElement.TouchMove> event occurs multiple times as the user moves the finger within the element.</span></span>

4. <span data-ttu-id="72759-235">当用户将手指从元素中抬起时，会发生 <xref:System.Windows.UIElement.TouchUp> 事件一次。</span><span class="sxs-lookup"><span data-stu-id="72759-235">The <xref:System.Windows.UIElement.TouchUp> event occurs one time when the user lifts the finger from the element.</span></span>

5. <span data-ttu-id="72759-236"><xref:System.Windows.UIElement.TouchLeave> 事件发生一次。</span><span class="sxs-lookup"><span data-stu-id="72759-236">The <xref:System.Windows.UIElement.TouchLeave> event occurs one time.</span></span>

 <span data-ttu-id="72759-237">当使用两根以上的手指时，每根手指都会发生事件。</span><span class="sxs-lookup"><span data-stu-id="72759-237">When more than two fingers are used, the events occur for each finger.</span></span>

### <a name="manipulation-events"></a><span data-ttu-id="72759-238">操作事件</span><span class="sxs-lookup"><span data-stu-id="72759-238">Manipulation Events</span></span>
 <span data-ttu-id="72759-239">对于应用程序允许用户操纵对象的情况，<xref:System.Windows.UIElement> 类定义操作事件。</span><span class="sxs-lookup"><span data-stu-id="72759-239">For cases where an application enables a user to manipulate an object, the <xref:System.Windows.UIElement> class defines manipulation events.</span></span> <span data-ttu-id="72759-240">与只是报告触摸位置的触摸事件不同，操作事件会报告可采用何种方式解释输入。</span><span class="sxs-lookup"><span data-stu-id="72759-240">Unlike the touch events that simply report the position of touch, the manipulation events report how the input can be interpreted.</span></span> <span data-ttu-id="72759-241">有三种类型的操作：转换、扩展和旋转。</span><span class="sxs-lookup"><span data-stu-id="72759-241">There are three types of manipulations, translation, expansion, and rotation.</span></span> <span data-ttu-id="72759-242">下列内容介绍了如何调用这三种类型的操作。</span><span class="sxs-lookup"><span data-stu-id="72759-242">The following list describes how to invoke the three types of manipulations.</span></span>

- <span data-ttu-id="72759-243">将一根手指放在对象上，并在触摸屏上拖动手指以调用转换操作。</span><span class="sxs-lookup"><span data-stu-id="72759-243">Put a finger on an object and move the finger across the touchscreen to invoke a translation manipulation.</span></span> <span data-ttu-id="72759-244">此操作通常会移动对象。</span><span class="sxs-lookup"><span data-stu-id="72759-244">This usually moves the object.</span></span>

- <span data-ttu-id="72759-245">将两根手指放在物体上，并将手指相互靠拢或分开以调用扩展操作。</span><span class="sxs-lookup"><span data-stu-id="72759-245">Put two fingers on an object and move the fingers closer together or farther apart from one another to invoke an expansion manipulation.</span></span> <span data-ttu-id="72759-246">此操作通常会调整对象的大小。</span><span class="sxs-lookup"><span data-stu-id="72759-246">This usually resizes the object.</span></span>

- <span data-ttu-id="72759-247">将两根手指放在对象上，并将一个手指围绕另一个手指旋转以调用旋转操作。</span><span class="sxs-lookup"><span data-stu-id="72759-247">Put two fingers on an object and rotate the fingers around each other to invoke a rotation manipulation.</span></span> <span data-ttu-id="72759-248">此操作通常会旋转对象。</span><span class="sxs-lookup"><span data-stu-id="72759-248">This usually rotates the object.</span></span>

 <span data-ttu-id="72759-249">多种类型的操作可以同时发生。</span><span class="sxs-lookup"><span data-stu-id="72759-249">More than one type of manipulation can occur simultaneously.</span></span>

 <span data-ttu-id="72759-250">使对象响应操作时，可以让对象看起来具有惯性。</span><span class="sxs-lookup"><span data-stu-id="72759-250">When you cause objects to respond to manipulations, you can have the object appear to have inertia.</span></span> <span data-ttu-id="72759-251">这样可以使对象模拟真实的世界。</span><span class="sxs-lookup"><span data-stu-id="72759-251">This can make your objects simulate the physical world.</span></span> <span data-ttu-id="72759-252">例如，在桌子上推一本书时，如果你足够用力，书将在你松手后继续移动。</span><span class="sxs-lookup"><span data-stu-id="72759-252">For example, when you push a book across a table, if you push hard enough the book will continue to move after you release it.</span></span> <span data-ttu-id="72759-253">利用 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]，可以通过在用户的手指松开对象后引发操作事件来模拟这种行为。</span><span class="sxs-lookup"><span data-stu-id="72759-253">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] enables you to simulate this behavior by raising manipulation events after the user's fingers releases the object.</span></span>

 <span data-ttu-id="72759-254">如需深入了解如何创建使用户可以对对象进行移动、调整大小和旋转的应用程序，请参阅[演练：创建你的第一个触控应用程序](walkthrough-creating-your-first-touch-application.md)。</span><span class="sxs-lookup"><span data-stu-id="72759-254">For information about how to create an application that enables the user to move, resize, and rotate an object, see [Walkthrough: Creating Your First Touch Application](walkthrough-creating-your-first-touch-application.md).</span></span>

 <span data-ttu-id="72759-255"><xref:System.Windows.UIElement> 定义以下操作事件。</span><span class="sxs-lookup"><span data-stu-id="72759-255">The <xref:System.Windows.UIElement> defines the following manipulation events.</span></span>

- <xref:System.Windows.UIElement.ManipulationStarting>

- <xref:System.Windows.UIElement.ManipulationStarted>

- <xref:System.Windows.UIElement.ManipulationDelta>

- <xref:System.Windows.UIElement.ManipulationInertiaStarting>

- <xref:System.Windows.UIElement.ManipulationCompleted>

- <xref:System.Windows.UIElement.ManipulationBoundaryFeedback>

 <span data-ttu-id="72759-256">默认情况下，<xref:System.Windows.UIElement> 不会接收这些操作事件。</span><span class="sxs-lookup"><span data-stu-id="72759-256">By default, a <xref:System.Windows.UIElement> does not receive these manipulation events.</span></span> <span data-ttu-id="72759-257">若要在 <xref:System.Windows.UIElement>上接收操作事件，请将 <xref:System.Windows.UIElement.IsManipulationEnabled%2A?displayProperty=nameWithType> 设置为 "`true`"。</span><span class="sxs-lookup"><span data-stu-id="72759-257">To receive manipulation events on a <xref:System.Windows.UIElement>, set <xref:System.Windows.UIElement.IsManipulationEnabled%2A?displayProperty=nameWithType> to `true`.</span></span>

#### <a name="the-execution-path-of-manipulation-events"></a><span data-ttu-id="72759-258">操作事件的执行路径</span><span class="sxs-lookup"><span data-stu-id="72759-258">The Execution Path of Manipulation Events</span></span>
 <span data-ttu-id="72759-259">考虑用户“抛出”一个对象的情况。</span><span class="sxs-lookup"><span data-stu-id="72759-259">Consider a scenario where a user "throws" an object.</span></span> <span data-ttu-id="72759-260">用户将手指放在对象上，将手指在触摸屏上移动一段短距离，然后在移动的同时抬起手指。</span><span class="sxs-lookup"><span data-stu-id="72759-260">The user puts a finger on the object, moves the finger across the touchscreen for a short distance, and then lifts the finger while it is moving.</span></span> <span data-ttu-id="72759-261">此操作的结果是，该对象将在用户的手指下方移动，并在用户抬起手指后继续移动。</span><span class="sxs-lookup"><span data-stu-id="72759-261">The result of this is that the object will move under the user's finger and continue to move after the user lifts the finger.</span></span>

 <span data-ttu-id="72759-262">下图显示了操作事件的执行路径和每个事件的重要信息。</span><span class="sxs-lookup"><span data-stu-id="72759-262">The following illustration shows the execution path of manipulation events and important information about each event.</span></span>

 <span data-ttu-id="72759-263">![操作事件的序列。](./media/ndp-manipulationevents.png "NDP_ManipulationEvents")操作事件</span><span class="sxs-lookup"><span data-stu-id="72759-263">![The sequence of manipulation events.](./media/ndp-manipulationevents.png "NDP_ManipulationEvents") Manipulation events</span></span>

 <span data-ttu-id="72759-264">下列内容描述了上图中的事件顺序。</span><span class="sxs-lookup"><span data-stu-id="72759-264">The following list describes the sequence of the events in the preceding illustration.</span></span>

1. <span data-ttu-id="72759-265">当用户将手指放在对象上时，<xref:System.Windows.UIElement.ManipulationStarting> 事件发生。</span><span class="sxs-lookup"><span data-stu-id="72759-265">The <xref:System.Windows.UIElement.ManipulationStarting> event occurs when the user places a finger on the object.</span></span> <span data-ttu-id="72759-266">除此之外，此事件还允许您设置 "<xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A>" 属性。</span><span class="sxs-lookup"><span data-stu-id="72759-266">Among other things, this event allows you to set the <xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A> property.</span></span> <span data-ttu-id="72759-267">在后续事件中，操作的位置将与 <xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A>相关。</span><span class="sxs-lookup"><span data-stu-id="72759-267">In the subsequent events, the position of the manipulation will be relative to the <xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A>.</span></span> <span data-ttu-id="72759-268">在 <xref:System.Windows.UIElement.ManipulationStarting>以外的事件中，此属性是只读的，因此 <xref:System.Windows.UIElement.ManipulationStarting> 事件是唯一可以设置此属性的时间。</span><span class="sxs-lookup"><span data-stu-id="72759-268">In events other than <xref:System.Windows.UIElement.ManipulationStarting>, this property is read-only, so the <xref:System.Windows.UIElement.ManipulationStarting> event is the only time that you can set this property.</span></span>

2. <span data-ttu-id="72759-269">接下来，<xref:System.Windows.UIElement.ManipulationStarted> 事件发生。</span><span class="sxs-lookup"><span data-stu-id="72759-269">The <xref:System.Windows.UIElement.ManipulationStarted> event occurs next.</span></span> <span data-ttu-id="72759-270">此事件报告操作的原始位置。</span><span class="sxs-lookup"><span data-stu-id="72759-270">This event reports the origin of the manipulation.</span></span>

3. <span data-ttu-id="72759-271">当用户的手指在触摸屏上移动时，<xref:System.Windows.UIElement.ManipulationDelta> 事件发生多次。</span><span class="sxs-lookup"><span data-stu-id="72759-271">The <xref:System.Windows.UIElement.ManipulationDelta> event occurs multiple times as a user's fingers move on a touchscreen.</span></span> <span data-ttu-id="72759-272"><xref:System.Windows.Input.ManipulationDeltaEventArgs> 类的 <xref:System.Windows.Input.ManipulationDeltaEventArgs.DeltaManipulation%2A> 属性可报告操作是解释为移动、扩展还是转换。</span><span class="sxs-lookup"><span data-stu-id="72759-272">The <xref:System.Windows.Input.ManipulationDeltaEventArgs.DeltaManipulation%2A> property of the <xref:System.Windows.Input.ManipulationDeltaEventArgs> class reports whether the manipulation is interpreted as movement, expansion, or translation.</span></span> <span data-ttu-id="72759-273">这是你执行操作对象的大部分工作的地方。</span><span class="sxs-lookup"><span data-stu-id="72759-273">This is where you perform most of the work of manipulating an object.</span></span>

4. <span data-ttu-id="72759-274">当用户的手指与对象失去联系时，将发生 <xref:System.Windows.UIElement.ManipulationInertiaStarting> 事件。</span><span class="sxs-lookup"><span data-stu-id="72759-274">The <xref:System.Windows.UIElement.ManipulationInertiaStarting> event occurs when the user's fingers lose contact with the object.</span></span> <span data-ttu-id="72759-275">此事件使你可以指定操作在惯性期间的减速。</span><span class="sxs-lookup"><span data-stu-id="72759-275">This event enables you to specify the deceleration of the manipulations during inertia.</span></span> <span data-ttu-id="72759-276">这样，选择时对象就可以模拟不同的物理空间或特性。</span><span class="sxs-lookup"><span data-stu-id="72759-276">This is so your object can emulate different physical spaces or attributes if you choose.</span></span> <span data-ttu-id="72759-277">例如，假设应用程序有两个表示真实世界中的物品的对象，并且一个物品比另一个物品重。</span><span class="sxs-lookup"><span data-stu-id="72759-277">For example, suppose your application has two objects that represent items in the physical world, and one is heavier than the other.</span></span> <span data-ttu-id="72759-278">你可以使较重的对象比较轻的对象减速更快。</span><span class="sxs-lookup"><span data-stu-id="72759-278">You can make the heavier object decelerate faster than the lighter object.</span></span>

5. <span data-ttu-id="72759-279">发生惯性时，<xref:System.Windows.UIElement.ManipulationDelta> 事件发生多次。</span><span class="sxs-lookup"><span data-stu-id="72759-279">The <xref:System.Windows.UIElement.ManipulationDelta> event occurs multiple times as inertia occurs.</span></span> <span data-ttu-id="72759-280">请注意，当用户的手指在触摸屏上移动并且 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 模拟惯性时，将发生此事件。</span><span class="sxs-lookup"><span data-stu-id="72759-280">Note that this event occurs when the user's fingers move across the touchscreen and when [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] simulates inertia.</span></span> <span data-ttu-id="72759-281">换句话说，<xref:System.Windows.UIElement.ManipulationDelta> 在 <xref:System.Windows.UIElement.ManipulationInertiaStarting> 事件之前和之后发生。</span><span class="sxs-lookup"><span data-stu-id="72759-281">In other words, <xref:System.Windows.UIElement.ManipulationDelta> occurs before and after the <xref:System.Windows.UIElement.ManipulationInertiaStarting> event.</span></span> <span data-ttu-id="72759-282"><xref:System.Windows.Input.ManipulationDeltaEventArgs.IsInertial%2A?displayProperty=nameWithType> 属性报告在惯性期间是否发生了 <xref:System.Windows.UIElement.ManipulationDelta> 事件，因此您可以检查该属性并执行不同的操作，具体取决于其值。</span><span class="sxs-lookup"><span data-stu-id="72759-282">The <xref:System.Windows.Input.ManipulationDeltaEventArgs.IsInertial%2A?displayProperty=nameWithType> property reports whether the <xref:System.Windows.UIElement.ManipulationDelta> event occurs during inertia, so you can check that property and perform different actions, depending on its value.</span></span>

6. <span data-ttu-id="72759-283">当操作和任何惯性结束时，将发生 <xref:System.Windows.UIElement.ManipulationCompleted> 事件。</span><span class="sxs-lookup"><span data-stu-id="72759-283">The <xref:System.Windows.UIElement.ManipulationCompleted> event occurs when the manipulation and any inertia ends.</span></span> <span data-ttu-id="72759-284">也就是说，在所有 <xref:System.Windows.UIElement.ManipulationDelta> 事件发生后，将发生 <xref:System.Windows.UIElement.ManipulationCompleted> 事件，以指示操作已完成。</span><span class="sxs-lookup"><span data-stu-id="72759-284">That is, after all the <xref:System.Windows.UIElement.ManipulationDelta> events occur, the <xref:System.Windows.UIElement.ManipulationCompleted> event occurs to signal that the manipulation is complete.</span></span>

 <span data-ttu-id="72759-285"><xref:System.Windows.UIElement> 还定义了 <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> 事件。</span><span class="sxs-lookup"><span data-stu-id="72759-285">The <xref:System.Windows.UIElement> also defines the <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> event.</span></span> <span data-ttu-id="72759-286">当 <xref:System.Windows.UIElement.ManipulationDelta> 事件中调用 <xref:System.Windows.Input.ManipulationDeltaEventArgs.ReportBoundaryFeedback%2A> 方法时发生此事件。</span><span class="sxs-lookup"><span data-stu-id="72759-286">This event occurs when the <xref:System.Windows.Input.ManipulationDeltaEventArgs.ReportBoundaryFeedback%2A> method is called in the <xref:System.Windows.UIElement.ManipulationDelta> event.</span></span> <span data-ttu-id="72759-287">使用 <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> 事件，应用程序或组件可以在对象达到边界时提供可视反馈。</span><span class="sxs-lookup"><span data-stu-id="72759-287">The <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> event enables applications or components to provide visual feedback when an object hits a boundary.</span></span> <span data-ttu-id="72759-288">例如，<xref:System.Windows.Window> 类处理 <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> 事件，以在遇到窗口边缘时使窗口稍微移动。</span><span class="sxs-lookup"><span data-stu-id="72759-288">For example, the <xref:System.Windows.Window> class handles the <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> event to cause the window to slightly move when its edge is encountered.</span></span>

 <span data-ttu-id="72759-289">可以通过对任何操作事件中的事件参数调用 <xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A> 方法来取消操作，<xref:System.Windows.UIElement.ManipulationBoundaryFeedback> 事件除外。</span><span class="sxs-lookup"><span data-stu-id="72759-289">You can cancel the manipulation by calling the <xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A> method on the event arguments in any manipulation event except <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> event.</span></span> <span data-ttu-id="72759-290">调用 <xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A>时，将不再引发操作事件，并发生触控鼠标事件。</span><span class="sxs-lookup"><span data-stu-id="72759-290">When you call <xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A>, the manipulation events are no longer raised and mouse events occur for touch.</span></span> <span data-ttu-id="72759-291">下表描述了取消操作的时间与所发生的鼠标事件之间的关系。</span><span class="sxs-lookup"><span data-stu-id="72759-291">The following table describes the relationship between the time the manipulation is canceled and the mouse events that occur.</span></span>

|<span data-ttu-id="72759-292">在其中调用取消的事件</span><span class="sxs-lookup"><span data-stu-id="72759-292">The event that Cancel is called in</span></span>|<span data-ttu-id="72759-293">针对已经发生的输入发生的鼠标事件</span><span class="sxs-lookup"><span data-stu-id="72759-293">The mouse events that occur for input that already occurred</span></span>|
|----------------------------------------|-----------------------------------------------------------------|
|<span data-ttu-id="72759-294"><xref:System.Windows.UIElement.ManipulationStarting> 和 <xref:System.Windows.UIElement.ManipulationStarted></span><span class="sxs-lookup"><span data-stu-id="72759-294"><xref:System.Windows.UIElement.ManipulationStarting> and <xref:System.Windows.UIElement.ManipulationStarted></span></span>|<span data-ttu-id="72759-295">鼠标按下事件。</span><span class="sxs-lookup"><span data-stu-id="72759-295">Mouse down events.</span></span>|
|<xref:System.Windows.UIElement.ManipulationDelta>|<span data-ttu-id="72759-296">鼠标按下和鼠标移动事件。</span><span class="sxs-lookup"><span data-stu-id="72759-296">Mouse down and mouse move events.</span></span>|
|<span data-ttu-id="72759-297"><xref:System.Windows.UIElement.ManipulationInertiaStarting> 和 <xref:System.Windows.UIElement.ManipulationCompleted></span><span class="sxs-lookup"><span data-stu-id="72759-297"><xref:System.Windows.UIElement.ManipulationInertiaStarting> and <xref:System.Windows.UIElement.ManipulationCompleted></span></span>|<span data-ttu-id="72759-298">鼠标按下、鼠标移动和鼠标弹起事件。</span><span class="sxs-lookup"><span data-stu-id="72759-298">Mouse down, mouse move, and mouse up events.</span></span>|

 <span data-ttu-id="72759-299">请注意，如果在操作处于惯性中时调用 <xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A>，则该方法将返回 `false` 并且输入不会引发鼠标事件。</span><span class="sxs-lookup"><span data-stu-id="72759-299">Note that if you call <xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A> when the manipulation is in inertia, the method returns `false` and the input does not raise mouse events.</span></span>

### <a name="the-relationship-between-touch-and-manipulation-events"></a><span data-ttu-id="72759-300">触摸事件和操作事件之间的关系</span><span class="sxs-lookup"><span data-stu-id="72759-300">The Relationship Between Touch and Manipulation Events</span></span>
 <span data-ttu-id="72759-301"><xref:System.Windows.UIElement> 始终可以接收触控事件。</span><span class="sxs-lookup"><span data-stu-id="72759-301">A <xref:System.Windows.UIElement> can always receive touch events.</span></span> <span data-ttu-id="72759-302"><xref:System.Windows.UIElement.IsManipulationEnabled%2A> 属性设置为 `true`时，<xref:System.Windows.UIElement> 可以同时接收触控事件和操作事件。</span><span class="sxs-lookup"><span data-stu-id="72759-302">When the <xref:System.Windows.UIElement.IsManipulationEnabled%2A> property is set to `true`, a <xref:System.Windows.UIElement> can receive both touch and manipulation events.</span></span>  <span data-ttu-id="72759-303">如果未处理 <xref:System.Windows.UIElement.TouchDown> 事件（即，`false`<xref:System.Windows.RoutedEventArgs.Handled%2A> 属性），则操作逻辑会将触摸屏捕获到元素，并生成操作事件。</span><span class="sxs-lookup"><span data-stu-id="72759-303">If the <xref:System.Windows.UIElement.TouchDown> event is not handled (that is, the <xref:System.Windows.RoutedEventArgs.Handled%2A> property is `false`), the manipulation logic captures the touch to the element and generates the manipulation events.</span></span> <span data-ttu-id="72759-304">如果在 <xref:System.Windows.UIElement.TouchDown> 事件中将 <xref:System.Windows.RoutedEventArgs.Handled%2A> 属性设置为 `true`，则操作逻辑不会生成操作事件。</span><span class="sxs-lookup"><span data-stu-id="72759-304">If the <xref:System.Windows.RoutedEventArgs.Handled%2A> property is set to `true` in the <xref:System.Windows.UIElement.TouchDown> event, the manipulation logic does not generate manipulation events.</span></span> <span data-ttu-id="72759-305">下图显示了触摸事件和操作事件之间的关系。</span><span class="sxs-lookup"><span data-stu-id="72759-305">The following illustration shows the relationship between touch events and manipulation events.</span></span>

 <span data-ttu-id="72759-306">![触控事件和操作事件之间的关系](./media/ndp-touchmanipulateevents.png "NDP_TouchManipulateEvents")触控和操作事件</span><span class="sxs-lookup"><span data-stu-id="72759-306">![Relationship between touch and manipulation events](./media/ndp-touchmanipulateevents.png "NDP_TouchManipulateEvents") Touch and manipulation events</span></span>

 <span data-ttu-id="72759-307">下列内容描述了上图中所示的触摸事件和操作事件之间的关系。</span><span class="sxs-lookup"><span data-stu-id="72759-307">The following list describes the relationship between the touch and manipulation events that is shown in the preceding illustration.</span></span>

- <span data-ttu-id="72759-308">当第一个触摸设备在 <xref:System.Windows.UIElement>上生成 <xref:System.Windows.UIElement.TouchDown> 事件时，操作逻辑将调用 <xref:System.Windows.UIElement.CaptureTouch%2A> 方法，该方法将生成 <xref:System.Windows.UIElement.GotTouchCapture> 事件。</span><span class="sxs-lookup"><span data-stu-id="72759-308">When the first touch device generates a <xref:System.Windows.UIElement.TouchDown> event on a <xref:System.Windows.UIElement>, the manipulation logic calls the <xref:System.Windows.UIElement.CaptureTouch%2A> method, which generates the <xref:System.Windows.UIElement.GotTouchCapture> event.</span></span>

- <span data-ttu-id="72759-309">当发生 <xref:System.Windows.UIElement.GotTouchCapture> 时，操作逻辑将调用 <xref:System.Windows.Input.Manipulation.AddManipulator%2A?displayProperty=nameWithType> 方法，该方法将生成 <xref:System.Windows.UIElement.ManipulationStarting> 事件。</span><span class="sxs-lookup"><span data-stu-id="72759-309">When the <xref:System.Windows.UIElement.GotTouchCapture> occurs, the manipulation logic calls the <xref:System.Windows.Input.Manipulation.AddManipulator%2A?displayProperty=nameWithType> method, which generates the <xref:System.Windows.UIElement.ManipulationStarting> event.</span></span>

- <span data-ttu-id="72759-310">当 <xref:System.Windows.UIElement.TouchMove> 事件发生时，操作逻辑将生成在 <xref:System.Windows.UIElement.ManipulationInertiaStarting> 事件之前发生的 <xref:System.Windows.UIElement.ManipulationDelta> 事件。</span><span class="sxs-lookup"><span data-stu-id="72759-310">When the <xref:System.Windows.UIElement.TouchMove> events occur, the manipulation logic generates the <xref:System.Windows.UIElement.ManipulationDelta> events that occur before the <xref:System.Windows.UIElement.ManipulationInertiaStarting> event.</span></span>

- <span data-ttu-id="72759-311">当元素上的最后一个触摸设备引发 <xref:System.Windows.UIElement.TouchUp> 事件时，操作逻辑将生成 <xref:System.Windows.UIElement.ManipulationInertiaStarting> 事件。</span><span class="sxs-lookup"><span data-stu-id="72759-311">When the last touch device on the element raises the <xref:System.Windows.UIElement.TouchUp> event, the manipulation logic generates the <xref:System.Windows.UIElement.ManipulationInertiaStarting> event.</span></span>

<a name="focus"></a>
## <a name="focus"></a><span data-ttu-id="72759-312">聚焦</span><span class="sxs-lookup"><span data-stu-id="72759-312">Focus</span></span>
 <span data-ttu-id="72759-313">在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中，有两个与焦点有关的主要概念：键盘焦点和逻辑焦点。</span><span class="sxs-lookup"><span data-stu-id="72759-313">There are two main concepts that pertain to focus in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]: keyboard focus and logical focus.</span></span>

### <a name="keyboard-focus"></a><span data-ttu-id="72759-314">键盘焦点</span><span class="sxs-lookup"><span data-stu-id="72759-314">Keyboard Focus</span></span>
 <span data-ttu-id="72759-315">键盘焦点指当前正在接收键盘输入的元素。</span><span class="sxs-lookup"><span data-stu-id="72759-315">Keyboard focus refers to the element that is receiving keyboard input.</span></span>  <span data-ttu-id="72759-316">在整个桌面上，只能有一个具有键盘焦点的元素。</span><span class="sxs-lookup"><span data-stu-id="72759-316">There can be only one element on the whole desktop that has keyboard focus.</span></span>  <span data-ttu-id="72759-317">在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]中，具有键盘焦点的元素将 <xref:System.Windows.IInputElement.IsKeyboardFocused%2A> 设置为 "`true`"。</span><span class="sxs-lookup"><span data-stu-id="72759-317">In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], the element that has keyboard focus will have <xref:System.Windows.IInputElement.IsKeyboardFocused%2A> set to `true`.</span></span>  <span data-ttu-id="72759-318">静态 <xref:System.Windows.Input.Keyboard> 方法 <xref:System.Windows.Input.Keyboard.FocusedElement%2A> 返回当前具有键盘焦点的元素。</span><span class="sxs-lookup"><span data-stu-id="72759-318">The static <xref:System.Windows.Input.Keyboard> method <xref:System.Windows.Input.Keyboard.FocusedElement%2A> returns the element that currently has keyboard focus.</span></span>

 <span data-ttu-id="72759-319">可以通过切换到元素或在某些元素（如 <xref:System.Windows.Controls.TextBox>）上单击鼠标来获取键盘焦点。</span><span class="sxs-lookup"><span data-stu-id="72759-319">Keyboard focus can be obtained by tabbing to an element or by clicking the mouse on certain elements, such as a <xref:System.Windows.Controls.TextBox>.</span></span>  <span data-ttu-id="72759-320">还可以通过对 <xref:System.Windows.Input.Keyboard> 类使用 <xref:System.Windows.Input.Keyboard.Focus%2A> 方法，以编程方式获取键盘焦点。</span><span class="sxs-lookup"><span data-stu-id="72759-320">Keyboard focus can also be obtained programmatically by using the <xref:System.Windows.Input.Keyboard.Focus%2A> method on the <xref:System.Windows.Input.Keyboard> class.</span></span>  <span data-ttu-id="72759-321"><xref:System.Windows.Input.Keyboard.Focus%2A> 尝试给指定元素的键盘焦点。</span><span class="sxs-lookup"><span data-stu-id="72759-321"><xref:System.Windows.Input.Keyboard.Focus%2A> attempts to give the specified element keyboard focus.</span></span>  <span data-ttu-id="72759-322"><xref:System.Windows.Input.Keyboard.Focus%2A> 返回的元素是当前具有键盘焦点的元素。</span><span class="sxs-lookup"><span data-stu-id="72759-322">The element returned by <xref:System.Windows.Input.Keyboard.Focus%2A> is the element that currently has keyboard focus.</span></span>

 <span data-ttu-id="72759-323">为了使元素获得键盘焦点，<xref:System.Windows.UIElement.Focusable%2A> 属性和 <xref:System.Windows.UIElement.IsVisible%2A> 属性必须设置为**true**。</span><span class="sxs-lookup"><span data-stu-id="72759-323">In order for an element to obtain keyboard focus the <xref:System.Windows.UIElement.Focusable%2A> property and the <xref:System.Windows.UIElement.IsVisible%2A> properties must be set to **true**.</span></span>  <span data-ttu-id="72759-324">某些类（如 <xref:System.Windows.Controls.Panel>） <xref:System.Windows.UIElement.Focusable%2A> 默认设置为 `false`;因此，您可能需要将此属性设置为 `true` 如果希望该元素能够获取焦点。</span><span class="sxs-lookup"><span data-stu-id="72759-324">Some classes, such as <xref:System.Windows.Controls.Panel>, have <xref:System.Windows.UIElement.Focusable%2A> set to `false` by default; therefore, you may have to set this property to `true` if you want that element to be able to obtain focus.</span></span>

 <span data-ttu-id="72759-325">下面的示例使用 <xref:System.Windows.Input.Keyboard.Focus%2A> 设置 <xref:System.Windows.Controls.Button>上的键盘焦点。</span><span class="sxs-lookup"><span data-stu-id="72759-325">The following example uses <xref:System.Windows.Input.Keyboard.Focus%2A> to set keyboard focus on a <xref:System.Windows.Controls.Button>.</span></span>  <span data-ttu-id="72759-326">在应用程序中设置初始焦点的建议位置是在 <xref:System.Windows.FrameworkElement.Loaded> 事件处理程序中。</span><span class="sxs-lookup"><span data-stu-id="72759-326">The recommended place to set initial focus in an application is in the <xref:System.Windows.FrameworkElement.Loaded> event handler.</span></span>

 [!code-csharp[focussample#FocusSampleSetFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#focussamplesetfocus)]
 [!code-vb[focussample#FocusSampleSetFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#focussamplesetfocus)]

 <span data-ttu-id="72759-327">有关键盘焦点的详细信息，请参阅[焦点概述](focus-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="72759-327">For more information about keyboard focus, see [Focus Overview](focus-overview.md).</span></span>

### <a name="logical-focus"></a><span data-ttu-id="72759-328">逻辑焦点</span><span class="sxs-lookup"><span data-stu-id="72759-328">Logical Focus</span></span>
 <span data-ttu-id="72759-329">逻辑焦点指的是焦点范围中的 <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="72759-329">Logical focus refers to the <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> in a focus scope.</span></span>  <span data-ttu-id="72759-330">一个应用程序中可以有多个具有逻辑焦点的元素，但在一个特定的焦点范围中只能有一个具有逻辑焦点的元素。</span><span class="sxs-lookup"><span data-stu-id="72759-330">There can be multiple elements that have logical focus in an application, but there may only be one element that has logical focus in a particular focus scope.</span></span>

 <span data-ttu-id="72759-331">焦点作用域是一个容器元素，用于跟踪其范围内的 <xref:System.Windows.Input.FocusManager.FocusedElement%2A>。</span><span class="sxs-lookup"><span data-stu-id="72759-331">A focus scope is a container element that keeps track of the <xref:System.Windows.Input.FocusManager.FocusedElement%2A> within its scope.</span></span>  <span data-ttu-id="72759-332">焦点离开焦点范围时，焦点元素会失去键盘焦点，但保留逻辑焦点。</span><span class="sxs-lookup"><span data-stu-id="72759-332">When focus leaves a focus scope, the focused element will lose keyboard focus but will retain logical focus.</span></span>  <span data-ttu-id="72759-333">焦点返回到焦点范围时，焦点元素会再次获得键盘焦点。</span><span class="sxs-lookup"><span data-stu-id="72759-333">When focus returns to the focus scope, the focused element will obtain keyboard focus.</span></span>  <span data-ttu-id="72759-334">这使得键盘焦点可在多个焦点范围之间切换，但确保了焦点返回到焦点范围时，焦点范围中的焦点元素仍为焦点元素。</span><span class="sxs-lookup"><span data-stu-id="72759-334">This allows for keyboard focus to be changed between multiple focus scopes but insures that the focused element within the focus scope remains the focused element when focus returns.</span></span>

 <span data-ttu-id="72759-335">通过使用 <xref:System.Windows.Input.FocusManager.SetIsFocusScope%2A> 方法设置附加属性，可以将元素转换为 [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] 中的焦点作用域，方法是将 <xref:System.Windows.Input.FocusManager> 附加 <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> 属性设置为 `true`，或在代码中设置该属性。</span><span class="sxs-lookup"><span data-stu-id="72759-335">An element can be turned into a focus scope in [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] by setting the <xref:System.Windows.Input.FocusManager> attached property <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> to `true`, or in code by setting the attached property by using the <xref:System.Windows.Input.FocusManager.SetIsFocusScope%2A> method.</span></span>

 <span data-ttu-id="72759-336">下面的示例通过设置 <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> 附加属性，使 <xref:System.Windows.Controls.StackPanel> 成为焦点范围。</span><span class="sxs-lookup"><span data-stu-id="72759-336">The following example makes a <xref:System.Windows.Controls.StackPanel> into a focus scope by setting the <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> attached property.</span></span>

 [!code-xaml[MarkupSnippets#MarkupIsFocusScopeXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/MarkupSnippets/CSharp/Window1.xaml#markupisfocusscopexaml)]

 [!code-csharp[FocusSnippets#FocusSetIsFocusScope](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSnippets/CSharp/Window1.xaml.cs#focussetisfocusscope)]
 [!code-vb[FocusSnippets#FocusSetIsFocusScope](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSnippets/visualbasic/window1.xaml.vb#focussetisfocusscope)]

 <span data-ttu-id="72759-337">默认情况下，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中的类为焦点范围 <xref:System.Windows.Window>、<xref:System.Windows.Controls.Menu>、<xref:System.Windows.Controls.ToolBar>和 <xref:System.Windows.Controls.ContextMenu>。</span><span class="sxs-lookup"><span data-stu-id="72759-337">Classes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] which are focus scopes by default are <xref:System.Windows.Window>, <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ToolBar>, and <xref:System.Windows.Controls.ContextMenu>.</span></span>

 <span data-ttu-id="72759-338">具有键盘焦点的元素还将对其所属的焦点范围具有逻辑焦点;因此，将焦点设置到 <xref:System.Windows.Input.Keyboard> 类上具有 <xref:System.Windows.Input.Keyboard.Focus%2A> 方法的元素上或基元素类将尝试为元素提供键盘焦点和逻辑焦点。</span><span class="sxs-lookup"><span data-stu-id="72759-338">An element that has keyboard focus will also have logical focus for the focus scope it belongs to; therefore, setting focus on an element with the <xref:System.Windows.Input.Keyboard.Focus%2A> method on the <xref:System.Windows.Input.Keyboard> class or the base element classes will attempt to give the element keyboard focus and logical focus.</span></span>

 <span data-ttu-id="72759-339">若要确定焦点范围中的焦点元素，请使用 <xref:System.Windows.Input.FocusManager.GetFocusedElement%2A>。</span><span class="sxs-lookup"><span data-stu-id="72759-339">To determine the focused element in a focus scope, use <xref:System.Windows.Input.FocusManager.GetFocusedElement%2A>.</span></span> <span data-ttu-id="72759-340">若要更改焦点范围中的焦点元素，请使用 <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A>。</span><span class="sxs-lookup"><span data-stu-id="72759-340">To change the focused element for a focus scope, use <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A>.</span></span>

 <span data-ttu-id="72759-341">有关逻辑焦点的详细信息，请参阅[焦点概述](focus-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="72759-341">For more information about logical focus, see [Focus Overview](focus-overview.md).</span></span>

<a name="mouse_position"></a>
## <a name="mouse-position"></a><span data-ttu-id="72759-342">鼠标位置</span><span class="sxs-lookup"><span data-stu-id="72759-342">Mouse Position</span></span>
 <span data-ttu-id="72759-343">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 输入 API 提供有关坐标空间的有用信息。</span><span class="sxs-lookup"><span data-stu-id="72759-343">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] input API provides helpful information with regard to coordinate spaces.</span></span>  <span data-ttu-id="72759-344">例如，坐标 `(0,0)` 为左上角坐标，但该坐标是树中那一个元素的左上角坐标？</span><span class="sxs-lookup"><span data-stu-id="72759-344">For example, coordinate `(0,0)` is the upper-left coordinate, but the upper-left of which element in the tree?</span></span> <span data-ttu-id="72759-345">是属于输入目标的元素？</span><span class="sxs-lookup"><span data-stu-id="72759-345">The element that is the input target?</span></span> <span data-ttu-id="72759-346">是在其上附加事件处理程序的元素？</span><span class="sxs-lookup"><span data-stu-id="72759-346">The element you attached your event handler to?</span></span> <span data-ttu-id="72759-347">还是其他内容？</span><span class="sxs-lookup"><span data-stu-id="72759-347">Or something else?</span></span> <span data-ttu-id="72759-348">为避免混淆，在使用通过鼠标获取的坐标时，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 输入 API 需要指定引用框架。</span><span class="sxs-lookup"><span data-stu-id="72759-348">To avoid confusion, the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] input API requires that you specify your frame of reference when you work with coordinates obtained through the mouse.</span></span> <span data-ttu-id="72759-349"><xref:System.Windows.Input.Mouse.GetPosition%2A> 方法返回鼠标指针相对于指定元素的坐标。</span><span class="sxs-lookup"><span data-stu-id="72759-349">The <xref:System.Windows.Input.Mouse.GetPosition%2A> method returns the coordinate of the mouse pointer relative to the specified element.</span></span>

<a name="mouse_capture"></a>
## <a name="mouse-capture"></a><span data-ttu-id="72759-350">鼠标捕获</span><span class="sxs-lookup"><span data-stu-id="72759-350">Mouse Capture</span></span>
 <span data-ttu-id="72759-351">鼠标设备专门保留称为鼠标捕获的模式特征。</span><span class="sxs-lookup"><span data-stu-id="72759-351">Mouse devices specifically hold a modal characteristic known as mouse capture.</span></span> <span data-ttu-id="72759-352">鼠标捕获用于在拖放操作开始时保持转换的输入状态，从而不一定发生涉及鼠标指针的标称屏幕位置的其他操作。</span><span class="sxs-lookup"><span data-stu-id="72759-352">Mouse capture is used to maintain a transitional input state when a drag-and-drop operation is started, so that other operations involving the nominal on-screen position of the mouse pointer do not necessarily occur.</span></span> <span data-ttu-id="72759-353">拖动过程中，未终止拖放时用户无法单击，这使得大多数鼠标悬停提示在拖动来源拥有鼠标捕获时是不合适的。</span><span class="sxs-lookup"><span data-stu-id="72759-353">During the drag, the user cannot click without aborting the drag-and-drop, which makes most mouseover cues inappropriate while the mouse capture is held by the drag origin.</span></span> <span data-ttu-id="72759-354">输入系统公开可确定鼠标捕获状态的 Api，以及可强制将鼠标捕获到特定元素或清除鼠标捕获状态的 Api。</span><span class="sxs-lookup"><span data-stu-id="72759-354">The input system exposes APIs that can determine mouse capture state, as well as APIs that can force mouse capture to a specific element, or clear mouse capture state.</span></span> <span data-ttu-id="72759-355">有关拖放操作的详细信息，请参阅[拖放概述](drag-and-drop-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="72759-355">For more information on drag-and-drop operations, see [Drag and Drop Overview](drag-and-drop-overview.md).</span></span>

<a name="commands"></a>
## <a name="commands"></a><span data-ttu-id="72759-356">命令</span><span class="sxs-lookup"><span data-stu-id="72759-356">Commands</span></span>
 <span data-ttu-id="72759-357">使用命令，输入处理可以更多地在语义级别（而不是在设备输入级别）进行。</span><span class="sxs-lookup"><span data-stu-id="72759-357">Commands enable input handling at a more semantic level than device input.</span></span>  <span data-ttu-id="72759-358">命令是简单的指令，如 `Cut`、`Copy`、`Paste` 或 `Open`。</span><span class="sxs-lookup"><span data-stu-id="72759-358">Commands are simple directives, such as `Cut`, `Copy`, `Paste`, or `Open`.</span></span>  <span data-ttu-id="72759-359">命令可用于集中命令逻辑。</span><span class="sxs-lookup"><span data-stu-id="72759-359">Commands are useful for centralizing your command logic.</span></span>  <span data-ttu-id="72759-360">可以通过 <xref:System.Windows.Controls.Menu>、<xref:System.Windows.Controls.ToolBar>或键盘快捷方式访问同一命令。</span><span class="sxs-lookup"><span data-stu-id="72759-360">The same command might be accessed from a <xref:System.Windows.Controls.Menu>, on a <xref:System.Windows.Controls.ToolBar>, or through a keyboard shortcut.</span></span> <span data-ttu-id="72759-361">命令还提供一种机制，用于在命令不可用时禁用控件。</span><span class="sxs-lookup"><span data-stu-id="72759-361">Commands also provide a mechanism for disabling controls when the command becomes unavailable.</span></span>

 <span data-ttu-id="72759-362"><xref:System.Windows.Input.RoutedCommand> 是 <xref:System.Windows.Input.ICommand>的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 实现。</span><span class="sxs-lookup"><span data-stu-id="72759-362"><xref:System.Windows.Input.RoutedCommand> is the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] implementation of <xref:System.Windows.Input.ICommand>.</span></span>  <span data-ttu-id="72759-363">当执行 <xref:System.Windows.Input.RoutedCommand> 时，将在命令目标上引发 <xref:System.Windows.Input.CommandManager.PreviewExecuted> 和 <xref:System.Windows.Input.CommandManager.Executed> 事件，这会通过元素树进行隧道和冒泡，如其他输入。</span><span class="sxs-lookup"><span data-stu-id="72759-363">When a <xref:System.Windows.Input.RoutedCommand> is executed, a <xref:System.Windows.Input.CommandManager.PreviewExecuted> and an <xref:System.Windows.Input.CommandManager.Executed> event are raised on the command target, which tunnel and bubble through the element tree like other input.</span></span>  <span data-ttu-id="72759-364">如果未设置命令目标，则具有键盘焦点的元素将成为命令目标。</span><span class="sxs-lookup"><span data-stu-id="72759-364">If a command target is not set, the element with keyboard focus will be the command target.</span></span>  <span data-ttu-id="72759-365">执行命令的逻辑附加到 <xref:System.Windows.Input.CommandBinding>。</span><span class="sxs-lookup"><span data-stu-id="72759-365">The logic that performs the command is attached to a <xref:System.Windows.Input.CommandBinding>.</span></span>  <span data-ttu-id="72759-366">当 <xref:System.Windows.Input.CommandManager.Executed> 事件到达该特定命令的 <xref:System.Windows.Input.CommandBinding> 时，会调用 <xref:System.Windows.Input.CommandBinding> 上的 <xref:System.Windows.Input.ExecutedRoutedEventHandler>。</span><span class="sxs-lookup"><span data-stu-id="72759-366">When an <xref:System.Windows.Input.CommandManager.Executed> event reaches a <xref:System.Windows.Input.CommandBinding> for that specific command, the <xref:System.Windows.Input.ExecutedRoutedEventHandler> on the <xref:System.Windows.Input.CommandBinding> is called.</span></span>  <span data-ttu-id="72759-367">此处理程序执行该命令的操作。</span><span class="sxs-lookup"><span data-stu-id="72759-367">This handler performs the action of the command.</span></span>

 <span data-ttu-id="72759-368">有关命令的详细信息，请参阅[命令概述](commanding-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="72759-368">For more information on commanding, see [Commanding Overview](commanding-overview.md).</span></span>

 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="72759-369">提供了包含 <xref:System.Windows.Input.ApplicationCommands>、<xref:System.Windows.Input.MediaCommands>、<xref:System.Windows.Input.ComponentCommands>、<xref:System.Windows.Input.NavigationCommands>和 <xref:System.Windows.Documents.EditingCommands>的常见命令库，你也可以定义自己的命令。</span><span class="sxs-lookup"><span data-stu-id="72759-369">provides a library of common commands which consists of <xref:System.Windows.Input.ApplicationCommands>, <xref:System.Windows.Input.MediaCommands>, <xref:System.Windows.Input.ComponentCommands>, <xref:System.Windows.Input.NavigationCommands>, and <xref:System.Windows.Documents.EditingCommands>, or you can define your own.</span></span>

 <span data-ttu-id="72759-370">下面的示例演示如何设置 <xref:System.Windows.Controls.MenuItem> 以便在单击它时，它将调用 <xref:System.Windows.Controls.TextBox>上的 <xref:System.Windows.Input.ApplicationCommands.Paste%2A> 命令，假定 <xref:System.Windows.Controls.TextBox> 具有键盘焦点。</span><span class="sxs-lookup"><span data-stu-id="72759-370">The following example shows how to set up a <xref:System.Windows.Controls.MenuItem> so that when it is clicked it will invoke the <xref:System.Windows.Input.ApplicationCommands.Paste%2A> command on the <xref:System.Windows.Controls.TextBox>, assuming the <xref:System.Windows.Controls.TextBox> has keyboard focus.</span></span>

 [!code-xaml[CommandingOverviewSnippets#CommandingOverviewSimpleCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewsimplecommand)]

 [!code-csharp[CommandingOverviewSnippets#CommandingOverviewCommandTargetCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewcommandtargetcodebehind)]
 [!code-vb[CommandingOverviewSnippets#CommandingOverviewCommandTargetCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewcommandtargetcodebehind)]

 <span data-ttu-id="72759-371">有关 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中的命令的详细信息，请参阅[命令概述](commanding-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="72759-371">For more information about commands in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], see [Commanding Overview](commanding-overview.md).</span></span>

<a name="the_input_system_and_base_elements"></a>
## <a name="the-input-system-and-base-elements"></a><span data-ttu-id="72759-372">输入系统和基元素</span><span class="sxs-lookup"><span data-stu-id="72759-372">The Input System and Base Elements</span></span>
 <span data-ttu-id="72759-373">输入事件（例如 <xref:System.Windows.Input.Mouse>、<xref:System.Windows.Input.Keyboard>和 <xref:System.Windows.Input.Stylus> 类定义的附加事件）由输入系统引发，并根据运行时的可视化树命中测试，注入到对象模型中的特定位置。</span><span class="sxs-lookup"><span data-stu-id="72759-373">Input events such as the attached events defined by the <xref:System.Windows.Input.Mouse>, <xref:System.Windows.Input.Keyboard>, and <xref:System.Windows.Input.Stylus> classes are raised by the input system and injected into a particular position in the object model based on hit testing the visual tree at run time.</span></span>

 <span data-ttu-id="72759-374"><xref:System.Windows.Input.Mouse>、<xref:System.Windows.Input.Keyboard>和 <xref:System.Windows.Input.Stylus> 定义为附加事件的每个事件也会由基元素 <xref:System.Windows.UIElement> 类重新公开，并 <xref:System.Windows.ContentElement> 作为新的路由事件。</span><span class="sxs-lookup"><span data-stu-id="72759-374">Each of the events that <xref:System.Windows.Input.Mouse>, <xref:System.Windows.Input.Keyboard>, and <xref:System.Windows.Input.Stylus> define as an attached event is also re-exposed by the base element classes <xref:System.Windows.UIElement> and <xref:System.Windows.ContentElement> as a new routed event.</span></span> <span data-ttu-id="72759-375">基元素路由事件由处理原始附加事件并重用事件数据的类生成。</span><span class="sxs-lookup"><span data-stu-id="72759-375">The base element routed events are generated by classes handling the original attached event and reusing the event data.</span></span>

 <span data-ttu-id="72759-376">当输入事件通过其基元素输入事件实现与特定源元素相关联时，可以通过基于逻辑和可视化树对象的组合的事件路由的其余部分进行路由，并由应用程序代码进行处理。</span><span class="sxs-lookup"><span data-stu-id="72759-376">When the input event becomes associated with a particular source element through its base element input event implementation, it can be routed through the remainder of an event route that is based on a combination of logical and visual tree objects, and be handled by application code.</span></span>  <span data-ttu-id="72759-377">通常，使用 <xref:System.Windows.UIElement> 和 <xref:System.Windows.ContentElement>上的路由事件处理这些与设备有关的输入事件会更方便，因为可以在 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 和代码中使用更直观的事件处理程序语法。</span><span class="sxs-lookup"><span data-stu-id="72759-377">Generally, it is more convenient to handle these device-related input events using the routed events on <xref:System.Windows.UIElement> and <xref:System.Windows.ContentElement>, because you can use more intuitive event handler syntax both in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] and in code.</span></span> <span data-ttu-id="72759-378">你可以选择处理发起进程的附加事件，但将会面临几个问题：附加事件可能会被基元素类处理标记为已处理，并且你需要使用访问器方法（而不是真正的事件语法）才能为附加事件附加处理程序。</span><span class="sxs-lookup"><span data-stu-id="72759-378">You could choose to handle the attached event that initiated the process instead, but you would face several issues: the attached event may be marked handled by the base element class handling, and you need to use accessor methods rather than true event syntax in order to attach handlers for attached events.</span></span>

<a name="whats_next"></a>
## <a name="whats-next"></a><span data-ttu-id="72759-379">后续步骤</span><span class="sxs-lookup"><span data-stu-id="72759-379">What's Next</span></span>
 <span data-ttu-id="72759-380">现在有多种方法来处理 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中的输入。</span><span class="sxs-lookup"><span data-stu-id="72759-380">You now have several techniques to handle input in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>  <span data-ttu-id="72759-381">你还应该对 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 使用的各种类型的输入事件和路由事件机制有进一步的了解。</span><span class="sxs-lookup"><span data-stu-id="72759-381">You should also have an improved understanding of the various types of input events and the routed event mechanisms used by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>

 <span data-ttu-id="72759-382">也可以获取更详细说明 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 框架元素和事件路由的详细资源。</span><span class="sxs-lookup"><span data-stu-id="72759-382">Additional resources are available that explain [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] framework elements and event routing in more detail.</span></span> <span data-ttu-id="72759-383">有关详细信息，请参阅以下概述：[命令概述](commanding-overview.md)、[焦点概述](focus-overview.md)、[基元素概述](base-elements-overview.md)、[WPF 中的树](trees-in-wpf.md)和[路由事件概述](routed-events-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="72759-383">See the following overviews for more information, [Commanding Overview](commanding-overview.md), [Focus Overview](focus-overview.md), [Base Elements Overview](base-elements-overview.md), [Trees in WPF](trees-in-wpf.md), and [Routed Events Overview](routed-events-overview.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="72759-384">另请参阅</span><span class="sxs-lookup"><span data-stu-id="72759-384">See also</span></span>

- [<span data-ttu-id="72759-385">焦点概述</span><span class="sxs-lookup"><span data-stu-id="72759-385">Focus Overview</span></span>](focus-overview.md)
- [<span data-ttu-id="72759-386">命令概述</span><span class="sxs-lookup"><span data-stu-id="72759-386">Commanding Overview</span></span>](commanding-overview.md)
- [<span data-ttu-id="72759-387">路由事件概述</span><span class="sxs-lookup"><span data-stu-id="72759-387">Routed Events Overview</span></span>](routed-events-overview.md)
- [<span data-ttu-id="72759-388">基元素概述</span><span class="sxs-lookup"><span data-stu-id="72759-388">Base Elements Overview</span></span>](base-elements-overview.md)
- [<span data-ttu-id="72759-389">属性</span><span class="sxs-lookup"><span data-stu-id="72759-389">Properties</span></span>](properties-wpf.md)
