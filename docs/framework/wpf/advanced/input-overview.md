---
title: 输入概述
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- commands [WPF]
- input [WPF], overview
- keyboard focus [WPF]
- keyboard input [WPF]
- touch events [WPF]
- event routing [WPF]
- touch input [WPF]
- manipulation [WPF]
- logical focus [WPF]
- stylus input [WPF]
- text input [WPF]
- input events [WPF], handling
- WPF [WPF], input overview
- manipulation events [WPF]
- mouse input [WPF]
- mouse capture [WPF]
- focus [WPF]
- mouse position [WPF]
ms.assetid: ee5258b7-6567-415a-9b1c-c0cbe46e79ef
ms.openlocfilehash: 47d892db8418b44fffeec870e56b49d5f986b563
ms.sourcegitcommit: eaa6d5cd0f4e7189dbe0bd756e9f53508b01989e
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 07/07/2019
ms.locfileid: "67610480"
---
# <a name="input-overview"></a><span data-ttu-id="98a46-102">输入概述</span><span class="sxs-lookup"><span data-stu-id="98a46-102">Input Overview</span></span>
<a name="introduction"></a> <span data-ttu-id="98a46-103">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]子系统提供了一个强大[!INCLUDE[TLA#tla_api](../../../../includes/tlasharptla-api-md.md)]用于获取输入不同的设备，包括鼠标、 键盘、 触控和触笔。</span><span class="sxs-lookup"><span data-stu-id="98a46-103">The [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] subsystem provides a powerful [!INCLUDE[TLA#tla_api](../../../../includes/tlasharptla-api-md.md)] for obtaining input from a variety of devices, including the mouse, keyboard, touch, and stylus.</span></span> <span data-ttu-id="98a46-104">本主题介绍了 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 提供的服务，并说明了输入系统的体系结构。</span><span class="sxs-lookup"><span data-stu-id="98a46-104">This topic describes the services provided by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and explains the architecture of the input systems.</span></span>

<a name="input_api"></a>
## <a name="input-api"></a><span data-ttu-id="98a46-105">输入 API</span><span class="sxs-lookup"><span data-stu-id="98a46-105">Input API</span></span>
 <span data-ttu-id="98a46-106">基元素类上找到 API 公开的主要输入： <xref:System.Windows.UIElement>， <xref:System.Windows.ContentElement>， <xref:System.Windows.FrameworkElement>，和<xref:System.Windows.FrameworkContentElement>。</span><span class="sxs-lookup"><span data-stu-id="98a46-106">The primary input API exposure is found on the base element classes: <xref:System.Windows.UIElement>, <xref:System.Windows.ContentElement>, <xref:System.Windows.FrameworkElement>, and <xref:System.Windows.FrameworkContentElement>.</span></span>  <span data-ttu-id="98a46-107">有关基元素的详细信息，请参阅[基元素概述](base-elements-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="98a46-107">For more information about the base elements, see [Base Elements Overview](base-elements-overview.md).</span></span>  <span data-ttu-id="98a46-108">这些类提供有关输入事件（例如按键、鼠标按钮、鼠标滚轮、鼠标移动、焦点管理和鼠标捕获等）的功能。</span><span class="sxs-lookup"><span data-stu-id="98a46-108">These classes provide functionality for input events related to key presses, mouse buttons, mouse wheel, mouse movement, focus management, and mouse capture, to name a few.</span></span> <span data-ttu-id="98a46-109">通过将输入 API 放在基元素上，而将所有输入的事件都视为服务，该输入体系结构使输入的事件可通过在 UI 中的特定对象指明其来源和以支持多个元素，从而使得有 opp 事件路由方案ortunity 来处理输入的事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-109">By placing the input API on the base elements, rather than treating all input events as a service, the input architecture enables the input events to be sourced by a particular object in the UI, and to support an event routing scheme whereby more than one element has an opportunity to handle an input event.</span></span> <span data-ttu-id="98a46-110">许多输入事件都具有与之相关联的一对事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-110">Many input events have a pair of events associated with them.</span></span>  <span data-ttu-id="98a46-111">例如，键按下事件与<xref:System.Windows.Input.Keyboard.KeyDown>和<xref:System.Windows.Input.Keyboard.PreviewKeyDown>事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-111">For example, the key down event is associated with the <xref:System.Windows.Input.Keyboard.KeyDown> and <xref:System.Windows.Input.Keyboard.PreviewKeyDown> events.</span></span>  <span data-ttu-id="98a46-112">这些事件的区别在于它们如何路由至目标元素。</span><span class="sxs-lookup"><span data-stu-id="98a46-112">The difference in these events is in how they are routed to the target element.</span></span>  <span data-ttu-id="98a46-113">预览事件将元素树从根元素到目标元素向下进行隧道操作。</span><span class="sxs-lookup"><span data-stu-id="98a46-113">Preview events tunnel down the element tree from the root element to the target element.</span></span>  <span data-ttu-id="98a46-114">冒泡事件从目标元素到根元素向上进行冒泡操作。</span><span class="sxs-lookup"><span data-stu-id="98a46-114">Bubbling events bubble up from the target element to the root element.</span></span>  <span data-ttu-id="98a46-115">本概述后面部分和[路由事件概述](routed-events-overview.md)中更详细地讨论了 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中的事件路由。</span><span class="sxs-lookup"><span data-stu-id="98a46-115">Event routing in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is discussed in more detail later in this overview and in the [Routed Events Overview](routed-events-overview.md).</span></span>

### <a name="keyboard-and-mouse-classes"></a><span data-ttu-id="98a46-116">键盘和鼠标类</span><span class="sxs-lookup"><span data-stu-id="98a46-116">Keyboard and Mouse Classes</span></span>
 <span data-ttu-id="98a46-117">除了基元素类上的输入 API<xref:System.Windows.Input.Keyboard>类和<xref:System.Windows.Input.Mouse>类提供用于处理与键盘和鼠标输入的其他 API。</span><span class="sxs-lookup"><span data-stu-id="98a46-117">In addition to the input API on the base element classes, the <xref:System.Windows.Input.Keyboard> class and <xref:System.Windows.Input.Mouse> classes provide additional API for working with keyboard and mouse input.</span></span>

 <span data-ttu-id="98a46-118">输入 API 上的示例<xref:System.Windows.Input.Keyboard>类是<xref:System.Windows.Input.Keyboard.Modifiers%2A>属性，它返回<xref:System.Windows.Input.ModifierKeys>当前按下，和<xref:System.Windows.Input.Keyboard.IsKeyDown%2A>方法，这可确定是否按下某个指定的键。</span><span class="sxs-lookup"><span data-stu-id="98a46-118">Examples of input API on the <xref:System.Windows.Input.Keyboard> class are the <xref:System.Windows.Input.Keyboard.Modifiers%2A> property, which returns the <xref:System.Windows.Input.ModifierKeys> currently pressed, and the <xref:System.Windows.Input.Keyboard.IsKeyDown%2A> method, which determines whether a specified key is pressed.</span></span>

 <span data-ttu-id="98a46-119">下面的示例使用<xref:System.Windows.Input.Keyboard.GetKeyStates%2A>方法，以确定如果<xref:System.Windows.Input.Key>处于关闭状态。</span><span class="sxs-lookup"><span data-stu-id="98a46-119">The following example uses the <xref:System.Windows.Input.Keyboard.GetKeyStates%2A> method to determine if a <xref:System.Windows.Input.Key> is in the down state.</span></span>

 [!code-csharp[keyargssnippetsample#KeyEventArgsKeyBoardGetKeyStates](~/samples/snippets/csharp/VS_Snippets_Wpf/KeyArgsSnippetSample/CSharp/Window1.xaml.cs#keyeventargskeyboardgetkeystates)]
 [!code-vb[keyargssnippetsample#KeyEventArgsKeyBoardGetKeyStates](~/samples/snippets/visualbasic/VS_Snippets_Wpf/KeyArgsSnippetSample/visualbasic/window1.xaml.vb#keyeventargskeyboardgetkeystates)]

 <span data-ttu-id="98a46-120">输入 API 上的示例<xref:System.Windows.Input.Mouse>类是<xref:System.Windows.Input.Mouse.MiddleButton%2A>，用于获取鼠标中键的状态和<xref:System.Windows.Input.Mouse.DirectlyOver%2A>，后者将获取该元素在鼠标指针当前位于。</span><span class="sxs-lookup"><span data-stu-id="98a46-120">Examples of input API on the <xref:System.Windows.Input.Mouse> class are <xref:System.Windows.Input.Mouse.MiddleButton%2A>, which obtains the state of the middle mouse button, and <xref:System.Windows.Input.Mouse.DirectlyOver%2A>, which gets the element the mouse pointer is currently over.</span></span>

 <span data-ttu-id="98a46-121">下面的示例确定是否<xref:System.Windows.Input.Mouse.LeftButton%2A>鼠标位于<xref:System.Windows.Input.MouseButtonState.Pressed>状态。</span><span class="sxs-lookup"><span data-stu-id="98a46-121">The following example determines whether the <xref:System.Windows.Input.Mouse.LeftButton%2A> on the mouse is in the <xref:System.Windows.Input.MouseButtonState.Pressed> state.</span></span>

 [!code-csharp[mouserelatedsnippets#MouseRelatedSnippetsGetLeftButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetleftbuttonmouse)]
 [!code-vb[mouserelatedsnippets#MouseRelatedSnippetsGetLeftButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetleftbuttonmouse)]

 <span data-ttu-id="98a46-122"><xref:System.Windows.Input.Mouse>和<xref:System.Windows.Input.Keyboard>中更详细地介绍本概述介绍了类。</span><span class="sxs-lookup"><span data-stu-id="98a46-122">The <xref:System.Windows.Input.Mouse> and <xref:System.Windows.Input.Keyboard> classes are covered in more detail throughout this overview.</span></span>

### <a name="stylus-input"></a><span data-ttu-id="98a46-123">触笔输入</span><span class="sxs-lookup"><span data-stu-id="98a46-123">Stylus Input</span></span>
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="98a46-124">支持集成的<xref:System.Windows.Input.Stylus>。</span><span class="sxs-lookup"><span data-stu-id="98a46-124">has integrated support for the <xref:System.Windows.Input.Stylus>.</span></span>  <span data-ttu-id="98a46-125"><xref:System.Windows.Input.Stylus>是变得流行的笔输入[!INCLUDE[TLA#tla_tpc](../../../../includes/tlasharptla-tpc-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="98a46-125">The <xref:System.Windows.Input.Stylus> is a pen input made popular by the [!INCLUDE[TLA#tla_tpc](../../../../includes/tlasharptla-tpc-md.md)].</span></span>  [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="98a46-126">应用程序可以将触笔视为鼠标使用鼠标 API，但[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]还公开了触笔设备抽象，使用与键盘和鼠标类似的模型。</span><span class="sxs-lookup"><span data-stu-id="98a46-126">applications can treat the stylus as a mouse by using the mouse API, but [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] also exposes a stylus device abstraction that use a model similar to the keyboard and mouse.</span></span>  <span data-ttu-id="98a46-127">所有与触笔相关的 [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] 都包含单词“触笔”。</span><span class="sxs-lookup"><span data-stu-id="98a46-127">All stylus-related [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] contain the word "Stylus".</span></span>

 <span data-ttu-id="98a46-128">由于触笔可充当鼠标，因此仅支持鼠标输入的应用程序仍可以自动获得一定程度的触笔支持。</span><span class="sxs-lookup"><span data-stu-id="98a46-128">Because the stylus can act as a mouse, applications that support only mouse input can still obtain some level of stylus support automatically.</span></span> <span data-ttu-id="98a46-129">以这种方式使用触笔时，应用程序有能力处理相应的触笔事件，然后处理相应的鼠标事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-129">When the stylus is used in such a manner, the application is given the opportunity to handle the appropriate stylus event and then handles the corresponding mouse event.</span></span> <span data-ttu-id="98a46-130">此外，通过触笔设备抽象也可以使用墨迹输入等较高级别的服务。</span><span class="sxs-lookup"><span data-stu-id="98a46-130">In addition, higher-level services such as ink input are also available through the stylus device abstraction.</span></span>  <span data-ttu-id="98a46-131">有关墨迹输入的详细信息，请参阅[墨迹入门](getting-started-with-ink.md)。</span><span class="sxs-lookup"><span data-stu-id="98a46-131">For more information about ink as input, see [Getting Started with Ink](getting-started-with-ink.md).</span></span>

<a name="event_routing"></a>
## <a name="event-routing"></a><span data-ttu-id="98a46-132">事件路由</span><span class="sxs-lookup"><span data-stu-id="98a46-132">Event Routing</span></span>
 <span data-ttu-id="98a46-133">一个<xref:System.Windows.FrameworkElement>可以包含其他元素，作为在其内容模型中，从而形成一个树的元素的子元素。</span><span class="sxs-lookup"><span data-stu-id="98a46-133">A <xref:System.Windows.FrameworkElement> can contain other elements as child elements in its content model, forming a tree of elements.</span></span>  <span data-ttu-id="98a46-134">在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中，父元素可以通过处理事件来参与定向到其子元素或其他后代的输入。</span><span class="sxs-lookup"><span data-stu-id="98a46-134">In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], the parent element can participate in input directed to its child elements or other descendants by handing events.</span></span> <span data-ttu-id="98a46-135">这特别适合于从较小的控件中生成控件，该过程称为“控件组合”或“合成”。</span><span class="sxs-lookup"><span data-stu-id="98a46-135">This is especially useful for building controls out of smaller controls, a process known as "control composition" or "compositing."</span></span> <span data-ttu-id="98a46-136">有关元素树以及元素树如何与事件路由关联的详细信息，请参阅 [WPF 中的树](trees-in-wpf.md)。</span><span class="sxs-lookup"><span data-stu-id="98a46-136">For more information about element trees and how element trees relate to event routes, see [Trees in WPF](trees-in-wpf.md).</span></span>

 <span data-ttu-id="98a46-137">事件路由是将事件转发到多个元素的过程，以便使路由中的特定对象或元素可以选择对已由其他元素指明来源的事件提供重要响应（通过处理）。</span><span class="sxs-lookup"><span data-stu-id="98a46-137">Event routing is the process of forwarding events to multiple elements, so that a particular object or element along the route can choose to offer a significant response (through handling) to an event that might have been sourced by a different element.</span></span>  <span data-ttu-id="98a46-138">路由事件使用三种路由机制的其中一种：直接、浮升和隧道。</span><span class="sxs-lookup"><span data-stu-id="98a46-138">Routed events use one of three routing mechanisms: direct, bubbling, and tunneling.</span></span>  <span data-ttu-id="98a46-139">在直接路由中，源元素是收到通知的唯一元素，事件不会路由至任何其他元素。</span><span class="sxs-lookup"><span data-stu-id="98a46-139">In direct routing, the source element is the only element notified, and the event is not routed to any other elements.</span></span> <span data-ttu-id="98a46-140">但是相对于标准 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 事件，直接路由事件仍然提供一些仅针对路由事件而存在的其他功能。</span><span class="sxs-lookup"><span data-stu-id="98a46-140">However, the direct routed event still offers some additional capabilities that are only present for routed events as opposed to standard [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] events.</span></span> <span data-ttu-id="98a46-141">浮升操作在元素树中向上进行，首先通知指明了事件来源的第一个元素，然后是父元素等等。</span><span class="sxs-lookup"><span data-stu-id="98a46-141">Bubbling works up the element tree by first notifying the element that sourced the event, then the parent element, and so on.</span></span>  <span data-ttu-id="98a46-142">隧道操作从元素树的根开始，然后向下进行，以原始的源元素结束。</span><span class="sxs-lookup"><span data-stu-id="98a46-142">Tunneling starts at the root of the element tree and works down, ending with the original source element.</span></span>  <span data-ttu-id="98a46-143">有关路由事件的详细信息，请参阅[路由事件概述](routed-events-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="98a46-143">For more information about routed events, see [Routed Events Overview](routed-events-overview.md).</span></span>

 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="98a46-144">输入事件通常成对出现，由一个隧道事件和一个冒泡事件组成。</span><span class="sxs-lookup"><span data-stu-id="98a46-144">input events generally come in pairs that consists of a tunneling event and a bubbling event.</span></span>  <span data-ttu-id="98a46-145">隧道事件与冒泡事件的不同之处在于它有“预览”前缀。</span><span class="sxs-lookup"><span data-stu-id="98a46-145">Tunneling events are distinguished from bubbling events with the "Preview" prefix.</span></span>  <span data-ttu-id="98a46-146">例如，<xref:System.Windows.Input.Mouse.PreviewMouseMove>是鼠标移动事件的隧道版本和<xref:System.Windows.Input.Mouse.MouseMove>是此事件的冒泡版本。</span><span class="sxs-lookup"><span data-stu-id="98a46-146">For instance, <xref:System.Windows.Input.Mouse.PreviewMouseMove> is the tunneling version of a mouse move event and <xref:System.Windows.Input.Mouse.MouseMove> is the bubbling version of this event.</span></span> <span data-ttu-id="98a46-147">此事件配对是在元素级别实现的一种约定，不是 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 事件系统的固有功能。</span><span class="sxs-lookup"><span data-stu-id="98a46-147">This event pairing is a convention that is implemented at the element level and is not an inherent capability of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event system.</span></span> <span data-ttu-id="98a46-148">有关详细信息，请参阅[路由事件概述](routed-events-overview.md)中的 WPF 输入事件部分。</span><span class="sxs-lookup"><span data-stu-id="98a46-148">For details, see the WPF Input Events section in [Routed Events Overview](routed-events-overview.md).</span></span>

<a name="handling_input_events"></a>
## <a name="handling-input-events"></a><span data-ttu-id="98a46-149">处理输入事件</span><span class="sxs-lookup"><span data-stu-id="98a46-149">Handling Input Events</span></span>
 <span data-ttu-id="98a46-150">若要在元素上接收输入，必须将事件处理程序与该特定事件关联。</span><span class="sxs-lookup"><span data-stu-id="98a46-150">To receive input on an element, an event handler must be associated with that particular event.</span></span>  <span data-ttu-id="98a46-151">在 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 中，这很简单：将事件的名称作为要侦听此事件的元素的特性进行引用。</span><span class="sxs-lookup"><span data-stu-id="98a46-151">In [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] this is straightforward: you reference the name of the event as an attribute of the element that will be listening for this event.</span></span>  <span data-ttu-id="98a46-152">然后，根据委托，将特性的值设置为所定义的事件处理程序的名称。</span><span class="sxs-lookup"><span data-stu-id="98a46-152">Then, you set the value of the attribute to the name of the event handler that you define, based on a delegate.</span></span>  <span data-ttu-id="98a46-153">事件处理程序必须采用如 C# 代码，并可以包含在代码隐藏文件。</span><span class="sxs-lookup"><span data-stu-id="98a46-153">The event handler must be written in code such as C# and can be included in a code-behind file.</span></span>

 <span data-ttu-id="98a46-154">当操作系统报告发生键操作时，如果键盘焦点正处在元素上，则将发生键盘事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-154">Keyboard events occur when the operating system reports key actions that occur while keyboard focus is on an element.</span></span> <span data-ttu-id="98a46-155">鼠标和触笔事件分别分为两类：报告指针位置相对于元素的变化的事件，和报告设备按钮状态的变化的事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-155">Mouse and stylus events each fall into two categories: events that report changes in pointer position relative to the element, and events that report changes in the state of device buttons.</span></span>

### <a name="keyboard-input-event-example"></a><span data-ttu-id="98a46-156">键盘输入事件示例</span><span class="sxs-lookup"><span data-stu-id="98a46-156">Keyboard Input Event Example</span></span>
 <span data-ttu-id="98a46-157">以下示例侦听按下向左键的操作。</span><span class="sxs-lookup"><span data-stu-id="98a46-157">The following example listens for a left arrow key press.</span></span>  <span data-ttu-id="98a46-158">一个<xref:System.Windows.Controls.StackPanel>将创建一个具有<xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="98a46-158">A <xref:System.Windows.Controls.StackPanel> is created that has a <xref:System.Windows.Controls.Button>.</span></span>  <span data-ttu-id="98a46-159">一个事件处理程序以侦听按向左的箭头键附加到<xref:System.Windows.Controls.Button>实例。</span><span class="sxs-lookup"><span data-stu-id="98a46-159">An event handler to listen for the left arrow key press is attached to the <xref:System.Windows.Controls.Button> instance.</span></span>

 <span data-ttu-id="98a46-160">该示例的第一个部分创建<xref:System.Windows.Controls.StackPanel>并<xref:System.Windows.Controls.Button>，并将附加的事件处理程序<xref:System.Windows.UIElement.KeyDown>。</span><span class="sxs-lookup"><span data-stu-id="98a46-160">The first section of the example creates the <xref:System.Windows.Controls.StackPanel> and the <xref:System.Windows.Controls.Button> and attaches the event handler for the <xref:System.Windows.UIElement.KeyDown>.</span></span>

 [!code-xaml[InputOvw#Input_OvwKeyboardExampleXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#input_ovwkeyboardexamplexaml)]

 [!code-csharp[InputOvw#Input_OvwKeyboardExampleUICodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml.cs#input_ovwkeyboardexampleuicodebehind)]
 [!code-vb[InputOvw#Input_OvwKeyboardExampleUICodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InputOvw/VisualBasic/Page1.xaml.vb#input_ovwkeyboardexampleuicodebehind)]

 <span data-ttu-id="98a46-161">第二部分用代码编写，定义了事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="98a46-161">The second section is written in code and defines the event handler.</span></span>  <span data-ttu-id="98a46-162">向左的箭头键按下时，<xref:System.Windows.Controls.Button>具有键盘焦点，处理程序将运行并<xref:System.Windows.Controls.Control.Background%2A>的颜色<xref:System.Windows.Controls.Button>更改。</span><span class="sxs-lookup"><span data-stu-id="98a46-162">When the left arrow key is pressed and the <xref:System.Windows.Controls.Button> has keyboard focus, the handler runs and the <xref:System.Windows.Controls.Control.Background%2A> color of the <xref:System.Windows.Controls.Button> is changed.</span></span>  <span data-ttu-id="98a46-163">如果按下了键，但它不是向的左键<xref:System.Windows.Controls.Control.Background%2A>颜色<xref:System.Windows.Controls.Button>更改回其开始颜色。</span><span class="sxs-lookup"><span data-stu-id="98a46-163">If the key is pressed, but it is not the left arrow key, the <xref:System.Windows.Controls.Control.Background%2A> color of the <xref:System.Windows.Controls.Button> is changed back to its starting color.</span></span>

 [!code-csharp[InputOvw#Input_OvwKeyboardExampleHandlerCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml.cs#input_ovwkeyboardexamplehandlercodebehind)]
 [!code-vb[InputOvw#Input_OvwKeyboardExampleHandlerCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InputOvw/VisualBasic/Page1.xaml.vb#input_ovwkeyboardexamplehandlercodebehind)]

### <a name="mouse-input-event-example"></a><span data-ttu-id="98a46-164">鼠标输入事件示例</span><span class="sxs-lookup"><span data-stu-id="98a46-164">Mouse Input Event Example</span></span>
 <span data-ttu-id="98a46-165">在以下示例中，<xref:System.Windows.Controls.Control.Background%2A>色<xref:System.Windows.Controls.Button>当鼠标指针进入更改<xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="98a46-165">In the following example, the <xref:System.Windows.Controls.Control.Background%2A> color of a <xref:System.Windows.Controls.Button> is changed when the mouse pointer enters the <xref:System.Windows.Controls.Button>.</span></span>  <span data-ttu-id="98a46-166"><xref:System.Windows.Controls.Control.Background%2A>颜色将还原当鼠标离开<xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="98a46-166">The <xref:System.Windows.Controls.Control.Background%2A> color is restored when the mouse leaves the <xref:System.Windows.Controls.Button>.</span></span>

 <span data-ttu-id="98a46-167">该示例的第一个部分创建<xref:System.Windows.Controls.StackPanel>和<xref:System.Windows.Controls.Button>控制，并将附加的事件处理程序<xref:System.Windows.UIElement.MouseEnter>并<xref:System.Windows.UIElement.MouseLeave>事件到<xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="98a46-167">The first section of the example creates the <xref:System.Windows.Controls.StackPanel> and the <xref:System.Windows.Controls.Button> control and attaches the event handlers for the <xref:System.Windows.UIElement.MouseEnter> and <xref:System.Windows.UIElement.MouseLeave> events to the <xref:System.Windows.Controls.Button>.</span></span>

 [!code-xaml[InputOvw#Input_OvwMouseExampleXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#input_ovwmouseexamplexaml)]

 [!code-csharp[InputOvw#Input_OvwMouseExampleUICodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml.cs#input_ovwmouseexampleuicodebehind)]
 [!code-vb[InputOvw#Input_OvwMouseExampleUICodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InputOvw/VisualBasic/Page1.xaml.vb#input_ovwmouseexampleuicodebehind)]

 <span data-ttu-id="98a46-168">该示例的第二部分用代码编写，定义了事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="98a46-168">The second section of the example is written in code and defines the event handlers.</span></span>  <span data-ttu-id="98a46-169">当鼠标进入<xref:System.Windows.Controls.Button>，则<xref:System.Windows.Controls.Control.Background%2A>的颜色<xref:System.Windows.Controls.Button>更改为<xref:System.Windows.Media.Brushes.SlateGray%2A>。</span><span class="sxs-lookup"><span data-stu-id="98a46-169">When the mouse enters the <xref:System.Windows.Controls.Button>, the <xref:System.Windows.Controls.Control.Background%2A> color of the <xref:System.Windows.Controls.Button> is changed to <xref:System.Windows.Media.Brushes.SlateGray%2A>.</span></span>  <span data-ttu-id="98a46-170">当鼠标离开<xref:System.Windows.Controls.Button>，则<xref:System.Windows.Controls.Control.Background%2A>的颜色<xref:System.Windows.Controls.Button>更改回<xref:System.Windows.Media.Brushes.AliceBlue%2A>。</span><span class="sxs-lookup"><span data-stu-id="98a46-170">When the mouse leaves the <xref:System.Windows.Controls.Button>, the <xref:System.Windows.Controls.Control.Background%2A> color of the <xref:System.Windows.Controls.Button> is changed back to <xref:System.Windows.Media.Brushes.AliceBlue%2A>.</span></span>

 [!code-csharp[InputOvw#Input_OvwMouseExampleEneterHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml.cs#input_ovwmouseexampleeneterhandler)]
 [!code-vb[InputOvw#Input_OvwMouseExampleEneterHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InputOvw/VisualBasic/Page1.xaml.vb#input_ovwmouseexampleeneterhandler)]

 [!code-csharp[InputOvw#Input_OvwMouseExampleLeaveHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml.cs#input_ovwmouseexampleleavehandler)]
 [!code-vb[InputOvw#Input_OvwMouseExampleLeaveHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InputOvw/VisualBasic/Page1.xaml.vb#input_ovwmouseexampleleavehandler)]

<a name="text_input"></a>
## <a name="text-input"></a><span data-ttu-id="98a46-171">文本输入</span><span class="sxs-lookup"><span data-stu-id="98a46-171">Text Input</span></span>
 <span data-ttu-id="98a46-172"><xref:System.Windows.ContentElement.TextInput>事件，可以以独立于设备的方式侦听文本输入。</span><span class="sxs-lookup"><span data-stu-id="98a46-172">The <xref:System.Windows.ContentElement.TextInput> event enables you to listen for text input in a device-independent manner.</span></span> <span data-ttu-id="98a46-173">键盘是文本输入的主要方式，但通过语音、手写和其他输入设备也可以生成文本输入。</span><span class="sxs-lookup"><span data-stu-id="98a46-173">The keyboard is the primary means of text input, but speech, handwriting, and other input devices can generate text input also.</span></span>

 <span data-ttu-id="98a46-174">对于键盘输入[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]首先发送相应<xref:System.Windows.ContentElement.KeyDown> / <xref:System.Windows.ContentElement.KeyUp>事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-174">For keyboard input, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] first sends the appropriate <xref:System.Windows.ContentElement.KeyDown>/<xref:System.Windows.ContentElement.KeyUp> events.</span></span> <span data-ttu-id="98a46-175">如果不处理这些事件，并且按键是文本而不是 （例如方向箭头的控制键） 或功能键，则<xref:System.Windows.ContentElement.TextInput>引发事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-175">If those events are not handled and the key is textual (rather than a control key such as directional arrows or function keys), then a <xref:System.Windows.ContentElement.TextInput> event is raised.</span></span>  <span data-ttu-id="98a46-176">不会始终之间简单的一对一映射<xref:System.Windows.ContentElement.KeyDown> / <xref:System.Windows.ContentElement.KeyUp>和<xref:System.Windows.ContentElement.TextInput>事件因为多次击键可以生成的文本输入单个字符，并且一次击键可以生成多字符字符串。</span><span class="sxs-lookup"><span data-stu-id="98a46-176">There is not always a simple one-to-one mapping between <xref:System.Windows.ContentElement.KeyDown>/<xref:System.Windows.ContentElement.KeyUp> and <xref:System.Windows.ContentElement.TextInput> events because multiple keystrokes can generate a single character of text input and single keystrokes can generate multi-character strings.</span></span>  <span data-ttu-id="98a46-177">对于中文、日文和韩文等语言尤其如此，这些语言使用 [!INCLUDE[TLA#tla_ime#plural](../../../../includes/tlasharptla-imesharpplural-md.md)] 生成由其对应的字母组成的成千上万个可能的字符。</span><span class="sxs-lookup"><span data-stu-id="98a46-177">This is especially true for languages such as Chinese, Japanese, and Korean which use [!INCLUDE[TLA#tla_ime#plural](../../../../includes/tlasharptla-imesharpplural-md.md)] to generate the thousands of possible characters in their corresponding alphabets.</span></span>

 <span data-ttu-id="98a46-178">当[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]发送<xref:System.Windows.ContentElement.KeyUp> / <xref:System.Windows.ContentElement.KeyDown>事件，<xref:System.Windows.Input.KeyEventArgs.Key%2A>设置为<xref:System.Windows.Input.Key.System?displayProperty=nameWithType>如果击键可以成为一部分<xref:System.Windows.ContentElement.TextInput>事件 （如果为例，按 ALT + S）。</span><span class="sxs-lookup"><span data-stu-id="98a46-178">When [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] sends a <xref:System.Windows.ContentElement.KeyUp>/<xref:System.Windows.ContentElement.KeyDown> event, <xref:System.Windows.Input.KeyEventArgs.Key%2A> is set to <xref:System.Windows.Input.Key.System?displayProperty=nameWithType> if the keystrokes could become part of a <xref:System.Windows.ContentElement.TextInput> event (if ALT+S is pressed, for example).</span></span> <span data-ttu-id="98a46-179">这样中的代码<xref:System.Windows.ContentElement.KeyDown>事件处理程序检查是否<xref:System.Windows.Input.Key.System?displayProperty=nameWithType>并且如果找到，保留对随后引发的处理程序处理<xref:System.Windows.ContentElement.TextInput>事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-179">This allows code in a <xref:System.Windows.ContentElement.KeyDown> event handler to check for <xref:System.Windows.Input.Key.System?displayProperty=nameWithType> and, if found, leave processing for the handler of the subsequently raised <xref:System.Windows.ContentElement.TextInput> event.</span></span> <span data-ttu-id="98a46-180">在这些情况下，各属性的<xref:System.Windows.Input.TextCompositionEventArgs>参数可用于确定原始击键。</span><span class="sxs-lookup"><span data-stu-id="98a46-180">In these cases, the various properties of the <xref:System.Windows.Input.TextCompositionEventArgs> argument can be used to determine the original keystrokes.</span></span> <span data-ttu-id="98a46-181">同样，如果[!INCLUDE[TLA2#tla_ime](../../../../includes/tla2sharptla-ime-md.md)]处于活动状态，<xref:System.Windows.Input.Key>的值为<xref:System.Windows.Input.Key.ImeProcessed?displayProperty=nameWithType>，和<xref:System.Windows.Input.KeyEventArgs.ImeProcessedKey%2A>不提供原始击键。</span><span class="sxs-lookup"><span data-stu-id="98a46-181">Similarly, if an [!INCLUDE[TLA2#tla_ime](../../../../includes/tla2sharptla-ime-md.md)] is active, <xref:System.Windows.Input.Key> has the value of <xref:System.Windows.Input.Key.ImeProcessed?displayProperty=nameWithType>, and <xref:System.Windows.Input.KeyEventArgs.ImeProcessedKey%2A> gives the original keystroke or keystrokes.</span></span>

 <span data-ttu-id="98a46-182">下面的示例定义的处理程序<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件和处理程序<xref:System.Windows.UIElement.KeyDown>事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-182">The following example defines a handler for the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event and a handler for the <xref:System.Windows.UIElement.KeyDown> event.</span></span>

 <span data-ttu-id="98a46-183">第一段代码或标记创建用户界面。</span><span class="sxs-lookup"><span data-stu-id="98a46-183">The first segment of code or markup creates the user interface.</span></span>

 [!code-xaml[InputOvw#Input_OvwTextInputXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#input_ovwtextinputxaml)]

 [!code-csharp[InputOvw#Input_OvwTextInputUICodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml.cs#input_ovwtextinputuicodebehind)]
 [!code-vb[InputOvw#Input_OvwTextInputUICodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InputOvw/VisualBasic/Page1.xaml.vb#input_ovwtextinputuicodebehind)]

 <span data-ttu-id="98a46-184">第二段代码包含事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="98a46-184">The second segment of code contains the event handlers.</span></span>

 [!code-csharp[InputOvw#Input_OvwTextInputHandlersCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml.cs#input_ovwtextinputhandlerscodebehind)]
 [!code-vb[InputOvw#Input_OvwTextInputHandlersCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InputOvw/VisualBasic/Page1.xaml.vb#input_ovwtextinputhandlerscodebehind)]

 <span data-ttu-id="98a46-185">由于输入的事件的事件路由，向上冒泡<xref:System.Windows.Controls.StackPanel>接收的输入不管哪个元素具有键盘焦点。</span><span class="sxs-lookup"><span data-stu-id="98a46-185">Because input events bubble up the event route, the <xref:System.Windows.Controls.StackPanel> receives the input regardless of which element has keyboard focus.</span></span> <span data-ttu-id="98a46-186"><xref:System.Windows.Controls.TextBox>控件首先得到通知并`OnTextInputKeyDown`仅当调用处理程序<xref:System.Windows.Controls.TextBox>未处理输入。</span><span class="sxs-lookup"><span data-stu-id="98a46-186">The <xref:System.Windows.Controls.TextBox> control is notified first and the `OnTextInputKeyDown` handler is called only if the <xref:System.Windows.Controls.TextBox> did not handle the input.</span></span> <span data-ttu-id="98a46-187">如果<xref:System.Windows.UIElement.PreviewKeyDown>而不是使用事件<xref:System.Windows.UIElement.KeyDown>事件，`OnTextInputKeyDown`首先调用处理程序。</span><span class="sxs-lookup"><span data-stu-id="98a46-187">If the <xref:System.Windows.UIElement.PreviewKeyDown> event is used instead of the <xref:System.Windows.UIElement.KeyDown> event, the `OnTextInputKeyDown` handler is called first.</span></span>

 <span data-ttu-id="98a46-188">在此示例中，处理逻辑写入了两次，分别针对 CTRL+O和按钮的单击事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-188">In this example, the handling logic is written two times—one time for CTRL+O, and again for button's click event.</span></span> <span data-ttu-id="98a46-189">使用命令，而不是直接处理输入事件，可简化此过程。</span><span class="sxs-lookup"><span data-stu-id="98a46-189">This can be simplified by using commands, instead of handling the input events directly.</span></span>  <span data-ttu-id="98a46-190">本概述和[命令概述](commanding-overview.md)中将讨论这些命令。</span><span class="sxs-lookup"><span data-stu-id="98a46-190">Commands are discussed in this overview and in [Commanding Overview](commanding-overview.md).</span></span>

<a name="touch_and_manipulation"></a>
## <a name="touch-and-manipulation"></a><span data-ttu-id="98a46-191">触摸和操作</span><span class="sxs-lookup"><span data-stu-id="98a46-191">Touch and Manipulation</span></span>
 <span data-ttu-id="98a46-192">Windows 7 操作系统中的新硬件和 API 使应用程序能够同时接收来自多个触控的输入。</span><span class="sxs-lookup"><span data-stu-id="98a46-192">New hardware and API in the Windows 7 operating system provide applications the ability to receive input from multiple touches simultaneously.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="98a46-193">通过在触摸发生时引发事件，从而使应用程序能够以类似于响应其他输入（例如鼠标或键盘）的方式来检测和响应触摸设备。</span><span class="sxs-lookup"><span data-stu-id="98a46-193">enables applications to detect and respond to touch in a manner similar to responding to other input, such as the mouse or keyboard, by raising events when touch occurs.</span></span>

 <span data-ttu-id="98a46-194">发生触摸时，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 将公开两种类型的事件：触摸事件和操作事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-194">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] exposes two types of events when touch occurs: touch events and manipulation events.</span></span> <span data-ttu-id="98a46-195">触摸事件提供有关触摸屏上每个手指及其移动的原始数据。</span><span class="sxs-lookup"><span data-stu-id="98a46-195">Touch events provide raw data about each finger on a touchscreen and its movement.</span></span> <span data-ttu-id="98a46-196">操作事件将输入解释为特定操作。</span><span class="sxs-lookup"><span data-stu-id="98a46-196">Manipulation events interpret the input as certain actions.</span></span> <span data-ttu-id="98a46-197">本部分将讨论这两种类型的事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-197">Both types of events are discussed in this section.</span></span>

### <a name="prerequisites"></a><span data-ttu-id="98a46-198">系统必备</span><span class="sxs-lookup"><span data-stu-id="98a46-198">Prerequisites</span></span>
 <span data-ttu-id="98a46-199">需要以下组件才能开发响应触摸的应用程序。</span><span class="sxs-lookup"><span data-stu-id="98a46-199">You need the following components to develop an application that responds to touch.</span></span>

- <span data-ttu-id="98a46-200">Visual Studio 2010。</span><span class="sxs-lookup"><span data-stu-id="98a46-200">Visual Studio 2010.</span></span>

- <span data-ttu-id="98a46-201">Windows 7。</span><span class="sxs-lookup"><span data-stu-id="98a46-201">Windows 7.</span></span>

- <span data-ttu-id="98a46-202">支持 Windows 触控的设备，如触摸屏。</span><span class="sxs-lookup"><span data-stu-id="98a46-202">A device, such as a touchscreen, that supports Windows Touch.</span></span>

### <a name="terminology"></a><span data-ttu-id="98a46-203">术语</span><span class="sxs-lookup"><span data-stu-id="98a46-203">Terminology</span></span>
 <span data-ttu-id="98a46-204">讨论触摸时使用了以下术语。</span><span class="sxs-lookup"><span data-stu-id="98a46-204">The following terms are used when touch is discussed.</span></span>

- <span data-ttu-id="98a46-205">**触摸**是 Windows 7 可识别的一种用户输入。</span><span class="sxs-lookup"><span data-stu-id="98a46-205">**Touch** is a type of user input that is recognized by Windows 7.</span></span> <span data-ttu-id="98a46-206">通常，将手指放在触敏式屏幕上会触发触摸。</span><span class="sxs-lookup"><span data-stu-id="98a46-206">Usually, touch is initiated by putting fingers on a touch-sensitive screen.</span></span> <span data-ttu-id="98a46-207">请注意，如果设备仅将手指的位置和移动转换为鼠标输入，则笔记本电脑上常用的触摸板等设备不支持触摸。</span><span class="sxs-lookup"><span data-stu-id="98a46-207">Note that devices such as a touchpad that is common on laptop computers do not support touch if the device merely converts the finger's position and movement as mouse input.</span></span>

- <span data-ttu-id="98a46-208">**多点触摸**是同时发生在多个点上的触摸。</span><span class="sxs-lookup"><span data-stu-id="98a46-208">**Multitouch** is touch that occurs from more than one point simultaneously.</span></span> <span data-ttu-id="98a46-209">Windows 7 和 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 支持多点触摸。</span><span class="sxs-lookup"><span data-stu-id="98a46-209">Windows 7 and [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] supports multitouch.</span></span> <span data-ttu-id="98a46-210">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 文档中每当论及触摸时，相关概念均适用于多点触摸。</span><span class="sxs-lookup"><span data-stu-id="98a46-210">Whenever touch is discussed in the documentation for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], the concepts apply to multitouch.</span></span>

- <span data-ttu-id="98a46-211">当触摸被解释为应用于对象的实际操作时，就发生了**操作**。</span><span class="sxs-lookup"><span data-stu-id="98a46-211">A **manipulation** occurs when touch is interpreted as a physical action that is applied to an object.</span></span> <span data-ttu-id="98a46-212">在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中，操作事件将输入解释为转换、扩展或旋转操作。</span><span class="sxs-lookup"><span data-stu-id="98a46-212">In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], manipulation events interpret input as a translation, expansion, or rotation manipulation.</span></span>

- <span data-ttu-id="98a46-213">`touch device` 表示产生触摸输入的设备，例如触摸屏上的一根手指。</span><span class="sxs-lookup"><span data-stu-id="98a46-213">A `touch device` represents a device that produces touch input, such as a single finger on a touchscreen.</span></span>

### <a name="controls-that-respond-to-touch"></a><span data-ttu-id="98a46-214">响应触摸的控件</span><span class="sxs-lookup"><span data-stu-id="98a46-214">Controls that Respond to Touch</span></span>
 <span data-ttu-id="98a46-215">如果以下控件的内容延伸到视图之外，则可以通过在控件上拖动手指来滚动该控件。</span><span class="sxs-lookup"><span data-stu-id="98a46-215">The following controls can be scrolled by dragging a finger across the control if it has content that is scrolled out of view.</span></span>

- <xref:System.Windows.Controls.ComboBox>

- <xref:System.Windows.Controls.ContextMenu>

- <xref:System.Windows.Controls.DataGrid>

- <xref:System.Windows.Controls.ListBox>

- <xref:System.Windows.Controls.ListView>

- <xref:System.Windows.Controls.MenuItem>

- <xref:System.Windows.Controls.TextBox>

- <xref:System.Windows.Controls.ToolBar>

- <xref:System.Windows.Controls.TreeView>

 <span data-ttu-id="98a46-216"><xref:System.Windows.Controls.ScrollViewer>定义<xref:System.Windows.Controls.ScrollViewer.PanningMode%2A?displayProperty=nameWithType>附加属性，可用于指定是否触摸平移启用水平、 垂直、 两者，还是两者皆否。</span><span class="sxs-lookup"><span data-stu-id="98a46-216">The <xref:System.Windows.Controls.ScrollViewer> defines the <xref:System.Windows.Controls.ScrollViewer.PanningMode%2A?displayProperty=nameWithType> attached property that enables you to specify whether touch panning is enabled horizontally, vertically, both, or neither.</span></span> <span data-ttu-id="98a46-217"><xref:System.Windows.Controls.ScrollViewer.PanningDeceleration%2A?displayProperty=nameWithType>属性指定如何快速滚动速度变慢时用户将手指从触摸屏。</span><span class="sxs-lookup"><span data-stu-id="98a46-217">The <xref:System.Windows.Controls.ScrollViewer.PanningDeceleration%2A?displayProperty=nameWithType> property specifies how quickly the scrolling slows down when the user lifts the finger from the touchscreen.</span></span> <span data-ttu-id="98a46-218"><xref:System.Windows.Controls.ScrollViewer.PanningRatio%2A?displayProperty=nameWithType>附加的属性指定滚动偏移与转换操作偏移的比率。</span><span class="sxs-lookup"><span data-stu-id="98a46-218">The <xref:System.Windows.Controls.ScrollViewer.PanningRatio%2A?displayProperty=nameWithType> attached property specifies the ratio of scrolling offset to translate manipulation offset.</span></span>

### <a name="touch-events"></a><span data-ttu-id="98a46-219">触摸事件</span><span class="sxs-lookup"><span data-stu-id="98a46-219">Touch Events</span></span>
 <span data-ttu-id="98a46-220">基类<xref:System.Windows.UIElement>， <xref:System.Windows.UIElement3D>，和<xref:System.Windows.ContentElement>，定义您可以订阅，以便你的应用程序响应触摸的事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-220">The base classes, <xref:System.Windows.UIElement>, <xref:System.Windows.UIElement3D>, and <xref:System.Windows.ContentElement>, define events that you can subscribe to so your application will respond to touch.</span></span> <span data-ttu-id="98a46-221">当应用程序将触摸解释为操作对象以外的其他操作时，触摸事件非常有用。</span><span class="sxs-lookup"><span data-stu-id="98a46-221">Touch events are useful when your application interprets touch as something other than manipulating an object.</span></span> <span data-ttu-id="98a46-222">例如，使用户能够以一个或多个手指绘制的应用程序将订阅触摸事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-222">For example, an application that enables a user to draw with one or more fingers would subscribe to touch events.</span></span>

 <span data-ttu-id="98a46-223">所有三个类都定义了以下事件，其行为类似，而无论定义类是什么。</span><span class="sxs-lookup"><span data-stu-id="98a46-223">All three classes define the following events, which behave similarly, regardless of the defining class.</span></span>

- <xref:System.Windows.UIElement.TouchDown>

- <xref:System.Windows.UIElement.TouchMove>

- <xref:System.Windows.UIElement.TouchUp>

- <xref:System.Windows.UIElement.TouchEnter>

- <xref:System.Windows.UIElement.TouchLeave>

- <xref:System.Windows.UIElement.PreviewTouchDown>

- <xref:System.Windows.UIElement.PreviewTouchMove>

- <xref:System.Windows.UIElement.PreviewTouchUp>

- <xref:System.Windows.UIElement.GotTouchCapture>

- <xref:System.Windows.UIElement.LostTouchCapture>

 <span data-ttu-id="98a46-224">像键盘和鼠标事件一样，触摸事件也是路由事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-224">Like keyboard and mouse events, the touch events are routed events.</span></span> <span data-ttu-id="98a46-225">以 `Preview` 开头的事件是隧道事件，以 `Touch` 开头的事件是冒泡事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-225">The events that begin with `Preview` are tunneling events and the events that begin with `Touch` are bubbling events.</span></span> <span data-ttu-id="98a46-226">有关路由事件的详细信息，请参阅[路由事件概述](routed-events-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="98a46-226">For more information about routed events, see [Routed Events Overview](routed-events-overview.md).</span></span> <span data-ttu-id="98a46-227">在您处理这些事件，可以通过调用获取的输入，相对于任何元素的位置<xref:System.Windows.Input.TouchEventArgs.GetTouchPoint%2A>或<xref:System.Windows.Input.TouchEventArgs.GetIntermediateTouchPoints%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="98a46-227">When you handle these events, you can get the position of the input, relative to any element, by calling the <xref:System.Windows.Input.TouchEventArgs.GetTouchPoint%2A> or <xref:System.Windows.Input.TouchEventArgs.GetIntermediateTouchPoints%2A> method.</span></span>

 <span data-ttu-id="98a46-228">为了理解触控事件之间的交互，请考虑以下这种情况：用户将一个手指放在元素上，在该元素中移动手指，然后将手指从该元素上移开。</span><span class="sxs-lookup"><span data-stu-id="98a46-228">To understand the interaction among the touch events, consider the scenario where a user puts one finger on an element, moves the finger in the element, and then lifts the finger from the element.</span></span> <span data-ttu-id="98a46-229">下图显示了冒泡事件的执行（为简单起见，省略了隧道事件）。</span><span class="sxs-lookup"><span data-stu-id="98a46-229">The following illustration shows the execution of the bubbling events (the tunneling events are omitted for simplicity).</span></span>

 <span data-ttu-id="98a46-230">![触摸事件的顺序。](./media/ndp-touchevents.png "NDP_TouchEvents")触摸事件</span><span class="sxs-lookup"><span data-stu-id="98a46-230">![The sequence of touch events.](./media/ndp-touchevents.png "NDP_TouchEvents") Touch events</span></span>

 <span data-ttu-id="98a46-231">下列内容描述了上图中的事件顺序。</span><span class="sxs-lookup"><span data-stu-id="98a46-231">The following list describes the sequence of the events in the preceding illustration.</span></span>

1. <span data-ttu-id="98a46-232"><xref:System.Windows.UIElement.TouchEnter>事件发生一次当用户将手指放在元素。</span><span class="sxs-lookup"><span data-stu-id="98a46-232">The <xref:System.Windows.UIElement.TouchEnter> event occurs one time when the user puts a finger on the element.</span></span>

2. <span data-ttu-id="98a46-233"><xref:System.Windows.UIElement.TouchDown>事件发生一次。</span><span class="sxs-lookup"><span data-stu-id="98a46-233">The <xref:System.Windows.UIElement.TouchDown> event occurs one time.</span></span>

3. <span data-ttu-id="98a46-234"><xref:System.Windows.UIElement.TouchMove>事件发生多次，用户在将移动手指在元素中的。</span><span class="sxs-lookup"><span data-stu-id="98a46-234">The <xref:System.Windows.UIElement.TouchMove> event occurs multiple times as the user moves the finger within the element.</span></span>

4. <span data-ttu-id="98a46-235"><xref:System.Windows.UIElement.TouchUp>事件发生一次当用户将手指从该元素。</span><span class="sxs-lookup"><span data-stu-id="98a46-235">The <xref:System.Windows.UIElement.TouchUp> event occurs one time when the user lifts the finger from the element.</span></span>

5. <span data-ttu-id="98a46-236"><xref:System.Windows.UIElement.TouchLeave>事件发生一次。</span><span class="sxs-lookup"><span data-stu-id="98a46-236">The <xref:System.Windows.UIElement.TouchLeave> event occurs one time.</span></span>

 <span data-ttu-id="98a46-237">当使用两根以上的手指时，每根手指都会发生事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-237">When more than two fingers are used, the events occur for each finger.</span></span>

### <a name="manipulation-events"></a><span data-ttu-id="98a46-238">操作事件</span><span class="sxs-lookup"><span data-stu-id="98a46-238">Manipulation Events</span></span>
 <span data-ttu-id="98a46-239">其中一个应用程序使用户能够的对象执行操作的情况下为<xref:System.Windows.UIElement>类定义了操作事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-239">For cases where an application enables a user to manipulate an object, the <xref:System.Windows.UIElement> class defines manipulation events.</span></span> <span data-ttu-id="98a46-240">与只是报告触摸位置的触摸事件不同，操作事件会报告可采用何种方式解释输入。</span><span class="sxs-lookup"><span data-stu-id="98a46-240">Unlike the touch events that simply report the position of touch, the manipulation events report how the input can be interpreted.</span></span> <span data-ttu-id="98a46-241">有三种类型的操作：转换、扩展和旋转。</span><span class="sxs-lookup"><span data-stu-id="98a46-241">There are three types of manipulations, translation, expansion, and rotation.</span></span> <span data-ttu-id="98a46-242">下列内容介绍了如何调用这三种类型的操作。</span><span class="sxs-lookup"><span data-stu-id="98a46-242">The following list describes how to invoke the three types of manipulations.</span></span>

- <span data-ttu-id="98a46-243">将一根手指放在对象上，并在触摸屏上拖动手指以调用转换操作。</span><span class="sxs-lookup"><span data-stu-id="98a46-243">Put a finger on an object and move the finger across the touchscreen to invoke a translation manipulation.</span></span> <span data-ttu-id="98a46-244">此操作通常会移动对象。</span><span class="sxs-lookup"><span data-stu-id="98a46-244">This usually moves the object.</span></span>

- <span data-ttu-id="98a46-245">将两根手指放在物体上，并将手指相互靠拢或分开以调用扩展操作。</span><span class="sxs-lookup"><span data-stu-id="98a46-245">Put two fingers on an object and move the fingers closer together or farther apart from one another to invoke an expansion manipulation.</span></span> <span data-ttu-id="98a46-246">此操作通常会调整对象的大小。</span><span class="sxs-lookup"><span data-stu-id="98a46-246">This usually resizes the object.</span></span>

- <span data-ttu-id="98a46-247">将两根手指放在对象上，并将一个手指围绕另一个手指旋转以调用旋转操作。</span><span class="sxs-lookup"><span data-stu-id="98a46-247">Put two fingers on an object and rotate the fingers around each other to invoke a rotation manipulation.</span></span> <span data-ttu-id="98a46-248">此操作通常会旋转对象。</span><span class="sxs-lookup"><span data-stu-id="98a46-248">This usually rotates the object.</span></span>

 <span data-ttu-id="98a46-249">多种类型的操作可以同时发生。</span><span class="sxs-lookup"><span data-stu-id="98a46-249">More than one type of manipulation can occur simultaneously.</span></span>

 <span data-ttu-id="98a46-250">使对象响应操作时，可以让对象看起来具有惯性。</span><span class="sxs-lookup"><span data-stu-id="98a46-250">When you cause objects to respond to manipulations, you can have the object appear to have inertia.</span></span> <span data-ttu-id="98a46-251">这样可以使对象模拟真实的世界。</span><span class="sxs-lookup"><span data-stu-id="98a46-251">This can make your objects simulate the physical world.</span></span> <span data-ttu-id="98a46-252">例如，在桌子上推一本书时，如果你足够用力，书将在你松手后继续移动。</span><span class="sxs-lookup"><span data-stu-id="98a46-252">For example, when you push a book across a table, if you push hard enough the book will continue to move after you release it.</span></span> <span data-ttu-id="98a46-253">利用 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]，可以通过在用户的手指松开对象后引发操作事件来模拟这种行为。</span><span class="sxs-lookup"><span data-stu-id="98a46-253">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] enables you to simulate this behavior by raising manipulation events after the user's fingers releases the object.</span></span>

 <span data-ttu-id="98a46-254">有关如何创建使用户能够移动、 调整大小和旋转对象的应用程序的信息，请参阅[演练：创建第一个触控应用程序](walkthrough-creating-your-first-touch-application.md)。</span><span class="sxs-lookup"><span data-stu-id="98a46-254">For information about how to create an application that enables the user to move, resize, and rotate an object, see [Walkthrough: Creating Your First Touch Application](walkthrough-creating-your-first-touch-application.md).</span></span>

 <span data-ttu-id="98a46-255"><xref:System.Windows.UIElement>定义了以下操作事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-255">The <xref:System.Windows.UIElement> defines the following manipulation events.</span></span>

- <xref:System.Windows.UIElement.ManipulationStarting>

- <xref:System.Windows.UIElement.ManipulationStarted>

- <xref:System.Windows.UIElement.ManipulationDelta>

- <xref:System.Windows.UIElement.ManipulationInertiaStarting>

- <xref:System.Windows.UIElement.ManipulationCompleted>

- <xref:System.Windows.UIElement.ManipulationBoundaryFeedback>

 <span data-ttu-id="98a46-256">默认情况下，<xref:System.Windows.UIElement>不会接收这些操作事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-256">By default, a <xref:System.Windows.UIElement> does not receive these manipulation events.</span></span> <span data-ttu-id="98a46-257">若要在接收操作事件<xref:System.Windows.UIElement>，将<xref:System.Windows.UIElement.IsManipulationEnabled%2A?displayProperty=nameWithType>到`true`。</span><span class="sxs-lookup"><span data-stu-id="98a46-257">To receive manipulation events on a <xref:System.Windows.UIElement>, set <xref:System.Windows.UIElement.IsManipulationEnabled%2A?displayProperty=nameWithType> to `true`.</span></span>

#### <a name="the-execution-path-of-manipulation-events"></a><span data-ttu-id="98a46-258">操作事件的执行路径</span><span class="sxs-lookup"><span data-stu-id="98a46-258">The Execution Path of Manipulation Events</span></span>
 <span data-ttu-id="98a46-259">考虑用户“抛出”一个对象的情况。</span><span class="sxs-lookup"><span data-stu-id="98a46-259">Consider a scenario where a user "throws" an object.</span></span> <span data-ttu-id="98a46-260">用户将手指放在对象上，将手指在触摸屏上移动一段短距离，然后在移动的同时抬起手指。</span><span class="sxs-lookup"><span data-stu-id="98a46-260">The user puts a finger on the object, moves the finger across the touchscreen for a short distance, and then lifts the finger while it is moving.</span></span> <span data-ttu-id="98a46-261">此操作的结果是，该对象将在用户的手指下方移动，并在用户抬起手指后继续移动。</span><span class="sxs-lookup"><span data-stu-id="98a46-261">The result of this is that the object will move under the user's finger and continue to move after the user lifts the finger.</span></span>

 <span data-ttu-id="98a46-262">下图显示了操作事件的执行路径和每个事件的重要信息。</span><span class="sxs-lookup"><span data-stu-id="98a46-262">The following illustration shows the execution path of manipulation events and important information about each event.</span></span>

 <span data-ttu-id="98a46-263">![操作事件的顺序。](./media/ndp-manipulationevents.png "NDP_ManipulationEvents")操作事件</span><span class="sxs-lookup"><span data-stu-id="98a46-263">![The sequence of manipulation events.](./media/ndp-manipulationevents.png "NDP_ManipulationEvents") Manipulation events</span></span>

 <span data-ttu-id="98a46-264">下列内容描述了上图中的事件顺序。</span><span class="sxs-lookup"><span data-stu-id="98a46-264">The following list describes the sequence of the events in the preceding illustration.</span></span>

1. <span data-ttu-id="98a46-265"><xref:System.Windows.UIElement.ManipulationStarting>时用户将手指放在对象上发生的事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-265">The <xref:System.Windows.UIElement.ManipulationStarting> event occurs when the user places a finger on the object.</span></span> <span data-ttu-id="98a46-266">此外，此事件，可设置<xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="98a46-266">Among other things, this event allows you to set the <xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A> property.</span></span> <span data-ttu-id="98a46-267">在随后的事件，操作位置将相对于<xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A>。</span><span class="sxs-lookup"><span data-stu-id="98a46-267">In the subsequent events, the position of the manipulation will be relative to the <xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A>.</span></span> <span data-ttu-id="98a46-268">在事件以外的其他<xref:System.Windows.UIElement.ManipulationStarting>，此属性是只读的因此<xref:System.Windows.UIElement.ManipulationStarting>事件是唯一一次，您可以设置此属性。</span><span class="sxs-lookup"><span data-stu-id="98a46-268">In events other than <xref:System.Windows.UIElement.ManipulationStarting>, this property is read-only, so the <xref:System.Windows.UIElement.ManipulationStarting> event is the only time that you can set this property.</span></span>

2. <span data-ttu-id="98a46-269"><xref:System.Windows.UIElement.ManipulationStarted>接下来发生的事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-269">The <xref:System.Windows.UIElement.ManipulationStarted> event occurs next.</span></span> <span data-ttu-id="98a46-270">此事件报告操作的原始位置。</span><span class="sxs-lookup"><span data-stu-id="98a46-270">This event reports the origin of the manipulation.</span></span>

3. <span data-ttu-id="98a46-271"><xref:System.Windows.UIElement.ManipulationDelta>事件发生多次作为用户的手指移动触摸屏上。</span><span class="sxs-lookup"><span data-stu-id="98a46-271">The <xref:System.Windows.UIElement.ManipulationDelta> event occurs multiple times as a user's fingers move on a touchscreen.</span></span> <span data-ttu-id="98a46-272"><xref:System.Windows.Input.ManipulationDeltaEventArgs.DeltaManipulation%2A>属性的<xref:System.Windows.Input.ManipulationDeltaEventArgs>类报告操作被解释为移动、 扩展还是转换。</span><span class="sxs-lookup"><span data-stu-id="98a46-272">The <xref:System.Windows.Input.ManipulationDeltaEventArgs.DeltaManipulation%2A> property of the <xref:System.Windows.Input.ManipulationDeltaEventArgs> class reports whether the manipulation is interpreted as movement, expansion, or translation.</span></span> <span data-ttu-id="98a46-273">这是你执行操作对象的大部分工作的地方。</span><span class="sxs-lookup"><span data-stu-id="98a46-273">This is where you perform most of the work of manipulating an object.</span></span>

4. <span data-ttu-id="98a46-274"><xref:System.Windows.UIElement.ManipulationInertiaStarting>事件发生时在用户的手指失去与对象的联系。</span><span class="sxs-lookup"><span data-stu-id="98a46-274">The <xref:System.Windows.UIElement.ManipulationInertiaStarting> event occurs when the user's fingers lose contact with the object.</span></span> <span data-ttu-id="98a46-275">此事件使你可以指定操作在惯性期间的减速。</span><span class="sxs-lookup"><span data-stu-id="98a46-275">This event enables you to specify the deceleration of the manipulations during inertia.</span></span> <span data-ttu-id="98a46-276">这样，选择时对象就可以模拟不同的物理空间或特性。</span><span class="sxs-lookup"><span data-stu-id="98a46-276">This is so your object can emulate different physical spaces or attributes if you choose.</span></span> <span data-ttu-id="98a46-277">例如，假设应用程序有两个表示真实世界中的物品的对象，并且一个物品比另一个物品重。</span><span class="sxs-lookup"><span data-stu-id="98a46-277">For example, suppose your application has two objects that represent items in the physical world, and one is heavier than the other.</span></span> <span data-ttu-id="98a46-278">你可以使较重的对象比较轻的对象减速更快。</span><span class="sxs-lookup"><span data-stu-id="98a46-278">You can make the heavier object decelerate faster than the lighter object.</span></span>

5. <span data-ttu-id="98a46-279"><xref:System.Windows.UIElement.ManipulationDelta>在出现惯性时，事件发生多次。</span><span class="sxs-lookup"><span data-stu-id="98a46-279">The <xref:System.Windows.UIElement.ManipulationDelta> event occurs multiple times as inertia occurs.</span></span> <span data-ttu-id="98a46-280">请注意，当用户的手指在触摸屏上移动并且 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 模拟惯性时，将发生此事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-280">Note that this event occurs when the user's fingers move across the touchscreen and when [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] simulates inertia.</span></span> <span data-ttu-id="98a46-281">换而言之，<xref:System.Windows.UIElement.ManipulationDelta>发生之前和之后<xref:System.Windows.UIElement.ManipulationInertiaStarting>事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-281">In other words, <xref:System.Windows.UIElement.ManipulationDelta> occurs before and after the <xref:System.Windows.UIElement.ManipulationInertiaStarting> event.</span></span> <span data-ttu-id="98a46-282"><xref:System.Windows.Input.ManipulationDeltaEventArgs.IsInertial%2A?displayProperty=nameWithType>属性的报表是否<xref:System.Windows.UIElement.ManipulationDelta>延时，期间发生的事件，因此您可以检查该属性并执行不同的操作，具体取决于它的值。</span><span class="sxs-lookup"><span data-stu-id="98a46-282">The <xref:System.Windows.Input.ManipulationDeltaEventArgs.IsInertial%2A?displayProperty=nameWithType> property reports whether the <xref:System.Windows.UIElement.ManipulationDelta> event occurs during inertia, so you can check that property and perform different actions, depending on its value.</span></span>

6. <span data-ttu-id="98a46-283"><xref:System.Windows.UIElement.ManipulationCompleted>事件发生的操作和所有惯性结束时。</span><span class="sxs-lookup"><span data-stu-id="98a46-283">The <xref:System.Windows.UIElement.ManipulationCompleted> event occurs when the manipulation and any inertia ends.</span></span> <span data-ttu-id="98a46-284">也就是说，毕竟<xref:System.Windows.UIElement.ManipulationDelta>发生事件，<xref:System.Windows.UIElement.ManipulationCompleted>发生事件发出信号的操作已完成。</span><span class="sxs-lookup"><span data-stu-id="98a46-284">That is, after all the <xref:System.Windows.UIElement.ManipulationDelta> events occur, the <xref:System.Windows.UIElement.ManipulationCompleted> event occurs to signal that the manipulation is complete.</span></span>

 <span data-ttu-id="98a46-285"><xref:System.Windows.UIElement>还定义了<xref:System.Windows.UIElement.ManipulationBoundaryFeedback>事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-285">The <xref:System.Windows.UIElement> also defines the <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> event.</span></span> <span data-ttu-id="98a46-286">此事件发生时<xref:System.Windows.Input.ManipulationDeltaEventArgs.ReportBoundaryFeedback%2A>方法调用<xref:System.Windows.UIElement.ManipulationDelta>事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-286">This event occurs when the <xref:System.Windows.Input.ManipulationDeltaEventArgs.ReportBoundaryFeedback%2A> method is called in the <xref:System.Windows.UIElement.ManipulationDelta> event.</span></span> <span data-ttu-id="98a46-287"><xref:System.Windows.UIElement.ManipulationBoundaryFeedback>事件，应用程序或组件对象到达边界时提供可视反馈。</span><span class="sxs-lookup"><span data-stu-id="98a46-287">The <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> event enables applications or components to provide visual feedback when an object hits a boundary.</span></span> <span data-ttu-id="98a46-288">例如，<xref:System.Windows.Window>类将处理<xref:System.Windows.UIElement.ManipulationBoundaryFeedback>要使窗口轻微移动时遇到其边缘事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-288">For example, the <xref:System.Windows.Window> class handles the <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> event to cause the window to slightly move when its edge is encountered.</span></span>

 <span data-ttu-id="98a46-289">您可以通过调用来取消该操作<xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A>除外的任何操作事件中的事件自变量的方法<xref:System.Windows.UIElement.ManipulationBoundaryFeedback>事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-289">You can cancel the manipulation by calling the <xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A> method on the event arguments in any manipulation event except <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> event.</span></span> <span data-ttu-id="98a46-290">当您调用<xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A>、 不再引发操作事件和触摸会发生鼠标事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-290">When you call <xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A>, the manipulation events are no longer raised and mouse events occur for touch.</span></span> <span data-ttu-id="98a46-291">下表描述了取消操作的时间与所发生的鼠标事件之间的关系。</span><span class="sxs-lookup"><span data-stu-id="98a46-291">The following table describes the relationship between the time the manipulation is canceled and the mouse events that occur.</span></span>

|<span data-ttu-id="98a46-292">在其中调用取消的事件</span><span class="sxs-lookup"><span data-stu-id="98a46-292">The event that Cancel is called in</span></span>|<span data-ttu-id="98a46-293">针对已经发生的输入发生的鼠标事件</span><span class="sxs-lookup"><span data-stu-id="98a46-293">The mouse events that occur for input that already occurred</span></span>|
|----------------------------------------|-----------------------------------------------------------------|
|<span data-ttu-id="98a46-294"><xref:System.Windows.UIElement.ManipulationStarting> 和 <xref:System.Windows.UIElement.ManipulationStarted></span><span class="sxs-lookup"><span data-stu-id="98a46-294"><xref:System.Windows.UIElement.ManipulationStarting> and <xref:System.Windows.UIElement.ManipulationStarted></span></span>|<span data-ttu-id="98a46-295">鼠标按下事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-295">Mouse down events.</span></span>|
|<xref:System.Windows.UIElement.ManipulationDelta>|<span data-ttu-id="98a46-296">鼠标按下和鼠标移动事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-296">Mouse down and mouse move events.</span></span>|
|<span data-ttu-id="98a46-297"><xref:System.Windows.UIElement.ManipulationInertiaStarting> 和 <xref:System.Windows.UIElement.ManipulationCompleted></span><span class="sxs-lookup"><span data-stu-id="98a46-297"><xref:System.Windows.UIElement.ManipulationInertiaStarting> and <xref:System.Windows.UIElement.ManipulationCompleted></span></span>|<span data-ttu-id="98a46-298">鼠标按下、鼠标移动和鼠标弹起事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-298">Mouse down, mouse move, and mouse up events.</span></span>|

 <span data-ttu-id="98a46-299">请注意，如果您调用<xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A>操作在惯性时，该方法返回`false`输入不会引发鼠标事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-299">Note that if you call <xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A> when the manipulation is in inertia, the method returns `false` and the input does not raise mouse events.</span></span>

### <a name="the-relationship-between-touch-and-manipulation-events"></a><span data-ttu-id="98a46-300">触摸事件和操作事件之间的关系</span><span class="sxs-lookup"><span data-stu-id="98a46-300">The Relationship Between Touch and Manipulation Events</span></span>
 <span data-ttu-id="98a46-301">一个<xref:System.Windows.UIElement>始终可以接收触控事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-301">A <xref:System.Windows.UIElement> can always receive touch events.</span></span> <span data-ttu-id="98a46-302">当<xref:System.Windows.UIElement.IsManipulationEnabled%2A>属性设置为`true`、<xref:System.Windows.UIElement>可以接收触摸和操作事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-302">When the <xref:System.Windows.UIElement.IsManipulationEnabled%2A> property is set to `true`, a <xref:System.Windows.UIElement> can receive both touch and manipulation events.</span></span>  <span data-ttu-id="98a46-303">如果<xref:System.Windows.UIElement.TouchDown>不处理事件 (即<xref:System.Windows.RoutedEventArgs.Handled%2A>属性是`false`)，操作逻辑的元素触摸屏输入捕获和生成操作事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-303">If the <xref:System.Windows.UIElement.TouchDown> event is not handled (that is, the <xref:System.Windows.RoutedEventArgs.Handled%2A> property is `false`), the manipulation logic captures the touch to the element and generates the manipulation events.</span></span> <span data-ttu-id="98a46-304">如果<xref:System.Windows.RoutedEventArgs.Handled%2A>属性设置为`true`中<xref:System.Windows.UIElement.TouchDown>事件，操作逻辑不会生成操作事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-304">If the <xref:System.Windows.RoutedEventArgs.Handled%2A> property is set to `true` in the <xref:System.Windows.UIElement.TouchDown> event, the manipulation logic does not generate manipulation events.</span></span> <span data-ttu-id="98a46-305">下图显示了触摸事件和操作事件之间的关系。</span><span class="sxs-lookup"><span data-stu-id="98a46-305">The following illustration shows the relationship between touch events and manipulation events.</span></span>

 <span data-ttu-id="98a46-306">![触摸和操作事件之间的关系](./media/ndp-touchmanipulateevents.png "NDP_TouchManipulateEvents")触摸和操作事件</span><span class="sxs-lookup"><span data-stu-id="98a46-306">![Relationship between touch and manipulation events](./media/ndp-touchmanipulateevents.png "NDP_TouchManipulateEvents") Touch and manipulation events</span></span>

 <span data-ttu-id="98a46-307">下列内容描述了上图中所示的触摸事件和操作事件之间的关系。</span><span class="sxs-lookup"><span data-stu-id="98a46-307">The following list describes the relationship between the touch and manipulation events that is shown in the preceding illustration.</span></span>

- <span data-ttu-id="98a46-308">当第一个触控设备生成<xref:System.Windows.UIElement.TouchDown>上的事件<xref:System.Windows.UIElement>，操作逻辑调用<xref:System.Windows.UIElement.CaptureTouch%2A>方法，后者生成<xref:System.Windows.UIElement.GotTouchCapture>事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-308">When the first touch device generates a <xref:System.Windows.UIElement.TouchDown> event on a <xref:System.Windows.UIElement>, the manipulation logic calls the <xref:System.Windows.UIElement.CaptureTouch%2A> method, which generates the <xref:System.Windows.UIElement.GotTouchCapture> event.</span></span>

- <span data-ttu-id="98a46-309">当<xref:System.Windows.UIElement.GotTouchCapture>发生，操作逻辑调用<xref:System.Windows.Input.Manipulation.AddManipulator%2A?displayProperty=nameWithType>方法，后者生成<xref:System.Windows.UIElement.ManipulationStarting>事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-309">When the <xref:System.Windows.UIElement.GotTouchCapture> occurs, the manipulation logic calls the <xref:System.Windows.Input.Manipulation.AddManipulator%2A?displayProperty=nameWithType> method, which generates the <xref:System.Windows.UIElement.ManipulationStarting> event.</span></span>

- <span data-ttu-id="98a46-310">当<xref:System.Windows.UIElement.TouchMove>发生事件，操作逻辑将生成<xref:System.Windows.UIElement.ManipulationDelta>之前发生的事件<xref:System.Windows.UIElement.ManipulationInertiaStarting>事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-310">When the <xref:System.Windows.UIElement.TouchMove> events occur, the manipulation logic generates the <xref:System.Windows.UIElement.ManipulationDelta> events that occur before the <xref:System.Windows.UIElement.ManipulationInertiaStarting> event.</span></span>

- <span data-ttu-id="98a46-311">当上一次触摸设备时元素将引发<xref:System.Windows.UIElement.TouchUp>事件，操作逻辑会生成<xref:System.Windows.UIElement.ManipulationInertiaStarting>事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-311">When the last touch device on the element raises the <xref:System.Windows.UIElement.TouchUp> event, the manipulation logic generates the <xref:System.Windows.UIElement.ManipulationInertiaStarting> event.</span></span>

<a name="focus"></a>
## <a name="focus"></a><span data-ttu-id="98a46-312">焦点</span><span class="sxs-lookup"><span data-stu-id="98a46-312">Focus</span></span>
 <span data-ttu-id="98a46-313">在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中，有两个与焦点有关的主要概念：键盘焦点和逻辑焦点。</span><span class="sxs-lookup"><span data-stu-id="98a46-313">There are two main concepts that pertain to focus in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]: keyboard focus and logical focus.</span></span>

### <a name="keyboard-focus"></a><span data-ttu-id="98a46-314">键盘焦点</span><span class="sxs-lookup"><span data-stu-id="98a46-314">Keyboard Focus</span></span>
 <span data-ttu-id="98a46-315">键盘焦点指当前正在接收键盘输入的元素。</span><span class="sxs-lookup"><span data-stu-id="98a46-315">Keyboard focus refers to the element that is receiving keyboard input.</span></span>  <span data-ttu-id="98a46-316">在整个桌面上，只能有一个具有键盘焦点的元素。</span><span class="sxs-lookup"><span data-stu-id="98a46-316">There can be only one element on the whole desktop that has keyboard focus.</span></span>  <span data-ttu-id="98a46-317">在中[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]，具有键盘焦点的元素将具有<xref:System.Windows.IInputElement.IsKeyboardFocused%2A>设置为`true`。</span><span class="sxs-lookup"><span data-stu-id="98a46-317">In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], the element that has keyboard focus will have <xref:System.Windows.IInputElement.IsKeyboardFocused%2A> set to `true`.</span></span>  <span data-ttu-id="98a46-318">静态<xref:System.Windows.Input.Keyboard>方法<xref:System.Windows.Input.Keyboard.FocusedElement%2A>返回当前具有键盘焦点的元素。</span><span class="sxs-lookup"><span data-stu-id="98a46-318">The static <xref:System.Windows.Input.Keyboard> method <xref:System.Windows.Input.Keyboard.FocusedElement%2A> returns the element that currently has keyboard focus.</span></span>

 <span data-ttu-id="98a46-319">通过 tab 键移到元素或如单击鼠标上的某些元素，可以获取键盘焦点<xref:System.Windows.Controls.TextBox>。</span><span class="sxs-lookup"><span data-stu-id="98a46-319">Keyboard focus can be obtained by tabbing to an element or by clicking the mouse on certain elements, such as a <xref:System.Windows.Controls.TextBox>.</span></span>  <span data-ttu-id="98a46-320">键盘焦点还可以获取以编程方式通过使用<xref:System.Windows.Input.Keyboard.Focus%2A>方法<xref:System.Windows.Input.Keyboard>类。</span><span class="sxs-lookup"><span data-stu-id="98a46-320">Keyboard focus can also be obtained programmatically by using the <xref:System.Windows.Input.Keyboard.Focus%2A> method on the <xref:System.Windows.Input.Keyboard> class.</span></span>  <span data-ttu-id="98a46-321"><xref:System.Windows.Input.Keyboard.Focus%2A> 尝试将指定的元素键盘焦点给予。</span><span class="sxs-lookup"><span data-stu-id="98a46-321"><xref:System.Windows.Input.Keyboard.Focus%2A> attempts to give the specified element keyboard focus.</span></span>  <span data-ttu-id="98a46-322">返回的元素<xref:System.Windows.Input.Keyboard.Focus%2A>是当前具有键盘焦点的元素。</span><span class="sxs-lookup"><span data-stu-id="98a46-322">The element returned by <xref:System.Windows.Input.Keyboard.Focus%2A> is the element that currently has keyboard focus.</span></span>

 <span data-ttu-id="98a46-323">为了使元素能够获取键盘焦点<xref:System.Windows.UIElement.Focusable%2A>属性和<xref:System.Windows.UIElement.IsVisible%2A>属性必须设置为**true**。</span><span class="sxs-lookup"><span data-stu-id="98a46-323">In order for an element to obtain keyboard focus the <xref:System.Windows.UIElement.Focusable%2A> property and the <xref:System.Windows.UIElement.IsVisible%2A> properties must be set to **true**.</span></span>  <span data-ttu-id="98a46-324">一些类，如<xref:System.Windows.Controls.Panel>，具有<xref:System.Windows.UIElement.Focusable%2A>设置为`false`默认情况下; 因此，您可能需要将此属性设置为`true`如果你希望该元素能够获取焦点。</span><span class="sxs-lookup"><span data-stu-id="98a46-324">Some classes, such as <xref:System.Windows.Controls.Panel>, have <xref:System.Windows.UIElement.Focusable%2A> set to `false` by default; therefore, you may have to set this property to `true` if you want that element to be able to obtain focus.</span></span>

 <span data-ttu-id="98a46-325">下面的示例使用<xref:System.Windows.Input.Keyboard.Focus%2A>上设置键盘焦点<xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="98a46-325">The following example uses <xref:System.Windows.Input.Keyboard.Focus%2A> to set keyboard focus on a <xref:System.Windows.Controls.Button>.</span></span>  <span data-ttu-id="98a46-326">应用程序中设置初始焦点的建议的位置是在<xref:System.Windows.FrameworkElement.Loaded>事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="98a46-326">The recommended place to set initial focus in an application is in the <xref:System.Windows.FrameworkElement.Loaded> event handler.</span></span>

 [!code-csharp[focussample#FocusSampleSetFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#focussamplesetfocus)]
 [!code-vb[focussample#FocusSampleSetFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#focussamplesetfocus)]

 <span data-ttu-id="98a46-327">有关键盘焦点的详细信息，请参阅[焦点概述](focus-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="98a46-327">For more information about keyboard focus, see [Focus Overview](focus-overview.md).</span></span>

### <a name="logical-focus"></a><span data-ttu-id="98a46-328">逻辑焦点</span><span class="sxs-lookup"><span data-stu-id="98a46-328">Logical Focus</span></span>
 <span data-ttu-id="98a46-329">逻辑焦点指<xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType>焦点范围中。</span><span class="sxs-lookup"><span data-stu-id="98a46-329">Logical focus refers to the <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> in a focus scope.</span></span>  <span data-ttu-id="98a46-330">一个应用程序中可以有多个具有逻辑焦点的元素，但在一个特定的焦点范围中只能有一个具有逻辑焦点的元素。</span><span class="sxs-lookup"><span data-stu-id="98a46-330">There can be multiple elements that have logical focus in an application, but there may only be one element that has logical focus in a particular focus scope.</span></span>

 <span data-ttu-id="98a46-331">焦点范围是一个容器元素，用于跟踪<xref:System.Windows.Input.FocusManager.FocusedElement%2A>其作用域内。</span><span class="sxs-lookup"><span data-stu-id="98a46-331">A focus scope is a container element that keeps track of the <xref:System.Windows.Input.FocusManager.FocusedElement%2A> within its scope.</span></span>  <span data-ttu-id="98a46-332">焦点离开焦点范围时，焦点元素会失去键盘焦点，但保留逻辑焦点。</span><span class="sxs-lookup"><span data-stu-id="98a46-332">When focus leaves a focus scope, the focused element will lose keyboard focus but will retain logical focus.</span></span>  <span data-ttu-id="98a46-333">焦点返回到焦点范围时，焦点元素会再次获得键盘焦点。</span><span class="sxs-lookup"><span data-stu-id="98a46-333">When focus returns to the focus scope, the focused element will obtain keyboard focus.</span></span>  <span data-ttu-id="98a46-334">这使得键盘焦点可在多个焦点范围之间切换，但确保了焦点返回到焦点范围时，焦点范围中的焦点元素仍为焦点元素。</span><span class="sxs-lookup"><span data-stu-id="98a46-334">This allows for keyboard focus to be changed between multiple focus scopes but insures that the focused element within the focus scope remains the focused element when focus returns.</span></span>

 <span data-ttu-id="98a46-335">元素可以转换为中的焦点范围[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]通过设置<xref:System.Windows.Input.FocusManager>附加属性<xref:System.Windows.Input.FocusManager.IsFocusScope%2A>到`true`，或在代码中设置附加的属性使用<xref:System.Windows.Input.FocusManager.SetIsFocusScope%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="98a46-335">An element can be turned into a focus scope in [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] by setting the <xref:System.Windows.Input.FocusManager> attached property <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> to `true`, or in code by setting the attached property by using the <xref:System.Windows.Input.FocusManager.SetIsFocusScope%2A> method.</span></span>

 <span data-ttu-id="98a46-336">以下示例使<xref:System.Windows.Controls.StackPanel>转变为焦点范围，通过设置<xref:System.Windows.Input.FocusManager.IsFocusScope%2A>附加属性。</span><span class="sxs-lookup"><span data-stu-id="98a46-336">The following example makes a <xref:System.Windows.Controls.StackPanel> into a focus scope by setting the <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> attached property.</span></span>

 [!code-xaml[MarkupSnippets#MarkupIsFocusScopeXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/MarkupSnippets/CSharp/Window1.xaml#markupisfocusscopexaml)]

 [!code-csharp[FocusSnippets#FocusSetIsFocusScope](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSnippets/CSharp/Window1.xaml.cs#focussetisfocusscope)]
 [!code-vb[FocusSnippets#FocusSetIsFocusScope](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSnippets/visualbasic/window1.xaml.vb#focussetisfocusscope)]

 <span data-ttu-id="98a46-337">中的类[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]为焦点范围的默认值是<xref:System.Windows.Window>， <xref:System.Windows.Controls.Menu>， <xref:System.Windows.Controls.ToolBar>，和<xref:System.Windows.Controls.ContextMenu>。</span><span class="sxs-lookup"><span data-stu-id="98a46-337">Classes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] which are focus scopes by default are <xref:System.Windows.Window>, <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ToolBar>, and <xref:System.Windows.Controls.ContextMenu>.</span></span>

 <span data-ttu-id="98a46-338">具有键盘焦点的元素，也将具有逻辑焦点; 它所属的焦点范围因此，具有的元素上设置焦点<xref:System.Windows.Input.Keyboard.Focus%2A>方法<xref:System.Windows.Input.Keyboard>类或基元素类将尝试为提供的元素键盘焦点和逻辑焦点。</span><span class="sxs-lookup"><span data-stu-id="98a46-338">An element that has keyboard focus will also have logical focus for the focus scope it belongs to; therefore, setting focus on an element with the <xref:System.Windows.Input.Keyboard.Focus%2A> method on the <xref:System.Windows.Input.Keyboard> class or the base element classes will attempt to give the element keyboard focus and logical focus.</span></span>

 <span data-ttu-id="98a46-339">若要确定焦点范围中具有焦点的元素，请使用<xref:System.Windows.Input.FocusManager.GetFocusedElement%2A>。</span><span class="sxs-lookup"><span data-stu-id="98a46-339">To determine the focused element in a focus scope, use <xref:System.Windows.Input.FocusManager.GetFocusedElement%2A>.</span></span> <span data-ttu-id="98a46-340">若要更改焦点范围的焦点的元素，请使用<xref:System.Windows.Input.FocusManager.SetFocusedElement%2A>。</span><span class="sxs-lookup"><span data-stu-id="98a46-340">To change the focused element for a focus scope, use <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A>.</span></span>

 <span data-ttu-id="98a46-341">有关逻辑焦点的详细信息，请参阅[焦点概述](focus-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="98a46-341">For more information about logical focus, see [Focus Overview](focus-overview.md).</span></span>

<a name="mouse_position"></a>
## <a name="mouse-position"></a><span data-ttu-id="98a46-342">鼠标位置</span><span class="sxs-lookup"><span data-stu-id="98a46-342">Mouse Position</span></span>
 <span data-ttu-id="98a46-343">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]输入 API 提供了与坐标空间有关的有用信息。</span><span class="sxs-lookup"><span data-stu-id="98a46-343">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] input API provides helpful information with regard to coordinate spaces.</span></span>  <span data-ttu-id="98a46-344">例如，坐标 `(0,0)` 为左上角坐标，但该坐标是树中那一个元素的左上角坐标？</span><span class="sxs-lookup"><span data-stu-id="98a46-344">For example, coordinate `(0,0)` is the upper-left coordinate, but the upper-left of which element in the tree?</span></span> <span data-ttu-id="98a46-345">是属于输入目标的元素？</span><span class="sxs-lookup"><span data-stu-id="98a46-345">The element that is the input target?</span></span> <span data-ttu-id="98a46-346">是在其上附加事件处理程序的元素？</span><span class="sxs-lookup"><span data-stu-id="98a46-346">The element you attached your event handler to?</span></span> <span data-ttu-id="98a46-347">还是其他内容？</span><span class="sxs-lookup"><span data-stu-id="98a46-347">Or something else?</span></span> <span data-ttu-id="98a46-348">为了避免混淆，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]输入 API 要求时使用通过鼠标获取的坐标指定参考框架。</span><span class="sxs-lookup"><span data-stu-id="98a46-348">To avoid confusion, the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] input API requires that you specify your frame of reference when you work with coordinates obtained through the mouse.</span></span> <span data-ttu-id="98a46-349"><xref:System.Windows.Input.Mouse.GetPosition%2A>方法返回鼠标指针相对于指定元素的坐标。</span><span class="sxs-lookup"><span data-stu-id="98a46-349">The <xref:System.Windows.Input.Mouse.GetPosition%2A> method returns the coordinate of the mouse pointer relative to the specified element.</span></span>

<a name="mouse_capture"></a>
## <a name="mouse-capture"></a><span data-ttu-id="98a46-350">鼠标捕获</span><span class="sxs-lookup"><span data-stu-id="98a46-350">Mouse Capture</span></span>
 <span data-ttu-id="98a46-351">鼠标设备专门保留称为鼠标捕获的模式特征。</span><span class="sxs-lookup"><span data-stu-id="98a46-351">Mouse devices specifically hold a modal characteristic known as mouse capture.</span></span> <span data-ttu-id="98a46-352">鼠标捕获用于在拖放操作开始时保持转换的输入状态，从而不一定发生涉及鼠标指针的标称屏幕位置的其他操作。</span><span class="sxs-lookup"><span data-stu-id="98a46-352">Mouse capture is used to maintain a transitional input state when a drag-and-drop operation is started, so that other operations involving the nominal on-screen position of the mouse pointer do not necessarily occur.</span></span> <span data-ttu-id="98a46-353">拖动过程中，未终止拖放时用户无法单击，这使得大多数鼠标悬停提示在拖动来源拥有鼠标捕获时是不合适的。</span><span class="sxs-lookup"><span data-stu-id="98a46-353">During the drag, the user cannot click without aborting the drag-and-drop, which makes most mouseover cues inappropriate while the mouse capture is held by the drag origin.</span></span> <span data-ttu-id="98a46-354">输入系统公开了可确定鼠标捕获状态的 [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] 以及可强制在特定元素上捕获鼠标或清除鼠标捕获状态的 [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="98a46-354">The input system exposes [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] that can determine mouse capture state, as well as [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] that can force mouse capture to a specific element, or clear mouse capture state.</span></span> <span data-ttu-id="98a46-355">有关拖放操作的详细信息，请参阅[拖放概述](drag-and-drop-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="98a46-355">For more information on drag-and-drop operations, see [Drag and Drop Overview](drag-and-drop-overview.md).</span></span>

<a name="commands"></a>
## <a name="commands"></a><span data-ttu-id="98a46-356">命令</span><span class="sxs-lookup"><span data-stu-id="98a46-356">Commands</span></span>
 <span data-ttu-id="98a46-357">使用命令，输入处理可以更多地在语义级别（而不是在设备输入级别）进行。</span><span class="sxs-lookup"><span data-stu-id="98a46-357">Commands enable input handling at a more semantic level than device input.</span></span>  <span data-ttu-id="98a46-358">命令是简单的指令，如 `Cut`、`Copy`、`Paste` 或 `Open`。</span><span class="sxs-lookup"><span data-stu-id="98a46-358">Commands are simple directives, such as `Cut`, `Copy`, `Paste`, or `Open`.</span></span>  <span data-ttu-id="98a46-359">命令可用于集中命令逻辑。</span><span class="sxs-lookup"><span data-stu-id="98a46-359">Commands are useful for centralizing your command logic.</span></span>  <span data-ttu-id="98a46-360">可能从访问相同的命令<xref:System.Windows.Controls.Menu>，然后在<xref:System.Windows.Controls.ToolBar>，或通过键盘快捷方式。</span><span class="sxs-lookup"><span data-stu-id="98a46-360">The same command might be accessed from a <xref:System.Windows.Controls.Menu>, on a <xref:System.Windows.Controls.ToolBar>, or through a keyboard shortcut.</span></span> <span data-ttu-id="98a46-361">命令还提供一种机制，用于在命令不可用时禁用控件。</span><span class="sxs-lookup"><span data-stu-id="98a46-361">Commands also provide a mechanism for disabling controls when the command becomes unavailable.</span></span>

 <span data-ttu-id="98a46-362"><xref:System.Windows.Input.RoutedCommand> 是[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]的实现<xref:System.Windows.Input.ICommand>。</span><span class="sxs-lookup"><span data-stu-id="98a46-362"><xref:System.Windows.Input.RoutedCommand> is the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] implementation of <xref:System.Windows.Input.ICommand>.</span></span>  <span data-ttu-id="98a46-363">当<xref:System.Windows.Input.RoutedCommand>执行时，<xref:System.Windows.Input.CommandManager.PreviewExecuted>和<xref:System.Windows.Input.CommandManager.Executed>的隧道和冒泡元素树与其他输入一样在命令目标上引发事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-363">When a <xref:System.Windows.Input.RoutedCommand> is executed, a <xref:System.Windows.Input.CommandManager.PreviewExecuted> and an <xref:System.Windows.Input.CommandManager.Executed> event are raised on the command target, which tunnel and bubble through the element tree like other input.</span></span>  <span data-ttu-id="98a46-364">如果未设置命令目标，则具有键盘焦点的元素将成为命令目标。</span><span class="sxs-lookup"><span data-stu-id="98a46-364">If a command target is not set, the element with keyboard focus will be the command target.</span></span>  <span data-ttu-id="98a46-365">执行此命令的逻辑附加到<xref:System.Windows.Input.CommandBinding>。</span><span class="sxs-lookup"><span data-stu-id="98a46-365">The logic that performs the command is attached to a <xref:System.Windows.Input.CommandBinding>.</span></span>  <span data-ttu-id="98a46-366">当<xref:System.Windows.Input.CommandManager.Executed>事件到达<xref:System.Windows.Input.CommandBinding>针对该特定命令<xref:System.Windows.Input.ExecutedRoutedEventHandler>上<xref:System.Windows.Input.CommandBinding>调用。</span><span class="sxs-lookup"><span data-stu-id="98a46-366">When an <xref:System.Windows.Input.CommandManager.Executed> event reaches a <xref:System.Windows.Input.CommandBinding> for that specific command, the <xref:System.Windows.Input.ExecutedRoutedEventHandler> on the <xref:System.Windows.Input.CommandBinding> is called.</span></span>  <span data-ttu-id="98a46-367">此处理程序执行该命令的操作。</span><span class="sxs-lookup"><span data-stu-id="98a46-367">This handler performs the action of the command.</span></span>

 <span data-ttu-id="98a46-368">有关命令的详细信息，请参阅[命令概述](commanding-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="98a46-368">For more information on commanding, see [Commanding Overview](commanding-overview.md).</span></span>

 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="98a46-369">提供一个常用的命令组成的库<xref:System.Windows.Input.ApplicationCommands>， <xref:System.Windows.Input.MediaCommands>， <xref:System.Windows.Input.ComponentCommands>， <xref:System.Windows.Input.NavigationCommands>，和<xref:System.Windows.Documents.EditingCommands>，也可以定义您自己。</span><span class="sxs-lookup"><span data-stu-id="98a46-369">provides a library of common commands which consists of <xref:System.Windows.Input.ApplicationCommands>, <xref:System.Windows.Input.MediaCommands>, <xref:System.Windows.Input.ComponentCommands>, <xref:System.Windows.Input.NavigationCommands>, and <xref:System.Windows.Documents.EditingCommands>, or you can define your own.</span></span>

 <span data-ttu-id="98a46-370">下面的示例演示如何设置<xref:System.Windows.Controls.MenuItem>，以便单击时它将调用<xref:System.Windows.Input.ApplicationCommands.Paste%2A>命令<xref:System.Windows.Controls.TextBox>，那么<xref:System.Windows.Controls.TextBox>具有键盘焦点。</span><span class="sxs-lookup"><span data-stu-id="98a46-370">The following example shows how to set up a <xref:System.Windows.Controls.MenuItem> so that when it is clicked it will invoke the <xref:System.Windows.Input.ApplicationCommands.Paste%2A> command on the <xref:System.Windows.Controls.TextBox>, assuming the <xref:System.Windows.Controls.TextBox> has keyboard focus.</span></span>

 [!code-xaml[CommandingOverviewSnippets#CommandingOverviewSimpleCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewsimplecommand)]

 [!code-csharp[CommandingOverviewSnippets#CommandingOverviewCommandTargetCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewcommandtargetcodebehind)]
 [!code-vb[CommandingOverviewSnippets#CommandingOverviewCommandTargetCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewcommandtargetcodebehind)]

 <span data-ttu-id="98a46-371">有关 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中的命令的详细信息，请参阅[命令概述](commanding-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="98a46-371">For more information about commands in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], see [Commanding Overview](commanding-overview.md).</span></span>

<a name="the_input_system_and_base_elements"></a>
## <a name="the-input-system-and-base-elements"></a><span data-ttu-id="98a46-372">输入系统和基元素</span><span class="sxs-lookup"><span data-stu-id="98a46-372">The Input System and Base Elements</span></span>
 <span data-ttu-id="98a46-373">输入事件，例如由定义的附加事件<xref:System.Windows.Input.Mouse>， <xref:System.Windows.Input.Keyboard>，和<xref:System.Windows.Input.Stylus>类是由输入系统引发和注入的命中测试可视化树在运行时所基于的对象模型中的特定位置。</span><span class="sxs-lookup"><span data-stu-id="98a46-373">Input events such as the attached events defined by the <xref:System.Windows.Input.Mouse>, <xref:System.Windows.Input.Keyboard>, and <xref:System.Windows.Input.Stylus> classes are raised by the input system and injected into a particular position in the object model based on hit testing the visual tree at run time.</span></span>

 <span data-ttu-id="98a46-374">每个事件的<xref:System.Windows.Input.Mouse>， <xref:System.Windows.Input.Keyboard>，并<xref:System.Windows.Input.Stylus>定义为附加的事件还会重新显示由基元素类<xref:System.Windows.UIElement>和<xref:System.Windows.ContentElement>作为新的路由事件。</span><span class="sxs-lookup"><span data-stu-id="98a46-374">Each of the events that <xref:System.Windows.Input.Mouse>, <xref:System.Windows.Input.Keyboard>, and <xref:System.Windows.Input.Stylus> define as an attached event is also re-exposed by the base element classes <xref:System.Windows.UIElement> and <xref:System.Windows.ContentElement> as a new routed event.</span></span> <span data-ttu-id="98a46-375">基元素路由事件由处理原始附加事件并重用事件数据的类生成。</span><span class="sxs-lookup"><span data-stu-id="98a46-375">The base element routed events are generated by classes handling the original attached event and reusing the event data.</span></span>

 <span data-ttu-id="98a46-376">当输入事件通过其基元素输入事件实现与特定源元素相关联时，可以通过基于逻辑和可视化树对象的组合的事件路由的其余部分进行路由，并由应用程序代码进行处理。</span><span class="sxs-lookup"><span data-stu-id="98a46-376">When the input event becomes associated with a particular source element through its base element input event implementation, it can be routed through the remainder of an event route that is based on a combination of logical and visual tree objects, and be handled by application code.</span></span>  <span data-ttu-id="98a46-377">通常情况下，它是处理使用路由的事件在这些设备相关的输入的事件更为方便<xref:System.Windows.UIElement>并<xref:System.Windows.ContentElement>，这是因为您可以使用更直观事件处理程序中的语法这两个[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]和代码中。</span><span class="sxs-lookup"><span data-stu-id="98a46-377">Generally, it is more convenient to handle these device-related input events using the routed events on <xref:System.Windows.UIElement> and <xref:System.Windows.ContentElement>, because you can use more intuitive event handler syntax both in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] and in code.</span></span> <span data-ttu-id="98a46-378">你可以选择处理发起进程的附加事件，但将会面临几个问题：附加事件可能会被基元素类处理标记为已处理，并且你需要使用访问器方法（而不是真正的事件语法）才能为附加事件附加处理程序。</span><span class="sxs-lookup"><span data-stu-id="98a46-378">You could choose to handle the attached event that initiated the process instead, but you would face several issues: the attached event may be marked handled by the base element class handling, and you need to use accessor methods rather than true event syntax in order to attach handlers for attached events.</span></span>

<a name="whats_next"></a>
## <a name="whats-next"></a><span data-ttu-id="98a46-379">下一步</span><span class="sxs-lookup"><span data-stu-id="98a46-379">What's Next</span></span>
 <span data-ttu-id="98a46-380">现在有多种方法来处理 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中的输入。</span><span class="sxs-lookup"><span data-stu-id="98a46-380">You now have several techniques to handle input in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>  <span data-ttu-id="98a46-381">你还应该对 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 使用的各种类型的输入事件和路由事件机制有进一步的了解。</span><span class="sxs-lookup"><span data-stu-id="98a46-381">You should also have an improved understanding of the various types of input events and the routed event mechanisms used by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>

 <span data-ttu-id="98a46-382">也可以获取更详细说明 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 框架元素和事件路由的详细资源。</span><span class="sxs-lookup"><span data-stu-id="98a46-382">Additional resources are available that explain [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] framework elements and event routing in more detail.</span></span> <span data-ttu-id="98a46-383">有关详细信息，请参阅以下概述：[命令概述](commanding-overview.md)、[焦点概述](focus-overview.md)、[基元素概述](base-elements-overview.md)、[WPF 中的树](trees-in-wpf.md)和[路由事件概述](routed-events-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="98a46-383">See the following overviews for more information, [Commanding Overview](commanding-overview.md), [Focus Overview](focus-overview.md), [Base Elements Overview](base-elements-overview.md), [Trees in WPF](trees-in-wpf.md), and [Routed Events Overview](routed-events-overview.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="98a46-384">请参阅</span><span class="sxs-lookup"><span data-stu-id="98a46-384">See also</span></span>

- [<span data-ttu-id="98a46-385">焦点概述</span><span class="sxs-lookup"><span data-stu-id="98a46-385">Focus Overview</span></span>](focus-overview.md)
- [<span data-ttu-id="98a46-386">命令概述</span><span class="sxs-lookup"><span data-stu-id="98a46-386">Commanding Overview</span></span>](commanding-overview.md)
- [<span data-ttu-id="98a46-387">路由事件概述</span><span class="sxs-lookup"><span data-stu-id="98a46-387">Routed Events Overview</span></span>](routed-events-overview.md)
- [<span data-ttu-id="98a46-388">基元素概述</span><span class="sxs-lookup"><span data-stu-id="98a46-388">Base Elements Overview</span></span>](base-elements-overview.md)
- [<span data-ttu-id="98a46-389">属性</span><span class="sxs-lookup"><span data-stu-id="98a46-389">Properties</span></span>](properties-wpf.md)
