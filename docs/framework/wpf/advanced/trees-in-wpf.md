---
title: 林中
ms.date: 03/30/2017
helpviewer_keywords:
- logical tree [WPF]
- element tree [WPF]
- visual tree [WPF]
ms.assetid: e83f25e5-d66b-4fc7-92d2-50130c9a6649
ms.openlocfilehash: d4b17c34fb33f73ca1c173bebc8f94ddac5b1942
ms.sourcegitcommit: de17a7a0a37042f0d4406f5ae5393531caeb25ba
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/24/2020
ms.locfileid: "76746579"
---
# <a name="trees-in-wpf"></a><span data-ttu-id="71228-102">WPF 中的树</span><span class="sxs-lookup"><span data-stu-id="71228-102">Trees in WPF</span></span>
<span data-ttu-id="71228-103">在许多技术中，元素和组件都按树结构的形式组织。在这种结构中，开发人员可以直接操作树中的对象节点来影响应用程序的绘制或行为。</span><span class="sxs-lookup"><span data-stu-id="71228-103">In many technologies, elements and components are organized in a tree structure where developers directly manipulate the object nodes in the tree to affect the rendering or behavior of an application.</span></span> [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <span data-ttu-id="71228-104">也使用了若干树结构形式来定义程序元素之间的关系。</span><span class="sxs-lookup"><span data-stu-id="71228-104">also uses several tree structure metaphors to define relationships between program elements.</span></span> <span data-ttu-id="71228-105">多数情况下，在概念层面考虑对象树形式时，WPF 开发人员会用代码创建应用程序，或用 XAML 定义应用程序的组成部分，但他们会调用具体的 API 或使用特定的标记来执行此操作，而不是像在 XML DOM 中那样，使用某些常规对象树操作 API。</span><span class="sxs-lookup"><span data-stu-id="71228-105">For the most part WPF developers can create an application in code or define portions of the application in XAML while thinking conceptually about the object tree metaphor, but will be calling specific API or using specific markup to do so rather than some general object tree manipulation API such as you might use in XML DOM.</span></span> <span data-ttu-id="71228-106">WPF 公开了两个帮助器类，它们提供树比喻视图，<xref:System.Windows.LogicalTreeHelper> 和 <xref:System.Windows.Media.VisualTreeHelper>。</span><span class="sxs-lookup"><span data-stu-id="71228-106">WPF exposes two helper classes that provide a tree metaphor view, <xref:System.Windows.LogicalTreeHelper> and <xref:System.Windows.Media.VisualTreeHelper>.</span></span> <span data-ttu-id="71228-107">WPF 文档中还使用了“可视化树”和“逻辑树”两个术语，它们有助于理解某些关键 WPF 功能的行为。</span><span class="sxs-lookup"><span data-stu-id="71228-107">The terms visual tree and logical tree are also used in the WPF documentation because these same trees are useful for understanding the behavior of certain key WPF features.</span></span> <span data-ttu-id="71228-108">本主题定义可视化树和逻辑树表示的内容，讨论此类树如何与整体对象树概念相关，并介绍 <xref:System.Windows.LogicalTreeHelper> 和 <xref:System.Windows.Media.VisualTreeHelper>。</span><span class="sxs-lookup"><span data-stu-id="71228-108">This topic defines what the visual tree and logical tree represent, discusses how such trees relate to an overall object tree concept, and introduces <xref:System.Windows.LogicalTreeHelper> and <xref:System.Windows.Media.VisualTreeHelper>s.</span></span>  

<a name="element_tree"></a>   
## <a name="trees-in-wpf"></a><span data-ttu-id="71228-109">WPF 中的树</span><span class="sxs-lookup"><span data-stu-id="71228-109">Trees in WPF</span></span>  
 <span data-ttu-id="71228-110">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中，最完整的树结构是对象树。</span><span class="sxs-lookup"><span data-stu-id="71228-110">The most complete tree structure in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is the object tree.</span></span> <span data-ttu-id="71228-111">如果在 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 中定义一个应用程序页，然后加载 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]，将根据标记中元素之间的嵌套关系来创建树结构。</span><span class="sxs-lookup"><span data-stu-id="71228-111">If you define an application page in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] and then load the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], the tree structure is created based on the nesting relationships of the elements in the markup.</span></span> <span data-ttu-id="71228-112">如果使用代码定义应用程序或应用程序的一部分，则将根据为属性（属性实现给定对象的内容模型）分配属性值的方式来创建树结构。</span><span class="sxs-lookup"><span data-stu-id="71228-112">If you define an application or a portion of the application in code, then the tree structure is created based on how you assign property values for properties that implement the content model for a given object.</span></span> <span data-ttu-id="71228-113">在 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 中，完整的对象树可通过两种方式进行概念化并报告给其公共 API：作为逻辑树和作为可视化树。</span><span class="sxs-lookup"><span data-stu-id="71228-113">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], there are two ways that the complete object tree is conceptualized and can be reported to its public API: as the logical tree and as the visual tree.</span></span> <span data-ttu-id="71228-114">逻辑树与可视化树之间的区别不一定重要，但在某些 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 子系统中它们偶尔可能会导致问题，并影响你对标记或代码的选择。</span><span class="sxs-lookup"><span data-stu-id="71228-114">The distinctions between logical tree and visual tree are not always necessarily important, but they can occasionally cause issues with certain [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] subsystems and affect choices you make in markup or code.</span></span>  
  
 <span data-ttu-id="71228-115">尽管你并不会总是直接操作逻辑树或可视化树，但理解它们之间的关系有助于你从技术角度了解 WPF。</span><span class="sxs-lookup"><span data-stu-id="71228-115">Even though you do not always manipulate either the logical tree or the visual tree directly, understanding the concepts of how the trees interact is useful for understanding WPF as a technology.</span></span> <span data-ttu-id="71228-116">若要理解 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中属性继承和事件路由的工作原理，将 WPF 视为某种树形式也相当重要。</span><span class="sxs-lookup"><span data-stu-id="71228-116">Thinking of WPF as a tree metaphor of some kind is also crucial to understanding how property inheritance and event routing work in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>  
  
> [!NOTE]
> <span data-ttu-id="71228-117">因为对象树更像是概念，而不像是实际 API，所以还可以将此概念视为对象图。</span><span class="sxs-lookup"><span data-stu-id="71228-117">Because the object tree is more of a concept than an actual API, another way to think of the concept is as an object graph.</span></span> <span data-ttu-id="71228-118">实际上，在运行时，对象之间的某些关系不能由树形式表示。</span><span class="sxs-lookup"><span data-stu-id="71228-118">In practice, there are relationships between objects at run time where the tree metaphor will break down.</span></span> <span data-ttu-id="71228-119">尽管如此，树形式的相关性还是很强，尤其是对于 XAML 定义的 UI。因此，大多数 WPF 文档在引用这个常见概念时，仍使用术语“对象树”。</span><span class="sxs-lookup"><span data-stu-id="71228-119">Nevertheless, particularly with XAML-defined UI, the tree metaphor is relevant enough that most WPF documentation will use the term object tree when referencing this general concept.</span></span>  
  
<a name="logical_tree"></a>   
## <a name="the-logical-tree"></a><span data-ttu-id="71228-120">逻辑树</span><span class="sxs-lookup"><span data-stu-id="71228-120">The Logical Tree</span></span>  
 <span data-ttu-id="71228-121">在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中，通过为支持 UI 元素的对象设置属性，可以向这些 UI 元素添加内容。</span><span class="sxs-lookup"><span data-stu-id="71228-121">In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], you add content to UI elements by setting properties of the objects that back those elements.</span></span> <span data-ttu-id="71228-122">例如，通过操作其 <xref:System.Windows.Controls.ItemsControl.Items%2A> 属性将项添加到 <xref:System.Windows.Controls.ListBox> 控件。</span><span class="sxs-lookup"><span data-stu-id="71228-122">For example, you add items to a <xref:System.Windows.Controls.ListBox> control by manipulating its <xref:System.Windows.Controls.ItemsControl.Items%2A> property.</span></span> <span data-ttu-id="71228-123">通过执行此操作，您可以将项放入作为 <xref:System.Windows.Controls.ItemsControl.Items%2A> 属性值的 <xref:System.Windows.Controls.ItemCollection> 中。</span><span class="sxs-lookup"><span data-stu-id="71228-123">By doing this, you are placing items into the <xref:System.Windows.Controls.ItemCollection> that is the <xref:System.Windows.Controls.ItemsControl.Items%2A> property value.</span></span> <span data-ttu-id="71228-124">同样，若要将对象添加到 <xref:System.Windows.Controls.DockPanel>，可以操作其 <xref:System.Windows.Controls.Panel.Children%2A> 属性值。</span><span class="sxs-lookup"><span data-stu-id="71228-124">Similarly, to add objects to a <xref:System.Windows.Controls.DockPanel>, you manipulate its <xref:System.Windows.Controls.Panel.Children%2A> property value.</span></span> <span data-ttu-id="71228-125">此处，你要将对象添加到 <xref:System.Windows.Controls.UIElementCollection>。</span><span class="sxs-lookup"><span data-stu-id="71228-125">Here, you are adding objects to the <xref:System.Windows.Controls.UIElementCollection>.</span></span> <span data-ttu-id="71228-126">有关代码示例，请参阅[如何：动态添加元素](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms752374(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="71228-126">For a code example, see [How to: Add an Element Dynamically](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms752374(v=vs.100)).</span></span>  
  
 <span data-ttu-id="71228-127">在 [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]中，当您将列表项放置在 <xref:System.Windows.Controls.DockPanel>的 <xref:System.Windows.Controls.ListBox> 或控件或其他 UI 元素中时，还可以显式或隐式使用 <xref:System.Windows.Controls.ItemsControl.Items%2A> 和 <xref:System.Windows.Controls.Panel.Children%2A> 属性，如以下示例中所示。</span><span class="sxs-lookup"><span data-stu-id="71228-127">In [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)], when you place list items in a <xref:System.Windows.Controls.ListBox> or controls or other UI elements in a <xref:System.Windows.Controls.DockPanel>, you also use the <xref:System.Windows.Controls.ItemsControl.Items%2A> and <xref:System.Windows.Controls.Panel.Children%2A> properties, either explicitly or implicitly, as in the following example.</span></span>  
  
 [!code-xaml[TreeOvwsSupport#AllCode](~/samples/snippets/csharp/VS_Snippets_Wpf/TreeOvwsSupport/CS/page1.xaml#allcode)]  
  
 <span data-ttu-id="71228-128">如果此 XAML 是作为文档对象模型下的 XML 进行处理，且已包含作为隐式项禁止注释的标记（可能是合法的），生成的 XML DOM 树已包含 `<ListBox.Items>` 的元素以及其他隐式项。</span><span class="sxs-lookup"><span data-stu-id="71228-128">If you were to process this XAML as XML under a document object model, and if you had included the tags commented out as implicit (which would have been legal), then the resulting XML DOM tree would have included elements for `<ListBox.Items>` and the other implicit items.</span></span> <span data-ttu-id="71228-129">但是，读取标记和写入对象时，XAML 不会这样处理，生成的对象图不包含 `ListBox.Items`。</span><span class="sxs-lookup"><span data-stu-id="71228-129">But XAML does not process that way when you read the markup and write to objects, the resulting object graph does not literally include `ListBox.Items`.</span></span> <span data-ttu-id="71228-130">但它确实具有一个名为 `Items` 的 <xref:System.Windows.Controls.ListBox> 属性，该属性包含一个 <xref:System.Windows.Controls.ItemCollection>，并且在处理 <xref:System.Windows.Controls.ListBox> XAML 时该 <xref:System.Windows.Controls.ItemCollection> 已初始化但为空。</span><span class="sxs-lookup"><span data-stu-id="71228-130">It does however have a <xref:System.Windows.Controls.ListBox> property named `Items` that contains a <xref:System.Windows.Controls.ItemCollection>, and that <xref:System.Windows.Controls.ItemCollection> is initialized but empty when the <xref:System.Windows.Controls.ListBox> XAML is processed.</span></span> <span data-ttu-id="71228-131">然后，将作为 <xref:System.Windows.Controls.ListBox> 的内容存在的每个子对象元素添加到 <xref:System.Windows.Controls.ItemCollection>，分析程序将调用 `ItemCollection.Add`。</span><span class="sxs-lookup"><span data-stu-id="71228-131">Then, each child object element that exists as content for the <xref:System.Windows.Controls.ListBox> is added to the <xref:System.Windows.Controls.ItemCollection> by parser calls to `ItemCollection.Add`.</span></span> <span data-ttu-id="71228-132">此示例将 XAML 处理成对象树，目前这似乎表明所创建的对象树基本上是逻辑树。</span><span class="sxs-lookup"><span data-stu-id="71228-132">This example of processing XAML into an object tree is so far seemingly an example where the created object tree is basically the logical tree.</span></span>  
  
 <span data-ttu-id="71228-133">但是，逻辑树并不是应用程序 UI 在运行时存在的整个对象图，即使已分解 XAML 隐式语法项也是如此。这种情况的主要原因是视觉对象和模板。</span><span class="sxs-lookup"><span data-stu-id="71228-133">However, the logical tree is not the entire object graph that exists for your application UI at run time, even with the XAML implicit syntax items factored out. The main reason for this is visuals and templates.</span></span> <span data-ttu-id="71228-134">例如，请考虑 <xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="71228-134">For example, consider the <xref:System.Windows.Controls.Button>.</span></span> <span data-ttu-id="71228-135">逻辑树报告 <xref:System.Windows.Controls.Button> 对象及其 `Content`的字符串。</span><span class="sxs-lookup"><span data-stu-id="71228-135">The logical tree reports the <xref:System.Windows.Controls.Button> object and also its string `Content`.</span></span> <span data-ttu-id="71228-136">但在运行时对象树中，此按钮还有更多内容。</span><span class="sxs-lookup"><span data-stu-id="71228-136">But there is more to this button in the run-time object tree.</span></span> <span data-ttu-id="71228-137">特别是，按钮只在屏幕上显示，因为应用了特定 <xref:System.Windows.Controls.Button> 控件模板。</span><span class="sxs-lookup"><span data-stu-id="71228-137">In particular, the button only appears on screen the way it does because a specific <xref:System.Windows.Controls.Button> control template was applied.</span></span> <span data-ttu-id="71228-138">即使您在运行时查看逻辑树（例如，从可见 UI 处理输入事件，然后读取逻辑树），来自应用的模板的视觉对象（如视觉按钮周围的模板定义 <xref:System.Windows.Controls.Border>）也不会在逻辑树中报告。</span><span class="sxs-lookup"><span data-stu-id="71228-138">The visuals that come from an applied template (such as the template-defined <xref:System.Windows.Controls.Border> of dark gray around the visual button) are not reported in the logical tree, even if you are looking at the logical tree during run time (such as handling an input event from the visible UI and then reading the logical tree).</span></span> <span data-ttu-id="71228-139">若要查找模板视觉对象，需要改为检查可视化树。</span><span class="sxs-lookup"><span data-stu-id="71228-139">To find the template visuals, you would instead need to examine the visual tree.</span></span>  
  
 <span data-ttu-id="71228-140">有关 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 语法如何映射到所创建的对象图，以及 XAML 中隐式语法的详细信息，请参阅 [XAML 语法详述](xaml-syntax-in-detail.md)或 [XAML 概述 (WPF)](xaml-overview-wpf.md)。</span><span class="sxs-lookup"><span data-stu-id="71228-140">For more information about how [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] syntax maps to the created object graph, and implicit syntax in XAML, see [XAML Syntax In Detail](xaml-syntax-in-detail.md) or [XAML Overview (WPF)](xaml-overview-wpf.md).</span></span>  
  
<a name="tree_property_inheritance_event_routing"></a>   
### <a name="the-purpose-of-the-logical-tree"></a><span data-ttu-id="71228-141">逻辑树用途</span><span class="sxs-lookup"><span data-stu-id="71228-141">The Purpose of the Logical Tree</span></span>  
 <span data-ttu-id="71228-142">借助逻辑树，内容模型可以方便地循环访问其可能的子对象，从而实现扩展。</span><span class="sxs-lookup"><span data-stu-id="71228-142">The logical tree exists so that content models can readily iterate over their possible child objects, and so that content models can be extensible.</span></span> <span data-ttu-id="71228-143">此外，逻辑树还为某些通知提供框架，例如在加载逻辑树中的所有对象时。</span><span class="sxs-lookup"><span data-stu-id="71228-143">Also, the logical tree provides a framework for certain notifications, such as when all objects in the logical tree are loaded.</span></span> <span data-ttu-id="71228-144">基本上，逻辑树是框架级别的近似运行时对象图（排除了视觉对象），但其足以用于对你自己的运行时应用程序组合执行多种查询操作。</span><span class="sxs-lookup"><span data-stu-id="71228-144">Basically, the logical tree is an approximation of a run time object graph at the framework level, which excludes visuals, but is adequate for many querying operations against your own run time application's composition.</span></span>  
  
 <span data-ttu-id="71228-145">此外，通过在初始请求对象上的 <xref:System.Windows.FrameworkElement.Resources%2A> 集合中向上查找逻辑树来解析静态和动态资源引用，然后继续运行逻辑树，并检查每个 <xref:System.Windows.FrameworkElement> （或 <xref:System.Windows.FrameworkContentElement>）以查找包含 <xref:System.Windows.ResourceDictionary>的另一个 `Resources` 值，可能包含该密钥。</span><span class="sxs-lookup"><span data-stu-id="71228-145">In addition, both static and dynamic resource references are resolved by looking upwards through the logical tree for <xref:System.Windows.FrameworkElement.Resources%2A> collections on the initial requesting object, and then continuing up the logical tree and checking each <xref:System.Windows.FrameworkElement> (or <xref:System.Windows.FrameworkContentElement>) for another `Resources` value that contains a <xref:System.Windows.ResourceDictionary>, possibly containing that key.</span></span> <span data-ttu-id="71228-146">当同时存在逻辑树和可视化树时，将使用逻辑树进行资源查找。</span><span class="sxs-lookup"><span data-stu-id="71228-146">The logical tree is used for resource lookup when both the logical tree and the visual tree are present.</span></span> <span data-ttu-id="71228-147">有关资源字典和查找的详细信息，请参见 [XAML 资源](../../../desktop-wpf/fundamentals/xaml-resources-define.md)。</span><span class="sxs-lookup"><span data-stu-id="71228-147">For more information on resource dictionaries and lookup, see [XAML Resources](../../../desktop-wpf/fundamentals/xaml-resources-define.md).</span></span>  
  
<a name="composition"></a>   
### <a name="composition-of-the-logical-tree"></a><span data-ttu-id="71228-148">逻辑树的构成</span><span class="sxs-lookup"><span data-stu-id="71228-148">Composition of the Logical Tree</span></span>  
 <span data-ttu-id="71228-149">逻辑树在 WPF 框架级别定义，这意味着，与逻辑树操作最相关的 WPF 基元素是 <xref:System.Windows.FrameworkElement> 或 <xref:System.Windows.FrameworkContentElement>。</span><span class="sxs-lookup"><span data-stu-id="71228-149">The logical tree is defined at the WPF framework-level, which means that the WPF base element that is most relevant for logical tree operations is either <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>.</span></span> <span data-ttu-id="71228-150">不过，您可以看到，确实使用 <xref:System.Windows.LogicalTreeHelper> API，逻辑树有时包含不 <xref:System.Windows.FrameworkElement> 或 <xref:System.Windows.FrameworkContentElement>的节点。</span><span class="sxs-lookup"><span data-stu-id="71228-150">However, as you can see if you actually use the <xref:System.Windows.LogicalTreeHelper> API, the logical tree sometimes contains nodes that are not either <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>.</span></span> <span data-ttu-id="71228-151">例如，逻辑树报告了 <xref:System.Windows.Controls.TextBlock>的 <xref:System.Windows.Controls.TextBlock.Text%2A> 值，这是一个字符串。</span><span class="sxs-lookup"><span data-stu-id="71228-151">For instance, the logical tree reports the <xref:System.Windows.Controls.TextBlock.Text%2A> value of a <xref:System.Windows.Controls.TextBlock>, which is a string.</span></span>  
  
<a name="override_logical_tree"></a>   
### <a name="overriding-the-logical-tree"></a><span data-ttu-id="71228-152">替代逻辑树</span><span class="sxs-lookup"><span data-stu-id="71228-152">Overriding the Logical Tree</span></span>  
 <span data-ttu-id="71228-153">高级控件作者可以通过重写几个 Api 来重写逻辑树，这些 Api 定义了常规对象或内容模型在逻辑树中添加或删除对象的方式。</span><span class="sxs-lookup"><span data-stu-id="71228-153">Advanced control authors can override the logical tree by overriding several APIs that define how a general object or content model adds or removes objects within the logical tree.</span></span> <span data-ttu-id="71228-154">有关如何替代逻辑树的示例，请参阅[替代逻辑树](how-to-override-the-logical-tree.md)。</span><span class="sxs-lookup"><span data-stu-id="71228-154">For an example of how to override the logical tree, see [Override the Logical Tree](how-to-override-the-logical-tree.md).</span></span>  
  
<a name="pvi"></a>   
### <a name="property-value-inheritance"></a><span data-ttu-id="71228-155">属性值继承</span><span class="sxs-lookup"><span data-stu-id="71228-155">Property Value Inheritance</span></span>  
 <span data-ttu-id="71228-156">属性值继承通过混合树操作。</span><span class="sxs-lookup"><span data-stu-id="71228-156">Property value inheritance operates through a hybrid tree.</span></span> <span data-ttu-id="71228-157">包含启用属性继承的 <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> 属性的实际元数据是 WPF 框架级 <xref:System.Windows.FrameworkPropertyMetadata> 类。</span><span class="sxs-lookup"><span data-stu-id="71228-157">The actual metadata that contains the <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> property that enables property inheritance is the WPF framework-level <xref:System.Windows.FrameworkPropertyMetadata> class.</span></span> <span data-ttu-id="71228-158">因此，持有原始值的父对象和继承该值的子对象都必须 <xref:System.Windows.FrameworkElement> 或 <xref:System.Windows.FrameworkContentElement>，并且它们必须都是部分逻辑树的一部分。</span><span class="sxs-lookup"><span data-stu-id="71228-158">Therefore, both the parent that holds the original value and the child object that inherits that value must both be <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>, and they must both be part of some logical tree.</span></span> <span data-ttu-id="71228-159">但是，对于支持属性继承的现有 WPF 属性，属性值的继承可通过逻辑树中没有的中介对象永久存在。</span><span class="sxs-lookup"><span data-stu-id="71228-159">However, for existing WPF properties that support property inheritance, property value inheritance is able to perpetuate through an intervening object that is not in the logical tree.</span></span> <span data-ttu-id="71228-160">这主要适用于以下情况：让模板元素使用在应用了模板的实例上设置的任何继承属性值，或者使用在更高级别的页级构成（因此在逻辑树中也位于更高位置）中设置的任何继承属性值。</span><span class="sxs-lookup"><span data-stu-id="71228-160">Mainly this is relevant for having template elements use any inherited property values set either on the instance that is templated, or at still higher levels of page-level composition and therefore higher in the logical tree.</span></span> <span data-ttu-id="71228-161">为了使属性值的继承在这两种情况下保持一致，继承属性必须注册为附加属性。如果要定义具有属性继承行为的自定义依赖属性，则应采用这种模式。</span><span class="sxs-lookup"><span data-stu-id="71228-161">In order for property value inheritance to work consistently across such a boundary, the inheriting property must be registered as an attached property, and you should follow this pattern if you intend to define a custom dependency property with property inheritance behavior.</span></span> <span data-ttu-id="71228-162">无法通过帮助器类实用工具方法完全预测属性继承确切使用的树，即使在运行时也是如此。</span><span class="sxs-lookup"><span data-stu-id="71228-162">The exact tree used for property inheritance cannot be entirely anticipated by a helper class utility method, even at run time.</span></span> <span data-ttu-id="71228-163">有关详细信息，请参阅[属性值继承](property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="71228-163">For more information, see [Property Value Inheritance](property-value-inheritance.md).</span></span>  
  
<a name="two_trees"></a>   
## <a name="the-visual-tree"></a><span data-ttu-id="71228-164">可视化树</span><span class="sxs-lookup"><span data-stu-id="71228-164">The Visual Tree</span></span>  
 <span data-ttu-id="71228-165">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中除了逻辑树的概念，还存在可视化树的概念。</span><span class="sxs-lookup"><span data-stu-id="71228-165">In addition to the concept of the logical tree, there is also the concept of the visual tree in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span> <span data-ttu-id="71228-166">可视化树描述了可视化对象的结构，由 <xref:System.Windows.Media.Visual> 基类表示。</span><span class="sxs-lookup"><span data-stu-id="71228-166">The visual tree describes the structure of visual objects, as represented by the <xref:System.Windows.Media.Visual> base class.</span></span> <span data-ttu-id="71228-167">为控件编写模板时，将定义或重新定义适用于该控件的可视化树。</span><span class="sxs-lookup"><span data-stu-id="71228-167">When you write a template for a control, you are defining or redefining the visual tree that applies for that control.</span></span> <span data-ttu-id="71228-168">对于出于性能和优化考虑需要对绘图进行较低级别控制的开发人员来说，他们也会对可视化树感兴趣。</span><span class="sxs-lookup"><span data-stu-id="71228-168">The visual tree is also of interest to developers who want lower-level control over drawing for performance and optimization reasons.</span></span> <span data-ttu-id="71228-169">在传统 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 应用程序编程中，可视化树的一个应用是：路由事件的事件路由大多遍历可视化树而非逻辑树。</span><span class="sxs-lookup"><span data-stu-id="71228-169">One exposure of the visual tree as part of conventional [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application programming is that event routes for a routed event mostly travel along the visual tree, not the logical tree.</span></span> <span data-ttu-id="71228-170">路由事件行为的这种微妙之处可能不会很明显，除非你是控件作者。</span><span class="sxs-lookup"><span data-stu-id="71228-170">This subtlety of routed event behavior might not be immediately apparent unless you are a control author.</span></span> <span data-ttu-id="71228-171">通过可视化树对事件进行路由可使控件在可视化级别实现组合以处理事件或创建事件资源库。</span><span class="sxs-lookup"><span data-stu-id="71228-171">Routing events through the visual tree enables controls that implement composition at the visual level to handle events or create event setters.</span></span>  
  
<a name="trees_content"></a>   
## <a name="trees-content-elements-and-content-hosts"></a><span data-ttu-id="71228-172">树、内容元素和内容宿主</span><span class="sxs-lookup"><span data-stu-id="71228-172">Trees, Content Elements, and Content Hosts</span></span>  
 <span data-ttu-id="71228-173">内容元素（从 <xref:System.Windows.ContentElement>派生的类）不是可视化树的一部分;它们不从 <xref:System.Windows.Media.Visual> 继承，并且不具有可视表示形式。</span><span class="sxs-lookup"><span data-stu-id="71228-173">Content elements (classes that derive from <xref:System.Windows.ContentElement>) are not part of the visual tree; they do not inherit from <xref:System.Windows.Media.Visual> and do not have a visual representation.</span></span> <span data-ttu-id="71228-174">为了始终显示在 UI 中，必须在既是 <xref:System.Windows.Media.Visual> 又是逻辑树参与者的内容主机中承载 <xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="71228-174">In order to appear in a UI at all, a <xref:System.Windows.ContentElement> must be hosted in a content host that is both a <xref:System.Windows.Media.Visual> and a logical tree participant.</span></span> <span data-ttu-id="71228-175">通常，此类对象是 <xref:System.Windows.FrameworkElement>。</span><span class="sxs-lookup"><span data-stu-id="71228-175">Usually such an object is a <xref:System.Windows.FrameworkElement>.</span></span> <span data-ttu-id="71228-176">从概念上讲，内容宿主有些类似于内容的“浏览器”，它选择在该宿主控制的屏幕区域中显示内容的方式。</span><span class="sxs-lookup"><span data-stu-id="71228-176">You can conceptualize that the content host is somewhat like a "browser" for the content and chooses how to display that content within the screen region that the host controls.</span></span> <span data-ttu-id="71228-177">承载内容时，可以使内容成为通常与可视化树关联的某些树进程的参与者。</span><span class="sxs-lookup"><span data-stu-id="71228-177">When the content is hosted, the content can be made a participant in certain tree processes that are normally associated with the visual tree.</span></span> <span data-ttu-id="71228-178">通常，<xref:System.Windows.FrameworkElement> 主机类包括实现代码，该代码通过 content 逻辑树的子节点将任何承载的 <xref:System.Windows.ContentElement> 添加到事件路由，即使所承载的内容不是真正的可视化树的一部分。</span><span class="sxs-lookup"><span data-stu-id="71228-178">Generally, the <xref:System.Windows.FrameworkElement> host class includes implementation code that adds any hosted <xref:System.Windows.ContentElement> to the event route through subnodes of the content logical tree, even though the hosted content is not part of the true visual tree.</span></span> <span data-ttu-id="71228-179">这是必需的，以便 <xref:System.Windows.ContentElement> 可以将路由的路由事件作为路由，而不是其自身的任何元素。</span><span class="sxs-lookup"><span data-stu-id="71228-179">This is necessary so that a <xref:System.Windows.ContentElement> can source a routed event that routes to any element other than itself.</span></span>  
  
<a name="tree_traversal"></a>   
## <a name="tree-traversal"></a><span data-ttu-id="71228-180">树遍历</span><span class="sxs-lookup"><span data-stu-id="71228-180">Tree Traversal</span></span>  
 <span data-ttu-id="71228-181"><xref:System.Windows.LogicalTreeHelper> 类为逻辑树遍历提供 <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>、<xref:System.Windows.LogicalTreeHelper.GetParent%2A>和 <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="71228-181">The <xref:System.Windows.LogicalTreeHelper> class provides the <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>, <xref:System.Windows.LogicalTreeHelper.GetParent%2A>, and <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> methods for logical tree traversal.</span></span> <span data-ttu-id="71228-182">在大多数情况下，不需要遍历现有控件的逻辑树，因为这些控件几乎总是将其逻辑子元素公开为一个专用集合属性，这种属性支持集合访问，如 `Add`、索引器等等。</span><span class="sxs-lookup"><span data-stu-id="71228-182">In most cases, you should not have to traverse the logical tree of existing controls, because these controls almost always expose their logical child elements as a dedicated collection property that supports collection access such as `Add`, an indexer, and so on.</span></span> <span data-ttu-id="71228-183">树遍历主要是一种方案，控件作者可以选择不从预期的控件模式派生，如 <xref:System.Windows.Controls.ItemsControl> 或已定义集合属性的 <xref:System.Windows.Controls.Panel>，以及要提供自己的集合属性支持的用户。</span><span class="sxs-lookup"><span data-stu-id="71228-183">Tree traversal is mainly a scenario that is used by control authors who choose not to derive from intended control patterns such as <xref:System.Windows.Controls.ItemsControl> or <xref:System.Windows.Controls.Panel> where collection properties are already defined, and who intend to provide their own collection property support.</span></span>  
  
 <span data-ttu-id="71228-184">可视化树还支持 visual tree 遍历的帮助器类，<xref:System.Windows.Media.VisualTreeHelper>。</span><span class="sxs-lookup"><span data-stu-id="71228-184">The visual tree also supports a helper class for visual tree traversal, <xref:System.Windows.Media.VisualTreeHelper>.</span></span> <span data-ttu-id="71228-185">可视化树不会通过特定于控件的属性方便地公开，因此，如果您的编程方案需要，则建议使用 <xref:System.Windows.Media.VisualTreeHelper> 类来遍历可视化树。</span><span class="sxs-lookup"><span data-stu-id="71228-185">The visual tree is not exposed as conveniently through control-specific properties, so the <xref:System.Windows.Media.VisualTreeHelper> class is the recommended way to traverse the visual tree if that is necessary for your programming scenario.</span></span> <span data-ttu-id="71228-186">有关详细信息，请参阅 [WPF 图形呈现概述](../graphics-multimedia/wpf-graphics-rendering-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="71228-186">For more information, see [WPF Graphics Rendering Overview](../graphics-multimedia/wpf-graphics-rendering-overview.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="71228-187">有时有必要检查所应用模板的可视化树。</span><span class="sxs-lookup"><span data-stu-id="71228-187">Sometimes it is necessary to examine the visual tree of an applied template.</span></span> <span data-ttu-id="71228-188">执行此操作时应谨慎。</span><span class="sxs-lookup"><span data-stu-id="71228-188">You should be careful when using this technique.</span></span> <span data-ttu-id="71228-189">即使您正在遍历定义模板的控件的可视化树，控件的使用者也可以通过设置实例的 <xref:System.Windows.Controls.Control.Template%2A> 属性来更改模板，甚至最终用户也可以通过更改系统主题来影响应用的模板。</span><span class="sxs-lookup"><span data-stu-id="71228-189">Even if you are traversing a visual tree for a control where you define the template, consumers of your control can always change the template by setting the <xref:System.Windows.Controls.Control.Template%2A> property on instances, and even the end user can influence the applied template by changing the system theme.</span></span>  
  
<a name="routes"></a>   
## <a name="routes-for-routed-events-as-a-tree"></a><span data-ttu-id="71228-190">“树”形式路由事件的路由</span><span class="sxs-lookup"><span data-stu-id="71228-190">Routes for Routed Events as a "Tree"</span></span>  
 <span data-ttu-id="71228-191">如前所述，对于任何给定的路由事件，其路由都沿着一条预定的树路径进行，这棵树是可视化树和逻辑树表示形式的混合体。</span><span class="sxs-lookup"><span data-stu-id="71228-191">As mentioned before, the route of any given routed event travels along a single and predetermined path of a tree that is a hybrid of the visual and logical tree representations.</span></span> <span data-ttu-id="71228-192">事件路由可在树中向上或向下进行，具体取决于该事件是隧道路由事件还是浮升路由事件。</span><span class="sxs-lookup"><span data-stu-id="71228-192">The event route can travel either in the up or down directions within the tree depending on whether it is a tunneling or bubbling routed event.</span></span> <span data-ttu-id="71228-193">事件路由概念没有直接支持的帮助器类（此类可用于独立于引发实际路由的事件，遍历事件）。</span><span class="sxs-lookup"><span data-stu-id="71228-193">The event route concept does not have a directly supporting helper class that could be used to "walk" the event route independently of raising an event that actually routes.</span></span> <span data-ttu-id="71228-194">存在表示路由 <xref:System.Windows.EventRoute>的类，但该类的方法通常仅供内部使用。</span><span class="sxs-lookup"><span data-stu-id="71228-194">There is a class that represents the route, <xref:System.Windows.EventRoute>, but the methods of that class are generally for internal use only.</span></span>  
  
<a name="resourcesandtrees"></a>   
## <a name="resource-dictionaries-and-trees"></a><span data-ttu-id="71228-195">资源字典和树</span><span class="sxs-lookup"><span data-stu-id="71228-195">Resource Dictionaries and Trees</span></span>  
 <span data-ttu-id="71228-196">对页中定义的所有 `Resources` 进行资源字典查找时，基本上遍历逻辑树。</span><span class="sxs-lookup"><span data-stu-id="71228-196">Resource dictionary lookup for all `Resources` defined in a page traverses basically the logical tree.</span></span> <span data-ttu-id="71228-197">逻辑树之外的对象可以引用键控资源，但资源查找顺序将从该对象与逻辑树的连接点开始。</span><span class="sxs-lookup"><span data-stu-id="71228-197">Objects that are not in the logical tree can reference keyed resources, but the resource lookup sequence begins at the point where that object is connected to the logical tree.</span></span> <span data-ttu-id="71228-198">在 WPF 中，仅逻辑树节点可以具有包含 <xref:System.Windows.ResourceDictionary>的 `Resources` 属性，因此，从 <xref:System.Windows.ResourceDictionary>遍历查找键控资源的可视化树没有任何好处。</span><span class="sxs-lookup"><span data-stu-id="71228-198">In WPF, only logical tree nodes can have a `Resources` property that contains a <xref:System.Windows.ResourceDictionary>, therefore there is no benefit in traversing the visual tree looking for keyed resources from a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
 <span data-ttu-id="71228-199">但是，资源查找也可以超出直接逻辑树。</span><span class="sxs-lookup"><span data-stu-id="71228-199">However, resource lookup can also extend beyond the immediate logical tree.</span></span> <span data-ttu-id="71228-200">对于应用程序标记，资源查找可向前继续进行到应用程序级资源字典，然后再到作为静态属性或键进行引用的主题支持和系统值。</span><span class="sxs-lookup"><span data-stu-id="71228-200">For application markup, the resource lookup can then continue onward to application-level resource dictionaries and then to theme support and system values that are referenced as static properties or keys.</span></span> <span data-ttu-id="71228-201">如果资源引用是动态的，则主题本身也可以引用主题逻辑树之外的系统值。</span><span class="sxs-lookup"><span data-stu-id="71228-201">Themes themselves can also reference system values outside of the theme logical tree if the resource references are dynamic.</span></span> <span data-ttu-id="71228-202">有关资源字典和查找逻辑的详细信息，请参阅 [XAML 资源](../../../desktop-wpf/fundamentals/xaml-resources-define.md)。</span><span class="sxs-lookup"><span data-stu-id="71228-202">For more information on resource dictionaries and the lookup logic, see [XAML Resources](../../../desktop-wpf/fundamentals/xaml-resources-define.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="71228-203">另请参阅</span><span class="sxs-lookup"><span data-stu-id="71228-203">See also</span></span>

- [<span data-ttu-id="71228-204">输入概述</span><span class="sxs-lookup"><span data-stu-id="71228-204">Input Overview</span></span>](input-overview.md)
- [<span data-ttu-id="71228-205">WPF 图形呈现概述</span><span class="sxs-lookup"><span data-stu-id="71228-205">WPF Graphics Rendering Overview</span></span>](../graphics-multimedia/wpf-graphics-rendering-overview.md)
- [<span data-ttu-id="71228-206">路由事件概述</span><span class="sxs-lookup"><span data-stu-id="71228-206">Routed Events Overview</span></span>](routed-events-overview.md)
- [<span data-ttu-id="71228-207">不在对象树中的对象元素的初始化</span><span class="sxs-lookup"><span data-stu-id="71228-207">Initialization for Object Elements Not in an Object Tree</span></span>](initialization-for-object-elements-not-in-an-object-tree.md)
- [<span data-ttu-id="71228-208">WPF 体系结构</span><span class="sxs-lookup"><span data-stu-id="71228-208">WPF Architecture</span></span>](wpf-architecture.md)
