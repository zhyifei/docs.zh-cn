---
title: WPF 图形呈现疑难解答
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- graphics [WPF], rendering
- rendering graphics [WPF]
ms.assetid: 6dec9657-4d8c-4e46-8c54-40fb80008265
ms.openlocfilehash: a0400ce32dc6dab2585a8d5e76ff8d416fae24c8
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/08/2019
ms.locfileid: "59101362"
---
# <a name="wpf-graphics-rendering-overview"></a><span data-ttu-id="fef9c-102">WPF 图形呈现疑难解答</span><span class="sxs-lookup"><span data-stu-id="fef9c-102">WPF Graphics Rendering Overview</span></span>
<span data-ttu-id="fef9c-103">本主题概述 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 可视化层。</span><span class="sxs-lookup"><span data-stu-id="fef9c-103">This topic provides an overview of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] visual layer.</span></span> <span data-ttu-id="fef9c-104">它主要关注的角色<xref:System.Windows.Media.Visual>类中呈现支持[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]模型。</span><span class="sxs-lookup"><span data-stu-id="fef9c-104">It focuses on the role of the <xref:System.Windows.Media.Visual> class for rendering support in the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] model.</span></span>  

<a name="role_of_visual_object"></a>   
## <a name="role-of-the-visual-object"></a><span data-ttu-id="fef9c-105">视觉对象的角色</span><span class="sxs-lookup"><span data-stu-id="fef9c-105">Role of the Visual Object</span></span>  
 <span data-ttu-id="fef9c-106"><xref:System.Windows.Media.Visual>类是从其的基本抽象每个<xref:System.Windows.FrameworkElement>对象派生。</span><span class="sxs-lookup"><span data-stu-id="fef9c-106">The <xref:System.Windows.Media.Visual> class is the basic abstraction from which every <xref:System.Windows.FrameworkElement> object derives.</span></span> <span data-ttu-id="fef9c-107">该类还用作在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中编写新控件的入口点，在 Win32 应用程序模型中，该类在许多方面可视为窗口句柄 (HWND)。</span><span class="sxs-lookup"><span data-stu-id="fef9c-107">It also serves as the entry point for writing new controls in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], and in many ways can be thought of as the window handle (HWND) in the Win32 application model.</span></span>  
  
 <span data-ttu-id="fef9c-108"><xref:System.Windows.Media.Visual>对象是一项核心[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]对象，它的主要角色是提供呈现支持。</span><span class="sxs-lookup"><span data-stu-id="fef9c-108">The <xref:System.Windows.Media.Visual> object is a core [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] object, whose primary role is to provide rendering support.</span></span> <span data-ttu-id="fef9c-109">用户界面控件，如<xref:System.Windows.Controls.Button>并<xref:System.Windows.Controls.TextBox>，派生自<xref:System.Windows.Media.Visual>类，并使用该类来保持其呈现数据。</span><span class="sxs-lookup"><span data-stu-id="fef9c-109">User interface controls, such as <xref:System.Windows.Controls.Button> and <xref:System.Windows.Controls.TextBox>, derive from the <xref:System.Windows.Media.Visual> class, and use it for persisting their rendering data.</span></span> <span data-ttu-id="fef9c-110"><xref:System.Windows.Media.Visual>对象提供支持：</span><span class="sxs-lookup"><span data-stu-id="fef9c-110">The <xref:System.Windows.Media.Visual> object provides support for:</span></span>  
  
-   <span data-ttu-id="fef9c-111">输出显示：呈现的持久、 序列化的视觉对象的绘图内容。</span><span class="sxs-lookup"><span data-stu-id="fef9c-111">Output display: Rendering the persisted, serialized drawing content of a visual.</span></span>  
  
-   <span data-ttu-id="fef9c-112">转换：视觉对象上执行转换。</span><span class="sxs-lookup"><span data-stu-id="fef9c-112">Transformations: Performing transformations on a visual.</span></span>  
  
-   <span data-ttu-id="fef9c-113">剪裁：为视觉对象提供剪裁区域支持。</span><span class="sxs-lookup"><span data-stu-id="fef9c-113">Clipping: Providing clipping region support for a visual.</span></span>  
  
-   <span data-ttu-id="fef9c-114">命中测试：确定是否在视觉对象的边界内包含坐标或几何形状。</span><span class="sxs-lookup"><span data-stu-id="fef9c-114">Hit testing: Determining whether a coordinate or geometry is contained within the bounds of a visual.</span></span>  
  
-   <span data-ttu-id="fef9c-115">边界框计算：确定视觉对象的边框。</span><span class="sxs-lookup"><span data-stu-id="fef9c-115">Bounding box calculations: Determining the bounding rectangle of a visual.</span></span>  
  
 <span data-ttu-id="fef9c-116">但是，<xref:System.Windows.Media.Visual>如对象不包含对非呈现功能的支持：</span><span class="sxs-lookup"><span data-stu-id="fef9c-116">However, the <xref:System.Windows.Media.Visual> object does not include support for non-rendering features, such as:</span></span>  
  
-   <span data-ttu-id="fef9c-117">事件处理</span><span class="sxs-lookup"><span data-stu-id="fef9c-117">Event handling</span></span>  
  
-   <span data-ttu-id="fef9c-118">布局</span><span class="sxs-lookup"><span data-stu-id="fef9c-118">Layout</span></span>  
  
-   <span data-ttu-id="fef9c-119">样式</span><span class="sxs-lookup"><span data-stu-id="fef9c-119">Styles</span></span>  
  
-   <span data-ttu-id="fef9c-120">数据绑定</span><span class="sxs-lookup"><span data-stu-id="fef9c-120">Data binding</span></span>  
  
-   <span data-ttu-id="fef9c-121">全球化</span><span class="sxs-lookup"><span data-stu-id="fef9c-121">Globalization</span></span>  
  
 <xref:System.Windows.Media.Visual> <span data-ttu-id="fef9c-122">公开为公共抽象类必须从中派生子类。</span><span class="sxs-lookup"><span data-stu-id="fef9c-122">is exposed as a public abstract class from which child classes must be derived.</span></span> <span data-ttu-id="fef9c-123">下图显示了 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中所公开的视觉对象的层次结构。</span><span class="sxs-lookup"><span data-stu-id="fef9c-123">The following illustration shows the hierarchy of the visual objects that are exposed in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>  
  
 ![从 Visual 对象派生的类的示意图](./media/wpf-graphics-rendering-overview/classes-derived-visual-object.png)    
  
### <a name="drawingvisual-class"></a><span data-ttu-id="fef9c-125">DrawingVisual 类</span><span class="sxs-lookup"><span data-stu-id="fef9c-125">DrawingVisual Class</span></span>  
 <span data-ttu-id="fef9c-126"><xref:System.Windows.Media.DrawingVisual>是一个轻量绘图类，用于呈现形状、 图像或文本。</span><span class="sxs-lookup"><span data-stu-id="fef9c-126">The <xref:System.Windows.Media.DrawingVisual> is a lightweight drawing class that is used to render shapes, images, or text.</span></span> <span data-ttu-id="fef9c-127">此类之所以为轻量类是因为它不提供布局或事件处理，从而提升其运行时性能。</span><span class="sxs-lookup"><span data-stu-id="fef9c-127">This class is considered lightweight because it does not provide layout or event handling, which improves its runtime performance.</span></span> <span data-ttu-id="fef9c-128">因此，绘图非常适用于背景和剪贴画。</span><span class="sxs-lookup"><span data-stu-id="fef9c-128">For this reason, drawings are ideal for backgrounds and clip art.</span></span> <span data-ttu-id="fef9c-129"><xref:System.Windows.Media.DrawingVisual>可用于创建自定义视觉对象。</span><span class="sxs-lookup"><span data-stu-id="fef9c-129">The <xref:System.Windows.Media.DrawingVisual> can be used to create a custom visual object.</span></span> <span data-ttu-id="fef9c-130">有关详细信息，请参阅[使用 DrawingVisual 对象](using-drawingvisual-objects.md)。</span><span class="sxs-lookup"><span data-stu-id="fef9c-130">For more information, see [Using DrawingVisual Objects](using-drawingvisual-objects.md).</span></span>  
  
### <a name="viewport3dvisual-class"></a><span data-ttu-id="fef9c-131">Viewport3DVisual 类</span><span class="sxs-lookup"><span data-stu-id="fef9c-131">Viewport3DVisual Class</span></span>  
 <span data-ttu-id="fef9c-132"><xref:System.Windows.Media.Media3D.Viewport3DVisual> 2D 之间的桥梁<xref:System.Windows.Media.Visual>和<xref:System.Windows.Media.Media3D.Visual3D>对象。</span><span class="sxs-lookup"><span data-stu-id="fef9c-132">The <xref:System.Windows.Media.Media3D.Viewport3DVisual> provides a bridge between 2D <xref:System.Windows.Media.Visual> and <xref:System.Windows.Media.Media3D.Visual3D> objects.</span></span> <span data-ttu-id="fef9c-133"><xref:System.Windows.Media.Media3D.Visual3D>类是所有 3D 可视化元素的基类。</span><span class="sxs-lookup"><span data-stu-id="fef9c-133">The <xref:System.Windows.Media.Media3D.Visual3D> class is the base class for all 3D visual elements.</span></span> <span data-ttu-id="fef9c-134"><xref:System.Windows.Media.Media3D.Viewport3DVisual>要求您定义<xref:System.Windows.Media.Media3D.Viewport3DVisual.Camera%2A>值和一个<xref:System.Windows.Media.Media3D.Viewport3DVisual.Viewport%2A>值。</span><span class="sxs-lookup"><span data-stu-id="fef9c-134">The <xref:System.Windows.Media.Media3D.Viewport3DVisual> requires that you define a <xref:System.Windows.Media.Media3D.Viewport3DVisual.Camera%2A> value and a <xref:System.Windows.Media.Media3D.Viewport3DVisual.Viewport%2A> value.</span></span> <span data-ttu-id="fef9c-135">借助照相机，可以查看场景。</span><span class="sxs-lookup"><span data-stu-id="fef9c-135">The camera allows you to view the scene.</span></span> <span data-ttu-id="fef9c-136">视区确定投影映射到 2D 图面的位置。</span><span class="sxs-lookup"><span data-stu-id="fef9c-136">The viewport establishes where the projection maps onto the 2D surface.</span></span> <span data-ttu-id="fef9c-137">有关 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中 3D 的详细信息，请参阅 [3-D 图形概述](3-d-graphics-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="fef9c-137">For more information on 3D in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], see [3-D Graphics Overview](3-d-graphics-overview.md).</span></span>  
  
### <a name="containervisual-class"></a><span data-ttu-id="fef9c-138">ContainerVisual 类</span><span class="sxs-lookup"><span data-stu-id="fef9c-138">ContainerVisual Class</span></span>  
 <span data-ttu-id="fef9c-139"><xref:System.Windows.Media.ContainerVisual>类用作一系列的容器<xref:System.Windows.Media.Visual>对象。</span><span class="sxs-lookup"><span data-stu-id="fef9c-139">The <xref:System.Windows.Media.ContainerVisual> class is used as a container for a collection of <xref:System.Windows.Media.Visual> objects.</span></span> <span data-ttu-id="fef9c-140"><xref:System.Windows.Media.DrawingVisual>类派生自<xref:System.Windows.Media.ContainerVisual>类，使其能够包含视觉对象的集合。</span><span class="sxs-lookup"><span data-stu-id="fef9c-140">The <xref:System.Windows.Media.DrawingVisual> class derives from the <xref:System.Windows.Media.ContainerVisual> class, allowing it to contain a collection of visual objects.</span></span>  
  
### <a name="drawing-content-in-visual-objects"></a><span data-ttu-id="fef9c-141">视觉对象中的绘图内容</span><span class="sxs-lookup"><span data-stu-id="fef9c-141">Drawing Content in Visual Objects</span></span>  
 <span data-ttu-id="fef9c-142">一个<xref:System.Windows.Media.Visual>对象将存储其呈现数据作为**矢量图形指令列表**。</span><span class="sxs-lookup"><span data-stu-id="fef9c-142">A <xref:System.Windows.Media.Visual> object stores its render data as a **vector graphics instruction list**.</span></span> <span data-ttu-id="fef9c-143">指令列表中的每一项都以序列化格式表示一组低级别的图形数据及其相关资源。</span><span class="sxs-lookup"><span data-stu-id="fef9c-143">Each item in the instruction list represents a low-level set of graphics data and associated resources in a serialized format.</span></span> <span data-ttu-id="fef9c-144">共有四种不同类型的呈现数据可以包含绘图内容。</span><span class="sxs-lookup"><span data-stu-id="fef9c-144">There are four different types of render data that can contain drawing content.</span></span>  
  
|<span data-ttu-id="fef9c-145">绘图内容类型</span><span class="sxs-lookup"><span data-stu-id="fef9c-145">Drawing content type</span></span>|<span data-ttu-id="fef9c-146">描述</span><span class="sxs-lookup"><span data-stu-id="fef9c-146">Description</span></span>|  
|--------------------------|-----------------|  
|<span data-ttu-id="fef9c-147">矢量图形</span><span class="sxs-lookup"><span data-stu-id="fef9c-147">Vector graphics</span></span>|<span data-ttu-id="fef9c-148">表示矢量图形数据以及任何相关联<xref:System.Windows.Media.Brush>和<xref:System.Windows.Media.Pen>信息。</span><span class="sxs-lookup"><span data-stu-id="fef9c-148">Represents vector graphics data, and any associated <xref:System.Windows.Media.Brush> and <xref:System.Windows.Media.Pen> information.</span></span>|  
|<span data-ttu-id="fef9c-149">图像</span><span class="sxs-lookup"><span data-stu-id="fef9c-149">Image</span></span>|<span data-ttu-id="fef9c-150">表示所定义区域内的图像<xref:System.Windows.Rect>。</span><span class="sxs-lookup"><span data-stu-id="fef9c-150">Represents an image within a region defined by a <xref:System.Windows.Rect>.</span></span>|  
|<span data-ttu-id="fef9c-151">标志符号</span><span class="sxs-lookup"><span data-stu-id="fef9c-151">Glyph</span></span>|<span data-ttu-id="fef9c-152">表示呈现绘图<xref:System.Windows.Media.GlyphRun>，这是一系列字形从指定的字体资源。</span><span class="sxs-lookup"><span data-stu-id="fef9c-152">Represents a drawing that renders a <xref:System.Windows.Media.GlyphRun>, which is a sequence of glyphs from a specified font resource.</span></span> <span data-ttu-id="fef9c-153">这是文本的表示方式。</span><span class="sxs-lookup"><span data-stu-id="fef9c-153">This is how text is represented.</span></span>|  
|<span data-ttu-id="fef9c-154">视频</span><span class="sxs-lookup"><span data-stu-id="fef9c-154">Video</span></span>|<span data-ttu-id="fef9c-155">表示用于呈现视频的绘图。</span><span class="sxs-lookup"><span data-stu-id="fef9c-155">Represents a drawing that renders video.</span></span>|  
  
 <span data-ttu-id="fef9c-156"><xref:System.Windows.Media.DrawingContext> ，可填充<xref:System.Windows.Media.Visual>可视化内容。</span><span class="sxs-lookup"><span data-stu-id="fef9c-156">The <xref:System.Windows.Media.DrawingContext> allows you to populate a <xref:System.Windows.Media.Visual> with visual content.</span></span> <span data-ttu-id="fef9c-157">当你使用<xref:System.Windows.Media.DrawingContext>对象的绘图命令时，实际上存储一组更高版本将由图形系统使用的呈现数据; 您不绘制到屏幕上实时。</span><span class="sxs-lookup"><span data-stu-id="fef9c-157">When you use a <xref:System.Windows.Media.DrawingContext> object's draw commands, you are actually storing a set of render data that will later be used by the graphics system; you are not drawing to the screen in real-time.</span></span>  
  
 <span data-ttu-id="fef9c-158">当您创建[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]控件，如<xref:System.Windows.Controls.Button>，控件隐式生成呈现数据为绘图本身。</span><span class="sxs-lookup"><span data-stu-id="fef9c-158">When you create a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control, such as a <xref:System.Windows.Controls.Button>, the control implicitly generates render data for drawing itself.</span></span> <span data-ttu-id="fef9c-159">例如，设置<xref:System.Windows.Controls.ContentControl.Content%2A>属性的<xref:System.Windows.Controls.Button>会导致该控件存储字形的呈现表示形式。</span><span class="sxs-lookup"><span data-stu-id="fef9c-159">For example, setting the <xref:System.Windows.Controls.ContentControl.Content%2A> property of the <xref:System.Windows.Controls.Button> causes the control to store a rendering representation of a glyph.</span></span>  
  
 <span data-ttu-id="fef9c-160">一个<xref:System.Windows.Media.Visual>其内容描述为一个或多个<xref:System.Windows.Media.Drawing>中包含的对象<xref:System.Windows.Media.DrawingGroup>。</span><span class="sxs-lookup"><span data-stu-id="fef9c-160">A <xref:System.Windows.Media.Visual> describes its content as one or more <xref:System.Windows.Media.Drawing> objects contained within a <xref:System.Windows.Media.DrawingGroup>.</span></span> <span data-ttu-id="fef9c-161">一个<xref:System.Windows.Media.DrawingGroup>还介绍了不透明蒙板、 转换、 位图效果和其他应用于其内容的操作。</span><span class="sxs-lookup"><span data-stu-id="fef9c-161">A <xref:System.Windows.Media.DrawingGroup> also describes opacity masks, transforms, bitmap effects, and other operations that are applied to its contents.</span></span> <xref:System.Windows.Media.DrawingGroup> <span data-ttu-id="fef9c-162">呈现内容时，操作将按以下顺序应用： <xref:System.Windows.Media.DrawingGroup.OpacityMask%2A>， <xref:System.Windows.Media.DrawingGroup.Opacity%2A>， <xref:System.Windows.Media.DrawingGroup.BitmapEffect%2A>， <xref:System.Windows.Media.DrawingGroup.ClipGeometry%2A>， <xref:System.Windows.Media.DrawingGroup.GuidelineSet%2A>，，然后<xref:System.Windows.Media.DrawingGroup.Transform%2A>。</span><span class="sxs-lookup"><span data-stu-id="fef9c-162">operations are applied in the following order when content is rendered: <xref:System.Windows.Media.DrawingGroup.OpacityMask%2A>, <xref:System.Windows.Media.DrawingGroup.Opacity%2A>, <xref:System.Windows.Media.DrawingGroup.BitmapEffect%2A>, <xref:System.Windows.Media.DrawingGroup.ClipGeometry%2A>, <xref:System.Windows.Media.DrawingGroup.GuidelineSet%2A>, and then <xref:System.Windows.Media.DrawingGroup.Transform%2A>.</span></span>  
  
 <span data-ttu-id="fef9c-163">下图中的显示顺序<xref:System.Windows.Media.DrawingGroup>呈现序列期间应用操作。</span><span class="sxs-lookup"><span data-stu-id="fef9c-163">The following illustration shows the order in which <xref:System.Windows.Media.DrawingGroup> operations are applied during the rendering sequence.</span></span>  
  
 <span data-ttu-id="fef9c-164">![DrawingGroup 操作顺序](./media/graphcismm-drawinggroup-order.png "graphcismm_drawinggroup_order")</span><span class="sxs-lookup"><span data-stu-id="fef9c-164">![DrawingGroup order of operations](./media/graphcismm-drawinggroup-order.png "graphcismm_drawinggroup_order")</span></span>  
<span data-ttu-id="fef9c-165">DrawingGroup 操作的顺序</span><span class="sxs-lookup"><span data-stu-id="fef9c-165">Order of DrawingGroup operations</span></span>  
  
 <span data-ttu-id="fef9c-166">有关详细信息，请参阅 [Drawing 对象概述](drawing-objects-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="fef9c-166">For more information, see [Drawing Objects Overview](drawing-objects-overview.md).</span></span>  
  
#### <a name="drawing-content-at-the-visual-layer"></a><span data-ttu-id="fef9c-167">可视化层中的绘图内容</span><span class="sxs-lookup"><span data-stu-id="fef9c-167">Drawing Content at the Visual Layer</span></span>  
 <span data-ttu-id="fef9c-168">您永远不会直接实例化<xref:System.Windows.Media.DrawingContext>; 但是，可以获取绘图上下文通过某些方法，如<xref:System.Windows.Media.DrawingGroup.Open%2A?displayProperty=nameWithType>和<xref:System.Windows.Media.DrawingVisual.RenderOpen%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="fef9c-168">You never directly instantiate a <xref:System.Windows.Media.DrawingContext>; you can, however, acquire a drawing context from certain methods, such as <xref:System.Windows.Media.DrawingGroup.Open%2A?displayProperty=nameWithType> and <xref:System.Windows.Media.DrawingVisual.RenderOpen%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="fef9c-169">下面的示例检索<xref:System.Windows.Media.DrawingContext>从<xref:System.Windows.Media.DrawingVisual>并使用它来绘制一个矩形。</span><span class="sxs-lookup"><span data-stu-id="fef9c-169">The following example retrieves a <xref:System.Windows.Media.DrawingContext> from a <xref:System.Windows.Media.DrawingVisual> and uses it to draw a rectangle.</span></span>  
  
 [!code-csharp[drawingvisualsample#101](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingVisualSample/CSharp/Window1.xaml.cs#101)]
 [!code-vb[drawingvisualsample#101](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingVisualSample/visualbasic/window1.xaml.vb#101)]  
  
#### <a name="enumerating-drawing-content-at-the-visual-layer"></a><span data-ttu-id="fef9c-170">在可视化层中枚举绘图内容</span><span class="sxs-lookup"><span data-stu-id="fef9c-170">Enumerating Drawing Content at the Visual Layer</span></span>  
 <span data-ttu-id="fef9c-171">除了其其他用途，请<xref:System.Windows.Media.Drawing>对象还提供用于枚举的内容的对象模型<xref:System.Windows.Media.Visual>。</span><span class="sxs-lookup"><span data-stu-id="fef9c-171">In addition to their other uses, <xref:System.Windows.Media.Drawing> objects also provide an object model for enumerating the contents of a <xref:System.Windows.Media.Visual>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fef9c-172">当枚举视觉对象的内容时，就在检索<xref:System.Windows.Media.Drawing>对象和表示形式呈现数据作为矢量图形指令列表不基础。</span><span class="sxs-lookup"><span data-stu-id="fef9c-172">When you are enumerating the contents of the visual, you are retrieving <xref:System.Windows.Media.Drawing> objects, and not the underlying representation of the render data as a vector graphics instruction list.</span></span>  
  
 <span data-ttu-id="fef9c-173">下面的示例使用<xref:System.Windows.Media.VisualTreeHelper.GetDrawing%2A>方法来检索<xref:System.Windows.Media.DrawingGroup>的值<xref:System.Windows.Media.Visual>并枚举该值。</span><span class="sxs-lookup"><span data-stu-id="fef9c-173">The following example uses the <xref:System.Windows.Media.VisualTreeHelper.GetDrawing%2A> method to retrieve the <xref:System.Windows.Media.DrawingGroup> value of a <xref:System.Windows.Media.Visual> and enumerate it.</span></span>  
  
 [!code-csharp[DrawingMiscSnippets_snip#GraphicsMMRetrieveDrawings](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingMiscSnippets_snip/CSharp/EnumerateDrawingsExample.xaml.cs#graphicsmmretrievedrawings)]  
  
<a name="how_visual_objects_are_used_to_build_controls"></a>   
## <a name="how-visual-objects-are-used-to-build-controls"></a><span data-ttu-id="fef9c-174">如何使用视觉对象来生成控件</span><span class="sxs-lookup"><span data-stu-id="fef9c-174">How Visual Objects are Used to Build Controls</span></span>  
 <span data-ttu-id="fef9c-175">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中的许多对象都由其他视觉对象组成，这意味着它们可以包含子代对象的各种层次结构。</span><span class="sxs-lookup"><span data-stu-id="fef9c-175">Many of the objects in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] are composed of other visual objects, meaning they can contain varying hierarchies of descendant objects.</span></span> <span data-ttu-id="fef9c-176">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中的许多用户界面元素（如控件）都由多个表示不同类型呈现元素的视觉对象组成。</span><span class="sxs-lookup"><span data-stu-id="fef9c-176">Many of the user interface elements in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], such as controls, are composed of multiple visual objects, representing different types of rendering elements.</span></span> <span data-ttu-id="fef9c-177">例如，<xref:System.Windows.Controls.Button>控件可以包含其他对象，其中包括许多<xref:Microsoft.Windows.Themes.ClassicBorderDecorator>， <xref:System.Windows.Controls.ContentPresenter>，和<xref:System.Windows.Controls.TextBlock>。</span><span class="sxs-lookup"><span data-stu-id="fef9c-177">For example, the <xref:System.Windows.Controls.Button> control can contain a number of other objects, including <xref:Microsoft.Windows.Themes.ClassicBorderDecorator>, <xref:System.Windows.Controls.ContentPresenter>, and <xref:System.Windows.Controls.TextBlock>.</span></span>  
  
 <span data-ttu-id="fef9c-178">下面的代码演示<xref:System.Windows.Controls.Button>在标记中定义的控件。</span><span class="sxs-lookup"><span data-stu-id="fef9c-178">The following code shows a <xref:System.Windows.Controls.Button> control defined in markup.</span></span>  
  
 [!code-xaml[VisualsOverview#VisualsOverviewSnippet1](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualsOverview/CSharp/Window1.xaml#visualsoverviewsnippet1)]  
  
 <span data-ttu-id="fef9c-179">如果你打算枚举包含默认值的视觉对象<xref:System.Windows.Controls.Button>控件，您将看到如下图所示的视觉对象的层次结构：</span><span class="sxs-lookup"><span data-stu-id="fef9c-179">If you were to enumerate the visual objects that comprise the default <xref:System.Windows.Controls.Button> control, you would find the hierarchy of visual objects illustrated below:</span></span>  
  
 ![可视化树层次结构示意图](./media/wpf-graphics-rendering-overview/visual-object-diagram.gif) 
  
 <span data-ttu-id="fef9c-181"><xref:System.Windows.Controls.Button>控件包含<xref:Microsoft.Windows.Themes.ClassicBorderDecorator>元素，它又包含<xref:System.Windows.Controls.ContentPresenter>元素。</span><span class="sxs-lookup"><span data-stu-id="fef9c-181">The <xref:System.Windows.Controls.Button> control contains a <xref:Microsoft.Windows.Themes.ClassicBorderDecorator> element, which in turn, contains a <xref:System.Windows.Controls.ContentPresenter> element.</span></span> <span data-ttu-id="fef9c-182"><xref:Microsoft.Windows.Themes.ClassicBorderDecorator>元素负责绘制边框和背景的<xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="fef9c-182">The <xref:Microsoft.Windows.Themes.ClassicBorderDecorator> element is responsible for drawing a border and a background for the <xref:System.Windows.Controls.Button>.</span></span> <span data-ttu-id="fef9c-183"><xref:System.Windows.Controls.ContentPresenter>元素负责显示的内容<xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="fef9c-183">The <xref:System.Windows.Controls.ContentPresenter> element is responsible for displaying the contents of the <xref:System.Windows.Controls.Button>.</span></span> <span data-ttu-id="fef9c-184">在这种情况下，由于您要显示的文本，<xref:System.Windows.Controls.ContentPresenter>元素包含<xref:System.Windows.Controls.TextBlock>元素。</span><span class="sxs-lookup"><span data-stu-id="fef9c-184">In this case, since you are displaying text, the <xref:System.Windows.Controls.ContentPresenter> element contains a <xref:System.Windows.Controls.TextBlock> element.</span></span> <span data-ttu-id="fef9c-185">这一事实，<xref:System.Windows.Controls.Button>控件使用<xref:System.Windows.Controls.ContentPresenter>意味着无法通过其他元素，如表示内容<xref:System.Windows.Controls.Image>或几何形状，如<xref:System.Windows.Media.EllipseGeometry>。</span><span class="sxs-lookup"><span data-stu-id="fef9c-185">The fact that the <xref:System.Windows.Controls.Button> control uses a <xref:System.Windows.Controls.ContentPresenter> means that the content could be represented by other elements, such as an <xref:System.Windows.Controls.Image> or a geometry, such as an <xref:System.Windows.Media.EllipseGeometry>.</span></span>  
  
### <a name="control-templates"></a><span data-ttu-id="fef9c-186">控件模板</span><span class="sxs-lookup"><span data-stu-id="fef9c-186">Control Templates</span></span>  
 <span data-ttu-id="fef9c-187">为控件的层次结构扩展为控件的关键是<xref:System.Windows.Controls.ControlTemplate>。</span><span class="sxs-lookup"><span data-stu-id="fef9c-187">The key to the expansion of a control into a hierarchy of controls is the <xref:System.Windows.Controls.ControlTemplate>.</span></span> <span data-ttu-id="fef9c-188">控件模板为控件指定了默认的可视化层次结构。</span><span class="sxs-lookup"><span data-stu-id="fef9c-188">A control template specifies the default visual hierarchy for a control.</span></span> <span data-ttu-id="fef9c-189">显式引用某个控件时，会隐式引用它的可视化层次结构。</span><span class="sxs-lookup"><span data-stu-id="fef9c-189">When you explicitly reference a control, you implicitly reference its visual hierarchy.</span></span> <span data-ttu-id="fef9c-190">可以重写控件模板的默认值，以便为控件创建自定义的可视化外观。</span><span class="sxs-lookup"><span data-stu-id="fef9c-190">You can override the default values for a control template to create a customized visual appearance for a control.</span></span> <span data-ttu-id="fef9c-191">例如，可以修改的背景颜色值<xref:System.Windows.Controls.Button>控件，以便它而不是使用纯色值使用线性渐变颜色值。</span><span class="sxs-lookup"><span data-stu-id="fef9c-191">For example, you could modify the background color value of the <xref:System.Windows.Controls.Button> control so that it uses a linear gradient color value instead of a solid color value.</span></span> <span data-ttu-id="fef9c-192">有关详细信息，请参阅[按钮样式和模板](../controls/button-styles-and-templates.md)。</span><span class="sxs-lookup"><span data-stu-id="fef9c-192">For more information, see [Button Styles and Templates](../controls/button-styles-and-templates.md).</span></span>  
  
 <span data-ttu-id="fef9c-193">用户界面元素，如<xref:System.Windows.Controls.Button>控件，包含描述控件的全部呈现定义的多个矢量图形指令列表。</span><span class="sxs-lookup"><span data-stu-id="fef9c-193">A user interface element, such as a <xref:System.Windows.Controls.Button> control, contains several vector graphics instruction lists that describe the entire rendering definition of a control.</span></span> <span data-ttu-id="fef9c-194">下面的代码演示<xref:System.Windows.Controls.Button>在标记中定义的控件。</span><span class="sxs-lookup"><span data-stu-id="fef9c-194">The following code shows a <xref:System.Windows.Controls.Button> control defined in markup.</span></span>  
  
 [!code-xaml[VisualsOverview#VisualsOverviewSnippet2](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualsOverview/CSharp/Window1.xaml#visualsoverviewsnippet2)]  
  
 <span data-ttu-id="fef9c-195">如果要枚举的视觉对象和矢量图形指令列表的构成<xref:System.Windows.Controls.Button>控件，您将看到如下所示对象的层次结构：</span><span class="sxs-lookup"><span data-stu-id="fef9c-195">If you were to enumerate the visual objects and vector graphics instruction lists that comprise the <xref:System.Windows.Controls.Button> control, you would find the hierarchy of objects illustrated below:</span></span>  
  
 ![可视化树和呈现数据示意图](./media/wpf-graphics-rendering-overview/visual-tree-rendering-data.png)  
  
 <span data-ttu-id="fef9c-197"><xref:System.Windows.Controls.Button>控件包含<xref:Microsoft.Windows.Themes.ClassicBorderDecorator>元素，它又包含<xref:System.Windows.Controls.ContentPresenter>元素。</span><span class="sxs-lookup"><span data-stu-id="fef9c-197">The <xref:System.Windows.Controls.Button> control contains a <xref:Microsoft.Windows.Themes.ClassicBorderDecorator> element, which in turn, contains a <xref:System.Windows.Controls.ContentPresenter> element.</span></span> <span data-ttu-id="fef9c-198"><xref:Microsoft.Windows.Themes.ClassicBorderDecorator>元素负责绘制所有离散图形元素的边框和背景的按钮构成。</span><span class="sxs-lookup"><span data-stu-id="fef9c-198">The <xref:Microsoft.Windows.Themes.ClassicBorderDecorator> element is responsible for drawing all the discrete graphic elements that make up the border and background of a button.</span></span> <span data-ttu-id="fef9c-199"><xref:System.Windows.Controls.ContentPresenter>元素负责显示的内容<xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="fef9c-199">The <xref:System.Windows.Controls.ContentPresenter> element is responsible for displaying the contents of the <xref:System.Windows.Controls.Button>.</span></span> <span data-ttu-id="fef9c-200">在这种情况下，由于您要显示图像，<xref:System.Windows.Controls.ContentPresenter>元素包含<xref:System.Windows.Controls.Image>元素。</span><span class="sxs-lookup"><span data-stu-id="fef9c-200">In this case, since you are displaying an image, the <xref:System.Windows.Controls.ContentPresenter> element contains a <xref:System.Windows.Controls.Image> element.</span></span>  
  
 <span data-ttu-id="fef9c-201">对于视觉对象和矢量图形指令列表的层次结构，需要注意多个事项：</span><span class="sxs-lookup"><span data-stu-id="fef9c-201">There are a number of points to note about the hierarchy of visual objects and vector graphics instruction lists:</span></span>  
  
-   <span data-ttu-id="fef9c-202">该层次结构中的排序表示绘图信息的呈现顺序。</span><span class="sxs-lookup"><span data-stu-id="fef9c-202">The ordering in the hierarchy represents the rendering order of the drawing information.</span></span> <span data-ttu-id="fef9c-203">从可视化元素的根，按照从左到右、从上到下的顺序遍历子元素。</span><span class="sxs-lookup"><span data-stu-id="fef9c-203">From the root visual element, child elements are traversed, left to right, top to bottom.</span></span> <span data-ttu-id="fef9c-204">如果某个元素有可视化子元素，则会先遍历该元素的子元素，然后再遍历该元素的同级。</span><span class="sxs-lookup"><span data-stu-id="fef9c-204">If an element has visual child elements, they are traversed before the element’s siblings.</span></span>  
  
-   <span data-ttu-id="fef9c-205">非叶节点元素中层次结构，如<xref:System.Windows.Controls.ContentPresenter>，用于包含子元素，它们不包含指令列表。</span><span class="sxs-lookup"><span data-stu-id="fef9c-205">Non-leaf node elements in the hierarchy, such as <xref:System.Windows.Controls.ContentPresenter>, are used to contain child elements—they do not contain instruction lists.</span></span>  
  
-   <span data-ttu-id="fef9c-206">如果可视化元素既包含矢量图形指令列表又包含可视化子级，则会先呈现父级可视化元素中的指令列表，然后再呈现任何可视化子对象中的绘图。</span><span class="sxs-lookup"><span data-stu-id="fef9c-206">If a visual element contains both a vector graphics instruction list and visual children, the instruction list in the parent visual element is rendered before drawings in any of the visual child objects.</span></span>  
  
-   <span data-ttu-id="fef9c-207">矢量图形指令列表中的项按照从左到右的顺序呈现。</span><span class="sxs-lookup"><span data-stu-id="fef9c-207">The items in the vector graphics instruction list are rendered left to right.</span></span>  
  
<a name="visual_tree"></a>   
## <a name="visual-tree"></a><span data-ttu-id="fef9c-208">可视化树</span><span class="sxs-lookup"><span data-stu-id="fef9c-208">Visual Tree</span></span>  
 <span data-ttu-id="fef9c-209">可视化树中包含某个应用程序的用户界面所使用的所有可视化元素。</span><span class="sxs-lookup"><span data-stu-id="fef9c-209">The visual tree contains all visual elements used in an application's user interface.</span></span> <span data-ttu-id="fef9c-210">由于可视化元素中包含持久的绘图信息，因此可以将可视化树视为场景图，其中包含将输出写入显示设备所必需的全部呈现信息。</span><span class="sxs-lookup"><span data-stu-id="fef9c-210">Since a visual element contains persisted drawing information, you can think of the visual tree as a scene graph, containing all the rendering information needed to compose the output to the display device.</span></span> <span data-ttu-id="fef9c-211">该树汇集了由该应用程序在代码或标记中直接创建的所有可视化元素。</span><span class="sxs-lookup"><span data-stu-id="fef9c-211">This tree is the accumulation of all visual elements created directly by the application, whether in code or in markup.</span></span> <span data-ttu-id="fef9c-212">该可视化树还包含由元素（如控件和数据对象）的模板扩展功能创建的所有可视化元素。</span><span class="sxs-lookup"><span data-stu-id="fef9c-212">The visual tree also contains all visual elements created by the template expansion of elements such as controls and data objects.</span></span>  
  
 <span data-ttu-id="fef9c-213">下面的代码演示<xref:System.Windows.Controls.StackPanel>在标记中定义的元素。</span><span class="sxs-lookup"><span data-stu-id="fef9c-213">The following code shows a <xref:System.Windows.Controls.StackPanel> element defined in markup.</span></span>  
  
 [!code-xaml[VisualsOverview#VisualsOverviewSnippet3](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualsOverview/CSharp/Window1.xaml#visualsoverviewsnippet3)]  
  
 <span data-ttu-id="fef9c-214">如果你打算枚举包含的视觉对象<xref:System.Windows.Controls.StackPanel>标记示例中的元素，您将看到如下图所示的视觉对象的层次结构：</span><span class="sxs-lookup"><span data-stu-id="fef9c-214">If you were to enumerate the visual objects that comprise the <xref:System.Windows.Controls.StackPanel> element in the markup example, you would find the hierarchy of visual objects illustrated below:</span></span>  
  
 ![可视化树层次结构示意图](./media/wpf-graphics-rendering-overview/visual-tree-hierarchy.gif)  
  
### <a name="rendering-order"></a><span data-ttu-id="fef9c-216">呈现顺序</span><span class="sxs-lookup"><span data-stu-id="fef9c-216">Rendering Order</span></span>  
 <span data-ttu-id="fef9c-217">通过可视化树，可以确定 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 可视化对象和绘图对象的呈现顺序。</span><span class="sxs-lookup"><span data-stu-id="fef9c-217">The visual tree determines the rendering order of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] visual and drawing objects.</span></span> <span data-ttu-id="fef9c-218">将从位于可视化树中最顶层节点中的可视化元素根开始遍历。</span><span class="sxs-lookup"><span data-stu-id="fef9c-218">The order of traversal starts with the root visual, which is the top-most node in the visual tree.</span></span> <span data-ttu-id="fef9c-219">然后，将按照从左到右的顺序遍历可视化元素根的子级。</span><span class="sxs-lookup"><span data-stu-id="fef9c-219">The root visual’s children are then traversed, left to right.</span></span> <span data-ttu-id="fef9c-220">如果可视化元素有子级，则将先遍历该可视化元素的子级，然后再遍历其同级。</span><span class="sxs-lookup"><span data-stu-id="fef9c-220">If a visual has children, its children are traversed before the visual’s siblings.</span></span> <span data-ttu-id="fef9c-221">这意味着子可视化元素的内容先于该可视化元素本身的内容呈现。</span><span class="sxs-lookup"><span data-stu-id="fef9c-221">This means that the content of a child visual is rendered in front of the visual's own content.</span></span>  
  
 ![可视化树呈现顺序关系图](./media/wpf-graphics-rendering-overview/visual-tree-rendering-order.gif) 
  
### <a name="root-visual"></a><span data-ttu-id="fef9c-223">可视化元素根</span><span class="sxs-lookup"><span data-stu-id="fef9c-223">Root Visual</span></span>  
 <span data-ttu-id="fef9c-224">**可视化元素根**是可视化树层次结构中最顶层的元素。</span><span class="sxs-lookup"><span data-stu-id="fef9c-224">The **root visual** is the top-most element in a visual tree hierarchy.</span></span> <span data-ttu-id="fef9c-225">在大多数应用程序的根可视化对象的基类是<xref:System.Windows.Window>或<xref:System.Windows.Navigation.NavigationWindow>。</span><span class="sxs-lookup"><span data-stu-id="fef9c-225">In most applications, the base class of the root visual is either <xref:System.Windows.Window> or <xref:System.Windows.Navigation.NavigationWindow>.</span></span> <span data-ttu-id="fef9c-226">但是，如果在 Win32 应用程序中承载视觉对象，则可视化元素根将是在 Win32 窗口中承载的最顶层的可视化元素。</span><span class="sxs-lookup"><span data-stu-id="fef9c-226">However, if you were hosting visual objects in a Win32 application, the root visual would be the top-most visual you were hosting in the Win32 window.</span></span> <span data-ttu-id="fef9c-227">有关详细信息，请参阅[教程：承载在 Win32 应用程序中的视觉对象](tutorial-hosting-visual-objects-in-a-win32-application.md)。</span><span class="sxs-lookup"><span data-stu-id="fef9c-227">For more information, see [Tutorial: Hosting Visual Objects in a Win32 Application](tutorial-hosting-visual-objects-in-a-win32-application.md).</span></span>  
  
### <a name="relationship-to-the-logical-tree"></a><span data-ttu-id="fef9c-228">与逻辑树的关系</span><span class="sxs-lookup"><span data-stu-id="fef9c-228">Relationship to the Logical Tree</span></span>  
 <span data-ttu-id="fef9c-229">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中的逻辑树表示应用程序在运行时的元素。</span><span class="sxs-lookup"><span data-stu-id="fef9c-229">The logical tree in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] represents the elements of an application at run time.</span></span> <span data-ttu-id="fef9c-230">尽管不直接操作该树，但是该应用程序视图对于了解属性继承和事件路由非常有用。</span><span class="sxs-lookup"><span data-stu-id="fef9c-230">Although you do not manipulate this tree directly, this view of the application is useful for understanding property inheritance and event routing.</span></span> <span data-ttu-id="fef9c-231">与可视化树中，不同的逻辑树可以表示非可视化数据对象，如<xref:System.Windows.Documents.ListItem>。</span><span class="sxs-lookup"><span data-stu-id="fef9c-231">Unlike the visual tree, the logical tree can represent non-visual data objects, such as <xref:System.Windows.Documents.ListItem>.</span></span> <span data-ttu-id="fef9c-232">在许多情况下，逻辑树密切映射到应用程序的标记定义。</span><span class="sxs-lookup"><span data-stu-id="fef9c-232">In many cases, the logical tree maps very closely to an application's markup definitions.</span></span> <span data-ttu-id="fef9c-233">下面的代码演示<xref:System.Windows.Controls.DockPanel>在标记中定义的元素。</span><span class="sxs-lookup"><span data-stu-id="fef9c-233">The following code shows a <xref:System.Windows.Controls.DockPanel> element defined in markup.</span></span>  
  
 [!code-xaml[VisualsOverview#VisualsOverviewSnippet5](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualsOverview/CSharp/Window1.xaml#visualsoverviewsnippet5)]  
  
 <span data-ttu-id="fef9c-234">如果你打算枚举包含的逻辑对象<xref:System.Windows.Controls.DockPanel>标记示例中的元素，您将看到如下所示逻辑对象的层次结构：</span><span class="sxs-lookup"><span data-stu-id="fef9c-234">If you were to enumerate the logical objects that comprise the <xref:System.Windows.Controls.DockPanel> element in the markup example, you would find the hierarchy of logical objects illustrated below:</span></span>  
  
 <span data-ttu-id="fef9c-235">![树关系图](./media/tree1-wcp.gif "Tree1_wcp")</span><span class="sxs-lookup"><span data-stu-id="fef9c-235">![Tree diagram](./media/tree1-wcp.gif "Tree1_wcp")</span></span>  
<span data-ttu-id="fef9c-236">逻辑树关系图</span><span class="sxs-lookup"><span data-stu-id="fef9c-236">Diagram of logical tree</span></span>  
  
 <span data-ttu-id="fef9c-237">可视化树和逻辑树与当前的应用程序元素集合同步，并反映对元素进行的任何添加、删除或修改。</span><span class="sxs-lookup"><span data-stu-id="fef9c-237">Both the visual tree and logical tree are synchronized with the current set of application elements, reflecting any addition, deletion, or modification of elements.</span></span> <span data-ttu-id="fef9c-238">但是，这些树表示不同的应用程序视图。</span><span class="sxs-lookup"><span data-stu-id="fef9c-238">However, the trees present different views of the application.</span></span> <span data-ttu-id="fef9c-239">与不同的可视化树中，逻辑树不展开控件的<xref:System.Windows.Controls.ContentPresenter>元素。</span><span class="sxs-lookup"><span data-stu-id="fef9c-239">Unlike the visual tree, the logical tree does not expand a control's <xref:System.Windows.Controls.ContentPresenter> element.</span></span> <span data-ttu-id="fef9c-240">这意味着同一组对象的逻辑树和可视化树之间不存在直接的一对一对应关系。</span><span class="sxs-lookup"><span data-stu-id="fef9c-240">This means there is not a direct one-to-one correspondence between a logical tree and a visual tree for the same set of objects.</span></span> <span data-ttu-id="fef9c-241">实际上，调用**LogicalTreeHelper**对象的<xref:System.Windows.LogicalTreeHelper.GetChildren%2A>方法并**VisualTreeHelper**对象的<xref:System.Windows.Media.VisualTreeHelper.GetChild%2A>方法使用同一个元素，如参数会产生不同的结果.</span><span class="sxs-lookup"><span data-stu-id="fef9c-241">In fact, invoking the **LogicalTreeHelper** object's <xref:System.Windows.LogicalTreeHelper.GetChildren%2A> method and the **VisualTreeHelper** object's <xref:System.Windows.Media.VisualTreeHelper.GetChild%2A> method using the same element as a parameter yields differing results.</span></span>  
  
 <span data-ttu-id="fef9c-242">有关逻辑树的详细信息，请参阅 [WPF 中的树](../advanced/trees-in-wpf.md)。</span><span class="sxs-lookup"><span data-stu-id="fef9c-242">For more information on the logical tree, see [Trees in WPF](../advanced/trees-in-wpf.md).</span></span>  
  
### <a name="viewing-the-visual-tree-with-xamlpad"></a><span data-ttu-id="fef9c-243">使用 XamlPad 查看可视化树</span><span class="sxs-lookup"><span data-stu-id="fef9c-243">Viewing the Visual Tree with XamlPad</span></span>  
 <span data-ttu-id="fef9c-244">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 工具 (XamlPad) 提供了一个用来查看和浏览可视化树的选项，该树与当前所定义的 [!INCLUDE[TLA#tla_titlexaml](../../../../includes/tlasharptla-titlexaml-md.md)] 内容相对应。</span><span class="sxs-lookup"><span data-stu-id="fef9c-244">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] tool, XamlPad, provides an option for viewing and exploring the visual tree that corresponds to the currently defined [!INCLUDE[TLA#tla_titlexaml](../../../../includes/tlasharptla-titlexaml-md.md)] content.</span></span> <span data-ttu-id="fef9c-245">单击菜单栏上的“显示可视化树”按钮可显示相应的可视化树。</span><span class="sxs-lookup"><span data-stu-id="fef9c-245">Click the **Show Visual Tree** button on the menu bar to display the visual tree.</span></span> <span data-ttu-id="fef9c-246">下面将说明如何在 XamlPad 的“可视化树资源管理器”面板中将 [!INCLUDE[TLA#tla_titlexaml](../../../../includes/tlasharptla-titlexaml-md.md)] 内容扩展为可视化树节点：</span><span class="sxs-lookup"><span data-stu-id="fef9c-246">The following illustrates the expansion of [!INCLUDE[TLA#tla_titlexaml](../../../../includes/tlasharptla-titlexaml-md.md)] content into visual tree nodes in the **Visual Tree Explorer** panel of XamlPad:</span></span>  
  
 ![XamlPad 中的“可视化树资源管理器”面板](./media/wpf-graphics-rendering-overview/visual-tree-explorer.png)  

 <span data-ttu-id="fef9c-248">请注意如何<xref:System.Windows.Controls.Label>， <xref:System.Windows.Controls.TextBox>，并<xref:System.Windows.Controls.Button>每个控件都显示在一个单独的视觉对象层次结构**可视化树资源管理器**XamlPad 的面板。</span><span class="sxs-lookup"><span data-stu-id="fef9c-248">Notice how the <xref:System.Windows.Controls.Label>, <xref:System.Windows.Controls.TextBox>, and <xref:System.Windows.Controls.Button> controls each display a separate visual object hierarchy in the **Visual Tree Explorer** panel of XamlPad.</span></span> <span data-ttu-id="fef9c-249">这是因为[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]控件具有<xref:System.Windows.Controls.ControlTemplate>，其中包含该控件的可视化树。</span><span class="sxs-lookup"><span data-stu-id="fef9c-249">This is because [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] controls have a <xref:System.Windows.Controls.ControlTemplate> that contains the visual tree of that control.</span></span> <span data-ttu-id="fef9c-250">显式引用某个控件时，会隐式引用它的可视化层次结构。</span><span class="sxs-lookup"><span data-stu-id="fef9c-250">When you explicitly reference a control, you implicitly reference its visual hierarchy.</span></span>  
  
### <a name="profiling-visual-performance"></a><span data-ttu-id="fef9c-251">分析可视化性能</span><span class="sxs-lookup"><span data-stu-id="fef9c-251">Profiling Visual Performance</span></span>  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="fef9c-252">提供了一套性能分析工具，可用于分析你的应用程序的运行时行为并确定可以应用的性能优化的类型。</span><span class="sxs-lookup"><span data-stu-id="fef9c-252">provides a suite of performance profiling tools that allow you to analyze the run-time behavior of your application and determine the types of performance optimizations you can apply.</span></span> <span data-ttu-id="fef9c-253">可视化探查器工具通过直接映射到应用程序的可视化树来为性能数据提供一个丰富的图形视图。</span><span class="sxs-lookup"><span data-stu-id="fef9c-253">The Visual Profiler tool provides a rich, graphical view of performance data by mapping directly to the application's visual tree.</span></span> <span data-ttu-id="fef9c-254">在此屏幕快照中，通过可视化探查器的“CPU 使用率”部分可以清楚地了解对象对 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 服务（如呈现和布局）的使用情况。</span><span class="sxs-lookup"><span data-stu-id="fef9c-254">In this screenshot, the **CPU Usage** section of the Visual Profiler gives you a precise breakdown of an object's use of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] services, such as rendering and layout.</span></span>  
  
 <span data-ttu-id="fef9c-255">![Visual Profiler 显示输出](./media/wpfperf-visualprofiler-04.png "WPFPerf_VisualProfiler_04")</span><span class="sxs-lookup"><span data-stu-id="fef9c-255">![Visual Profiler display output](./media/wpfperf-visualprofiler-04.png "WPFPerf_VisualProfiler_04")</span></span>  
<span data-ttu-id="fef9c-256">可视化探查器显示输出</span><span class="sxs-lookup"><span data-stu-id="fef9c-256">Visual Profiler display output</span></span>  
  
<a name="visual_rendering_behavior"></a>   
## <a name="visual-rendering-behavior"></a><span data-ttu-id="fef9c-257">视觉对象的呈现行为</span><span class="sxs-lookup"><span data-stu-id="fef9c-257">Visual Rendering Behavior</span></span>  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="fef9c-258">引入了影响视觉对象的呈现行为的一些功能： 保留模式图形、 矢量图形和与设备无关的图形。</span><span class="sxs-lookup"><span data-stu-id="fef9c-258">introduces several features that affect the rendering behavior of visual objects: retained mode graphics, vector graphics, and device independent graphics.</span></span>  
  
### <a name="retained-mode-graphics"></a><span data-ttu-id="fef9c-259">保留的模式图形</span><span class="sxs-lookup"><span data-stu-id="fef9c-259">Retained Mode Graphics</span></span>  
 <span data-ttu-id="fef9c-260">了解 Visual 对象角色的关键之一是，了解**即时模式**和**保留模式**图形系统之间的区别。</span><span class="sxs-lookup"><span data-stu-id="fef9c-260">One of the keys to understanding the role of the Visual object is to understand the difference between **immediate mode** and **retained mode** graphics systems.</span></span> <span data-ttu-id="fef9c-261">基于 GDI 或 GDI+ 的标准 Win32 应用程序使用即时模式图形系统。</span><span class="sxs-lookup"><span data-stu-id="fef9c-261">A standard Win32 application based on GDI or GDI+ uses an immediate mode graphics system.</span></span> <span data-ttu-id="fef9c-262">这意味着应用程序负责重新绘制由于某项操作（如重设窗口大小）或者对象的可视化外观发生变化而失效的工作区部分。</span><span class="sxs-lookup"><span data-stu-id="fef9c-262">This means that the application is responsible for repainting the portion of the client area that is invalidated, due to an action such as a window being resized, or an object changing its visual appearance.</span></span>  
  
 ![Win32 呈现序列示意图](./media/wpf-graphics-rendering-overview/win32-rendering-squence.png)  
  
 <span data-ttu-id="fef9c-264">相比之下，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 使用保留模式系统。</span><span class="sxs-lookup"><span data-stu-id="fef9c-264">In contrast, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses a retained mode system.</span></span> <span data-ttu-id="fef9c-265">这意味着具有可视化外观的应用程序对象定义一组序列化绘图数据。</span><span class="sxs-lookup"><span data-stu-id="fef9c-265">This means application objects that have a visual appearance define a set of serialized drawing data.</span></span> <span data-ttu-id="fef9c-266">在定义了绘图数据之后，系统会响应所有的重新绘制请求来呈现应用程序对象。</span><span class="sxs-lookup"><span data-stu-id="fef9c-266">Once the drawing data is defined, the system is responsible thereafter for responding to all repaint requests for rendering the application objects.</span></span> <span data-ttu-id="fef9c-267">甚至在运行时，用户可以修改或创建应用程序对象，并仍依赖于系统响应绘制请求。</span><span class="sxs-lookup"><span data-stu-id="fef9c-267">Even at run time, you can modify or create application objects, and still rely on the system for responding to paint requests.</span></span> <span data-ttu-id="fef9c-268">保留模式图形系统中有一个强大功能，即绘图信息总是由应用程序保持为序列化状态，但是呈现功能仍由系统负责。</span><span class="sxs-lookup"><span data-stu-id="fef9c-268">The power in a retained mode graphics system is that drawing information is always persisted in a serialized state by the application, but rendering responsibility left to the system.</span></span> <span data-ttu-id="fef9c-269">以下关系图演示应用程序如何依赖 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 来响应绘制请求。</span><span class="sxs-lookup"><span data-stu-id="fef9c-269">The following diagram shows how the application relies on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] for responding to paint requests.</span></span>  
  
 ![WPF 呈现序列示意图](./media/wpf-graphics-rendering-overview/wpf-rendering-sequence.png)  

#### <a name="intelligent-redrawing"></a><span data-ttu-id="fef9c-271">智能重绘</span><span class="sxs-lookup"><span data-stu-id="fef9c-271">Intelligent Redrawing</span></span>  
 <span data-ttu-id="fef9c-272">使用保留模型图形的最大好处之一就是，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 可以高效率地优化需要在应用程序中重绘的内容。</span><span class="sxs-lookup"><span data-stu-id="fef9c-272">One of the biggest benefits in using retained mode graphics is that [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] can efficiently optimize what needs to be redrawn in the application.</span></span> <span data-ttu-id="fef9c-273">即使存在一个具有各种不透明度的复杂场景，通常也不必编写特殊用途的代码来优化重绘功能。</span><span class="sxs-lookup"><span data-stu-id="fef9c-273">Even if you have a complex scene with varying levels of opacity, you generally do not need to write special-purpose code to optimize redrawing.</span></span> <span data-ttu-id="fef9c-274">将该功能与 Win32 编程进行比较，在后者中可以通过最小化更新区域中的重绘量来尽力优化应用程序。</span><span class="sxs-lookup"><span data-stu-id="fef9c-274">Compare this with Win32 programming in which you can spend a great deal of effort in optimizing your application by minimizing the amount of redrawing in the update region.</span></span> <span data-ttu-id="fef9c-275">有关在 Win32 应用程序中优化重绘功能时涉及到的复杂度类型的示例，请参阅[在更新区域中重绘](/windows/desktop/gdi/redrawing-in-the-update-region)。</span><span class="sxs-lookup"><span data-stu-id="fef9c-275">See [Redrawing in the Update Region](/windows/desktop/gdi/redrawing-in-the-update-region) for an example of the type of complexity involved in optimizing redrawing in Win32 applications.</span></span>  
  
### <a name="vector-graphics"></a><span data-ttu-id="fef9c-276">矢量图形</span><span class="sxs-lookup"><span data-stu-id="fef9c-276">Vector Graphics</span></span>  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="fef9c-277">使用**矢量图形**作为其呈现数据的格式。</span><span class="sxs-lookup"><span data-stu-id="fef9c-277">uses **vector graphics** as its rendering data format.</span></span> <span data-ttu-id="fef9c-278">矢量图形（包括可缩放的矢量图形 (SVG)、Windows 元文件 (.wmf) 和 TrueType 字体）存储呈现数据，并以指令列表的形式传输呈现数据，这些指令描述如何使用图形基元来重新创建图像。</span><span class="sxs-lookup"><span data-stu-id="fef9c-278">Vector graphics—which include Scalable Vector Graphics (SVG), Windows metafiles (.wmf), and TrueType fonts—store rendering data and transmit it as a list of instructions that describe how to recreate an image using graphics primitives.</span></span> <span data-ttu-id="fef9c-279">例如，TrueType 字体是描述一组直线、曲线和命令（而不是像素数组）的矢量字。</span><span class="sxs-lookup"><span data-stu-id="fef9c-279">For example, TrueType fonts are outline fonts that describe a set of lines, curves, and commands, rather than an array of pixels.</span></span> <span data-ttu-id="fef9c-280">矢量图形的主要好处之一就是能够缩放到任何大小和分辨率。</span><span class="sxs-lookup"><span data-stu-id="fef9c-280">One of the key benefits of vector graphics is the ability to scale to any size and resolution.</span></span>  
  
 <span data-ttu-id="fef9c-281">与矢量图形不同，位图图形以图像的逐像素表示形式来存储呈现数据，并在特定的分辨率下预先呈现。</span><span class="sxs-lookup"><span data-stu-id="fef9c-281">Unlike vector graphics, bitmap graphics store rendering data as a pixel-by-pixel representation of an image, pre-rendered for a specific resolution.</span></span> <span data-ttu-id="fef9c-282">位图图形格式和矢量图形格式的主要区别之一是对原始源图像的保真度。</span><span class="sxs-lookup"><span data-stu-id="fef9c-282">One of the key differences between bitmap and vector graphic formats is fidelity to the original source image.</span></span> <span data-ttu-id="fef9c-283">例如，当修改了某个源图像的大小发时，位图图形系统会拉伸该图像，而矢量图形系统会缩放该图像，从而保持图像的保真度。</span><span class="sxs-lookup"><span data-stu-id="fef9c-283">For example, when the size of a source image is modified, bitmap graphics systems stretch the image, whereas vector graphics systems scale the image, preserving the image fidelity.</span></span>  
  
 <span data-ttu-id="fef9c-284">下图显示了其大小重设为 300% 的源图像。</span><span class="sxs-lookup"><span data-stu-id="fef9c-284">The following illustration shows a source image that has been resized by 300%.</span></span> <span data-ttu-id="fef9c-285">请注意，当源图像作为位图图形图像拉伸而不是作为矢量图形图像缩放时会发生失真。</span><span class="sxs-lookup"><span data-stu-id="fef9c-285">Notice the distortions that appear when the source image is stretched as a bitmap graphics image rather than scaled as a vector graphics image.</span></span>  
  
 ![光栅图与矢量图之间的区别](./media/wpf-graphics-rendering-overview/raster-vector-differences.png)  
  
 <span data-ttu-id="fef9c-287">以下标记显示了两个<xref:System.Windows.Shapes.Path>定义的元素。</span><span class="sxs-lookup"><span data-stu-id="fef9c-287">The following markup shows two <xref:System.Windows.Shapes.Path> elements defined.</span></span> <span data-ttu-id="fef9c-288">第二个元素使用<xref:System.Windows.Media.ScaleTransform>调整的第一个元素的绘图指令大小 300%。</span><span class="sxs-lookup"><span data-stu-id="fef9c-288">The second element uses a <xref:System.Windows.Media.ScaleTransform> to resize the drawing instructions of the first element by 300%.</span></span> <span data-ttu-id="fef9c-289">请注意，中的绘图指令<xref:System.Windows.Shapes.Path>元素保持不变。</span><span class="sxs-lookup"><span data-stu-id="fef9c-289">Notice that the drawing instructions in the <xref:System.Windows.Shapes.Path> elements remain unchanged.</span></span>  
  
 [!code-xaml[VectorGraphicsSnippets#VectorGraphicsSnippet1](~/samples/snippets/csharp/VS_Snippets_Wpf/VectorGraphicsSnippets/CS/PageOne.xaml#vectorgraphicssnippet1)]  
  
### <a name="about-resolution-and-device-independent-graphics"></a><span data-ttu-id="fef9c-290">关于与分辨率和设备无关的图形</span><span class="sxs-lookup"><span data-stu-id="fef9c-290">About Resolution and Device-Independent Graphics</span></span>  
 <span data-ttu-id="fef9c-291">确定屏幕上的文本和图形的大小有两个系统因素：分辨率和 DPI。</span><span class="sxs-lookup"><span data-stu-id="fef9c-291">There are two system factors that determine the size of text and graphics on your screen: resolution and DPI.</span></span> <span data-ttu-id="fef9c-292">分辨率描述屏幕上显示的像素数。</span><span class="sxs-lookup"><span data-stu-id="fef9c-292">Resolution describes the number of pixels that appear on the screen.</span></span> <span data-ttu-id="fef9c-293">因为分辨率变得越来越高，像素将变得更小，从而导致图形和文本会显得更小。</span><span class="sxs-lookup"><span data-stu-id="fef9c-293">As the resolution gets higher, pixels get smaller, causing graphics and text to appear smaller.</span></span> <span data-ttu-id="fef9c-294">在设置为 1024 x 768 的监视器上所显示的图形将在分辨率更改为 1600 x 1200 时显示得小很多。</span><span class="sxs-lookup"><span data-stu-id="fef9c-294">A graphic displayed on a monitor set to 1024 x 768 will appear much smaller when the resolution is changed to 1600 x 1200.</span></span>  
  
 <span data-ttu-id="fef9c-295">另一个系统设置 DPI 描述屏幕英寸的大小（以像素为单位）。</span><span class="sxs-lookup"><span data-stu-id="fef9c-295">The other system setting, DPI, describes the size of a screen inch in pixels.</span></span> <span data-ttu-id="fef9c-296">大多数 [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] 系统的 DPI 都为 96，这意味着屏幕英寸为 96 像素。</span><span class="sxs-lookup"><span data-stu-id="fef9c-296">Most [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] systems have a DPI of 96, which means a screen inch is 96 pixels.</span></span> <span data-ttu-id="fef9c-297">增加 DPI 设置会使屏幕英寸更大；降低 DPI 可使屏幕英寸更小。</span><span class="sxs-lookup"><span data-stu-id="fef9c-297">Increasing the DPI setting makes the screen inch larger; decreasing the DPI makes the screen inch smaller.</span></span> <span data-ttu-id="fef9c-298">这意味着屏幕英寸与实际英寸不同；在大多数系统上，可能不相同。</span><span class="sxs-lookup"><span data-stu-id="fef9c-298">This means that a screen inch isn't the same size as a real-world inch; on most systems, it's probably not.</span></span> <span data-ttu-id="fef9c-299">当增加 DPI 时，可感知 DPI 的图形和文本会变大，因为已增加了屏幕英寸的大小。</span><span class="sxs-lookup"><span data-stu-id="fef9c-299">As you increase the DPI, DPI-aware graphics and text become larger because you've increased the size of the screen inch.</span></span> <span data-ttu-id="fef9c-300">增加 DPI 可以使文本更易于阅读，尤其是使用较高的分辨率时。</span><span class="sxs-lookup"><span data-stu-id="fef9c-300">Increasing the DPI can make text easier to read, especially at high resolutions.</span></span>  
  
 <span data-ttu-id="fef9c-301">并非所有应用程序都可感知 DPI：一些将硬件像素用作主要计量单位；更改系统 DPI 对这些应用程序没有影响。</span><span class="sxs-lookup"><span data-stu-id="fef9c-301">Not all applications are DPI-aware: some use hardware pixels as the primary unit of measurement; changing the system DPI has no effect on these applications.</span></span> <span data-ttu-id="fef9c-302">其他许多应用程序使用可感知 DPI 的单位来描述字体大小，但使用像素来描述其他所有内容。</span><span class="sxs-lookup"><span data-stu-id="fef9c-302">Many other applications use DPI-aware units to describe font sizes, but use pixels to describe everything else.</span></span> <span data-ttu-id="fef9c-303">使 DPI 太小或太大，可能导致这些应用程序的布局问题，因为应用程序的文本会随着系统的 DPI 设置而缩放，但应用程序的 UI 并不会。</span><span class="sxs-lookup"><span data-stu-id="fef9c-303">Making the DPI too small or too large can cause layout problems for these applications, because the applications' text scales with the system's DPI setting, but the applications' UI does not.</span></span> <span data-ttu-id="fef9c-304">对于使用 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 开发的应用程序，已消除此问题。</span><span class="sxs-lookup"><span data-stu-id="fef9c-304">This problem has been eliminated for applications developed using [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>  
  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="fef9c-305">支持通过使用与设备无关的像素作为度量值，而不是硬件像素; 其主计价单位的自动缩放图形和文本而无需任何额外的工作应用程序开发人员能正确缩放。</span><span class="sxs-lookup"><span data-stu-id="fef9c-305">supports automatic scaling by using the device independent pixel as its primary unit of measurement, instead of hardware pixels; graphics and text scale properly without any extra work from the application developer.</span></span> <span data-ttu-id="fef9c-306">下图显示 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 文本和图形如何采用不同 DPI 设置进行显示的示例。</span><span class="sxs-lookup"><span data-stu-id="fef9c-306">The following illustration shows an example of how [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] text and graphics are appear at different DPI settings.</span></span>  
  
 <span data-ttu-id="fef9c-307">![采用不同 DPI 设置的图形和文本](./media/graphicsmm-dpi-setting-examples.png "graphicsmm_dpi_setting_examples")</span><span class="sxs-lookup"><span data-stu-id="fef9c-307">![Graphics and text at different DPI settings](./media/graphicsmm-dpi-setting-examples.png "graphicsmm_dpi_setting_examples")</span></span>  
<span data-ttu-id="fef9c-308">采用不同 DPI 设置的图形和文本</span><span class="sxs-lookup"><span data-stu-id="fef9c-308">Graphics and text at different DPI settings</span></span>  
  
<a name="visualtreehelper_class"></a>   
## <a name="visualtreehelper-class"></a><span data-ttu-id="fef9c-309">VisualTreeHelper 类</span><span class="sxs-lookup"><span data-stu-id="fef9c-309">VisualTreeHelper Class</span></span>  
 <span data-ttu-id="fef9c-310"><xref:System.Windows.Media.VisualTreeHelper>类是一个静态帮助器类，它在视觉对象级别，可在非常具体的情况下，如开发高性能自定义控件的编程提供低级别的功能。</span><span class="sxs-lookup"><span data-stu-id="fef9c-310">The <xref:System.Windows.Media.VisualTreeHelper> class is a static helper class that provides low-level functionality for programming at the visual object level, which is useful in very specific scenarios, such as developing high-performance custom controls.</span></span> <span data-ttu-id="fef9c-311">在大多数情况下，更高级别的[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]framework 对象，如<xref:System.Windows.Controls.Canvas>和<xref:System.Windows.Controls.TextBlock>，提供更大的灵活性和易于使用。</span><span class="sxs-lookup"><span data-stu-id="fef9c-311">In most case, the higher-level [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] framework objects, such as <xref:System.Windows.Controls.Canvas> and <xref:System.Windows.Controls.TextBlock>, offer greater flexibility and ease of use.</span></span>  
  
### <a name="hit-testing"></a><span data-ttu-id="fef9c-312">命中测试</span><span class="sxs-lookup"><span data-stu-id="fef9c-312">Hit Testing</span></span>  
 <span data-ttu-id="fef9c-313"><xref:System.Windows.Media.VisualTreeHelper>类提供方法的命中测试可视化对象上，当默认命中测试支持不满足你的需求。</span><span class="sxs-lookup"><span data-stu-id="fef9c-313">The <xref:System.Windows.Media.VisualTreeHelper> class provides methods for hit testing on visual objects when the default hit test support does not meet your needs.</span></span> <span data-ttu-id="fef9c-314">可以使用<xref:System.Windows.Media.VisualTreeHelper.HitTest%2A>中的方法<xref:System.Windows.Media.VisualTreeHelper>类，以确定几何或点坐标值是否在给定的对象，如控件或图形元素的边界内。</span><span class="sxs-lookup"><span data-stu-id="fef9c-314">You can use the <xref:System.Windows.Media.VisualTreeHelper.HitTest%2A> methods in the <xref:System.Windows.Media.VisualTreeHelper> class to determine whether a geometry or point coordinate value is within the boundary of a given object, such as a control or graphic element.</span></span> <span data-ttu-id="fef9c-315">例如，可以使用命中测试确定对象的边框内的鼠标单击落在圆的几何内。还可以选择重写命中测试的默认实现，以执行自己的自定义命中测试计算。</span><span class="sxs-lookup"><span data-stu-id="fef9c-315">For example, you could use hit testing to determine whether a mouse click within the bounding rectangle of an object falls within the geometry of a circle You can also choose to override the default implementation of hit testing to perform your own custom hit test calculations.</span></span>  
  
 <span data-ttu-id="fef9c-316">有关命中测试的详细信息，请参阅[可视化层中的命中测试](hit-testing-in-the-visual-layer.md)。</span><span class="sxs-lookup"><span data-stu-id="fef9c-316">For more information on hit testing, see [Hit Testing in the Visual Layer](hit-testing-in-the-visual-layer.md).</span></span>  
  
### <a name="enumerating-the-visual-tree"></a><span data-ttu-id="fef9c-317">枚举可视化树</span><span class="sxs-lookup"><span data-stu-id="fef9c-317">Enumerating the Visual Tree</span></span>  
 <span data-ttu-id="fef9c-318"><xref:System.Windows.Media.VisualTreeHelper>类提供用于枚举可视化树的成员的功能。</span><span class="sxs-lookup"><span data-stu-id="fef9c-318">The <xref:System.Windows.Media.VisualTreeHelper> class provides functionality for enumerating the members of a visual tree.</span></span> <span data-ttu-id="fef9c-319">若要检索父级，调用<xref:System.Windows.Media.VisualTreeHelper.GetParent%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="fef9c-319">To retrieve a parent, call the <xref:System.Windows.Media.VisualTreeHelper.GetParent%2A> method.</span></span> <span data-ttu-id="fef9c-320">若要检索的子级或直接后代，视觉对象，调用<xref:System.Windows.Media.VisualTreeHelper.GetChild%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="fef9c-320">To retrieve a child, or direct descendant, of a visual object, call the <xref:System.Windows.Media.VisualTreeHelper.GetChild%2A> method.</span></span> <span data-ttu-id="fef9c-321">此方法返回子<xref:System.Windows.Media.Visual>的指定索引处的父级。</span><span class="sxs-lookup"><span data-stu-id="fef9c-321">This method returns a child <xref:System.Windows.Media.Visual> of the parent at the specified index.</span></span>  
  
 <span data-ttu-id="fef9c-322">下面的示例演示如何枚举视觉对象的所有后代，如果你对序列化可视化对象层次结构的所有呈现信息感兴趣，则可能希望使用该技术。</span><span class="sxs-lookup"><span data-stu-id="fef9c-322">The following example shows how to enumerate all the descendants of a visual object, which is a technique you might want to use if you were interested in serializing all the rendering information of a visual object hierarchy.</span></span>  
  
 [!code-csharp[VisualsOverview#101](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualsOverview/CSharp/Window1.xaml.cs#101)]
 [!code-vb[VisualsOverview#101](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualsOverview/visualbasic/window1.xaml.vb#101)]  
  
 <span data-ttu-id="fef9c-323">在大多数情况下，逻辑树是 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 应用程序中元素的更有用的表示形式。</span><span class="sxs-lookup"><span data-stu-id="fef9c-323">In most cases, the logical tree is a more useful representation of the elements in a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application.</span></span> <span data-ttu-id="fef9c-324">尽管不直接操作逻辑树，但是该应用程序视图对于了解属性继承和事件路由非常有用。</span><span class="sxs-lookup"><span data-stu-id="fef9c-324">Although you do not modify the logical tree directly, this view of the application is useful for understanding property inheritance and event routing.</span></span> <span data-ttu-id="fef9c-325">与可视化树中，不同的逻辑树可以表示非可视化数据对象，如<xref:System.Windows.Documents.ListItem>。</span><span class="sxs-lookup"><span data-stu-id="fef9c-325">Unlike the visual tree, the logical tree can represent non-visual data objects, such as <xref:System.Windows.Documents.ListItem>.</span></span> <span data-ttu-id="fef9c-326">有关逻辑树的详细信息，请参阅 [WPF 中的树](../advanced/trees-in-wpf.md)。</span><span class="sxs-lookup"><span data-stu-id="fef9c-326">For more information on the logical tree, see [Trees in WPF](../advanced/trees-in-wpf.md).</span></span>  
  
 <span data-ttu-id="fef9c-327"><xref:System.Windows.Media.VisualTreeHelper>类提供了用于返回边框的视觉对象的方法。</span><span class="sxs-lookup"><span data-stu-id="fef9c-327">The <xref:System.Windows.Media.VisualTreeHelper> class provides methods for returning the bounding rectangle of visual objects.</span></span> <span data-ttu-id="fef9c-328">可以通过调用返回的视觉对象的边界矩形<xref:System.Windows.Media.VisualTreeHelper.GetContentBounds%2A>。</span><span class="sxs-lookup"><span data-stu-id="fef9c-328">You can return the bounding rectangle of a visual object by calling <xref:System.Windows.Media.VisualTreeHelper.GetContentBounds%2A>.</span></span> <span data-ttu-id="fef9c-329">可以返回的视觉对象，通过调用包括视觉对象本身的所有子代的边框<xref:System.Windows.Media.VisualTreeHelper.GetDescendantBounds%2A>。</span><span class="sxs-lookup"><span data-stu-id="fef9c-329">You can return the bounding rectangle of all the descendants of a visual object, including the visual object itself, by calling <xref:System.Windows.Media.VisualTreeHelper.GetDescendantBounds%2A>.</span></span> <span data-ttu-id="fef9c-330">下面的代码演示如何计算可视化对象及其所有子代的边框。</span><span class="sxs-lookup"><span data-stu-id="fef9c-330">The following code shows how you would calculate the bounding rectangle of a visual object and all its descendants.</span></span>  
  
 [!code-csharp[VisualsOverview#102](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualsOverview/CSharp/Window1.xaml.cs#102)]
 [!code-vb[VisualsOverview#102](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualsOverview/visualbasic/window1.xaml.vb#102)]  
  
## <a name="see-also"></a><span data-ttu-id="fef9c-331">请参阅</span><span class="sxs-lookup"><span data-stu-id="fef9c-331">See also</span></span>

- <xref:System.Windows.Media.Visual>
- <xref:System.Windows.Media.VisualTreeHelper>
- <xref:System.Windows.Media.DrawingVisual>
- [<span data-ttu-id="fef9c-332">二维图形和图像处理</span><span class="sxs-lookup"><span data-stu-id="fef9c-332">2D Graphics and Imaging</span></span>](../advanced/optimizing-performance-2d-graphics-and-imaging.md)
- [<span data-ttu-id="fef9c-333">可视化层中的命中测试</span><span class="sxs-lookup"><span data-stu-id="fef9c-333">Hit Testing in the Visual Layer</span></span>](hit-testing-in-the-visual-layer.md)
- [<span data-ttu-id="fef9c-334">使用 DrawingVisual 对象</span><span class="sxs-lookup"><span data-stu-id="fef9c-334">Using DrawingVisual Objects</span></span>](using-drawingvisual-objects.md)
- [<span data-ttu-id="fef9c-335">教程：在 Win32 应用程序中承载视觉对象</span><span class="sxs-lookup"><span data-stu-id="fef9c-335">Tutorial: Hosting Visual Objects in a Win32 Application</span></span>](tutorial-hosting-visual-objects-in-a-win32-application.md)
- [<span data-ttu-id="fef9c-336">优化 WPF 应用程序性能</span><span class="sxs-lookup"><span data-stu-id="fef9c-336">Optimizing WPF Application Performance</span></span>](../advanced/optimizing-wpf-application-performance.md)
