---
title: "队列概述"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology:
- dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- queues [WCF], MSMQ integration
ms.assetid: b8757992-ffce-40ad-9e9b-3243f6d0fce1
caps.latest.revision: 
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload:
- dotnet
ms.openlocfilehash: eb5d0f51fbbb6c8bad9bfbbfd9977368fdbd0666
ms.sourcegitcommit: c0dd436f6f8f44dc80dc43b07f6841a00b74b23f
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/19/2018
---
# <a name="queues-overview"></a><span data-ttu-id="30a98-102">队列概述</span><span class="sxs-lookup"><span data-stu-id="30a98-102">Queues Overview</span></span>
<span data-ttu-id="30a98-103">本节介绍与排队通信相关的一般概念和核心概念。</span><span class="sxs-lookup"><span data-stu-id="30a98-103">This section introduces the general and core concepts behind queued communication.</span></span> <span data-ttu-id="30a98-104">后面的各节将详细介绍如何在 [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] 中显示此处描述的队列概念。</span><span class="sxs-lookup"><span data-stu-id="30a98-104">Subsequent sections go into details about how the queuing concepts described here are manifested in [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)].</span></span>  
  
## <a name="basic-queuing-concepts"></a><span data-ttu-id="30a98-105">基本的队列概念</span><span class="sxs-lookup"><span data-stu-id="30a98-105">Basic Queuing Concepts</span></span>  
 <span data-ttu-id="30a98-106">设计分布式应用程序时，在服务和客户端之间选择正确的通信传输是非常重要的。</span><span class="sxs-lookup"><span data-stu-id="30a98-106">When designing a distributed application, choosing the right transport for communication between services and clients is important.</span></span> <span data-ttu-id="30a98-107">使用的传输种类受几个因素影响。</span><span class="sxs-lookup"><span data-stu-id="30a98-107">Several factors affect the kind of transport to use.</span></span> <span data-ttu-id="30a98-108">一个重要的因素是服务、客户端和传输之间的隔离，它可确定是使用排队传输，还是使用直接传输（如 TCP 或 HTTP）。</span><span class="sxs-lookup"><span data-stu-id="30a98-108">One important factor—isolation between the service, the client, and the transport—determines use of a queued transport or a direct transport, such as TCP or HTTP.</span></span> <span data-ttu-id="30a98-109">由于直接传输（如 TCP 和 HTTP）的特性，如果服务或客户端停止工作或网络发生故障时，通信就会停止。</span><span class="sxs-lookup"><span data-stu-id="30a98-109">Due to the nature of direct transports such as TCP and HTTP, communication stops altogether if the service or the client stop functioning or if the network fails.</span></span> <span data-ttu-id="30a98-110">服务、客户端和网络必须同时运行，应用程序才能工作。</span><span class="sxs-lookup"><span data-stu-id="30a98-110">The service, the client, and the network must be running at the same time for the application to work.</span></span> <span data-ttu-id="30a98-111">排队传输可提供隔离，即如果服务或客户端发生故障或它们之间的通信链接出现问题，客户端和服务还可以继续工作。</span><span class="sxs-lookup"><span data-stu-id="30a98-111">Queued transports provide isolation, which means that if the service or client fail or if communication links between them fail, the client and service can continue to function.</span></span>  
  
 <span data-ttu-id="30a98-112">即使通信方或网络出现故障，队列也可以提供可靠的通信。</span><span class="sxs-lookup"><span data-stu-id="30a98-112">Queues provide reliable communication even with failures in the communicating parties or the network.</span></span> <span data-ttu-id="30a98-113">队列捕获和传送在通信方之间交换的消息。</span><span class="sxs-lookup"><span data-stu-id="30a98-113">Queues capture and deliver messages exchanged between the communicating parties.</span></span> <span data-ttu-id="30a98-114">通常，某些种类的存储（可变或持久）可支持队列。</span><span class="sxs-lookup"><span data-stu-id="30a98-114">Queues are typically backed by some kind of a store, which can be volatile or durable.</span></span> <span data-ttu-id="30a98-115">队列存储来自代表服务的客户端的消息，然后将这些消息转发给该服务。</span><span class="sxs-lookup"><span data-stu-id="30a98-115">Queues store messages from a client on behalf of a service and later forward these messages to the service.</span></span> <span data-ttu-id="30a98-116">间接寻址队列可确保隔离出现故障的任意一方，因此可将它作为高可用性系统和断开服务的首选通信机制。</span><span class="sxs-lookup"><span data-stu-id="30a98-116">The indirection queues provide ensured isolation of failure by either party, thus making it the preferred communication mechanism for high-availability systems and disconnected services.</span></span> <span data-ttu-id="30a98-117">间接寻址会产生因高延迟而引起的成本。</span><span class="sxs-lookup"><span data-stu-id="30a98-117">The indirection comes with the cost of high latency.</span></span> <span data-ttu-id="30a98-118">*延迟*是客户端发送一条消息的时间和服务接收它的时间之间的时间延迟。</span><span class="sxs-lookup"><span data-stu-id="30a98-118">*Latency* is the time delay between the time the client sends a message and the time the service receives it.</span></span> <span data-ttu-id="30a98-119">这表示发送消息后，不知道何时会处理该消息。</span><span class="sxs-lookup"><span data-stu-id="30a98-119">This means that once a message is sent, you do not know when that message may be processed.</span></span> <span data-ttu-id="30a98-120">大多数的排队应用程序都需要处理高延迟。</span><span class="sxs-lookup"><span data-stu-id="30a98-120">Most queued applications cope with high latency.</span></span> <span data-ttu-id="30a98-121">下面的插图显示了排队通信的概念模型。</span><span class="sxs-lookup"><span data-stu-id="30a98-121">The following illustration shows a conceptual model of queued communication.</span></span>  
  
 <span data-ttu-id="30a98-122">![排队通信的模型](../../../../docs/framework/wcf/feature-details/media/qconceptual-figure1c.gif "QConceptual Figure1c")</span><span class="sxs-lookup"><span data-stu-id="30a98-122">![Model of queued communication](../../../../docs/framework/wcf/feature-details/media/qconceptual-figure1c.gif "QConceptual-Figure1c")</span></span>  
  
 <span data-ttu-id="30a98-123">排队通信概念模型</span><span class="sxs-lookup"><span data-stu-id="30a98-123">Queued communication conceptual model</span></span>  
  
 <span data-ttu-id="30a98-124">实际上，队列是一个分布式概念。</span><span class="sxs-lookup"><span data-stu-id="30a98-124">In reality, the queue is a distributed concept.</span></span> <span data-ttu-id="30a98-125">因此，它们可以是任意一方的本地队列，也可以是双方的远程队列。</span><span class="sxs-lookup"><span data-stu-id="30a98-125">As such, they can be local to either party or remote to both parties.</span></span> <span data-ttu-id="30a98-126">通常，对于服务而言，队列是本地的。</span><span class="sxs-lookup"><span data-stu-id="30a98-126">Typically, the queue is local to the service.</span></span> <span data-ttu-id="30a98-127">在此配置中，客户端不会因连接到远程队列而持续可用。</span><span class="sxs-lookup"><span data-stu-id="30a98-127">In this configuration, the client cannot depend on connectivity to the remote queue to be constantly available.</span></span> <span data-ttu-id="30a98-128">同样，队列必须在独立于从队列读取的服务的可用性时才可用。</span><span class="sxs-lookup"><span data-stu-id="30a98-128">Similarly, the queue must be available independent of the availability of the service reading from the queue.</span></span> <span data-ttu-id="30a98-129">队列管理器管理队列集合。</span><span class="sxs-lookup"><span data-stu-id="30a98-129">A queue manager manages a collection of queues.</span></span> <span data-ttu-id="30a98-130">它负责接收其他队列管理器发送给它的队列的消息。</span><span class="sxs-lookup"><span data-stu-id="30a98-130">It is responsible for accepting messages sent to its queues from other queue managers.</span></span> <span data-ttu-id="30a98-131">它还负责管理连接远程队列并将消息传输至这些远程队列。</span><span class="sxs-lookup"><span data-stu-id="30a98-131">It is also responsible for managing connectivity to remote queues and transferring messages to those remote queues.</span></span> <span data-ttu-id="30a98-132">在客户端或服务应用程序出现故障时，要确保队列的可用性，队列管理器通常会作为外部服务运行。</span><span class="sxs-lookup"><span data-stu-id="30a98-132">To ensure availability of queues despite client or service application failures, the queue manager is typically run as an external service.</span></span>  
  
 <span data-ttu-id="30a98-133">客户端将消息发送至队列时，队列管理器会将该消息定址到由服务队列管理器管理的目标队列。</span><span class="sxs-lookup"><span data-stu-id="30a98-133">When a client sends a message to a queue, it addresses the message to the target queue, which is the queue managed by the service's queue manager.</span></span> <span data-ttu-id="30a98-134">客户端上的队列管理器将消息发送至传输（或传出）队列。</span><span class="sxs-lookup"><span data-stu-id="30a98-134">The queue manager on the client sends the message to a transmission (or outgoing) queue.</span></span> <span data-ttu-id="30a98-135">传输队列是客户端队列管理器（将传输的消息存储至目标队列）上的队列。</span><span class="sxs-lookup"><span data-stu-id="30a98-135">The transmission queue is a queue on the client queue manager that stores messages for transmission to the target queue.</span></span> <span data-ttu-id="30a98-136">然后队列管理器查找一个拥有目标队列的队列管理器的路径并将消息传输给它。</span><span class="sxs-lookup"><span data-stu-id="30a98-136">The queue manager then finds a path to the queue manager that owns the target queue and transfers the message to it.</span></span> <span data-ttu-id="30a98-137">要确保可靠通信，队列管理器将实现可靠传输协议以避免数据丢失。</span><span class="sxs-lookup"><span data-stu-id="30a98-137">To ensure reliable communication, the queue managers implement a reliable transfer protocol to prevent data loss.</span></span> <span data-ttu-id="30a98-138">目标队列管理器接受定址到目标队列的消息，该管理器可拥有并存储消息。</span><span class="sxs-lookup"><span data-stu-id="30a98-138">The destination queue manager accepts messages addressed to the target queues it owns and stores the messages.</span></span> <span data-ttu-id="30a98-139">服务发出从目标队列读取的请求时，队列管理器将消息传送至目标应用程序。</span><span class="sxs-lookup"><span data-stu-id="30a98-139">The service makes requests to read from the target queue, at which time the queue manager then delivers the message to the destination application.</span></span> <span data-ttu-id="30a98-140">下面的插图显示了四方之间的通信。</span><span class="sxs-lookup"><span data-stu-id="30a98-140">The following illustration shows communication between the four parties.</span></span>  
  
 <span data-ttu-id="30a98-141">![排队应用程序关系图](../../../../docs/framework/wcf/feature-details/media/distributed-queue-figure.jpg "分布式队列图")</span><span class="sxs-lookup"><span data-stu-id="30a98-141">![Queued Application Diagram](../../../../docs/framework/wcf/feature-details/media/distributed-queue-figure.jpg "Distributed-Queue-Figure")</span></span>  
  
 <span data-ttu-id="30a98-142">典型的部署方案中的排队通信</span><span class="sxs-lookup"><span data-stu-id="30a98-142">Queued communication in a typical deployment scenario</span></span>  
  
 <span data-ttu-id="30a98-143">因此，队列管理器可提供所需的隔离，这样在发送方和接收方单独出现故障时，不会影响实际的通信。</span><span class="sxs-lookup"><span data-stu-id="30a98-143">Thus, the queue manager provides the required isolation so that the sender and receiver can independently fail without affecting actual communication.</span></span> <span data-ttu-id="30a98-144">队列提供的额外间接寻址的优点还可以启用多个应用程序实例，以从同一队列中进行读取操作，这样节点间场工作的吞吐量可以更高。</span><span class="sxs-lookup"><span data-stu-id="30a98-144">The benefit of extra indirection that queues provide also enables multiple application instances to read from the same queue, so that farming work among the nodes achieves higher throughput.</span></span> <span data-ttu-id="30a98-145">因此，队列用于实现较高的缩放和吞吐量要求的情况并不少见。</span><span class="sxs-lookup"><span data-stu-id="30a98-145">Therefore, it is not uncommon to see queues being used to achieve higher scale and throughput requirements.</span></span>  
  
## <a name="queues-and-transactions"></a><span data-ttu-id="30a98-146">队列和事务</span><span class="sxs-lookup"><span data-stu-id="30a98-146">Queues and Transactions</span></span>  
 <span data-ttu-id="30a98-147">事务允许您将一组操作组合到一起，这样如果一个操作失败，所有的操作都将失败。</span><span class="sxs-lookup"><span data-stu-id="30a98-147">Transactions allow you to group a set of operations together so that if one operation fails, all of the operations fail.</span></span> <span data-ttu-id="30a98-148">事务使用方法的一个示例：某人使用 ATM 将存款帐户中的 1,000 美元转存到他的支票帐户中。</span><span class="sxs-lookup"><span data-stu-id="30a98-148">An example of how to use transactions is when a person uses an ATM to transfer $1,000 from his savings account to his checking account.</span></span> <span data-ttu-id="30a98-149">需要的操作如下：</span><span class="sxs-lookup"><span data-stu-id="30a98-149">This entails the following operations:</span></span>  
  
-   <span data-ttu-id="30a98-150">从存款帐户中取出 1,000 美元。</span><span class="sxs-lookup"><span data-stu-id="30a98-150">Withdrawing $1,000 from the savings account.</span></span>  
  
-   <span data-ttu-id="30a98-151">将 1,000 美元存入支票帐户中。</span><span class="sxs-lookup"><span data-stu-id="30a98-151">Depositing $1,000 into the checking account.</span></span>  
  
 <span data-ttu-id="30a98-152">如果第一步操作成功完成，即从存款帐户中取出了 1,000 美元，但没有完成第二步操作，则将会丢失 1,000 美元，因为这笔钱已经从存款帐户中取出。</span><span class="sxs-lookup"><span data-stu-id="30a98-152">If the first operation succeeds and $1,000 is withdrawn from the savings account but the second operation fails, the $1,000 is lost because it has already been withdrawn from the savings account.</span></span> <span data-ttu-id="30a98-153">为了保持帐户处于有效状态，如果一个操作失败，则两个操作都必须无效。</span><span class="sxs-lookup"><span data-stu-id="30a98-153">To keep the accounts in a valid state, if one operation fails, both operations must fail.</span></span>  
  
 <span data-ttu-id="30a98-154">在事务性消息处理中，将消息发送至事务的队列并从该队列接收消息。</span><span class="sxs-lookup"><span data-stu-id="30a98-154">In transactional messaging, messages can be sent to the queue and received from the queue under a transaction.</span></span> <span data-ttu-id="30a98-155">因此，如果在事务中发送消息后并且该事务被回滚，则结果就像从未将消息发送至队列一样。</span><span class="sxs-lookup"><span data-stu-id="30a98-155">Thus, if a message is sent in a transaction and the transaction is rolled back, then the outcome is as if the message had never been sent to the queue.</span></span> <span data-ttu-id="30a98-156">同样，如果在事务中接收消息并且该事务被回滚，则结果就像从未接收过消息一样。</span><span class="sxs-lookup"><span data-stu-id="30a98-156">Similarly if a message is received in a transaction and the transaction is rolled back, then the outcome is as if the message had never been received.</span></span> <span data-ttu-id="30a98-157">消息会保留在要读取的队列中。</span><span class="sxs-lookup"><span data-stu-id="30a98-157">The message remains in the queue to be read.</span></span>  
  
 <span data-ttu-id="30a98-158">由于高延迟，因此发送消息后，您无法知道需要多长时间消息才能到达它的目标队列，也不会知道需要多长时间服务才能处理该消息。</span><span class="sxs-lookup"><span data-stu-id="30a98-158">Because of high latency, when you send a message you have no way of knowing how long it takes to reach its target queue, nor do you know how long it takes for the service to process the message.</span></span> <span data-ttu-id="30a98-159">因此，不要使用单个事务来发送消息、接收消息以及处理消息。</span><span class="sxs-lookup"><span data-stu-id="30a98-159">Because of this, you do not want to use a single transaction to send the message, receive the message, and then process the message.</span></span> <span data-ttu-id="30a98-160">这样创建的事务才不会出现不确定的时间量。</span><span class="sxs-lookup"><span data-stu-id="30a98-160">This creates a transaction that is not committed for an indeterminate amount of time.</span></span> <span data-ttu-id="30a98-161">客户端和服务通过队列使用事务进行通信时，会涉及两个事务：一个在客户端上，另一个在服务上。</span><span class="sxs-lookup"><span data-stu-id="30a98-161">When a client and service communicate through a queue using a transaction, two transactions are involved: one on the client and one on the service.</span></span> <span data-ttu-id="30a98-162">下面的插图显示了在典型排队通信中的事务边界。</span><span class="sxs-lookup"><span data-stu-id="30a98-162">The following illustration shows the transaction boundaries in typical queued communication.</span></span>  
  
 <span data-ttu-id="30a98-163">![与事务的队列](../../../../docs/framework/wcf/feature-details/media/qwithtransactions-figure3.gif "QWithTransactions Figure3")</span><span class="sxs-lookup"><span data-stu-id="30a98-163">![Queue with transactions](../../../../docs/framework/wcf/feature-details/media/qwithtransactions-figure3.gif "QWithTransactions-Figure3")</span></span>  
  
 <span data-ttu-id="30a98-164">排队通信，其中分别显示了捕获和传送事务</span><span class="sxs-lookup"><span data-stu-id="30a98-164">Queued communication showing separate transactions for capture and delivery</span></span>  
  
 <span data-ttu-id="30a98-165">客户端事务处理并发送消息。</span><span class="sxs-lookup"><span data-stu-id="30a98-165">The client transaction processes and sends the message.</span></span> <span data-ttu-id="30a98-166">提交事务时，消息位于传输队列。</span><span class="sxs-lookup"><span data-stu-id="30a98-166">When the transaction is committed, the message is in the transmission queue.</span></span> <span data-ttu-id="30a98-167">在服务上，事务读取来自目标队列的消息，处理消息，然后提交事务。</span><span class="sxs-lookup"><span data-stu-id="30a98-167">On the service, the transaction reads the message from the target queue, processes the message, and then commits the transaction.</span></span> <span data-ttu-id="30a98-168">如果在处理期间发生错误，则消息将被回滚并置于目标队列中。</span><span class="sxs-lookup"><span data-stu-id="30a98-168">If an error occurs during the processing, the message is rolled back and placed in the target queue.</span></span>  
  
## <a name="asynchronous-communication-using-queues"></a><span data-ttu-id="30a98-169">使用队列的异步通信</span><span class="sxs-lookup"><span data-stu-id="30a98-169">Asynchronous Communication Using Queues</span></span>  
 <span data-ttu-id="30a98-170">队列提供一个异步通信的方法。</span><span class="sxs-lookup"><span data-stu-id="30a98-170">Queues provide an asynchronous means of communication.</span></span> <span data-ttu-id="30a98-171">由于队列管理器引起的高延迟，使用队列发送消息的应用程序无法等待接收方要接收并处理的消息。</span><span class="sxs-lookup"><span data-stu-id="30a98-171">Applications that send messages using queues cannot wait for the message to be received and processed by the receiver because of high latency introduced by the queue manager.</span></span> <span data-ttu-id="30a98-172">消息保留在队列中的时间可能远长于应用程序期望的时间。</span><span class="sxs-lookup"><span data-stu-id="30a98-172">Messages can remain in the queue for a far longer time than the application intended.</span></span> <span data-ttu-id="30a98-173">为了避免这种情况发生，应用程序可以为消息指定一个生存时间值。</span><span class="sxs-lookup"><span data-stu-id="30a98-173">To avoid this, the application can specify a Time-To-Live value on the message.</span></span> <span data-ttu-id="30a98-174">此值指定消息应该保留在传输队列中的时间。</span><span class="sxs-lookup"><span data-stu-id="30a98-174">This value specifies how long the message should remain in the transmission queue.</span></span> <span data-ttu-id="30a98-175">如果超出了此时间值，而消息仍然未发送至目标队列，则可以将消息传输到死信队列。</span><span class="sxs-lookup"><span data-stu-id="30a98-175">If this time value is exceeded, and the message still has not been sent to the target queue, the message can be transferred to a dead-letter queue.</span></span>  
  
 <span data-ttu-id="30a98-176">当发送方发送消息时，来自发送操作的返回表示消息只能被传送到发送方的传输队列中。</span><span class="sxs-lookup"><span data-stu-id="30a98-176">When the sender sends a message, the return from the send operation implies that the message only made it to the transmission queue on the sender.</span></span> <span data-ttu-id="30a98-177">因此，如果在将消息传送至目标队列时失败，则发送应用程序不能立即知道该情况。</span><span class="sxs-lookup"><span data-stu-id="30a98-177">As such, if there is a failure in getting the message to the target queue, the sending application cannot know about it immediately.</span></span> <span data-ttu-id="30a98-178">为了记录这些失败情况，失败消息将被传输到死信队列中。</span><span class="sxs-lookup"><span data-stu-id="30a98-178">To take note of such failures, the failed message is transferred to a dead-letter queue.</span></span>  
  
 <span data-ttu-id="30a98-179">任何错误，例如消息无法到达目标队列或生存时间即将过期，都必须单独处理。</span><span class="sxs-lookup"><span data-stu-id="30a98-179">Any error, such as a message failing to reach the target queue or the Time-To-Live expiring, must be processed separately.</span></span> <span data-ttu-id="30a98-180">因此通常情况下，排队应用程序会写入两组逻辑：</span><span class="sxs-lookup"><span data-stu-id="30a98-180">It is not uncommon, therefore, for queued applications to write two sets of logic:</span></span>  
  
-   <span data-ttu-id="30a98-181">发送和接收消息的普通客户端和服务逻辑。</span><span class="sxs-lookup"><span data-stu-id="30a98-181">The normal client and service logic of sending and receiving messages.</span></span>  
  
-   <span data-ttu-id="30a98-182">处理失败传输或传送中的消息的补偿逻辑。</span><span class="sxs-lookup"><span data-stu-id="30a98-182">Compensation logic to handle messages from the failed transmission or delivery.</span></span>  
  
 <span data-ttu-id="30a98-183">下面的部分讨论以下概念。</span><span class="sxs-lookup"><span data-stu-id="30a98-183">The following sections discuss these concepts.</span></span>  
  
## <a name="dead-letter-queue-programming"></a><span data-ttu-id="30a98-184">死信队列编程</span><span class="sxs-lookup"><span data-stu-id="30a98-184">Dead-Letter Queue Programming</span></span>  
 <span data-ttu-id="30a98-185">死信队列包含由于各种原因无法到达目标队列的消息。</span><span class="sxs-lookup"><span data-stu-id="30a98-185">Dead-letter queues contain messages that failed to reach the target queue for various reasons.</span></span> <span data-ttu-id="30a98-186">原因可能是消息过期、阻止消息传输到目标队列的连接问题等各种原因。</span><span class="sxs-lookup"><span data-stu-id="30a98-186">The reasons can range from expired messages to connectivity issues preventing transfer of the message to the target queue.</span></span>  
  
 <span data-ttu-id="30a98-187">通常情况下，应用程序可以从系统级死信队列中读取消息以确定发生了什么错误，并执行适当的操作，例如更正错误并重新发送消息或者记录该消息。</span><span class="sxs-lookup"><span data-stu-id="30a98-187">Typically, an application can read messages from a system-wide dead-letter queue, determine what went wrong, and take appropriate action, such as correcting the errors and resending the message or taking note of it.</span></span>  
  
## <a name="poison-message-queue-programming"></a><span data-ttu-id="30a98-188">病毒消息队列编程</span><span class="sxs-lookup"><span data-stu-id="30a98-188">Poison Message Queue Programming</span></span>  
 <span data-ttu-id="30a98-189">在将消息传送到目标队列后，服务在处理该消息时可能会反复出现故障。</span><span class="sxs-lookup"><span data-stu-id="30a98-189">After a message makes it to the target queue, the service may repeatedly fail to process the message.</span></span> <span data-ttu-id="30a98-190">例如，从事务的队列中读取消息和更新数据库的应用程序可能会发现数据库暂时已断开连接。</span><span class="sxs-lookup"><span data-stu-id="30a98-190">For example, an application reading a message from the queue under a transaction and updating a database may find the database temporarily disconnected.</span></span> <span data-ttu-id="30a98-191">在这种情况下，事务将回滚，会创建一个新的事务，并从队列中重新读取消息。</span><span class="sxs-lookup"><span data-stu-id="30a98-191">In this case, the transaction is rolled back, a new transaction is created, and the message is reread from the queue.</span></span> <span data-ttu-id="30a98-192">第二次尝试可能成功，也可能失败。</span><span class="sxs-lookup"><span data-stu-id="30a98-192">A second attempt may succeed or fail.</span></span> <span data-ttu-id="30a98-193">在某些情况下，根据错误产生的原因，消息传送到应用程序时可能会反复出现故障。</span><span class="sxs-lookup"><span data-stu-id="30a98-193">In some cases, depending on the cause of the error, the message may repeatedly fail delivery to the application.</span></span> <span data-ttu-id="30a98-194">在这种情况下，该消息被认为是“病毒”。</span><span class="sxs-lookup"><span data-stu-id="30a98-194">In this case, the message is deemed as "poison."</span></span> <span data-ttu-id="30a98-195">这些消息将移动到可以通过病毒处理应用程序读取的病毒队列中。</span><span class="sxs-lookup"><span data-stu-id="30a98-195">Such messages are moved to a poison queue that can be read by a poison-handling application.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="30a98-196">请参阅</span><span class="sxs-lookup"><span data-stu-id="30a98-196">See Also</span></span>  
 [<span data-ttu-id="30a98-197">在 WCF 中排队</span><span class="sxs-lookup"><span data-stu-id="30a98-197">Queuing in WCF</span></span>](../../../../docs/framework/wcf/feature-details/queuing-in-wcf.md)  
 [<span data-ttu-id="30a98-198">在 WCF 中排队</span><span class="sxs-lookup"><span data-stu-id="30a98-198">Queuing in WCF</span></span>](../../../../docs/framework/wcf/feature-details/queuing-in-wcf.md)  
 [<span data-ttu-id="30a98-199">会话和队列</span><span class="sxs-lookup"><span data-stu-id="30a98-199">Sessions and Queues</span></span>](../../../../docs/framework/wcf/samples/sessions-and-queues.md)  
 [<span data-ttu-id="30a98-200">死信队列</span><span class="sxs-lookup"><span data-stu-id="30a98-200">Dead Letter Queues</span></span>](../../../../docs/framework/wcf/samples/dead-letter-queues.md)  
 [<span data-ttu-id="30a98-201">可变排队通信</span><span class="sxs-lookup"><span data-stu-id="30a98-201">Volatile Queued Communication</span></span>](../../../../docs/framework/wcf/samples/volatile-queued-communication.md)  
 [<span data-ttu-id="30a98-202">Windows Communication Foundation 到消息队列</span><span class="sxs-lookup"><span data-stu-id="30a98-202">Windows Communication Foundation to Message Queuing</span></span>](../../../../docs/framework/wcf/samples/wcf-to-message-queuing.md)  
 [<span data-ttu-id="30a98-203">安装消息队列 (MSMQ)</span><span class="sxs-lookup"><span data-stu-id="30a98-203">Installing Message Queuing (MSMQ)</span></span>](../../../../docs/framework/wcf/samples/installing-message-queuing-msmq.md)  
 [<span data-ttu-id="30a98-204">消息队列集成绑定示例</span><span class="sxs-lookup"><span data-stu-id="30a98-204">Message Queuing Integration Binding Samples</span></span>](http://msdn.microsoft.com/library/997d11cb-f2c5-4ba0-9209-92843d4d0e1a)  
 [<span data-ttu-id="30a98-205">到 Windows Communication Foundation 的消息队列</span><span class="sxs-lookup"><span data-stu-id="30a98-205">Message Queuing to Windows Communication Foundation</span></span>](../../../../docs/framework/wcf/samples/message-queuing-to-wcf.md)  
 [<span data-ttu-id="30a98-206">基于消息队列的消息安全性</span><span class="sxs-lookup"><span data-stu-id="30a98-206">Message Security over Message Queuing</span></span>](../../../../docs/framework/wcf/samples/message-security-over-message-queuing.md)
