---
title: "数据传输体系结构概述"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords: data transfer [WCF], architectural overview
ms.assetid: 343c2ca2-af53-4936-a28c-c186b3524ee9
caps.latest.revision: "14"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.openlocfilehash: 7ef0886fe5319d2ddd8c4c4be1b61f629f2aa6f4
ms.sourcegitcommit: ce279f2d7fe2220e6ea0a25a8a7a5370ddf8d9f0
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/02/2017
---
# <a name="data-transfer-architectural-overview"></a><span data-ttu-id="455da-102">数据传输体系结构概述</span><span class="sxs-lookup"><span data-stu-id="455da-102">Data Transfer Architectural Overview</span></span>
<span data-ttu-id="455da-103">可以将[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] 视为一种消息传递基础结构。</span><span class="sxs-lookup"><span data-stu-id="455da-103">[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] can be thought of as a messaging infrastructure.</span></span> <span data-ttu-id="455da-104">它可以接收消息，处理消息，根据用户代码调度消息以便进一步操作，或者从用户代码给定的数据构造消息并将消息发送到目标。</span><span class="sxs-lookup"><span data-stu-id="455da-104">It can receive messages, process them, and dispatch them to user code for further action, or it can construct messages from data given by user code and deliver them to a destination.</span></span> <span data-ttu-id="455da-105">本主题旨在向高级开发人员说明用于处理消息和所包含数据的体系结构。</span><span class="sxs-lookup"><span data-stu-id="455da-105">This topic, which is intended for advanced developers, describes the architecture for handling messages and the contained data.</span></span> <span data-ttu-id="455da-106">有关如何发送和接收数据的面向任务的更简单介绍，请参阅 [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)。</span><span class="sxs-lookup"><span data-stu-id="455da-106">For a simpler, task-oriented view of how to send and receive data, see [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="455da-107">本主题讨论通过检查 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 对象模型所看不到的 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 实现详细信息。</span><span class="sxs-lookup"><span data-stu-id="455da-107">This topic discusses [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] implementation details that are not visible by examining the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] object model.</span></span> <span data-ttu-id="455da-108">对于有记载的实现详细信息，请记住两点。</span><span class="sxs-lookup"><span data-stu-id="455da-108">Two words of caution are in order with regard to documented implementation details.</span></span> <span data-ttu-id="455da-109">首先，说明非常简单；由于优化或其他原因，实际实现可能更复杂。</span><span class="sxs-lookup"><span data-stu-id="455da-109">First, the descriptions are simplified; actual implementation may be more complex due to optimizations or other reasons.</span></span> <span data-ttu-id="455da-110">其次，切勿依赖于特定的实现详细信息（即使是已记载的详细信息），因为这些信息在版本之间，甚至在服务发行过程中有可能在不另行通知的情况下发生更改。</span><span class="sxs-lookup"><span data-stu-id="455da-110">Second, you should never rely on specific implementation details, even documented ones, because these may change without notice from version to version or even in a servicing release.</span></span>  
  
## <a name="basic-architecture"></a><span data-ttu-id="455da-111">基本体系结构</span><span class="sxs-lookup"><span data-stu-id="455da-111">Basic Architecture</span></span>  
 <span data-ttu-id="455da-112">核心[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]消息处理功能是<xref:System.ServiceModel.Channels.Message>类，该类中详细描述[使用 Message 类](../../../../docs/framework/wcf/feature-details/using-the-message-class.md)。</span><span class="sxs-lookup"><span data-stu-id="455da-112">At the core of [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] message-handling capabilities is the <xref:System.ServiceModel.Channels.Message> class, which is described in detail in [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).</span></span> <span data-ttu-id="455da-113">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 的运行时组件可分为两个主要部分：通道堆栈和服务框架，其间使用 <xref:System.ServiceModel.Channels.Message> 类作为连接点。</span><span class="sxs-lookup"><span data-stu-id="455da-113">The run-time components of [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] can be divided into two major parts: the channel stack and the service framework, with the <xref:System.ServiceModel.Channels.Message> class being the connection point.</span></span>  
  
 <span data-ttu-id="455da-114">通道堆栈负责在有效的 <xref:System.ServiceModel.Channels.Message> 实例和对应于发送或接收消息数据的某种操作之间进行转换。</span><span class="sxs-lookup"><span data-stu-id="455da-114">The channel stack is responsible for converting between a valid <xref:System.ServiceModel.Channels.Message> instance and some action that corresponds to the sending or receiving of message data.</span></span> <span data-ttu-id="455da-115">在发送端，通道堆栈采用有效的 <xref:System.ServiceModel.Channels.Message> 实例，经过一些处理后，执行逻辑上对应于发送消息的某种操作。</span><span class="sxs-lookup"><span data-stu-id="455da-115">On the sending side, the channel stack takes a valid <xref:System.ServiceModel.Channels.Message> instance and, after some processing, performs some action that logically corresponds to sending the message.</span></span> <span data-ttu-id="455da-116">该操作可能是发送 TCP 或 HTTP 数据包、让消息在消息队列中排队、将消息写入数据库、将消息保存到文件共享或其他任何操作，具体取决于实现。</span><span class="sxs-lookup"><span data-stu-id="455da-116">The action may be sending TCP or HTTP packets, queuing the message in Message Queuing, writing the message to a database, saving it to a file share, or any other action, depending on the implementation.</span></span> <span data-ttu-id="455da-117">最常见的操作是通过网络协议发送消息。</span><span class="sxs-lookup"><span data-stu-id="455da-117">The most common action is sending the message over a network protocol.</span></span> <span data-ttu-id="455da-118">在接收端发生相反的情况：检测操作（可能是 TCP 或 HTTP 数据包接收操作或任何其他操作），处理后，通道堆栈将此操作转换为有效的 <xref:System.ServiceModel.Channels.Message> 实例。</span><span class="sxs-lookup"><span data-stu-id="455da-118">On the receive side, the opposite happens—an action is detected (which may be TCP or HTTP packets arriving or any other action), and, after processing, the channel stack converts this action into a valid <xref:System.ServiceModel.Channels.Message> instance.</span></span>  
  
 <span data-ttu-id="455da-119">可以通过直接使用 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 类和通道堆栈来使用 <xref:System.ServiceModel.Channels.Message> 。</span><span class="sxs-lookup"><span data-stu-id="455da-119">You can use [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] by using the <xref:System.ServiceModel.Channels.Message> class and the channel stack directly.</span></span> <span data-ttu-id="455da-120">但是，这样做很麻烦且很费时。</span><span class="sxs-lookup"><span data-stu-id="455da-120">However, doing so is difficult and time-consuming.</span></span> <span data-ttu-id="455da-121">另外， <xref:System.ServiceModel.Channels.Message> 对象不提供元数据支持，因此如果您以这种方式使用 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] ，则不能生成强类型的 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 客户端。</span><span class="sxs-lookup"><span data-stu-id="455da-121">Additionally, the <xref:System.ServiceModel.Channels.Message> object provides no metadata support, so you cannot generate strongly typed [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] clients if you use [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] in this manner.</span></span>  
  
 <span data-ttu-id="455da-122">因此， [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 包括了一个提供易于使用的编程模型的服务框架，您可以使用该框架构造和接收 `Message` 对象。</span><span class="sxs-lookup"><span data-stu-id="455da-122">Therefore, [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] includes a service framework that provides an easy-to-use programming model that you can use to construct and receive `Message` objects.</span></span> <span data-ttu-id="455da-123">服务框架通过服务协定概念将服务映射到 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 类型，并将消息调度给用户操作，而用户操作只不过是由 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 属性标记的 <xref:System.ServiceModel.OperationContractAttribute> 方法（有关更多详细信息，请参阅 [Designing Service Contracts](../../../../docs/framework/wcf/designing-service-contracts.md)）。</span><span class="sxs-lookup"><span data-stu-id="455da-123">The service framework maps services to [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] types through the notion of service contracts, and dispatches messages to user operations that are simply [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] methods marked with the <xref:System.ServiceModel.OperationContractAttribute> attribute (for more details, see [Designing Service Contracts](../../../../docs/framework/wcf/designing-service-contracts.md)).</span></span> <span data-ttu-id="455da-124">这些方法可能具有参数和返回值。</span><span class="sxs-lookup"><span data-stu-id="455da-124">These methods may have parameters and return values.</span></span> <span data-ttu-id="455da-125">在服务端，服务框架将传入的 <xref:System.ServiceModel.Channels.Message> 实例转换为参数，并将返回值转换为传出的 <xref:System.ServiceModel.Channels.Message> 实例。</span><span class="sxs-lookup"><span data-stu-id="455da-125">On the service side, the service framework converts incoming <xref:System.ServiceModel.Channels.Message> instances into parameters and converts return values into outgoing <xref:System.ServiceModel.Channels.Message> instances.</span></span> <span data-ttu-id="455da-126">在客户端，执行相反的操作。</span><span class="sxs-lookup"><span data-stu-id="455da-126">On the client side, it does the opposite.</span></span> <span data-ttu-id="455da-127">例如，考虑下面的 `FindAirfare` 操作。</span><span class="sxs-lookup"><span data-stu-id="455da-127">For example, consider the `FindAirfare` operation below.</span></span>  
  
 [!code-csharp[c_DataArchitecture#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#1)]
 [!code-vb[c_DataArchitecture#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#1)]  
  
 <span data-ttu-id="455da-128">假设在客户端上调用了 `FindAirfare` 。</span><span class="sxs-lookup"><span data-stu-id="455da-128">Suppose `FindAirfare` is called on the client.</span></span> <span data-ttu-id="455da-129">客户端上的服务框架会将 `FromCity` 和 `ToCity` 参数转换为传出的 <xref:System.ServiceModel.Channels.Message> 实例并将该实例传递到通道堆栈以便发送。</span><span class="sxs-lookup"><span data-stu-id="455da-129">The service framework on the client converts the `FromCity` and `ToCity` parameters into an outgoing <xref:System.ServiceModel.Channels.Message> instance and passes it to the channel stack to be sent.</span></span>  
  
 <span data-ttu-id="455da-130">在服务端，来自通道堆栈的 <xref:System.ServiceModel.Channels.Message> 实例到达时，服务框架会从消息中提取相关数据来填充 `FromCity` 和 `ToCity` 参数，然后调用服务端 `FindAirfare` 方法。</span><span class="sxs-lookup"><span data-stu-id="455da-130">On the service side, when a <xref:System.ServiceModel.Channels.Message> instance arrives from the channel stack, the service framework extracts the relevant data from the message to populate the `FromCity` and `ToCity` parameters and then calls the service-side `FindAirfare` method.</span></span> <span data-ttu-id="455da-131">该方法返回时，服务框架会采用返回的整数值和 `IsDirectFlight` 输出参数，并创建一个包含此信息的 <xref:System.ServiceModel.Channels.Message> 对象实例。</span><span class="sxs-lookup"><span data-stu-id="455da-131">When the method returns, the service framework takes the returned integer value and the `IsDirectFlight` output parameter and creates a <xref:System.ServiceModel.Channels.Message> object instance that contains this information.</span></span> <span data-ttu-id="455da-132">然后，服务框架会将 `Message` 实例传递到通道堆栈以便发回到客户端。</span><span class="sxs-lookup"><span data-stu-id="455da-132">It then passes the `Message` instance to the channel stack to be sent back to the client.</span></span>  
  
 <span data-ttu-id="455da-133">在客户端，包含响应消息的 <xref:System.ServiceModel.Channels.Message> 实例会从通道堆栈中显现出来。</span><span class="sxs-lookup"><span data-stu-id="455da-133">On the client side, a <xref:System.ServiceModel.Channels.Message> instance that contains the response message emerges from the channel stack.</span></span> <span data-ttu-id="455da-134">服务框架会提取返回值和 `IsDirectFlight` 值并将这些值返回到客户端的调用方。</span><span class="sxs-lookup"><span data-stu-id="455da-134">The service framework extracts the return value and the `IsDirectFlight` value and returns these to the caller of the client.</span></span>  
  
## <a name="message-class"></a><span data-ttu-id="455da-135">Message 类</span><span class="sxs-lookup"><span data-stu-id="455da-135">Message Class</span></span>  
 <span data-ttu-id="455da-136"><xref:System.ServiceModel.Channels.Message> 类用作消息的抽象表示形式，但其设计在很大程度上依赖于 SOAP 消息。</span><span class="sxs-lookup"><span data-stu-id="455da-136">The <xref:System.ServiceModel.Channels.Message> class is intended to be an abstract representation of a message, but its design is strongly tied to the SOAP message.</span></span> <span data-ttu-id="455da-137"><xref:System.ServiceModel.Channels.Message> 包含三个主要信息部分：消息正文、消息头和消息属性。</span><span class="sxs-lookup"><span data-stu-id="455da-137">A <xref:System.ServiceModel.Channels.Message> contains three major pieces of information: a message body, message headers, and message properties.</span></span>  
  
## <a name="message-body"></a><span data-ttu-id="455da-138">消息正文</span><span class="sxs-lookup"><span data-stu-id="455da-138">Message Body</span></span>  
 <span data-ttu-id="455da-139">消息正文用于表示消息的实际数据负载。</span><span class="sxs-lookup"><span data-stu-id="455da-139">The message body is intended to represent the actual data payload of the message.</span></span> <span data-ttu-id="455da-140">消息正文始终表示为 XML Infoset。</span><span class="sxs-lookup"><span data-stu-id="455da-140">The message body is always represented as an XML Infoset.</span></span> <span data-ttu-id="455da-141">这并不意味着在 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 中创建或接收的所有消息都必须为 XML 格式。</span><span class="sxs-lookup"><span data-stu-id="455da-141">This does not mean that all messages created or received in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] must be in XML format.</span></span> <span data-ttu-id="455da-142">这要由通道堆栈来确定如何解释消息正文。</span><span class="sxs-lookup"><span data-stu-id="455da-142">It is up to the channel stack to decide how to interpret the message body.</span></span> <span data-ttu-id="455da-143">通道堆栈可能会将消息正文作为 XML 发出、将转换为某种其他格式，甚至可能会完全忽略该消息正文。</span><span class="sxs-lookup"><span data-stu-id="455da-143">It may emit it as XML, convert it to some other format, or even omit it entirely.</span></span> <span data-ttu-id="455da-144">当然，对于 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 提供的大多数绑定，消息正文在 SOAP 信封的正文部分中都表示为 XML 内容。</span><span class="sxs-lookup"><span data-stu-id="455da-144">Of course, with most of the bindings [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] supplies, the message body is represented as XML content in the body section of a SOAP envelope.</span></span>  
  
 <span data-ttu-id="455da-145">必须认识到的是， `Message` 类并不一定对表示正文的 XML 数据包含缓冲区。</span><span class="sxs-lookup"><span data-stu-id="455da-145">It is important to realize that the `Message` class does not necessarily contain a buffer with XML data representing the body.</span></span> <span data-ttu-id="455da-146">从逻辑上说， `Message` 包含 XML Infoset，但可以动态构造此 Infoset，因此它可能永远也不会实际存在于内存中。</span><span class="sxs-lookup"><span data-stu-id="455da-146">Logically, `Message` contains an XML Infoset, but this Infoset may be dynamically constructed and may never physically exist in memory.</span></span>  
  
### <a name="putting-data-into-the-message-body"></a><span data-ttu-id="455da-147">将数据放入消息正文</span><span class="sxs-lookup"><span data-stu-id="455da-147">Putting Data into the Message Body</span></span>  
 <span data-ttu-id="455da-148">将数据放入消息正文并没有统一的机制。</span><span class="sxs-lookup"><span data-stu-id="455da-148">There is no uniform mechanism to put data into a message body.</span></span> <span data-ttu-id="455da-149"><xref:System.ServiceModel.Channels.Message> 类有一个抽象方法 <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29>，该方法采用 <xref:System.Xml.XmlDictionaryWriter>。</span><span class="sxs-lookup"><span data-stu-id="455da-149">The <xref:System.ServiceModel.Channels.Message> class has an abstract method, <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, which takes an <xref:System.Xml.XmlDictionaryWriter>.</span></span> <span data-ttu-id="455da-150"><xref:System.ServiceModel.Channels.Message> 类的每个子类负责重写此方法并写出其自己的内容。</span><span class="sxs-lookup"><span data-stu-id="455da-150">Each subclass of the <xref:System.ServiceModel.Channels.Message> class is responsible for overriding this method and writing out its own contents.</span></span> <span data-ttu-id="455da-151">消息正文逻辑上包含 `OnWriteBodyContent` 生成的 XML Infoset。</span><span class="sxs-lookup"><span data-stu-id="455da-151">The message body logically contains the XML Infoset that `OnWriteBodyContent` produces.</span></span> <span data-ttu-id="455da-152">例如，考虑下面的 `Message` 子类。</span><span class="sxs-lookup"><span data-stu-id="455da-152">For example, consider the following `Message` subclass.</span></span>  
  
 [!code-csharp[c_DataArchitecture#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#2)]
 [!code-vb[c_DataArchitecture#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#2)]  
  
 <span data-ttu-id="455da-153">实际上，一个 `AirfareRequestMessage` 实例仅包含两个字符串（“fromCity”和“toCity”）。</span><span class="sxs-lookup"><span data-stu-id="455da-153">Physically, an `AirfareRequestMessage` instance contains only two strings ("fromCity" and "toCity").</span></span> <span data-ttu-id="455da-154">但在逻辑上，消息中包含的是下面的 XML Infoset：</span><span class="sxs-lookup"><span data-stu-id="455da-154">However, logically the message contains the following XML infoset:</span></span>  
  
```xml  
<airfareRequest>  
    <from>Tokyo</from>  
    <to>London</to>  
</airfareRequest>  
```  
  
 <span data-ttu-id="455da-155">当然，您通常不会用这种方式创建消息，因为您可以使用服务框架从操作协定参数创建诸如前面的消息。</span><span class="sxs-lookup"><span data-stu-id="455da-155">Of course, you would normally not create messages in this manner, because you can use the service framework to create a message like the preceding one from operation contract parameters.</span></span> <span data-ttu-id="455da-156">另外， <xref:System.ServiceModel.Channels.Message> 类具有静态 `CreateMessage` 方法，您可以使用此方法创建具有常见内容类型的消息：空消息、包含用 <xref:System.Runtime.Serialization.DataContractSerializer>序列化为 XML 的对象的消息、包含 SOAP 错误的消息、包含由 <xref:System.Xml.XmlReader>表示的 XML 的消息等。</span><span class="sxs-lookup"><span data-stu-id="455da-156">Additionally, the <xref:System.ServiceModel.Channels.Message> class has static `CreateMessage` methods that you can use to create messages with common types of content: an empty message, a message that contains an object serialized to XML with the <xref:System.Runtime.Serialization.DataContractSerializer>, a message that contains a SOAP fault, a message that contains XML represented by an <xref:System.Xml.XmlReader>, and so on.</span></span>  
  
### <a name="getting-data-from-a-message-body"></a><span data-ttu-id="455da-157">从消息正文获取数据</span><span class="sxs-lookup"><span data-stu-id="455da-157">Getting Data from a Message Body</span></span>  
 <span data-ttu-id="455da-158">可以采用两种主要方式提取消息正文中存储的数据：</span><span class="sxs-lookup"><span data-stu-id="455da-158">You can extract the data stored in a message body in two main ways:</span></span>  
  
-   <span data-ttu-id="455da-159">通过调用 <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> 方法并传入一个 XML 编写器，可以一次获取整个消息正文。</span><span class="sxs-lookup"><span data-stu-id="455da-159">You can get the entire message body at one time by calling the <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> method and passing in an XML writer.</span></span> <span data-ttu-id="455da-160">完整的消息正文会写出到此编写器中。</span><span class="sxs-lookup"><span data-stu-id="455da-160">The complete message body is written out to this writer.</span></span> <span data-ttu-id="455da-161">一次获取整个消息正文也称为“写入消息” 。</span><span class="sxs-lookup"><span data-stu-id="455da-161">Getting the entire message body at one time is also called *writing a message*.</span></span> <span data-ttu-id="455da-162">编写主要由通道堆栈在发送消息时完成：通道堆栈的某些部分通常会访问整个消息正文、进行编码，然后发送整个消息正文。</span><span class="sxs-lookup"><span data-stu-id="455da-162">Writing is done primarily by the channel stack when sending messages—some part of the channel stack will usually get access to the entire message body, encode it, and send it.</span></span>  
  
-   <span data-ttu-id="455da-163">从消息正文获取信息的另一种方式是调用 <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> 并获取一个 XML 读取器。</span><span class="sxs-lookup"><span data-stu-id="455da-163">Another way to get information out of the message body is to call <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> and get an XML reader.</span></span> <span data-ttu-id="455da-164">之后可以通过在读取器上调用方法，根据需要按顺序访问消息正文。</span><span class="sxs-lookup"><span data-stu-id="455da-164">The message body can then be accessed sequentially as needed by calling methods on the reader.</span></span> <span data-ttu-id="455da-165">逐段获取消息正文也称为“读取消息” 。</span><span class="sxs-lookup"><span data-stu-id="455da-165">Getting the message body piece-by-piece is also called *reading a message*.</span></span> <span data-ttu-id="455da-166">读取消息主要由服务框架在接收消息时使用。</span><span class="sxs-lookup"><span data-stu-id="455da-166">Reading the message is primarily used by the service framework when receiving messages.</span></span> <span data-ttu-id="455da-167">例如，使用 <xref:System.Runtime.Serialization.DataContractSerializer> 时，服务框架将使用 XML 读取器获取消息正文并将其传递给反序列化引擎，之后，反序列化引擎将开始逐元素地读取消息并构造相应对象图。</span><span class="sxs-lookup"><span data-stu-id="455da-167">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> is in use, the service framework will get an XML reader over the body and pass it to the deserialization engine, which will then start reading the message element-by-element and constructing the corresponding object graph.</span></span>  
  
 <span data-ttu-id="455da-168">消息正文只能检索一次。</span><span class="sxs-lookup"><span data-stu-id="455da-168">A message body can be retrieved only once.</span></span> <span data-ttu-id="455da-169">这为使用只进流提供了可能。</span><span class="sxs-lookup"><span data-stu-id="455da-169">This makes it possible to work with forward-only streams.</span></span> <span data-ttu-id="455da-170">例如，您可以写入一个从 <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> 读取数据的 <xref:System.IO.FileStream> 重写，并以 XML Infoset 形式返回结果。</span><span class="sxs-lookup"><span data-stu-id="455da-170">For example, you can write an <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> override that reads from a <xref:System.IO.FileStream> and returns the results as an XML Infoset.</span></span> <span data-ttu-id="455da-171">你将永远不会需要"后退"到文件的开头。</span><span class="sxs-lookup"><span data-stu-id="455da-171">You will never need to "rewind" to the beginning of the file.</span></span>  
  
 <span data-ttu-id="455da-172">`WriteBodyContents` 和 `GetReaderAtBodyContents` 方法只检查以前是否从未检索过该消息正文，然后分别调用 `OnWriteBodyContents` 或 `OnGetReaderAtBodyContents`。</span><span class="sxs-lookup"><span data-stu-id="455da-172">The `WriteBodyContents` and `GetReaderAtBodyContents` methods simply check that the message body has never been retrieved before, and then call `OnWriteBodyContents` or `OnGetReaderAtBodyContents`, respectively.</span></span>  
  
## <a name="message-usage-in-wcf"></a><span data-ttu-id="455da-173">WCF 中的消息用法</span><span class="sxs-lookup"><span data-stu-id="455da-173">Message Usage in WCF</span></span>  
 <span data-ttu-id="455da-174">大多数消息都可以分类为传出消息  （由服务框架创建并由通道堆栈发送的消息）或传入消息  （来自通道堆栈并由服务框架解释的消息）。</span><span class="sxs-lookup"><span data-stu-id="455da-174">Most messages can be classified as either *outgoing* (those that are created by the service framework to be sent by the channel stack) or *incoming* (those that arrive from the channel stack and are interpreted by the service framework).</span></span> <span data-ttu-id="455da-175">而且，通道堆栈可以以缓冲模式或流模式操作。</span><span class="sxs-lookup"><span data-stu-id="455da-175">Furthermore, the channel stack can operate in either buffered or streaming mode.</span></span> <span data-ttu-id="455da-176">服务框架还可以公开流处理或非流处理的编程模型。</span><span class="sxs-lookup"><span data-stu-id="455da-176">The service framework may also expose a streamed or nonstreamed programming model.</span></span> <span data-ttu-id="455da-177">下表列出了可能出现的各种情况，并提供了有关其实现的简单说明。</span><span class="sxs-lookup"><span data-stu-id="455da-177">This leads to the cases listed in the following table, along with simplified details of their implementation.</span></span>  
  
|<span data-ttu-id="455da-178">消息类型</span><span class="sxs-lookup"><span data-stu-id="455da-178">Message type</span></span>|<span data-ttu-id="455da-179">消息中的正文数据</span><span class="sxs-lookup"><span data-stu-id="455da-179">Body data in message</span></span>|<span data-ttu-id="455da-180">写入 (OnWriteBodyContents) 实现</span><span class="sxs-lookup"><span data-stu-id="455da-180">Write (OnWriteBodyContents) implementation</span></span>|<span data-ttu-id="455da-181">读取 (OnGetReaderAtBodyContents) 实现</span><span class="sxs-lookup"><span data-stu-id="455da-181">Read (OnGetReaderAtBodyContents) Implementation</span></span>|  
|------------------|--------------------------|--------------------------------------------------|-------------------------------------------------------|  
|<span data-ttu-id="455da-182">传出，从非流处理编程模型创建</span><span class="sxs-lookup"><span data-stu-id="455da-182">Outgoing, created from nonstreamed programming model</span></span>|<span data-ttu-id="455da-183">写入消息所需的数据（例如，序列化消息所需的对象和 <xref:System.Runtime.Serialization.DataContractSerializer> 实例）*</span><span class="sxs-lookup"><span data-stu-id="455da-183">The data needed to write the message (for example, an object and the <xref:System.Runtime.Serialization.DataContractSerializer> instance needed to serialize it)*</span></span>|<span data-ttu-id="455da-184">用于基于存储的数据写出消息的自定义逻辑（例如，在使用的序列化程序 `WriteObject` 上调用 `DataContractSerializer` ）*</span><span class="sxs-lookup"><span data-stu-id="455da-184">Custom logic to write out the message based on the stored data (for example, call `WriteObject` on the `DataContractSerializer` if that is the serializer in use)*</span></span>|<span data-ttu-id="455da-185">调用 `OnWriteBodyContents`，缓冲结果，通过缓冲区返回 XML 读取器</span><span class="sxs-lookup"><span data-stu-id="455da-185">Call `OnWriteBodyContents`, buffer the results, return an XML reader over the buffer</span></span>|  
|<span data-ttu-id="455da-186">传出，从流处理编程模型创建</span><span class="sxs-lookup"><span data-stu-id="455da-186">Outgoing, created from streamed programming model</span></span>|<span data-ttu-id="455da-187">具有要写入数据的 `Stream` *</span><span class="sxs-lookup"><span data-stu-id="455da-187">The `Stream` with the data to be written*</span></span>|<span data-ttu-id="455da-188">使用 <xref:System.Xml.IStreamProvider> 机制从存储的流中写出数据*</span><span class="sxs-lookup"><span data-stu-id="455da-188">Write out data from the stored stream using the <xref:System.Xml.IStreamProvider> mechanism*</span></span>|<span data-ttu-id="455da-189">调用 `OnWriteBodyContents`，缓冲结果，通过缓冲区返回 XML 读取器</span><span class="sxs-lookup"><span data-stu-id="455da-189">Call `OnWriteBodyContents`, buffer the results, return an XML reader over the buffer</span></span>|  
|<span data-ttu-id="455da-190">从流通道堆栈传入</span><span class="sxs-lookup"><span data-stu-id="455da-190">Incoming from streaming channel stack</span></span>|<span data-ttu-id="455da-191">一个 `Stream` 对象，表示通过网络传入的、具有 <xref:System.Xml.XmlReader> 的数据</span><span class="sxs-lookup"><span data-stu-id="455da-191">A `Stream` object that represents the data coming in over the network with an <xref:System.Xml.XmlReader> over it</span></span>|<span data-ttu-id="455da-192">使用 `XmlReader` 从存储的 `WriteNode`中写出内容</span><span class="sxs-lookup"><span data-stu-id="455da-192">Write out the contents from the stored `XmlReader` using `WriteNode`</span></span>|<span data-ttu-id="455da-193">返回存储的 `XmlReader`</span><span class="sxs-lookup"><span data-stu-id="455da-193">Returns the stored `XmlReader`</span></span>|  
|<span data-ttu-id="455da-194">从非流处理通道堆栈传入</span><span class="sxs-lookup"><span data-stu-id="455da-194">Incoming from nonstreaming channel stack</span></span>|<span data-ttu-id="455da-195">一个缓冲区，其中包含具有 `XmlReader` 的正文数据</span><span class="sxs-lookup"><span data-stu-id="455da-195">A buffer that contains body data with an `XmlReader` over it</span></span>|<span data-ttu-id="455da-196">使用 `XmlReader` 从存储的 `WriteNode`中写出内容</span><span class="sxs-lookup"><span data-stu-id="455da-196">Writes out the contents from the stored `XmlReader` using `WriteNode`</span></span>|<span data-ttu-id="455da-197">返回存储的 lang</span><span class="sxs-lookup"><span data-stu-id="455da-197">Returns the stored lang</span></span>|  
  
 <span data-ttu-id="455da-198">\*这些项并不直接在实现`Message`子类，但在的子类<xref:System.ServiceModel.Channels.BodyWriter>类。</span><span class="sxs-lookup"><span data-stu-id="455da-198">\* These items are not implemented directly in `Message` subclasses, but in subclasses of the <xref:System.ServiceModel.Channels.BodyWriter> class.</span></span> <span data-ttu-id="455da-199">有关 <xref:System.ServiceModel.Channels.BodyWriter>的详细信息，请参阅 [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md)。</span><span class="sxs-lookup"><span data-stu-id="455da-199">For more information about the <xref:System.ServiceModel.Channels.BodyWriter>, see [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).</span></span>  
  
## <a name="message-headers"></a><span data-ttu-id="455da-200">消息头</span><span class="sxs-lookup"><span data-stu-id="455da-200">Message Headers</span></span>  
 <span data-ttu-id="455da-201">消息可以包含标头。</span><span class="sxs-lookup"><span data-stu-id="455da-201">A message may contain headers.</span></span> <span data-ttu-id="455da-202">标头在逻辑上由与名称、命名空间和几个其他属性相关联的 XML Infoset 组成。</span><span class="sxs-lookup"><span data-stu-id="455da-202">A header logically consists of an XML Infoset that is associated with a name, a namespace, and a few other properties.</span></span> <span data-ttu-id="455da-203">在 `Headers` 上使用 <xref:System.ServiceModel.Channels.Message>属性可以访问消息头。</span><span class="sxs-lookup"><span data-stu-id="455da-203">Message headers are accessed using the `Headers` property on <xref:System.ServiceModel.Channels.Message>.</span></span> <span data-ttu-id="455da-204">每个标头由一个 <xref:System.ServiceModel.Channels.MessageHeader> 类表示。</span><span class="sxs-lookup"><span data-stu-id="455da-204">Each header is represented by a <xref:System.ServiceModel.Channels.MessageHeader> class.</span></span> <span data-ttu-id="455da-205">消息头通常在使用配置的通道堆栈处理 SOAP 消息时映射到 SOAP 消息头。</span><span class="sxs-lookup"><span data-stu-id="455da-205">Normally, message headers are mapped to SOAP message headers when using a channel stack configured to work with SOAP messages.</span></span>  
  
 <span data-ttu-id="455da-206">将信息放入消息头和从消息头中提取信息类似于使用消息正文。</span><span class="sxs-lookup"><span data-stu-id="455da-206">Putting information into a message header and extracting information from it is similar to using the message body.</span></span> <span data-ttu-id="455da-207">由于不支持流处理，因此过程有些简化。</span><span class="sxs-lookup"><span data-stu-id="455da-207">The process is somewhat simplified because streaming is not supported.</span></span> <span data-ttu-id="455da-208">可以多次访问同一个标头的内容，并且可以按任意顺序访问标头，强制标头始终进行缓冲。</span><span class="sxs-lookup"><span data-stu-id="455da-208">It is possible to access the contents of the same header more than once, and headers can be accessed in arbitrary order, forcing headers to always be buffered.</span></span> <span data-ttu-id="455da-209">虽然没有可用于通过标头获取 XML 读取器的通用机制，但是 `MessageHeader` 内部具有一个 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 子类，可表示具有此功能的可读标头。</span><span class="sxs-lookup"><span data-stu-id="455da-209">There is no general-purpose mechanism available to get an XML reader over a header, but there is a `MessageHeader` subclass internal to [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] that represents a readable header with such a capability.</span></span> <span data-ttu-id="455da-210">这种类型的 `MessageHeader` 是在传入具有自定义应用程序标头的消息时由通道堆栈创建的。</span><span class="sxs-lookup"><span data-stu-id="455da-210">This type of `MessageHeader` is created by the channel stack when a message with custom application headers comes in.</span></span> <span data-ttu-id="455da-211">它使服务框架能够使用反序列化引擎（如 <xref:System.Runtime.Serialization.DataContractSerializer>）来解释这些标头。</span><span class="sxs-lookup"><span data-stu-id="455da-211">This enables the service framework to use a deserialization engine, such as the <xref:System.Runtime.Serialization.DataContractSerializer>, to interpret these headers.</span></span>  
  
 [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="455da-212"> [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md)。</span><span class="sxs-lookup"><span data-stu-id="455da-212"> [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).</span></span>  
  
## <a name="message-properties"></a><span data-ttu-id="455da-213">消息属性</span><span class="sxs-lookup"><span data-stu-id="455da-213">Message Properties</span></span>  
 <span data-ttu-id="455da-214">消息可以包含属性。</span><span class="sxs-lookup"><span data-stu-id="455da-214">A message may contain properties.</span></span> <span data-ttu-id="455da-215">属性  是任何与字符串名称关联的 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 对象。</span><span class="sxs-lookup"><span data-stu-id="455da-215">A *property* is any [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] object that is associated with a string name.</span></span> <span data-ttu-id="455da-216">通过 `Properties` 上的 `Message`属性可以访问这些属性。</span><span class="sxs-lookup"><span data-stu-id="455da-216">Properties are accessed through the `Properties` property on `Message`.</span></span>  
  
 <span data-ttu-id="455da-217">与消息正文和消息头不同（通常分别映射到 SOAP 正文和 SOAP 标头），消息属性通常不与消息一起发送或接收。</span><span class="sxs-lookup"><span data-stu-id="455da-217">Unlike the message body and message headers (which normally map to the SOAP body and SOAP headers, respectively), message properties are normally not sent or received along with the messages.</span></span> <span data-ttu-id="455da-218">消息属性主要作为一种通信机制，用于在通道堆栈中的各个通道之间以及通道堆栈和服务模块之间传递有关消息的数据。</span><span class="sxs-lookup"><span data-stu-id="455da-218">Message properties exist primarily as a communication mechanism to pass data about the message between the various channels in the channel stack, and between the channel stack and the service model.</span></span>  
  
 <span data-ttu-id="455da-219">例如，作为 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 一部分的 HTTP 传输通道在向客户端发送答复时，能够生成多种 HTTP 状态代码，如“404（未找到）”和“500（内部服务器错误）”。</span><span class="sxs-lookup"><span data-stu-id="455da-219">For example, the HTTP transport channel included as part of [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] is capable of producing various HTTP status codes, such as "404 (Not Found)" and "500 (Internal Server Error)," when it sends replies to clients.</span></span> <span data-ttu-id="455da-220">在之前发送答复消息，它检查是否`Properties`的`Message`包含名为"httpResponse"包含类型的对象的属性<xref:System.ServiceModel.Channels.HttpResponseMessageProperty>。</span><span class="sxs-lookup"><span data-stu-id="455da-220">Before sending a reply message, it checks to see whether the `Properties` of the `Message` contain a property called "httpResponse" that contains an object of type <xref:System.ServiceModel.Channels.HttpResponseMessageProperty>.</span></span> <span data-ttu-id="455da-221">如果找到此属性，HTTP 传输通道将查看 <xref:System.ServiceModel.Channels.HttpResponseMessageProperty.StatusCode%2A> 属性并使用该状态代码。</span><span class="sxs-lookup"><span data-stu-id="455da-221">If such a property is found, it will look at the <xref:System.ServiceModel.Channels.HttpResponseMessageProperty.StatusCode%2A> property and use that status code.</span></span> <span data-ttu-id="455da-222">如果未找到此属性，则使用默认的“200（确定）”代码。</span><span class="sxs-lookup"><span data-stu-id="455da-222">If it is not found, the default "200 (OK)" code is used.</span></span>  
  
 [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="455da-223"> [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md)。</span><span class="sxs-lookup"><span data-stu-id="455da-223"> [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).</span></span>  
  
### <a name="the-message-as-a-whole"></a><span data-ttu-id="455da-224">整体消息</span><span class="sxs-lookup"><span data-stu-id="455da-224">The Message as a Whole</span></span>  
 <span data-ttu-id="455da-225">到目前为止，我们已经讨论了用于单独访问消息各个部分的方法。</span><span class="sxs-lookup"><span data-stu-id="455da-225">So far, we have discussed methods for accessing the various parts of the message in isolation.</span></span> <span data-ttu-id="455da-226">不过， <xref:System.ServiceModel.Channels.Message> 类还提供了以整体形式处理整个消息的方法。</span><span class="sxs-lookup"><span data-stu-id="455da-226">However, the <xref:System.ServiceModel.Channels.Message> class also provides methods to work with the entire message as a whole.</span></span> <span data-ttu-id="455da-227">例如， `WriteMessage` 方法可将整个消息写出到 XML 编写器。</span><span class="sxs-lookup"><span data-stu-id="455da-227">For example, the `WriteMessage` method writes out the entire message to an XML writer.</span></span>  
  
 <span data-ttu-id="455da-228">为此，必须在整个 `Message` 实例和 XML Infoset 之间定义一个映射。</span><span class="sxs-lookup"><span data-stu-id="455da-228">For this to be possible, a mapping must be defined between the entire `Message` instance and an XML Infoset.</span></span> <span data-ttu-id="455da-229">实际上存在这样的映射： [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 使用 SOAP 标准定义此映射。</span><span class="sxs-lookup"><span data-stu-id="455da-229">Such a mapping, in fact, exists: [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] uses the SOAP standard to define this mapping.</span></span> <span data-ttu-id="455da-230">在将 `Message` 实例作为 XML Infoset 写出时，生成的 Infoset 是包含该消息的有效 SOAP 信封。</span><span class="sxs-lookup"><span data-stu-id="455da-230">When a `Message` instance is written out as an XML Infoset, the resulting Infoset is the valid SOAP envelope that contains the message.</span></span> <span data-ttu-id="455da-231">因此， `WriteMessage` 通常会执行以下步骤：</span><span class="sxs-lookup"><span data-stu-id="455da-231">Thus, `WriteMessage` would normally perform the following steps:</span></span>  
  
1.  <span data-ttu-id="455da-232">写入 SOAP 信封元素开始标记。</span><span class="sxs-lookup"><span data-stu-id="455da-232">Write the SOAP envelope element opening tag.</span></span>  
  
2.  <span data-ttu-id="455da-233">写入 SOAP 标头元素开始标记，写出所有标头并关闭标头元素。</span><span class="sxs-lookup"><span data-stu-id="455da-233">Write the SOAP header element opening tag, write out all of the headers, and close the header element.</span></span>  
  
3.  <span data-ttu-id="455da-234">写入 SOAP 正文元素开始标记。</span><span class="sxs-lookup"><span data-stu-id="455da-234">Write the SOAP body element opening tag.</span></span>  
  
4.  <span data-ttu-id="455da-235">调用 `WriteBodyContents` 或等效方法写出正文。</span><span class="sxs-lookup"><span data-stu-id="455da-235">Call `WriteBodyContents` or an equivalent method to write out the body.</span></span>  
  
5.  <span data-ttu-id="455da-236">关闭正文和信封元素。</span><span class="sxs-lookup"><span data-stu-id="455da-236">Close the body and envelope elements.</span></span>  
  
 <span data-ttu-id="455da-237">前面的步骤与 SOAP 标准密切相关。</span><span class="sxs-lookup"><span data-stu-id="455da-237">The preceding steps are closely tied to the SOAP standard.</span></span> <span data-ttu-id="455da-238">实际上，由于存在多个版本的 SOAP，因此情况会更复杂，例如，不知道使用的 SOAP 版本将不可能正确写出 SOAP 信封元素。</span><span class="sxs-lookup"><span data-stu-id="455da-238">This is complicated by the fact that multiple versions of SOAP exist, for example, it is impossible to write out the SOAP envelope element correctly without knowing the SOAP version in use.</span></span> <span data-ttu-id="455da-239">而且，有时可能需要完全关闭这种特定于 SOAP 的复杂映射。</span><span class="sxs-lookup"><span data-stu-id="455da-239">Also, in some cases, it may be desirable to turn off this complex SOAP-specific mapping completely.</span></span>  
  
 <span data-ttu-id="455da-240">为此， `Version` 上提供了 `Message`属性。</span><span class="sxs-lookup"><span data-stu-id="455da-240">For these purposes, a `Version` property is provided on `Message`.</span></span> <span data-ttu-id="455da-241">该属性可以设置为写出消息时要使用的 SOAP 版本，也可以设置为 `None` 以阻止任何特定于 SOAP 的映射。</span><span class="sxs-lookup"><span data-stu-id="455da-241">It can be set to the SOAP version to use when writing out the message, or it can be set to `None` to prevent any SOAP-specific mappings.</span></span> <span data-ttu-id="455da-242">如果将 `Version` 属性设置为 `None`，则处理整个消息的方法会将消息视为仅由正文构成，例如， `WriteMessage` 将只调用 `WriteBodyContents` 而不执行上面列出的多个步骤。</span><span class="sxs-lookup"><span data-stu-id="455da-242">If the `Version` property is set to `None`, methods that work with the entire message act as if the message consisted of its body only, for example, `WriteMessage` would simply call `WriteBodyContents` instead of performing the multiple steps listed above.</span></span> <span data-ttu-id="455da-243">对于传入消息，需要自动检测并正确设置 `Version` 。</span><span class="sxs-lookup"><span data-stu-id="455da-243">It is expected that on incoming messages, `Version` will be auto-detected and set correctly.</span></span>  
  
## <a name="the-channel-stack"></a><span data-ttu-id="455da-244">通道堆栈</span><span class="sxs-lookup"><span data-stu-id="455da-244">The Channel Stack</span></span>  
  
### <a name="channels"></a><span data-ttu-id="455da-245">信道</span><span class="sxs-lookup"><span data-stu-id="455da-245">Channels</span></span>  
 <span data-ttu-id="455da-246">如前所述，通道堆栈负责将传出的 <xref:System.ServiceModel.Channels.Message> 实例转换为某种操作（如通过网络发送数据包），或者将某种操作（如接收网络数据包）转换为传入的 `Message` 实例。</span><span class="sxs-lookup"><span data-stu-id="455da-246">As stated before, the channel stack is responsible for converting outgoing <xref:System.ServiceModel.Channels.Message> instances into some action (such as sending packets over the network), or converting some action (such as receiving network packets) into incoming `Message` instances.</span></span>  
  
 <span data-ttu-id="455da-247">通道堆栈由一个或多个按顺序排序的通道组成。</span><span class="sxs-lookup"><span data-stu-id="455da-247">The channel stack is composed of one or more channels ordered in a sequence.</span></span> <span data-ttu-id="455da-248">传出的 `Message` 实例传递到堆栈中的第一个通道（也称为“最顶端通道” ），该通道将该实例向下传递到堆栈中的下一个通道，依此类推。</span><span class="sxs-lookup"><span data-stu-id="455da-248">An outgoing `Message` instance is passed to the first channel in the stack (also called the *topmost channel*), which passes it to the next channel down in stack, and so on.</span></span> <span data-ttu-id="455da-249">消息在最后一个通道中终止，此通道称为“传输通道” 。</span><span class="sxs-lookup"><span data-stu-id="455da-249">The message terminates in the last channel, which is called the *transport channel*.</span></span> <span data-ttu-id="455da-250">传入消息源自传输通道，在堆栈中从一个通道向上传递到另一个通道。</span><span class="sxs-lookup"><span data-stu-id="455da-250">Incoming messages originate in the transport channel and are passed from channel to channel up the stack.</span></span> <span data-ttu-id="455da-251">消息通常从最顶端通道传入服务框架。</span><span class="sxs-lookup"><span data-stu-id="455da-251">From the topmost channel, the message is usually passed into the service framework.</span></span> <span data-ttu-id="455da-252">这是应用程序消息的通常模式，但某些通道的工作方式可能略有不同，例如这些通道可能会发送自己的基础结构消息，而不从其上面的通道传入消息。</span><span class="sxs-lookup"><span data-stu-id="455da-252">While this is the usual pattern for application messages, some channels may work slightly differently, for example, they may send their own infrastructure messages without being passed a message from a channel above.</span></span>  
  
 <span data-ttu-id="455da-253">消息在堆栈中传递时，通道可能会对消息执行各种操作。</span><span class="sxs-lookup"><span data-stu-id="455da-253">Channels may operate on the message in various ways as it passes through the stack.</span></span> <span data-ttu-id="455da-254">最常见的操作是给传出消息添加标头和读取传入消息的标头。</span><span class="sxs-lookup"><span data-stu-id="455da-254">The most common operation is adding a header to an outgoing message and reading headers on an incoming message.</span></span> <span data-ttu-id="455da-255">例如，通道可能会计算消息的数字签名并将此签名添加为标头。</span><span class="sxs-lookup"><span data-stu-id="455da-255">For example, a channel may compute the digital signature of a message and add it as a header.</span></span> <span data-ttu-id="455da-256">通道也可能检查传入消息的数字签名标头，并阻止没有有效签名的消息在通道堆栈中向上传递。</span><span class="sxs-lookup"><span data-stu-id="455da-256">A channel may also inspect this digital signature header on incoming messages and block messages that do not have a valid signature from making their way up the channel stack.</span></span> <span data-ttu-id="455da-257">通道通常还设置或检查消息属性。</span><span class="sxs-lookup"><span data-stu-id="455da-257">Channels also often set or inspect message properties.</span></span> <span data-ttu-id="455da-258">虽然允许修改消息正文，但通常不这样做，例如， [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 安全通道可以加密消息正文。</span><span class="sxs-lookup"><span data-stu-id="455da-258">The message body is usually not modified, although this is allowed, for example, the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] security channel can encrypt the message body.</span></span>  
  
### <a name="transport-channels-and-message-encoders"></a><span data-ttu-id="455da-259">传输通道和消息编码器</span><span class="sxs-lookup"><span data-stu-id="455da-259">Transport Channels and Message Encoders</span></span>  
 <span data-ttu-id="455da-260">堆栈中的最底端通道负责实际将传出的 <xref:System.ServiceModel.Channels.Message>（由其他通道修改后）转换为某种操作。</span><span class="sxs-lookup"><span data-stu-id="455da-260">The bottommost channel in the stack is responsible for actually transforming an outgoing <xref:System.ServiceModel.Channels.Message>, as modified by other channels, into some action.</span></span> <span data-ttu-id="455da-261">在接收端，这是将某种操作转换为由其他通道进行处理的 `Message` 的通道。</span><span class="sxs-lookup"><span data-stu-id="455da-261">On the receive side, this is the channel that converts some action into a `Message` that other channels process.</span></span>  
  
 <span data-ttu-id="455da-262">如前所述，这些操作可能有所不同，例如：通过各种协议发送或接收网络数据包、在数据库中读取或写入消息、在“消息队列”队列中对消息进行排队或取消排队，等等。</span><span class="sxs-lookup"><span data-stu-id="455da-262">As stated previously, the actions may be varied: sending or receiving network packets over various protocols, reading or writing the message in a database, or queuing or dequeuing the message in a Message Queuing queue, to provide but a few examples.</span></span> <span data-ttu-id="455da-263">所有这些操作都有一个共同点：它们都需要在 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]`Message` 实例和可以发送、接收、写入、读取、排队或取消排队的字节组之间进行转换。</span><span class="sxs-lookup"><span data-stu-id="455da-263">All these actions have one thing in common: they require a transformation between the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]`Message` instance and an actual group of bytes that can be sent, received, read, written, queued, or dequeued.</span></span> <span data-ttu-id="455da-264">将 `Message` 转换为字节组的过程称为“编码” ，从字节组创建 `Message` 的逆过程称为“解码” 。</span><span class="sxs-lookup"><span data-stu-id="455da-264">The process of converting a `Message` into a group of bytes is called *encoding*, and the reverse process of creating a `Message` from a group of bytes is called *decoding*.</span></span>  
  
 <span data-ttu-id="455da-265">大多数传输通道都使用称为“消息编码器”  的组件来完成编码和解码工作。</span><span class="sxs-lookup"><span data-stu-id="455da-265">Most transport channels use components called *message encoders* to accomplish the encoding and decoding work.</span></span> <span data-ttu-id="455da-266">消息编码器是 <xref:System.ServiceModel.Channels.MessageEncoder> 类的子类。</span><span class="sxs-lookup"><span data-stu-id="455da-266">A message encoder is a subclass of the <xref:System.ServiceModel.Channels.MessageEncoder> class.</span></span> <span data-ttu-id="455da-267">`MessageEncoder` 包括各种 `ReadMessage` 和 `WriteMessage` 方法重载，可在 `Message` 和字节组之间转换。</span><span class="sxs-lookup"><span data-stu-id="455da-267">`MessageEncoder` includes various `ReadMessage` and `WriteMessage` method overloads to convert between `Message` and groups of bytes.</span></span>  
  
 <span data-ttu-id="455da-268">在发送端，缓冲传输通道将从上面通道中接收的 `Message` 对象传递到 `WriteMessage`。</span><span class="sxs-lookup"><span data-stu-id="455da-268">On the sending side, a buffering transport channel passes the `Message` object that it received from a channel above it to `WriteMessage`.</span></span> <span data-ttu-id="455da-269">该通道返回字节数组，然后使用此数组执行其操作（如将这些字节包装为有效的 TCP 数据包并将这些数据包发送到正确目标）。</span><span class="sxs-lookup"><span data-stu-id="455da-269">It gets back an array of bytes, which it then uses to perform its action (such as packaging these bytes as valid TCP packets and sending them to the correct destination).</span></span> <span data-ttu-id="455da-270">流传输通道首先创建一个 `Stream` （例如通过传出 TCP 连接），然后传递需要的 `Stream` 和 `Message` 以便发送相应的 `WriteMessage` 重载，从而写出消息。</span><span class="sxs-lookup"><span data-stu-id="455da-270">A streaming transport channel first creates a `Stream` (for example, over the outgoing TCP connection), and then passes both the `Stream` and the `Message` it needs to send to the appropriate `WriteMessage` overload, which writes out the message.</span></span>  
  
 <span data-ttu-id="455da-271">在接收端，缓冲传输通道将传入字节（例如传入的 TCP 数据包中的字节）提取到数组中并调用 `ReadMessage` 以获取可在通道堆栈中继续向上传递的 `Message` 对象。</span><span class="sxs-lookup"><span data-stu-id="455da-271">On the receiving side, a buffering transport channel extracts incoming bytes (for example, from incoming TCP packets) into an array and calls `ReadMessage` to get a `Message` object that it can pass further up the channel stack.</span></span> <span data-ttu-id="455da-272">流传输通道创建 `Stream` 对象（例如通过传入 TCP 连接传输的网络流）并将该对象传递到 `ReadMessage` 以返回 `Message` 对象。</span><span class="sxs-lookup"><span data-stu-id="455da-272">A streaming transport channel creates a `Stream` object (for example, a network stream over the incoming TCP connection) and passes that to `ReadMessage` to get back a `Message` object.</span></span>  
  
 <span data-ttu-id="455da-273">传输通道和消息编码器之间并不强制分离；可以写入不使用消息编码器的传输通道。</span><span class="sxs-lookup"><span data-stu-id="455da-273">The separation between the transport channels and the message encoder is not mandatory; it is possible to write a transport channel that does not use a message encoder.</span></span> <span data-ttu-id="455da-274">但这种分离具有易于撰写的优势。</span><span class="sxs-lookup"><span data-stu-id="455da-274">However, the advantage of this separation is ease of composition.</span></span> <span data-ttu-id="455da-275">只要传输通道仅使用基本 <xref:System.ServiceModel.Channels.MessageEncoder>，它就能使用任何 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 或第三方消息编码器。</span><span class="sxs-lookup"><span data-stu-id="455da-275">As long as a transport channel uses only the base <xref:System.ServiceModel.Channels.MessageEncoder>, it can work with any [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] or third-party message encoder.</span></span> <span data-ttu-id="455da-276">同样，这个编码器通常可用于任何传输通道。</span><span class="sxs-lookup"><span data-stu-id="455da-276">Likewise, the same encoder can normally be used in any transport channel.</span></span>  
  
### <a name="message-encoder-operation"></a><span data-ttu-id="455da-277">消息编码器操作</span><span class="sxs-lookup"><span data-stu-id="455da-277">Message Encoder Operation</span></span>  
 <span data-ttu-id="455da-278">为了说明编码器的典型操作，有必要考虑以下四种情况。</span><span class="sxs-lookup"><span data-stu-id="455da-278">To describe the typical operation of an encoder, it is useful to consider the following four cases.</span></span>  
  
|<span data-ttu-id="455da-279">操作</span><span class="sxs-lookup"><span data-stu-id="455da-279">Operation</span></span>|<span data-ttu-id="455da-280">注释</span><span class="sxs-lookup"><span data-stu-id="455da-280">Comment</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="455da-281">编码，缓冲</span><span class="sxs-lookup"><span data-stu-id="455da-281">Encoding, Buffered</span></span>|<span data-ttu-id="455da-282">在缓冲模式中，编码器通常创建可变大小的缓冲区，然后在其上创建 XML 编写器。</span><span class="sxs-lookup"><span data-stu-id="455da-282">In buffered mode, the encoder normally creates a variable-size buffer and then creates an XML writer over it.</span></span> <span data-ttu-id="455da-283">然后，编码器在编码的消息上调用 <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> ，使用 <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29>依次写出标头和正文，如本主题前面有关 `Message` 的一节所述。</span><span class="sxs-lookup"><span data-stu-id="455da-283">It then calls <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> on the message being encoded, which writes out the headers and then the body using <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, as explained in the preceding section about `Message` in this topic.</span></span> <span data-ttu-id="455da-284">然后为要使用的传输通道返回缓冲区的内容（表示为字节数组）。</span><span class="sxs-lookup"><span data-stu-id="455da-284">The contents of the buffer (represented as an array of bytes) are then returned for the transport channel to use.</span></span>|  
|<span data-ttu-id="455da-285">编码，流处理</span><span class="sxs-lookup"><span data-stu-id="455da-285">Encoding, Streamed</span></span>|<span data-ttu-id="455da-286">在流处理模式中，操作与上面类似，但更简单。</span><span class="sxs-lookup"><span data-stu-id="455da-286">In streamed mode, the operation is similar to the above, but simpler.</span></span> <span data-ttu-id="455da-287">不需要使用缓冲区。</span><span class="sxs-lookup"><span data-stu-id="455da-287">There is no need for a buffer.</span></span> <span data-ttu-id="455da-288">通常在流上创建 XML 编写器并在 <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> 上调用 `Message` 以将消息写出到此编写器。</span><span class="sxs-lookup"><span data-stu-id="455da-288">An XML writer is normally created over the stream and <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> is called on the `Message` to write it out to this writer.</span></span>|  
|<span data-ttu-id="455da-289">解码，缓冲</span><span class="sxs-lookup"><span data-stu-id="455da-289">Decoding, Buffered</span></span>|<span data-ttu-id="455da-290">在缓冲模式中解码时，通常创建包含缓冲数据的特殊的 `Message` 子类。</span><span class="sxs-lookup"><span data-stu-id="455da-290">When decoding in buffered mode, a special `Message` subclass that contains the buffered data is normally created.</span></span> <span data-ttu-id="455da-291">读取消息头，在消息正文上创建 XML 读取器。</span><span class="sxs-lookup"><span data-stu-id="455da-291">The headers of the message are read, and an XML reader positioned on the message body is created.</span></span> <span data-ttu-id="455da-292">这将是用 <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>返回的读取器。</span><span class="sxs-lookup"><span data-stu-id="455da-292">This is the reader that will be returned with <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span></span>|  
|<span data-ttu-id="455da-293">解码，流处理</span><span class="sxs-lookup"><span data-stu-id="455da-293">Decoding, Streamed</span></span>|<span data-ttu-id="455da-294">在流处理模式中解码时，通常创建特殊的 Message 子类。</span><span class="sxs-lookup"><span data-stu-id="455da-294">When decoding in streamed mode, a special Message subclass is normally created.</span></span> <span data-ttu-id="455da-295">流的前进速度刚好足以读取所有标头并将标头定位在消息正文上。</span><span class="sxs-lookup"><span data-stu-id="455da-295">The stream is advanced just enough to read all the headers and position it on the message body.</span></span> <span data-ttu-id="455da-296">然后在流上创建 XML 读取器。</span><span class="sxs-lookup"><span data-stu-id="455da-296">An XML reader is then created over the stream.</span></span> <span data-ttu-id="455da-297">这将是用 <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>返回的读取器。</span><span class="sxs-lookup"><span data-stu-id="455da-297">This is the reader that will be returned with <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span></span>|  
  
 <span data-ttu-id="455da-298">编码器也可以执行其他功能。</span><span class="sxs-lookup"><span data-stu-id="455da-298">Encoders can perform other functions as well.</span></span> <span data-ttu-id="455da-299">例如，编码器可以共享 XML 读取器和编写器。</span><span class="sxs-lookup"><span data-stu-id="455da-299">For example, the encoders can pool XML readers and writers.</span></span> <span data-ttu-id="455da-300">每次需要新 XML 读取器或编写器时都进行创建很浪费资源。</span><span class="sxs-lookup"><span data-stu-id="455da-300">It is expensive to create a new XML reader or writer every time one is needed.</span></span> <span data-ttu-id="455da-301">因此，编码器通常保持一个可配置大小的读取器池和编写器池。</span><span class="sxs-lookup"><span data-stu-id="455da-301">Therefore, encoders normally maintain a pool of readers and a pool of writers of configurable size.</span></span> <span data-ttu-id="455da-302">在前面所述的编码器操作说明中，每当的短语使用"创建 XML 读取器/编写器"，通常是指"需要从该池，或创建一个，如果一个不可用。"</span><span class="sxs-lookup"><span data-stu-id="455da-302">In the descriptions of encoder operation described previously, whenever the phrase "create an XML reader/writer" is used, it normally means "take one from the pool, or create one if one is not available."</span></span> <span data-ttu-id="455da-303">编码器（及其在解码时创建的 `Message` 子类）中包含用于在不需要读取器和编写器时（例如关闭 `Message` 时）将其返回到池的逻辑。</span><span class="sxs-lookup"><span data-stu-id="455da-303">The encoder (and the `Message` subclasses it creates while decoding) contain logic to return readers and writers to the pools once they are no longer needed (for example, when the `Message` is closed).</span></span>  
  
 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]<span data-ttu-id="455da-304"> 提供了三种消息编码器，但也可以创建其他自定义类型。</span><span class="sxs-lookup"><span data-stu-id="455da-304"> provides three message encoders, although it is possible to create additional custom types.</span></span> <span data-ttu-id="455da-305">提供的类型为文本、二进制和消息传输优化机制 (MTOM)。</span><span class="sxs-lookup"><span data-stu-id="455da-305">The supplied types are Text, Binary, and Message Transmission Optimization Mechanism (MTOM).</span></span> <span data-ttu-id="455da-306">这些编码器将在 [Choosing a Message Encoder](../../../../docs/framework/wcf/feature-details/choosing-a-message-encoder.md)中详细说明。</span><span class="sxs-lookup"><span data-stu-id="455da-306">These are described in detail in [Choosing a Message Encoder](../../../../docs/framework/wcf/feature-details/choosing-a-message-encoder.md).</span></span>  
  
### <a name="the-istreamprovider-interface"></a><span data-ttu-id="455da-307">IStreamProvider 接口</span><span class="sxs-lookup"><span data-stu-id="455da-307">The IStreamProvider Interface</span></span>  
 <span data-ttu-id="455da-308">在将包含经过流处理的正文的传出消息写入 XML 编写器时， <xref:System.ServiceModel.Channels.Message> 会在其 <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> 实现中使用类似于下面的一系列调用：</span><span class="sxs-lookup"><span data-stu-id="455da-308">When writing an outgoing message that contains a streamed body to an XML writer, the <xref:System.ServiceModel.Channels.Message> uses a sequence of calls similar to the following in its <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> implementation:</span></span>  
  
-   <span data-ttu-id="455da-309">写入流之前的所有必要信息（例如 XML 开始标记）。</span><span class="sxs-lookup"><span data-stu-id="455da-309">Write any necessary information preceding the stream (for example, the opening XML tag).</span></span>  
  
-   <span data-ttu-id="455da-310">写入流。</span><span class="sxs-lookup"><span data-stu-id="455da-310">Write the stream.</span></span>  
  
-   <span data-ttu-id="455da-311">写入流之后的任何信息（例如 XML 结束标记）。</span><span class="sxs-lookup"><span data-stu-id="455da-311">Write any information following the stream (for example, the closing XML tag).</span></span>  
  
 <span data-ttu-id="455da-312">这对于类似于文本 XML 编码的编码可以正常工作。</span><span class="sxs-lookup"><span data-stu-id="455da-312">This works well with encodings that are similar to the textual XML encoding.</span></span> <span data-ttu-id="455da-313">但是，有些编码不将 XML Infoset 信息（例如，开始和结束 XML 元素的标记）和元素中包含的数据放在一起。</span><span class="sxs-lookup"><span data-stu-id="455da-313">However, some encodings do not place XML Infoset information (for example, tags for starting and ending XML elements) together with the data contained within elements.</span></span> <span data-ttu-id="455da-314">例如，在 MTOM 编码中，消息拆分为多个部分。</span><span class="sxs-lookup"><span data-stu-id="455da-314">For example, in the MTOM encoding, the message is split into multiple parts.</span></span> <span data-ttu-id="455da-315">一部分包含 XML Infoset，其中可能包含对实际元素内容的其他部分的引用。</span><span class="sxs-lookup"><span data-stu-id="455da-315">One part contains the XML Infoset, which may contain references to other parts for actual element contents.</span></span> <span data-ttu-id="455da-316">由于 XML Infoset 通常比流处理的内容小，因此有必要缓冲 Infoset，将其写出，然后以流处理方式写入内容。</span><span class="sxs-lookup"><span data-stu-id="455da-316">The XML Infoset is normally small compared to the streamed contents, so it makes sense to buffer the Infoset, write it out, and then write the contents in a streamed way.</span></span> <span data-ttu-id="455da-317">这意味着在写入结束元素标记时，应当尚未写出流。</span><span class="sxs-lookup"><span data-stu-id="455da-317">This means that by the time the closing element tag is written, the stream should not have been written out yet.</span></span>  
  
 <span data-ttu-id="455da-318">为此，应使用 <xref:System.Xml.IStreamProvider> 接口。</span><span class="sxs-lookup"><span data-stu-id="455da-318">For this purpose, the <xref:System.Xml.IStreamProvider> interface is used.</span></span> <span data-ttu-id="455da-319">该接口具有一个可返回要写入的流的 <xref:System.Xml.IStreamProvider.GetStream> 方法。</span><span class="sxs-lookup"><span data-stu-id="455da-319">The interface has a <xref:System.Xml.IStreamProvider.GetStream> method that returns the stream to be written.</span></span> <span data-ttu-id="455da-320">写出 <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> 中经过流处理的消息正文的正确方式如下：</span><span class="sxs-lookup"><span data-stu-id="455da-320">The correct way to write out a streamed message body in <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> is as follows:</span></span>  
  
1.  <span data-ttu-id="455da-321">写入流之前的所有必要信息（例如 XML 开始标记）。</span><span class="sxs-lookup"><span data-stu-id="455da-321">Write any necessary information preceding the stream (for example, the opening XML tag).</span></span>  
  
2.  <span data-ttu-id="455da-322">对采用 `WriteValue` 、具有 <xref:System.Xml.XmlDictionaryWriter> 实现（该实现可返回要写入的流）的 <xref:System.Xml.IStreamProvider>调用 `IStreamProvider` 重载。</span><span class="sxs-lookup"><span data-stu-id="455da-322">Call the `WriteValue` overload on the <xref:System.Xml.XmlDictionaryWriter> that takes an <xref:System.Xml.IStreamProvider>, with an `IStreamProvider` implementation that returns the stream to be written.</span></span>  
  
3.  <span data-ttu-id="455da-323">写入流之后的任何信息（例如 XML 结束标记）。</span><span class="sxs-lookup"><span data-stu-id="455da-323">Write any information following the stream (for example, the closing XML tag).</span></span>  
  
 <span data-ttu-id="455da-324">使用此方法时，XML 编写器可以选择何时调用 <xref:System.Xml.IStreamProvider.GetStream> 和写出经过流处理的数据。</span><span class="sxs-lookup"><span data-stu-id="455da-324">With this approach, the XML writer has a choice of when to call <xref:System.Xml.IStreamProvider.GetStream> and write out the streamed data.</span></span> <span data-ttu-id="455da-325">例如，文本和二进制 XML 编写器将立即调用此方法并写出开始标记和结束标记之间的经过流处理的内容。</span><span class="sxs-lookup"><span data-stu-id="455da-325">For example, the textual and binary XML writers will call it immediately and write out the streamed contents in-between the start and end tags.</span></span> <span data-ttu-id="455da-326">MTOM 编写器准备写入消息的相应部分时，它可以决定以后调用 <xref:System.Xml.IStreamProvider.GetStream> 。</span><span class="sxs-lookup"><span data-stu-id="455da-326">The MTOM writer may decide to call <xref:System.Xml.IStreamProvider.GetStream> later, when it is ready to write the appropriate part of the message.</span></span>  
  
## <a name="representing-data-in-the-service-framework"></a><span data-ttu-id="455da-327">在服务框架中表示数据</span><span class="sxs-lookup"><span data-stu-id="455da-327">Representing Data in the Service Framework</span></span>  
 <span data-ttu-id="455da-328">如本主题“基础体系结构”一节中所述，服务框架是 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 的一部分，负责在消息数据的用户友好编程模型和实际的 `Message` 实例之间进行转换。</span><span class="sxs-lookup"><span data-stu-id="455da-328">As stated in the "Basic Architecture" section of this topic, the service framework is the part of [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] that, among other things, is responsible for converting between a user-friendly programming model for message data and actual `Message` instances.</span></span> <span data-ttu-id="455da-329">通常，消息交换在服务框架中表示为用 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 属性标记的 <xref:System.ServiceModel.OperationContractAttribute> 方法。</span><span class="sxs-lookup"><span data-stu-id="455da-329">Normally, a message exchange is represented in the service framework as a [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] method marked with the <xref:System.ServiceModel.OperationContractAttribute> attribute.</span></span> <span data-ttu-id="455da-330">此方法可以接受参数并可以返回一个返回值和/或 out 参数。</span><span class="sxs-lookup"><span data-stu-id="455da-330">The method can take in some parameters and can return a return value or out parameters (or both).</span></span> <span data-ttu-id="455da-331">在服务端，输入参数表示传入消息，返回值和 out 参数表示传出消息。</span><span class="sxs-lookup"><span data-stu-id="455da-331">On the service side, the input parameters represent the incoming message, and the return value and out parameters represent the outgoing message.</span></span> <span data-ttu-id="455da-332">在客户端，情况正好相反。</span><span class="sxs-lookup"><span data-stu-id="455da-332">On the client side, the reverse is true.</span></span> <span data-ttu-id="455da-333">使用参数和返回值来说明消息的编程模型将在 [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)中详细说明。</span><span class="sxs-lookup"><span data-stu-id="455da-333">The programming model for describing messages using parameters and the return value is described in detail in [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).</span></span> <span data-ttu-id="455da-334">不过，本节将提供简要概述。</span><span class="sxs-lookup"><span data-stu-id="455da-334">However, this section will provide a brief overview.</span></span>  
  
## <a name="programming-models"></a><span data-ttu-id="455da-335">编程模型</span><span class="sxs-lookup"><span data-stu-id="455da-335">Programming Models</span></span>  
 <span data-ttu-id="455da-336">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 服务框架支持五种用于说明消息的编程模型：</span><span class="sxs-lookup"><span data-stu-id="455da-336">The [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] service framework supports five different programming models for describing messages:</span></span>  
  
### <a name="1-the-empty-message"></a><span data-ttu-id="455da-337">1.空消息</span><span class="sxs-lookup"><span data-stu-id="455da-337">1. The Empty Message</span></span>  
 <span data-ttu-id="455da-338">这是最简单的情况。</span><span class="sxs-lookup"><span data-stu-id="455da-338">This is the simplest case.</span></span> <span data-ttu-id="455da-339">若要说明空的传入消息，请不要使用任何输入参数。</span><span class="sxs-lookup"><span data-stu-id="455da-339">To describe an empty incoming message, do not use any input parameters.</span></span>  
  
 [!code-csharp[C_DataArchitecture#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#3)]
 [!code-vb[C_DataArchitecture#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#3)]  
  
 <span data-ttu-id="455da-340">若要说明空的传出消息，请使用一个空的返回值且不使用任何 out 参数：</span><span class="sxs-lookup"><span data-stu-id="455da-340">To describe an empty outgoing message, use a void return value and do not use any out parameters:</span></span>  
  
 [!code-csharp[C_DataArchitecture#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#4)]
 [!code-vb[C_DataArchitecture#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#4)]  
  
 <span data-ttu-id="455da-341">请注意，这不同于单向操作协定：</span><span class="sxs-lookup"><span data-stu-id="455da-341">Note that this is different from a one-way operation contract:</span></span>  
  
 [!code-csharp[C_DataArchitecture#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#5)]
 [!code-vb[C_DataArchitecture#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#5)]  
  
 <span data-ttu-id="455da-342">在 `SetDesiredTemperature` 示例中，说明了双向消息交换模式。</span><span class="sxs-lookup"><span data-stu-id="455da-342">In the `SetDesiredTemperature` example, a two-way message exchange pattern is described.</span></span> <span data-ttu-id="455da-343">从操作中返回了消息，但该消息为空。</span><span class="sxs-lookup"><span data-stu-id="455da-343">A message is returned from the operation, but it is empty.</span></span> <span data-ttu-id="455da-344">可以从操作中返回错误。</span><span class="sxs-lookup"><span data-stu-id="455da-344">It is possible to return a fault from the operation.</span></span> <span data-ttu-id="455da-345">在“Set Lightbulb”示例中，消息交换模式为单向，因此没有要说明的传出消息。</span><span class="sxs-lookup"><span data-stu-id="455da-345">In the "Set Lightbulb" example, the message exchange pattern is one-way, so there is no outgoing message to describe.</span></span> <span data-ttu-id="455da-346">在此例中，服务无法将任何状态传回客户端。</span><span class="sxs-lookup"><span data-stu-id="455da-346">The service cannot communicate any status back to the client in this case.</span></span>  
  
### <a name="2-using-the-message-class-directly"></a><span data-ttu-id="455da-347">2.直接使用 Message 类</span><span class="sxs-lookup"><span data-stu-id="455da-347">2. Using the Message Class Directly</span></span>  
 <span data-ttu-id="455da-348">在操作协定中可以直接使用 <xref:System.ServiceModel.Channels.Message> 类（或它的一个子类）。</span><span class="sxs-lookup"><span data-stu-id="455da-348">It is possible to use the <xref:System.ServiceModel.Channels.Message> class (or one of its subclasses) directly in an operation contract.</span></span> <span data-ttu-id="455da-349">在这种情况下，服务框架只将 `Message` 从操作传递到通道堆栈（或从通道堆栈传递到操作），不进行其他处理。</span><span class="sxs-lookup"><span data-stu-id="455da-349">In this case, the service framework just passes the `Message` from the operation to the channel stack and vice versa, with no further processing.</span></span>  
  
 <span data-ttu-id="455da-350">直接使用 `Message` 有两种主要使用场合。</span><span class="sxs-lookup"><span data-stu-id="455da-350">There are two main use cases for using `Message` directly.</span></span> <span data-ttu-id="455da-351">如果任何其他编程模型都不能灵活地说明消息，则可以对高级方案使用此模型。</span><span class="sxs-lookup"><span data-stu-id="455da-351">You can use this for advanced scenarios, when none of the other programming models gives you enough flexibility to describe your message.</span></span> <span data-ttu-id="455da-352">例如，您可能想使用磁盘上的文件来说明消息，用文件的属性作为消息头，用文件的内容作为消息正文。</span><span class="sxs-lookup"><span data-stu-id="455da-352">For example, you might want to use files on disk to describe a message, with the file’s properties becoming message headers and the file’s contents becoming the message body.</span></span> <span data-ttu-id="455da-353">您可以创建类似于下面的内容。</span><span class="sxs-lookup"><span data-stu-id="455da-353">You can then create something similar to the following.</span></span>  
  
 [!code-csharp[C_DataArchitecture#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#6)]
 [!code-vb[C_DataArchitecture#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#6)]  
  
 <span data-ttu-id="455da-354">操作协定中 `Message` 的第二种常见用途是，服务并不关心特定的消息内容，而是像对待黑盒子一样对待消息。</span><span class="sxs-lookup"><span data-stu-id="455da-354">The second common use for `Message` in an operation contract is when a service does not care about the particular message contents and acts on the message as on a black box.</span></span> <span data-ttu-id="455da-355">例如，您可能具有将消息转发给多个其他收件人的服务。</span><span class="sxs-lookup"><span data-stu-id="455da-355">For example, you might have a service that forwards messages to multiple other recipients.</span></span> <span data-ttu-id="455da-356">可以按以下方式编写协定。</span><span class="sxs-lookup"><span data-stu-id="455da-356">The contract can be written as follows.</span></span>  
  
 [!code-csharp[C_DataArchitecture#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#7)]
 [!code-vb[C_DataArchitecture#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#7)]  
  
 <span data-ttu-id="455da-357">操作 ="*"行有效地关闭消息调度并确保所有消息都发送到`IForwardingService`协定使其往`ForwardMessage`操作。</span><span class="sxs-lookup"><span data-stu-id="455da-357">The Action="*" line effectively turns off message dispatching and ensures that all messages sent to the `IForwardingService` contract make their way to the `ForwardMessage` operation.</span></span> <span data-ttu-id="455da-358">（通常情况下，调度程序会检查消息的"Action"标头来确定适用于哪个操作。</span><span class="sxs-lookup"><span data-stu-id="455da-358">(Normally, the dispatcher would examine the message’s "Action" header to determine which operation it is intended for.</span></span> <span data-ttu-id="455da-359">操作 ="\*"意味着"所有的操作标头可能的值"。)操作的组合 ="\*"和使用 Message 作为一个参数被称为"通用协定"，因为它是能够接收所有可能的消息。</span><span class="sxs-lookup"><span data-stu-id="455da-359">Action="\*" means "all possible values of the Action header".) The combination of Action="\*" and using Message as a parameter is known as the "universal contract" because it is able to receive all possible messages.</span></span> <span data-ttu-id="455da-360">若要能够发送所有可能的消息，请使用 Message 作为返回值并设置`ReplyAction`到"\*"。</span><span class="sxs-lookup"><span data-stu-id="455da-360">To be able to send all possible messages, use Message as the return value and set `ReplyAction` to "\*".</span></span> <span data-ttu-id="455da-361">这将阻止服务框架添加其自己的 Action 标头，使您能够使用返回的 `Message` 对象控制此标头。</span><span class="sxs-lookup"><span data-stu-id="455da-361">This will prevent the service framework from adding its own Action header, enabling you to control this header using the `Message` object you return.</span></span>  
  
### <a name="3-message-contracts"></a><span data-ttu-id="455da-362">3.消息协定</span><span class="sxs-lookup"><span data-stu-id="455da-362">3. Message Contracts</span></span>  
 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]<span data-ttu-id="455da-363"> 为说明消息提供了一种声明性编程模型，称为“消息协定” 。</span><span class="sxs-lookup"><span data-stu-id="455da-363"> provides a declarative programming model for describing messages, called *message contracts*.</span></span> <span data-ttu-id="455da-364">此模型将在 [Using Message Contracts](../../../../docs/framework/wcf/feature-details/using-message-contracts.md)中详细说明。</span><span class="sxs-lookup"><span data-stu-id="455da-364">This model is described in detail in [Using Message Contracts](../../../../docs/framework/wcf/feature-details/using-message-contracts.md).</span></span> <span data-ttu-id="455da-365">实质上，整个消息由单个 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 类型表示，该类型使用 <xref:System.ServiceModel.MessageBodyMemberAttribute> 和 <xref:System.ServiceModel.MessageHeaderAttribute> 这样的属性来说明消息协定类的哪些部分应当映射到消息的哪个部分。</span><span class="sxs-lookup"><span data-stu-id="455da-365">Essentially, the entire message is represented by a single [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] type that uses attributes like the <xref:System.ServiceModel.MessageBodyMemberAttribute> and <xref:System.ServiceModel.MessageHeaderAttribute> to describe which parts of the message contract class should map to which part of the message.</span></span>  
  
 <span data-ttu-id="455da-366">消息协定对生成的 `Message` 实例提供广泛的控制（虽然明显没有直接使用 `Message` 类所提供的控制那样广泛）。</span><span class="sxs-lookup"><span data-stu-id="455da-366">Message contracts provide a lot of control over the resulting `Message` instances (although obviously not as much control as using the `Message` class directly).</span></span> <span data-ttu-id="455da-367">例如，消息正文通常由多段信息组成，每段消息由其各自的 XML 元素表示。</span><span class="sxs-lookup"><span data-stu-id="455da-367">For example, message bodies are often composed of multiple pieces of information, each represented by its own XML element.</span></span> <span data-ttu-id="455da-368">这些元素可以直接出现在正文中（空 模式），也可以包装  在包含 XML 元素中。</span><span class="sxs-lookup"><span data-stu-id="455da-368">These elements can either occur directly in the body (*bare* mode) or can be *wrapped* in an encompassing XML element.</span></span> <span data-ttu-id="455da-369">使用消息协定编程模型时可以进行空与包装决策并控制包装名称和命名空间的名称。</span><span class="sxs-lookup"><span data-stu-id="455da-369">Using the message contract programming model enables you to make the bare-versus-wrapped decision and control the name of the wrapper name and namespace.</span></span>  
  
 <span data-ttu-id="455da-370">下面的消息协定代码示例演示了这些功能。</span><span class="sxs-lookup"><span data-stu-id="455da-370">The following code example of a message contract demonstrates these features.</span></span>  
  
 [!code-csharp[C_DataArchitecture#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#9)]
 [!code-vb[C_DataArchitecture#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#9)]  
  
 <span data-ttu-id="455da-371">标记为要进行序列化（使用 <xref:System.ServiceModel.MessageBodyMemberAttribute>、 <xref:System.ServiceModel.MessageHeaderAttribute>或其他相关特性）的项必须为可序列化的，以参与消息协定。</span><span class="sxs-lookup"><span data-stu-id="455da-371">Items marked to be serialized (with the <xref:System.ServiceModel.MessageBodyMemberAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>, or other related attributes) must be serializable to participate in a message contract.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="455da-372">本主题后面的“序列化”一节。</span><span class="sxs-lookup"><span data-stu-id="455da-372"> the "Serialization" section later in this topic.</span></span>  
  
### <a name="4-parameters"></a><span data-ttu-id="455da-373">4.参数</span><span class="sxs-lookup"><span data-stu-id="455da-373">4. Parameters</span></span>  
 <span data-ttu-id="455da-374">通常，想要说明对多段数据执行的操作的开发人员并不需要消息协定所提供的那样高的控制度。</span><span class="sxs-lookup"><span data-stu-id="455da-374">Often, a developer who wants to describe an operation that acts on multiple pieces of data does not need the degree of control that message contracts provide.</span></span> <span data-ttu-id="455da-375">例如，在创建新服务时，开发人员通常不需要进行空与包装决策和确定包装元素名称。</span><span class="sxs-lookup"><span data-stu-id="455da-375">For example, when creating new services, one does not usually want to make the bare-versus-wrapped decision and decide on the wrapper element name.</span></span> <span data-ttu-id="455da-376">进行这些决策通常需要了解有关 Web 服务和 SOAP 的深入知识。</span><span class="sxs-lookup"><span data-stu-id="455da-376">Making these decisions often requires deep knowledge of Web services and SOAP.</span></span>  
  
 <span data-ttu-id="455da-377">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 服务框架可以自动挑选最佳和最具互操作性的 SOAP 表示形式来发送或接收多个相关信息段，而不强制用户进行这些选择。</span><span class="sxs-lookup"><span data-stu-id="455da-377">The [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] service framework can automatically pick the best and most interoperable SOAP representation for sending or receiving multiple related pieces of information, without forcing these choices on the user.</span></span> <span data-ttu-id="455da-378">只要将这些信息段作为参数或操作协定的返回值进行说明就能实现此目的。</span><span class="sxs-lookup"><span data-stu-id="455da-378">This is accomplished by simply describing these pieces of information as parameters or return values of an operation contract.</span></span> <span data-ttu-id="455da-379">例如，请考虑下面的操作协定。</span><span class="sxs-lookup"><span data-stu-id="455da-379">For example, consider the following operation contract.</span></span>  
  
 [!code-csharp[C_DataArchitecture#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#11)]
 [!code-vb[C_DataArchitecture#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#11)]  
  
 <span data-ttu-id="455da-380">服务框架将自动决定将所有三段信息（`customerID`、 `item`和 `quantity`）放入消息正文并将它们包装在名为 `SubmitOrderRequest`的包装元素中。</span><span class="sxs-lookup"><span data-stu-id="455da-380">The service framework automatically decides to put all three pieces of information (`customerID`, `item`, and `quantity`) into the message body and wrap them in a wrapper element named `SubmitOrderRequest`.</span></span>  
  
 <span data-ttu-id="455da-381">推荐的方法是将要发送或接收的信息作为操作协定参数的简单列表进行说明，除非存在特殊原因需要移动到更复杂的消息协定或基于 `Message` 的编程模型。</span><span class="sxs-lookup"><span data-stu-id="455da-381">Describing the information to be sent or received as a simple list of operation contract parameters is the recommended approach, unless special reasons exist to move to the more-complex message contract or `Message`-based programming models.</span></span>  
  
### <a name="5-stream"></a><span data-ttu-id="455da-382">5.流</span><span class="sxs-lookup"><span data-stu-id="455da-382">5. Stream</span></span>  
 <span data-ttu-id="455da-383">在操作协定中使用 `Stream` 或它的一个子类或者将其作为消息协定中唯一的消息正文部分，这种方式可视为与上述模型不同的一种单独的编程模型。</span><span class="sxs-lookup"><span data-stu-id="455da-383">Using `Stream` or one of its subclasses in an operation contract or as a sole message body part in a message contract can be considered a separate programming model from the ones described above.</span></span> <span data-ttu-id="455da-384">以这种方式使用 `Stream` 是除了编写您自己的流兼容 `Message` 子类以外，保证协定能够以流处理方式使用的唯一途径。</span><span class="sxs-lookup"><span data-stu-id="455da-384">Using `Stream` in this way is the only way to guarantee that your contract will be usable in a streamed fashion, short of writing your own streaming-compatible `Message` subclass.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="455da-385">[大型数据和流式处理](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md)。</span><span class="sxs-lookup"><span data-stu-id="455da-385"> [Large Data and Streaming](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md).</span></span>  
  
 <span data-ttu-id="455da-386">以这种方式使用 `Stream` 或它的一个子类时，不会调用序列化程序。</span><span class="sxs-lookup"><span data-stu-id="455da-386">When `Stream` or one of its subclasses is used in this way, the serializer is not invoked.</span></span> <span data-ttu-id="455da-387">对于传出消息，会创建一个特殊流 `Message` 子类并写出流，如关于 <xref:System.Xml.IStreamProvider> 接口的一节中所述。</span><span class="sxs-lookup"><span data-stu-id="455da-387">For outgoing messages, a special streaming `Message` subclass is created and the stream is written out as described in the section on the <xref:System.Xml.IStreamProvider> interface.</span></span> <span data-ttu-id="455da-388">对于传入消息，服务框架会在传入消息上创建一个 `Stream` 子类并将该子类提供给操作。</span><span class="sxs-lookup"><span data-stu-id="455da-388">For incoming messages, the service framework creates a `Stream` subclass over the incoming message and provides it to the operation.</span></span>  
  
## <a name="programming-model-restrictions"></a><span data-ttu-id="455da-389">编程模型限制</span><span class="sxs-lookup"><span data-stu-id="455da-389">Programming Model Restrictions</span></span>  
 <span data-ttu-id="455da-390">上述编程模型不能任意组合。</span><span class="sxs-lookup"><span data-stu-id="455da-390">The programming models described above cannot be arbitrarily combined.</span></span> <span data-ttu-id="455da-391">例如，如果某个操作接受某种消息协定类型，则消息协定必须是其唯一的输入参数。</span><span class="sxs-lookup"><span data-stu-id="455da-391">For example, if an operation accepts a message contract type, the message contract must be its only input parameter.</span></span> <span data-ttu-id="455da-392">而且，操作必须返回空消息（void 返回类型）或另一个消息协定。</span><span class="sxs-lookup"><span data-stu-id="455da-392">Furthermore, the operation must then either return an empty message (return type of void) or another message contract.</span></span> <span data-ttu-id="455da-393">这些编程模型限制将在每个特定编程模型的主题： [Using Message Contracts](../../../../docs/framework/wcf/feature-details/using-message-contracts.md)、 [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md)和 [Large Data and Streaming](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md)中进行说明。</span><span class="sxs-lookup"><span data-stu-id="455da-393">These programming model restrictions are described in the topics for each specific programming model: [Using Message Contracts](../../../../docs/framework/wcf/feature-details/using-message-contracts.md), [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md), and [Large Data and Streaming](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md).</span></span>  
  
## <a name="message-formatters"></a><span data-ttu-id="455da-394">消息格式化程序</span><span class="sxs-lookup"><span data-stu-id="455da-394">Message Formatters</span></span>  
 <span data-ttu-id="455da-395">通过将称为“消息格式化程序”  的组件插入到服务框架中可以为上述编程模型提供支持。</span><span class="sxs-lookup"><span data-stu-id="455da-395">The programming models described above are supported by plugging in components called *message formatters* into the service framework.</span></span> <span data-ttu-id="455da-396">消息格式化程序是实现 <xref:System.ServiceModel.Dispatcher.IClientMessageFormatter> 和/或 <xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter> 接口（以便分别在客户端和服务 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 客户端中使用）的类型。</span><span class="sxs-lookup"><span data-stu-id="455da-396">Message formatters are types that implement the <xref:System.ServiceModel.Dispatcher.IClientMessageFormatter> or <xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter> interface, or both, for use in clients and service [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] clients, respectively.</span></span>  
  
 <span data-ttu-id="455da-397">消息格式化程序通常由行为插入。</span><span class="sxs-lookup"><span data-stu-id="455da-397">Message formatters are normally plugged in by behaviors.</span></span> <span data-ttu-id="455da-398">例如， <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> 可插入数据协定消息格式化程序。</span><span class="sxs-lookup"><span data-stu-id="455da-398">For example, the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> plugs in the data contract message formatter.</span></span> <span data-ttu-id="455da-399">通过在服务端在 <xref:System.ServiceModel.Dispatcher.DispatchOperation.Formatter%2A> 方法中将 <xref:System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.DispatchOperation%29> 设置为正确的格式化程序，或者在客户端在 <xref:System.ServiceModel.Dispatcher.ClientOperation.Formatter%2A> 方法中将 <xref:System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.ClientOperation%29> 设置为正确的格式化程序，可以完成此操作。</span><span class="sxs-lookup"><span data-stu-id="455da-399">This is done on the service side by setting <xref:System.ServiceModel.Dispatcher.DispatchOperation.Formatter%2A> to the correct formatter in the <xref:System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.DispatchOperation%29> method, or on the client side by setting <xref:System.ServiceModel.Dispatcher.ClientOperation.Formatter%2A> to the correct formatter in the <xref:System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.ClientOperation%29> method.</span></span>  
  
 <span data-ttu-id="455da-400">下表列出了消息格式化程序可能实现的方法。</span><span class="sxs-lookup"><span data-stu-id="455da-400">The following tables lists the methods that a message formatter may implement.</span></span>  
  
|<span data-ttu-id="455da-401">接口</span><span class="sxs-lookup"><span data-stu-id="455da-401">Interface</span></span>|<span data-ttu-id="455da-402">方法</span><span class="sxs-lookup"><span data-stu-id="455da-402">Method</span></span>|<span data-ttu-id="455da-403">操作</span><span class="sxs-lookup"><span data-stu-id="455da-403">Action</span></span>|  
|---------------|------------|------------|  
|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.DeserializeRequest%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|<span data-ttu-id="455da-404">将传入的 `Message` 转换为操作参数</span><span class="sxs-lookup"><span data-stu-id="455da-404">Converts an incoming `Message` to operation parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.SerializeReply%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%2CSystem.Object%29>|<span data-ttu-id="455da-405">从操作返回值/out 参数创建传出的 `Message`</span><span class="sxs-lookup"><span data-stu-id="455da-405">Creates an outgoing `Message` from operation return value/out parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.SerializeRequest%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%29>|<span data-ttu-id="455da-406">从操作参数创建传出的 `Message`</span><span class="sxs-lookup"><span data-stu-id="455da-406">Creates an outgoing `Message` from operation parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.DeserializeReply%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|<span data-ttu-id="455da-407">将传入的 `Message` 转换为返回值/out 参数</span><span class="sxs-lookup"><span data-stu-id="455da-407">Converts an incoming `Message` to a return value/out parameters</span></span>|  
  
## <a name="serialization"></a><span data-ttu-id="455da-408">序列化</span><span class="sxs-lookup"><span data-stu-id="455da-408">Serialization</span></span>  
 <span data-ttu-id="455da-409">每当使用消息协定或参数来说明消息内容时，必须使用序列化在 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 类型和 XML Infoset 表示形式之间进行转换。</span><span class="sxs-lookup"><span data-stu-id="455da-409">Whenever you use message contracts or parameters to describe message contents, you must use serialization to convert between [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] types and XML Infoset representation.</span></span> <span data-ttu-id="455da-410">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]中的其他位置也使用序列化，例如， <xref:System.ServiceModel.Channels.Message> 具有一个通用 <xref:System.ServiceModel.Channels.Message.GetBody%2A> 方法，您可以用该方法来读取序列化为对象的整个消息正文。</span><span class="sxs-lookup"><span data-stu-id="455da-410">Serialization is used in other places in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], for example, <xref:System.ServiceModel.Channels.Message> has a Generic <xref:System.ServiceModel.Channels.Message.GetBody%2A> method that you can use to read the entire body of the message deserialized into an object.</span></span>  
  
 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]<span data-ttu-id="455da-411"> 支持两种“现成”的序列化技术对参数和消息部分进行序列化和反序列化： <xref:System.Runtime.Serialization.DataContractSerializer> 和 `XmlSerializer`。</span><span class="sxs-lookup"><span data-stu-id="455da-411"> supports two serialization technologies "out of the box" for serializing and deserializing parameters and message parts: the <xref:System.Runtime.Serialization.DataContractSerializer> and the `XmlSerializer`.</span></span> <span data-ttu-id="455da-412">另外，您也可以编写自定义序列化程序。</span><span class="sxs-lookup"><span data-stu-id="455da-412">Additionally, you can write custom serializers.</span></span> <span data-ttu-id="455da-413">但是， [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 的其他部分（如通用 `GetBody` 方法或 SOAP 错误序列化）可能限制为仅使用 <xref:System.Runtime.Serialization.XmlObjectSerializer> 子类（<xref:System.Runtime.Serialization.DataContractSerializer> 和 <xref:System.Runtime.Serialization.NetDataContractSerializer>，而不是 <xref:System.Xml.Serialization.XmlSerializer>），甚至已经硬编码为仅使用 <xref:System.Runtime.Serialization.DataContractSerializer>。</span><span class="sxs-lookup"><span data-stu-id="455da-413">However, other parts of [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] (such as the Generic `GetBody` method or SOAP fault serialization) may be restricted to use only the <xref:System.Runtime.Serialization.XmlObjectSerializer> subclasses (<xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>, but not the <xref:System.Xml.Serialization.XmlSerializer>), or may even be hard-coded to use only the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span>  
  
 <span data-ttu-id="455da-414">`XmlSerializer` 是 [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] Web 服务中使用的序列化引擎。</span><span class="sxs-lookup"><span data-stu-id="455da-414">The `XmlSerializer` is the serialization engine used in [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] Web services.</span></span> <span data-ttu-id="455da-415">`DataContractSerializer` 是理解新数据协定编程模型的新序列化引擎。</span><span class="sxs-lookup"><span data-stu-id="455da-415">The `DataContractSerializer` is the new serialization engine that understands the new data contract programming model.</span></span> <span data-ttu-id="455da-416">`DataContractSerializer` 默认选择，可以通过使用 `XmlSerializer` 特性对每个操作选择使用 <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.DataContractFormatAttribute%2A> 。</span><span class="sxs-lookup"><span data-stu-id="455da-416">`DataContractSerializer` is the default choice, and the choice to use the `XmlSerializer` can be made on a per-operation basis using the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.DataContractFormatAttribute%2A> attribute.</span></span>  
  
 <span data-ttu-id="455da-417"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> 和 <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> 是分别负责为 `DataContractSerializer` 和 `XmlSerializer`插入消息格式化程序的操作行为。</span><span class="sxs-lookup"><span data-stu-id="455da-417"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> and <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> are the operation behaviors responsible for plugging in the message formatters for the `DataContractSerializer` and the `XmlSerializer`, respectively.</span></span> <span data-ttu-id="455da-418"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> 行为实际上可操作从 <xref:System.Runtime.Serialization.XmlObjectSerializer>派生的任何序列化程序，包括 <xref:System.Runtime.Serialization.NetDataContractSerializer> （在“使用独立序列化”中进行详细说明）。</span><span class="sxs-lookup"><span data-stu-id="455da-418">The <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> behavior can actually operate with any serializer that derives from <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.NetDataContractSerializer> (described in detail in Using Stand-Alone Serialization).</span></span> <span data-ttu-id="455da-419">此行为调用 `CreateSerializer` 虚拟方法重载之一以获取序列化程序。</span><span class="sxs-lookup"><span data-stu-id="455da-419">The behavior calls one of the `CreateSerializer` virtual method overloads to obtain the serializer.</span></span> <span data-ttu-id="455da-420">若要插入其他序列化程序，请创建一个新的 <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> 子类并重写两个 `CreateSerializer` 重载。</span><span class="sxs-lookup"><span data-stu-id="455da-420">To plug in a different serializer, create a new <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> subclass and override both `CreateSerializer` overloads.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="455da-421">另请参阅</span><span class="sxs-lookup"><span data-stu-id="455da-421">See Also</span></span>  
 [<span data-ttu-id="455da-422">Specifying Data Transfer in Service Contracts</span><span class="sxs-lookup"><span data-stu-id="455da-422">Specifying Data Transfer in Service Contracts</span></span>](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)
