---
title: 使用 DataContractJsonSerializer 的独立 JSON 序列化
ms.date: 03/30/2017
ms.assetid: 312bd7b2-1300-4b12-801e-ebe742bd2287
ms.openlocfilehash: 39d3c0acd75ffd9a54c5e62a15487a2cd8c465cb
ms.sourcegitcommit: dfad244ba549702b649bfef3bb057e33f24a8fb2
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/12/2020
ms.locfileid: "75904603"
---
# <a name="stand-alone-json-serialization-using-datacontractjsonserializer"></a><span data-ttu-id="e2dcc-102">使用 DataContractJsonSerializer 的独立 JSON 序列化</span><span class="sxs-lookup"><span data-stu-id="e2dcc-102">Stand-Alone JSON Serialization using DataContractJsonSerializer</span></span>

> [!NOTE]
> <span data-ttu-id="e2dcc-103">本文介绍 <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-103">This article is about <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="e2dcc-104">对于涉及序列化和反序列化 JSON 的大多数方案，我们建议在[system.web 命名空间](../../../standard/serialization/system-text-json-overview.md)中提供 api。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-104">For most scenarios that involve serializing and deserializing JSON, we recommend the APIs in the [System.Text.Json namespace](../../../standard/serialization/system-text-json-overview.md).</span></span> 

<span data-ttu-id="e2dcc-105">JSON（JavaScript 对象表示法）是专门为浏览器中的网页上运行的 JavaScript 代码而设计的一种数据格式。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-105">JSON (JavaScript Object Notation) is a data format that is specifically designed to be used by JavaScript code running on Web pages inside the browser.</span></span> <span data-ttu-id="e2dcc-106">这是 ASP.NET AJAX 服务在 Windows Communication Foundation （WCF）中创建的默认数据格式。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-106">It is the default data format used by ASP.NET AJAX services created in Windows Communication Foundation (WCF).</span></span>

<span data-ttu-id="e2dcc-107">在未与 ASP.NET 集成的情况下（在此情况下，XML 将是默认格式，但可以选择 JSON）创建 AJAX 服务时，也可以使用此格式。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-107">This format can also be used when creating AJAX services without integrating with ASP.NET - in this case, XML is the default but JSON can be chosen.</span></span>

<span data-ttu-id="e2dcc-108">最后，如果需要 JSON 支持但不创建 AJAX 服务，则可以使用 <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>，以便将 .NET 对象直接序列化为 JSON 数据并将此类数据反序列化回 .NET 类型的实例。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-108">Finally, if you require JSON support but are not creating an AJAX service, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> makes it possible to directly serialize .NET objects into JSON data and to deserialize such data back into instances of .NET types.</span></span> <span data-ttu-id="e2dcc-109">有关如何执行此操作的说明，请参阅[如何：对 JSON 数据进行序列化和反序列](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md)化。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-109">For a description of how to do this, see [How to: Serialize and Deserialize JSON Data](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span></span>

<span data-ttu-id="e2dcc-110">使用 JSON 时，它支持的 .NET 类型与 <xref:System.Runtime.Serialization.DataContractSerializer> 支持的类型相同，但有少数例外。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-110">When working with JSON, the same .NET types are supported, with a few exceptions, as are supported by the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="e2dcc-111">有关支持的类型的列表，请参阅[数据协定序列化程序支持的类型](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-111">For a list of the types supported, see [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="e2dcc-112">支持的类型包括大多数基元类型、大多数数组和集合类型，以及使用 <xref:System.Runtime.Serialization.DataContractAttribute> 和 <xref:System.Runtime.Serialization.DataMemberAttribute> 的复杂类型。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-112">This includes most primitive types, most array and collection types, as well as complex types that use the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute>.</span></span>

## <a name="mapping-net-types-to-json-types"></a><span data-ttu-id="e2dcc-113">将 .NET 类型映射到 JSON 类型</span><span class="sxs-lookup"><span data-stu-id="e2dcc-113">Mapping .NET types to JSON Types</span></span>

<span data-ttu-id="e2dcc-114">下表显示 .NET 类型和 JSON/JavaScript 类型在通过序列化和反序列化过程进行映射时的对应关系。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-114">The following table shows the correspondence between .NET types and JSON/JavaScript types when mapped by serialization and deserialization procedures.</span></span>

|<span data-ttu-id="e2dcc-115">.NET 类型</span><span class="sxs-lookup"><span data-stu-id="e2dcc-115">.NET Types</span></span>|<span data-ttu-id="e2dcc-116">JSON/JavaScript</span><span class="sxs-lookup"><span data-stu-id="e2dcc-116">JSON/JavaScript</span></span>|<span data-ttu-id="e2dcc-117">注释</span><span class="sxs-lookup"><span data-stu-id="e2dcc-117">Notes</span></span>|
|----------------|----------------------|-----------|
|<span data-ttu-id="e2dcc-118">所有数值类型，例如 <xref:System.Int32>、<xref:System.Decimal> 或 <xref:System.Double></span><span class="sxs-lookup"><span data-stu-id="e2dcc-118">All numeric types, for example <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double></span></span>|<span data-ttu-id="e2dcc-119">Number</span><span class="sxs-lookup"><span data-stu-id="e2dcc-119">Number</span></span>|<span data-ttu-id="e2dcc-120">不支持 `Double.NaN`、`Double.PositiveInfinity` 和 `Double.NegativeInfinity` 等特殊值，它们会导致无效的 JSON。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-120">Special values such as  `Double.NaN`, `Double.PositiveInfinity` and `Double.NegativeInfinity` are not supported and result in invalid JSON.</span></span>|
|<xref:System.Enum>|<span data-ttu-id="e2dcc-121">Number</span><span class="sxs-lookup"><span data-stu-id="e2dcc-121">Number</span></span>|<span data-ttu-id="e2dcc-122">请参见本主题中后面的“枚举和 JSON”。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-122">See "Enumerations and JSON" later in this topic.</span></span>|
|<xref:System.Boolean>|<span data-ttu-id="e2dcc-123">Boolean</span><span class="sxs-lookup"><span data-stu-id="e2dcc-123">Boolean</span></span>|--|
|<span data-ttu-id="e2dcc-124"><xref:System.String>, <xref:System.Char></span><span class="sxs-lookup"><span data-stu-id="e2dcc-124"><xref:System.String>, <xref:System.Char></span></span>|<span data-ttu-id="e2dcc-125">字符串</span><span class="sxs-lookup"><span data-stu-id="e2dcc-125">String</span></span>|--|
|<span data-ttu-id="e2dcc-126"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span><span class="sxs-lookup"><span data-stu-id="e2dcc-126"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span></span>|<span data-ttu-id="e2dcc-127">字符串</span><span class="sxs-lookup"><span data-stu-id="e2dcc-127">String</span></span>|<span data-ttu-id="e2dcc-128">在 JSON 中这些类型的格式是与 XML 中的相同 (实质上，采用 ISO 8601 持续时间格式的时间跨度，采用"12345678-ABCD-ABCD-ABCD-1234567890AB"格式的 GUID 和其自然字符串形式的 URI，如" http://www.example.com ")。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-128">The format of these types in JSON is the same as in XML (essentially, TimeSpan in the ISO 8601 Duration format, GUID in the "12345678-ABCD-ABCD-ABCD-1234567890AB" format and URI in its natural string form like "http://www.example.com").</span></span> <span data-ttu-id="e2dcc-129">有关精确信息，请参阅[数据协定架构参考](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-129">For precise information, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span>|
|<xref:System.Xml.XmlQualifiedName>|<span data-ttu-id="e2dcc-130">字符串</span><span class="sxs-lookup"><span data-stu-id="e2dcc-130">String</span></span>|<span data-ttu-id="e2dcc-131">格式为“名称:命名空间”（第一个冒号之前的所有内容都是名称）。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-131">The format is "name:namespace" (anything before the first colon is the name).</span></span> <span data-ttu-id="e2dcc-132">可以缺少名称或命名空间。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-132">Either the name or the namespace can be missing.</span></span> <span data-ttu-id="e2dcc-133">如果没有命名空间，则也可以省略冒号。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-133">If there is no namespace the colon can be omitted as well.</span></span>|
|<span data-ttu-id="e2dcc-134"><xref:System.Array> 类型的 <xref:System.Byte></span><span class="sxs-lookup"><span data-stu-id="e2dcc-134"><xref:System.Array> of type <xref:System.Byte></span></span>|<span data-ttu-id="e2dcc-135">数字数组</span><span class="sxs-lookup"><span data-stu-id="e2dcc-135">Array of numbers</span></span>|<span data-ttu-id="e2dcc-136">每个数字都表示一个字节的值。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-136">Each number represents the value of one byte.</span></span>|
|<xref:System.DateTime>|<span data-ttu-id="e2dcc-137">DateTime 或 String</span><span class="sxs-lookup"><span data-stu-id="e2dcc-137">DateTime or String</span></span>|<span data-ttu-id="e2dcc-138">请参见本主题中后面的“日期/时间和 JSON”。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-138">See Dates/Times and JSON later in this topic.</span></span>|
|<xref:System.DateTimeOffset>|<span data-ttu-id="e2dcc-139">复杂类型</span><span class="sxs-lookup"><span data-stu-id="e2dcc-139">Complex type</span></span>|<span data-ttu-id="e2dcc-140">请参见本主题中后面的“日期/时间和 JSON”。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-140">See Dates/Times and JSON later in this topic.</span></span>|
|<span data-ttu-id="e2dcc-141">XML 和 ADO.NET 类型（<xref:System.Xml.XmlElement>、</span><span class="sxs-lookup"><span data-stu-id="e2dcc-141">XML and ADO.NET types (<xref:System.Xml.XmlElement>,</span></span><br /><br /> <span data-ttu-id="e2dcc-142"><xref:System.Xml.Linq.XElement>。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-142"><xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="e2dcc-143"><xref:System.Xml.XmlNode>、</span><span class="sxs-lookup"><span data-stu-id="e2dcc-143">Arrays of <xref:System.Xml.XmlNode>,</span></span><br /><br /> <span data-ttu-id="e2dcc-144"><xref:System.Runtime.Serialization.ISerializable>,</span><span class="sxs-lookup"><span data-stu-id="e2dcc-144"><xref:System.Runtime.Serialization.ISerializable>,</span></span><br /><br /> <span data-ttu-id="e2dcc-145"><xref:System.Data.DataSet>) 格式模式中出现的位置匹配。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-145"><xref:System.Data.DataSet>).</span></span>|<span data-ttu-id="e2dcc-146">字符串</span><span class="sxs-lookup"><span data-stu-id="e2dcc-146">String</span></span>|<span data-ttu-id="e2dcc-147">请参见本主题的“XML 类型和 JSON”一节。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-147">See the XML Types and JSON section of this topic.</span></span>|
|<xref:System.DBNull>|<span data-ttu-id="e2dcc-148">空复杂类型</span><span class="sxs-lookup"><span data-stu-id="e2dcc-148">Empty complex type</span></span>|--|
|<span data-ttu-id="e2dcc-149">集合、字典和数组</span><span class="sxs-lookup"><span data-stu-id="e2dcc-149">Collections, dictionaries, and arrays</span></span>|<span data-ttu-id="e2dcc-150">数组</span><span class="sxs-lookup"><span data-stu-id="e2dcc-150">Array</span></span>|<span data-ttu-id="e2dcc-151">请参见本主题的“集合、字典和数组”一节。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-151">See the Collections, Dictionaries, and Arrays section of this topic.</span></span>|
|<span data-ttu-id="e2dcc-152">复杂类型（应用了 <xref:System.Runtime.Serialization.DataContractAttribute> 或 <xref:System.SerializableAttribute>）</span><span class="sxs-lookup"><span data-stu-id="e2dcc-152">Complex types (with the <xref:System.Runtime.Serialization.DataContractAttribute> or <xref:System.SerializableAttribute> applied)</span></span>|<span data-ttu-id="e2dcc-153">复杂类型</span><span class="sxs-lookup"><span data-stu-id="e2dcc-153">Complex type</span></span>|<span data-ttu-id="e2dcc-154">数据成员变为 JavaScript 复杂类型的成员。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-154">Data members become members of the JavaScript complex type.</span></span>|
|<span data-ttu-id="e2dcc-155">实现 <xref:System.Runtime.Serialization.ISerializable> 接口的复杂类型</span><span class="sxs-lookup"><span data-stu-id="e2dcc-155">Complex types implementing the <xref:System.Runtime.Serialization.ISerializable> interface)</span></span>|<span data-ttu-id="e2dcc-156">复杂类型</span><span class="sxs-lookup"><span data-stu-id="e2dcc-156">Complex type</span></span>|<span data-ttu-id="e2dcc-157">与其他复杂类型相同，但不支持某些 <xref:System.Runtime.Serialization.ISerializable> 类型（请参见本主题“高级信息”一节的“ISerializable 支持”部分）。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-157">Same as other complex types but some <xref:System.Runtime.Serialization.ISerializable> types are not supported – see the ISerializable Support part of the Advanced Information section of this topic.</span></span>|
|<span data-ttu-id="e2dcc-158">任何类型的 `Null` 值</span><span class="sxs-lookup"><span data-stu-id="e2dcc-158">`Null` value for any type</span></span>|<span data-ttu-id="e2dcc-159">null</span><span class="sxs-lookup"><span data-stu-id="e2dcc-159">Null</span></span>|<span data-ttu-id="e2dcc-160">也支持可以为 null 的类型，这些类型映射到 JSON 的方式与不可以为 null 的类型相同。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-160">Nullable types are also supported and map to JSON in the same way as non-nullable types.</span></span>|

### <a name="enumerations-and-json"></a><span data-ttu-id="e2dcc-161">枚举和 JSON</span><span class="sxs-lookup"><span data-stu-id="e2dcc-161">Enumerations and JSON</span></span>

<span data-ttu-id="e2dcc-162">在 JSON 中，枚举成员值被作为数字处理，这与数据协定中处理枚举成员值的方式不同。在数据协定中，枚举成员值被视为成员名称。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-162">Enumeration member values are treated as numbers in JSON, which is different from how they are treated in data contracts, where they are included as member names.</span></span> <span data-ttu-id="e2dcc-163">有关数据协定处理的详细信息，请参阅[数据协定中的枚举类型](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md)。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-163">For more information about the data contract treatment, see [Enumeration Types in Data Contracts](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span></span>

- <span data-ttu-id="e2dcc-164">例如，如果存在 `public enum Color {red, green, blue, yellow, pink}`，则序列化 `yellow` 将生成数字 3，而不是字符串“yellow”。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-164">For example, if you have `public enum Color {red, green, blue, yellow, pink}`, serializing `yellow` produces the number 3 and not the string "yellow".</span></span>

- <span data-ttu-id="e2dcc-165">所有 `enum` 成员都是可序列化的。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-165">All `enum` members are serializable.</span></span> <span data-ttu-id="e2dcc-166">如果使用了 <xref:System.Runtime.Serialization.EnumMemberAttribute> 和 <xref:System.NonSerializedAttribute> 属性，则忽略它们。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-166">The <xref:System.Runtime.Serialization.EnumMemberAttribute> and the <xref:System.NonSerializedAttribute> attributes are ignored if used.</span></span>

- <span data-ttu-id="e2dcc-167">可以反序列化不存在的 `enum` 值。例如，可以将值 87 反序列化为上面的颜色枚举，尽管并未定义相应的颜色名称。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-167">It is possible to deserialize a nonexistent `enum` value - for example, the value 87 can be deserialized into the previous Color enum even though there is no corresponding color name defined.</span></span>

- <span data-ttu-id="e2dcc-168">标志 `enum` 并不特殊，其处理方式与任何其他 `enum` 相同。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-168">A flags `enum` is not special and is treated the same as any other `enum`.</span></span>

### <a name="datestimes-and-json"></a><span data-ttu-id="e2dcc-169">日期/时间和 JSON</span><span class="sxs-lookup"><span data-stu-id="e2dcc-169">Dates/Times and JSON</span></span>

<span data-ttu-id="e2dcc-170">JSON 格式不直接支持日期和时间。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-170">The JSON format does not directly support dates and times.</span></span> <span data-ttu-id="e2dcc-171">但是，由于这些类型十分常用，因此 ASP.NET AJAX 对它们提供了特殊的支持。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-171">However, they are very commonly used and ASP.NET AJAX provides special support for these types.</span></span> <span data-ttu-id="e2dcc-172">使用 ASP.NET AJAX 代理时，.NET 中的 <xref:System.DateTime> 类型与 JavaScript 中的 `DateTime` 类型完全对应。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-172">When using ASP.NET AJAX proxies, the <xref:System.DateTime> type in .NET fully corresponds to the `DateTime` type in JavaScript.</span></span>

- <span data-ttu-id="e2dcc-173">当不使用 ASP.NET 时，<xref:System.DateTime> 类型在 JSON 中将表示为一个具有特殊格式的字符串。本主题的“高级信息”一节中对这种特殊格式进行了描述。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-173">When not using ASP.NET, a <xref:System.DateTime> type is represented in JSON as a string with a special format that is described in the Advanced Information section of this topic.</span></span>

- <span data-ttu-id="e2dcc-174"><xref:System.DateTimeOffset> 在 JSON 中以复杂类型表示：{"DateTime":dateTime,"OffsetMinutes":offsetMinutes}。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-174"><xref:System.DateTimeOffset> is represented in JSON as a complex type: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}.</span></span> <span data-ttu-id="e2dcc-175">`offsetMinutes` 成员是与相关事件所在位置关联的本地时间与格林威治标准时间 (GMT)（现在也称为协调世界时 (UTC)）之间的偏移量。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-175">The `offsetMinutes` member is the local time offset from Greenwich Mean Time (GMT), also now referred to as Coordinated Universal Time (UTC), associated with the location of the event of interest.</span></span> <span data-ttu-id="e2dcc-176">`dateTime` 成员表示发生相关事件时的时间实例（同样，当使用 ASP.NET AJAX 时，它将变为 JavaScript 中的 `DateTime`；不使用 ASP.NET AJAX 时，它将变为字符串）。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-176">The `dateTime` member represents the instance in time when the event of interest occurred (again, it becomes a `DateTime` in JavaScript when ASP.NET AJAX is in use and a string when it is not).</span></span> <span data-ttu-id="e2dcc-177">`dateTime` 成员始终用 GMT 格式进行序列化。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-177">On serialization, the `dateTime` member is always serialized in GMT.</span></span> <span data-ttu-id="e2dcc-178">因此，如果描述纽约时间凌晨 3:00，`dateTime` 的时间部分将是上午 8:00，而 `offsetMinutes` 是 300（从 GMT 中减去 300 分钟或 5 个小时）。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-178">So, if describing 3:00 AM New York time, `dateTime` has a time component of 8:00 AM and `offsetMinutes` are 300 (minus 300 minutes or 5 hours from GMT).</span></span>

  > [!NOTE]
  > <span data-ttu-id="e2dcc-179">在将 <xref:System.DateTime> 和 <xref:System.DateTimeOffset> 对象序列化为 JSON 时，它们保留的信息精度仅为毫秒。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-179"><xref:System.DateTime> and <xref:System.DateTimeOffset> objects, when serialized to JSON, only preserve information to millisecond precision.</span></span> <span data-ttu-id="e2dcc-180">在序列化期间，次于毫秒的值（微秒/毫微秒）将丢失。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-180">Sub-millisecond values (micro/nanoseconds) are lost during serialization.</span></span>

### <a name="xml-types-and-json"></a><span data-ttu-id="e2dcc-181">XML 类型和 JSON</span><span class="sxs-lookup"><span data-stu-id="e2dcc-181">XML Types and JSON</span></span>

<span data-ttu-id="e2dcc-182">XML 类型成为 JSON 字符串。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-182">XML types become JSON strings.</span></span>

- <span data-ttu-id="e2dcc-183">例如，如果类型为 System.xml.linq.xelement> 的数据成员 "q" 包含 \<abc/>，则 JSON 为 {"q"： "\<abc/>"}。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-183">For example, if a data member "q" of type XElement contains \<abc/>, the JSON is {"q":"\<abc/>"}.</span></span>

- <span data-ttu-id="e2dcc-184">有一些特殊的规则来指定如何包装 XML。有关更多信息，请参见本主题后面的“高级信息”一节。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-184">There are some special rules that specify how XML is wrapped - for more information, see the Advanced Information section later in this topic.</span></span>

- <span data-ttu-id="e2dcc-185">使用 ASP.NET AJAX 时，如果不希望使用 JavaScript 中的字符串，而是想改用 XML DOM，请在 <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> 上将 <xref:System.ServiceModel.Web.WebGetAttribute> 属性设置为 XML，或者在 <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> 上将 <xref:System.ServiceModel.Web.WebInvokeAttribute> 属性设置为 XML。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-185">If you are using ASP.NET AJAX and do not want to use strings in the JavaScript, but want the XML DOM instead, set the <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> property to XML on <xref:System.ServiceModel.Web.WebGetAttribute> or the <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> property to XML on the <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span></span>

### <a name="collections-dictionaries-and-arrays"></a><span data-ttu-id="e2dcc-186">集合、字典和数组</span><span class="sxs-lookup"><span data-stu-id="e2dcc-186">Collections, Dictionaries and Arrays</span></span>

<span data-ttu-id="e2dcc-187">在 JSON 中，所有的集合、字典和数组都表示为数组。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-187">All collections, dictionaries, and arrays are represented in JSON as arrays.</span></span>

- <span data-ttu-id="e2dcc-188">在 JSON 表示中，忽略使用 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 的任何自定义。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-188">Any customization that uses the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> is ignored in the JSON representation.</span></span>

- <span data-ttu-id="e2dcc-189">词典不能直接用于 JSON。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-189">Dictionaries are not a way to work directly with JSON.</span></span> <span data-ttu-id="e2dcc-190">字典\<字符串，在 WCF 中，对象 > 的支持方式与处理其他 JSON 技术所需的方式不同。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-190">Dictionary\<string,object> may not be supported in the same way in WCF as expected from working with other JSON technologies.</span></span> <span data-ttu-id="e2dcc-191">例如，在字典中，如果“abc”映射到“xyz”，且“def”映射到 42，则 JSON 表示形式不是 {"abc":"xyz","def":42}，而是 [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}]。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-191">For example, if "abc" is mapped to "xyz" and "def" is mapped to 42 in a dictionary, the JSON representation is not {"abc":"xyz","def":42} but is [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}] instead.</span></span>

- <span data-ttu-id="e2dcc-192">如果想要直接使用 JSON（动态访问键和值，而不预定义严格的协定），您有下面几个选择：</span><span class="sxs-lookup"><span data-stu-id="e2dcc-192">If you would like to work with JSON directly (accessing keys and values dynamically, without pre-defining a rigid contract), you have several options:</span></span>

  - <span data-ttu-id="e2dcc-193">请考虑使用[弱类型 JSON 序列化（AJAX）](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md)示例。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-193">Consider using the [Weakly-typed JSON Serialization (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) sample.</span></span>

  - <span data-ttu-id="e2dcc-194">请考虑使用 <xref:System.Runtime.Serialization.ISerializable> 接口和反序列化构造函数。这两个机制允许分别访问序列化和反序列化时的 JSON 键/值对，但不能用于部分受信任的方案。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-194">Consider using the <xref:System.Runtime.Serialization.ISerializable> interface and deserialization constructors - these two mechanisms allow you to access JSON key/value pairs on serialization and deserialization respectively, but do not work in partial trust scenarios.</span></span>

  - <span data-ttu-id="e2dcc-195">请考虑使用[JSON 和 XML 之间的映射，](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md)而不是使用序列化程序。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-195">Consider working with the [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) instead of using a serializer.</span></span>

  - <span data-ttu-id="e2dcc-196">序列化上下文中的*多态性*指的是在需要其基类型的情况下序列化派生类型的能力。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-196">*Polymorphism* in the context of serialization refers to the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="e2dcc-197">在以多态形式使用集合时（例如，在将集合分配给 <xref:System.Object> 时），有一些 JSON 特定的特殊规则。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-197">There are special JSON-specific rules when using collections polymorphically, when, for example, assigning a collection to an <xref:System.Object>.</span></span> <span data-ttu-id="e2dcc-198">有关此问题的更多详细讨论，请参见本主题后面的“高级信息”一节。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-198">This issue is more fully discussed in the Advanced Information section later in this topic.</span></span>

## <a name="additional-details"></a><span data-ttu-id="e2dcc-199">其他详细信息</span><span class="sxs-lookup"><span data-stu-id="e2dcc-199">Additional Details</span></span>

### <a name="order-of-data-members"></a><span data-ttu-id="e2dcc-200">数据成员的顺序</span><span class="sxs-lookup"><span data-stu-id="e2dcc-200">Order of Data Members</span></span>

<span data-ttu-id="e2dcc-201">使用 JSON 时数据成员的顺序并不重要。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-201">Order of data members is not important when using JSON.</span></span> <span data-ttu-id="e2dcc-202">具体而言，即使设置了 <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>，也仍然可以按任意顺序反序列化 JSON 数据。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-202">Specifically, even if <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> is set, JSON data can still be deserialized in any order.</span></span>

### <a name="json-types"></a><span data-ttu-id="e2dcc-203">JSON 类型</span><span class="sxs-lookup"><span data-stu-id="e2dcc-203">JSON Types</span></span>

<span data-ttu-id="e2dcc-204">JSON 类型在反序列化时并不一定要与上面的表匹配。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-204">The JSON type does not have to match the preceding table on deserialization.</span></span> <span data-ttu-id="e2dcc-205">例如，`Int` 通常映射到 JSON 数字，但只要 JSON 字符串中包含有效的数字，就可以成功地从该字符串反序列化到此类型。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-205">For example, an `Int` normally maps to a JSON number, but it can also be successfully deserialized from a JSON string as long as that string contains a valid number.</span></span> <span data-ttu-id="e2dcc-206">即，如果存在名为“q”的 `Int` 数据成员，则 {"q":42} 和 {"q":"42"} 都是有效的。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-206">That is, both {"q":42} and {"q":"42"} are valid if there is an `Int` data member called "q".</span></span>

### <a name="polymorphism"></a><span data-ttu-id="e2dcc-207">多态性</span><span class="sxs-lookup"><span data-stu-id="e2dcc-207">Polymorphism</span></span>

<span data-ttu-id="e2dcc-208">多态序列化具备在需要基类型时序列化派生类型的能力。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-208">Polymorphic serialization consists of the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="e2dcc-209">WCF 可以通过 WCF 与支持 XML 序列化的方式进行 JSON 序列化。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-209">This is supported for JSON serialization by WCF comparable to the way XML serialization is supported.</span></span> <span data-ttu-id="e2dcc-210">例如，可以序列化 `MyDerivedType` 所需的 `MyBaseType`，或者序列化 `Int` 应为 `Object`。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-210">For example, you can serialize `MyDerivedType` where `MyBaseType` is expected, or serialize `Int` where `Object` is expected.</span></span>

<span data-ttu-id="e2dcc-211">需要基类型时，反序列化派生类型可能会丢失类型信息，除非反序列化复杂类型。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-211">Type information may be lost when deserializing a derived type if the base type is expected, unless you are deserializing a complex type.</span></span> <span data-ttu-id="e2dcc-212">例如，如果在需要 <xref:System.Uri> 时序列化 <xref:System.Object>，将导致一个 JSON 字符串。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-212">For example, if <xref:System.Uri> is serialized where <xref:System.Object> is expected, it results in a JSON string.</span></span> <span data-ttu-id="e2dcc-213">如果随后将此字符串反序列化回 <xref:System.Object>，将返回一个 .NET <xref:System.String>。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-213">If this string is then deserialized back into <xref:System.Object>, a .NET <xref:System.String> is returned.</span></span> <span data-ttu-id="e2dcc-214">反序列化程序并不知道该字符串最初属于 <xref:System.Uri> 类型。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-214">The deserializer does not know that the string was initially of type <xref:System.Uri>.</span></span> <span data-ttu-id="e2dcc-215">通常情况下，在需要 <xref:System.Object> 时，所有的 JSON 字符串都将反序列化为 .NET 字符串，并且用于序列化 .NET 集合、字典和数组的所有 JSON 数组都将反序列化为 <xref:System.Array> 类型的 .NET <xref:System.Object>，而不考虑实际的原始类型。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-215">Generally, when expecting <xref:System.Object>, all JSON strings are deserialized as .NET strings, and all JSON arrays used to serialize .NET collections, dictionaries, and arrays are deserialized as .NET <xref:System.Array> of type <xref:System.Object>, regardless of what the actual original type had been.</span></span> <span data-ttu-id="e2dcc-216">JSON 布尔值映射到 .NET <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-216">A JSON boolean maps to a .NET <xref:System.Boolean>.</span></span> <span data-ttu-id="e2dcc-217">但是，在需要 <xref:System.Object> 时，JSON 数字将反序列化为 .NET <xref:System.Int32>、<xref:System.Decimal> 或 <xref:System.Double>，将根据具体情况自动选择最适合的类型。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-217">However when expecting an <xref:System.Object>, JSON numbers are deserialized as either .NET <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double>, where the most appropriate type is automatically picked.</span></span>

<span data-ttu-id="e2dcc-218">反序列化为接口类型时，<xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> 会将声明的类型作为对象进行反序列化。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-218">When deserializing into an interface type, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> deserializes as if the declared type were object.</span></span>

<span data-ttu-id="e2dcc-219">在处理自己的基类型和派生类型时，通常需要使用 <xref:System.Runtime.Serialization.KnownTypeAttribute>、<xref:System.ServiceModel.ServiceKnownTypeAttribute> 或与之等效的机制。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-219">When working with your own base and derived types, using the <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> or an equivalent mechanism is normally required.</span></span> <span data-ttu-id="e2dcc-220">例如，如果您有一个操作，该操作具有一个 `Animal` 返回值并且确实返回了 `Cat` 的实例（从 `Animal`派生），则应将 <xref:System.Runtime.Serialization.KnownTypeAttribute>应用于该操作的 `Animal` 类型或 <xref:System.ServiceModel.ServiceKnownTypeAttribute>，并在这些特性中指定 `Cat` 类型。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-220">For example, if you have an operation that has an `Animal` return value and it actually returns an instance of `Cat` (derived from `Animal`), you should either apply the <xref:System.Runtime.Serialization.KnownTypeAttribute>, to the `Animal` type or the <xref:System.ServiceModel.ServiceKnownTypeAttribute> to the operation and specify the `Cat` type in these attributes.</span></span> <span data-ttu-id="e2dcc-221">有关详细信息，请参阅[数据协定已知类型](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-221">For more information, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span></span>

<span data-ttu-id="e2dcc-222">有关多态序列化工作方式的详细信息，以及使用多态序列化时必须遵从的部分限制的讨论，请参见本主题后面的“高级信息”一节。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-222">For details of how polymorphic serialization works and a discussion of some of the limitations that must be respected when using it, see the Advanced Information section later in this topic.</span></span>

### <a name="versioning"></a><span data-ttu-id="e2dcc-223">版本管理</span><span class="sxs-lookup"><span data-stu-id="e2dcc-223">Versioning</span></span>

<span data-ttu-id="e2dcc-224">JSON 中完全支持数据协定版本管理功能，其中包括 <xref:System.Runtime.Serialization.IExtensibleDataObject> 接口。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-224">The data contract versioning features, including the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface, are fully supported in JSON.</span></span> <span data-ttu-id="e2dcc-225">不仅如此，在多数情况下还可以将一个类型反序列化为一种格式（例如 XML），然后再将其序列化为另一种格式（例如 JSON），同时仍然保留 <xref:System.Runtime.Serialization.IExtensibleDataObject> 中的数据。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-225">Furthermore, in most cases it is possible to deserialize a type in one format (for example, XML) and then serialize it into another format (for example, JSON) and still preserve the data in <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span></span> <span data-ttu-id="e2dcc-226">有关详细信息，请参阅[向前兼容的数据协定](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-226">For more information, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span></span> <span data-ttu-id="e2dcc-227">请记住，JSON 不进行排序，因此所有顺序信息都将丢失。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-227">Remember that JSON is unordered so any order information is lost.</span></span> <span data-ttu-id="e2dcc-228">而且，JSON 不支持多个键/值对使用同一键名。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-228">Furthermore, JSON does not support multiple key/value pairs with the same key name.</span></span> <span data-ttu-id="e2dcc-229">最后，对 <xref:System.Runtime.Serialization.IExtensibleDataObject> 执行的所有操作在本质上都是多态的，即它们的派生类型均被分配给所有类型的基类型 <xref:System.Object>。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-229">Finally, all operations on <xref:System.Runtime.Serialization.IExtensibleDataObject> are inherently polymorphic - that is their derived type are assigned to <xref:System.Object>, the base type for all types.</span></span>

## <a name="json-in-urls"></a><span data-ttu-id="e2dcc-230">URL 中的 JSON</span><span class="sxs-lookup"><span data-stu-id="e2dcc-230">JSON in URLs</span></span>

<span data-ttu-id="e2dcc-231">在结合使用 ASP.NET AJAX 终结点与 HTTP GET 谓词（使用 <xref:System.ServiceModel.Web.WebGetAttribute> 属性）时，传入的参数将出现在请求 URL 而不是消息正文中。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-231">When using ASP.NET AJAX endpoints with the HTTP GET verb (using the <xref:System.ServiceModel.Web.WebGetAttribute> attribute), incoming parameters appear in the request URL instead of the message body.</span></span> <span data-ttu-id="e2dcc-232">即使在请求 URL 中，也支持 JSON，因此，如果操作采用名为 "number" 的 `Int` 和称为 "p" 的 `Person` 复杂类型，则 URL 可能类似于以下 URL。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-232">JSON is supported even in the request URL, so if you have an operation that takes an `Int` called "number" and a `Person` complex type called "p", the URL may resemble the following URL.</span></span>

```html
http://example.com/myservice.svc/MyOperation?number=7&p={"name":"John","age":42}
```

<span data-ttu-id="e2dcc-233">如果使用 ASP.NET AJAX 脚本管理器控件和代理调用服务，则此 URL 将由代理自动生成，而不会显示出来。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-233">If you are using an ASP.NET AJAX Script Manager control and proxy to call the service, this URL is automatically generated by the proxy and is not seen.</span></span> <span data-ttu-id="e2dcc-234">JSON 不能用在非 ASP.NET AJAX 终结点上的 URL 中。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-234">JSON cannot be used in URLs on non-ASP.NET AJAX endpoints.</span></span>

## <a name="advanced-information"></a><span data-ttu-id="e2dcc-235">高级信息</span><span class="sxs-lookup"><span data-stu-id="e2dcc-235">Advanced information</span></span>

### <a name="iserializable-support"></a><span data-ttu-id="e2dcc-236">ISerializable 支持</span><span class="sxs-lookup"><span data-stu-id="e2dcc-236">ISerializable Support</span></span>

#### <a name="supported-and-unsupported-iserializable-types"></a><span data-ttu-id="e2dcc-237">受支持和不受支持的 ISerializable 类型</span><span class="sxs-lookup"><span data-stu-id="e2dcc-237">Supported and Unsupported ISerializable Types</span></span>

<span data-ttu-id="e2dcc-238">通常情况下，序列化/反序列化 JSON 时完全支持实现 <xref:System.Runtime.Serialization.ISerializable> 接口的类型。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-238">In general, types that implement the <xref:System.Runtime.Serialization.ISerializable> interface are fully supported when serializing/deserializing JSON.</span></span> <span data-ttu-id="e2dcc-239">但是，其中有些类型（包括一些 .NET Framework 类型）采用特殊的实现方式，以致以下 JSON 特定的序列化方面会导致它们不能正确地反序列化：</span><span class="sxs-lookup"><span data-stu-id="e2dcc-239">However, some of these types (including some .NET Framework types) are implemented in such a way that the JSON-specific serialization aspects cause them to not deserialize correctly:</span></span>

- <span data-ttu-id="e2dcc-240">使用 <xref:System.Runtime.Serialization.ISerializable> 时，各个数据成员的类型始终无法提前预知。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-240">With <xref:System.Runtime.Serialization.ISerializable>, the type of individual data members is never known in advance.</span></span> <span data-ttu-id="e2dcc-241">这将导致与将类型反序列化为对象时类似的多态情况。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-241">This leads to a polymorphic situation similar to deserializing types into an object.</span></span> <span data-ttu-id="e2dcc-242">正如前文所述，这在 JSON 中可能会导致类型信息丢失。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-242">As mentioned before, this may lead to loss of type information in JSON.</span></span> <span data-ttu-id="e2dcc-243">例如，如果某类型在其 `enum` 实现中序列化一个 <xref:System.Runtime.Serialization.ISerializable>，则当其尝试直接反序列化回 `enum`（未执行正确的强制转换）时将失败。这是因为，`enum` 使用 JSON 中的数字进行序列化，而 JSON 数字却反序列化为内置的 .NET 数值类型（Int32、Decimal 或 Double）。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-243">For example, a type that serializes an `enum` in its <xref:System.Runtime.Serialization.ISerializable> implementation and attempts to deserialize back directly into an `enum` (without proper casts) fails, because an `enum` is serialized using numbers in JSON and JSON numbers deserialize into built-in .NET numeric types (Int32, Decimal or Double).</span></span> <span data-ttu-id="e2dcc-244">因此，数字用于 `enum` 值的事实将丢失。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-244">So the fact that the number used to be an `enum` value is lost.</span></span>

- <span data-ttu-id="e2dcc-245">在反序列化构造函数中依赖特定的反序列化顺序的 <xref:System.Runtime.Serialization.ISerializable> 类型可能也无法反序列化某些 JSON 数据，因为大多数 JSON 序列化程序并不能保证遵循任何特定的顺序。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-245">An <xref:System.Runtime.Serialization.ISerializable> type that depends on a particular order of deserialization in its deserialization constructor may also fail to deserialize some JSON data, because most JSON serializers do not guarantee any specific order.</span></span>

#### <a name="factory-types"></a><span data-ttu-id="e2dcc-246">工厂类型</span><span class="sxs-lookup"><span data-stu-id="e2dcc-246">Factory Types</span></span>

<span data-ttu-id="e2dcc-247">虽然 JSON 中通常支持 <xref:System.Runtime.Serialization.IObjectReference> 接口，但它不支持需要“工厂类型”功能（从 <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> 中返回与实现接口的类型不同的类型实例）的任何类型。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-247">While the <xref:System.Runtime.Serialization.IObjectReference> interface is supported in JSON in general, any types that require the "factory type" feature (returning an instance of a different type from <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> than the type that implements the interface) are not supported.</span></span>

### <a name="datetime-wire-format"></a><span data-ttu-id="e2dcc-248">DateTime 连网格式</span><span class="sxs-lookup"><span data-stu-id="e2dcc-248">DateTime Wire Format</span></span>

<span data-ttu-id="e2dcc-249"><xref:System.DateTime> 值显示为“/Date(700000+0500)/”形式的 JSON 字符串，其中第一个数字（在提供的示例中为 700000）是 GMT 时区中自 1970 年 1 月 1 日午夜以来按正常时间（非夏令时）经过的毫秒数。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-249"><xref:System.DateTime> values appear as JSON strings in the form of "/Date(700000+0500)/", where the first number (700000 in the example provided) is the number of milliseconds in the GMT time zone, regular (non-daylight savings) time since midnight, January 1, 1970.</span></span> <span data-ttu-id="e2dcc-250">该数字可以是负数，以表示之前的时间。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-250">The number may be negative to represent earlier times.</span></span> <span data-ttu-id="e2dcc-251">示例中包括“+0500”的部分可选，它指示该时间属于 <xref:System.DateTimeKind.Local> 类型，即它在反序列化时应转换为本地时区。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-251">The part that consists of "+0500" in the example is optional and indicates that the time is of the <xref:System.DateTimeKind.Local> kind - that is, should be converted to the local time zone on deserialization.</span></span> <span data-ttu-id="e2dcc-252">如果没有该部分，则会将时间反序列化为 <xref:System.DateTimeKind.Utc>。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-252">If it is absent, the time is deserialized as <xref:System.DateTimeKind.Utc>.</span></span> <span data-ttu-id="e2dcc-253">实际数字（本示例中为“0500”）及其符号（+ 或 -）将被忽略。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-253">The actual number ("0500" in this example) and its sign (+ or -) are ignored.</span></span>

<span data-ttu-id="e2dcc-254">序列化 <xref:System.DateTime> 时，写入的 <xref:System.DateTimeKind.Local> 和 <xref:System.DateTimeKind.Unspecified> 时间将带有偏移量，而写入的 <xref:System.DateTimeKind.Utc> 则不带偏移量。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-254">When serializing <xref:System.DateTime>, <xref:System.DateTimeKind.Local> and <xref:System.DateTimeKind.Unspecified> times are written with an offset, and <xref:System.DateTimeKind.Utc> is written without.</span></span>

<span data-ttu-id="e2dcc-255">ASP.NET AJAX 客户端 JavaScript 代码会自动将此类字符串转换为 JavaScript `DateTime` 实例。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-255">The ASP.NET AJAX client JavaScript code automatically converts such strings into JavaScript `DateTime` instances.</span></span> <span data-ttu-id="e2dcc-256">如果有其他字符串采用了类似的形式，则即使它们不属于 .NET 中的 <xref:System.DateTime> 类型，也会对它们执行转换。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-256">If there are other strings that have a similar form that are not of type <xref:System.DateTime> in .NET, they are converted as well.</span></span>

<span data-ttu-id="e2dcc-257">仅当对 "/" 字符进行转义时才会发生转换（也就是说，JSON 类似于 "\\/Date （700000 + 0500）\\/"），因此，出于此原因，WCF 的 JSON 编码器（由 <xref:System.ServiceModel.WebHttpBinding>启用）始终对 "/" 字符进行转义。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-257">The conversion only takes place if the "/" characters are escaped (that is, the JSON looks like "\\/Date(700000+0500)\\/"), and for this reason WCF's JSON encoder (enabled by the <xref:System.ServiceModel.WebHttpBinding>) always escapes the "/" character.</span></span>

### <a name="xml-in-json-strings"></a><span data-ttu-id="e2dcc-258">JSON 字符串中的 XML</span><span class="sxs-lookup"><span data-stu-id="e2dcc-258">XML in JSON Strings</span></span>

#### <a name="xmlelement"></a><span data-ttu-id="e2dcc-259">XmlElement</span><span class="sxs-lookup"><span data-stu-id="e2dcc-259">XmlElement</span></span>

<span data-ttu-id="e2dcc-260"><xref:System.Xml.XmlElement> 按原样执行序列化，而不进行包装。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-260"><xref:System.Xml.XmlElement> is serialized as is, with no wrapping.</span></span> <span data-ttu-id="e2dcc-261">例如，包含 \<abc/> 的 <xref:System.Xml.XmlElement> 类型的数据成员 "x" 如下所示：</span><span class="sxs-lookup"><span data-stu-id="e2dcc-261">For example, data member "x" of type <xref:System.Xml.XmlElement> that contains \<abc/> is represented as follows:</span></span>

```json
{"x":"<abc/>"}
```

#### <a name="arrays-of-xmlnode"></a><span data-ttu-id="e2dcc-262">XmlNode 数组</span><span class="sxs-lookup"><span data-stu-id="e2dcc-262">Arrays of XmlNode</span></span>

<span data-ttu-id="e2dcc-263">在 <xref:System.Array> 类型的标准数据协定命名空间内，该类型的 <xref:System.Xml.XmlNode> 对象被包装在一个称为 ArrayOfXmlNode 的元素中。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-263"><xref:System.Array> objects of type <xref:System.Xml.XmlNode> are wrapped in an element called ArrayOfXmlNode in the standard data contract namespace for the type.</span></span> <span data-ttu-id="e2dcc-264">如果“x”是一个数组，并包含命名空间“ns”中的属性节点“N”，且该属性节点又包含“value”和一个空元素节点“M”，则可以按以下方式表示该数组。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-264">If "x" is an array that contains attribute node "N" in namespace "ns" that contains "value" and an empty element node "M", the representation is as follows.</span></span>

```json
{"x":"<ArrayOfXmlNode xmlns=\"http://schemas.datacontract.org/2004/07/System.Xml\" a:N=\"value\" xmlns:a=\"ns\"><M/></ArrayOfXmlNode>"}
```

 <span data-ttu-id="e2dcc-265">XmlNode 数组的开头（在其他元素之前）不支持空命名空间中的属性。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-265">Attributes in the empty namespace at the beginning of XmlNode arrays (before other elements) are unsupported.</span></span>

#### <a name="ixmlserializable-types-including-xelement-and-dataset"></a><span data-ttu-id="e2dcc-266">包括 XElement 和 DataSet 的 IXmlSerializable 类型</span><span class="sxs-lookup"><span data-stu-id="e2dcc-266">IXmlSerializable Types including XElement and DataSet</span></span>

<span data-ttu-id="e2dcc-267"><xref:System.Runtime.Serialization.ISerializable> 类型可分为“内容类型”、“数据集类型”和“元素类型”。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-267"><xref:System.Runtime.Serialization.ISerializable> types subdivide into "content types", "DataSet types" and "element types".</span></span> <span data-ttu-id="e2dcc-268">有关这些类型的定义，请参阅[数据协定中的 XML 和 ADO.NET 类型](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md)。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-268">For definitions of these types, see [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span></span>

<span data-ttu-id="e2dcc-269">“内容”和“数据集”类型类似，它们都会被序列化为上一节中所讨论的 <xref:System.Array> 的 <xref:System.Xml.XmlNode> 对象。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-269">"Content" and "DataSet" types are serialized similar to <xref:System.Array> objects of <xref:System.Xml.XmlNode> discussed in the previous section.</span></span> <span data-ttu-id="e2dcc-270">它们的包装元素的名称和命名空间与数据协定的名称和相应类型的命名空间相对应。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-270">They are wrapped in an element whose name and namespace corresponds to the data contract name and namespace of the type in question.</span></span>

<span data-ttu-id="e2dcc-271">“元素”类型（例如 <xref:System.Xml.Linq.XElement>）按原样序列化，这与本主题前面讨论的 <xref:System.Xml.XmlElement> 类似。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-271">"Element" types such as <xref:System.Xml.Linq.XElement> are serialized as is, similar to <xref:System.Xml.XmlElement> previously discussed in this topic.</span></span>

### <a name="polymorphism"></a><span data-ttu-id="e2dcc-272">多态性</span><span class="sxs-lookup"><span data-stu-id="e2dcc-272">Polymorphism</span></span>

#### <a name="preserving-type-information"></a><span data-ttu-id="e2dcc-273">保留类型信息</span><span class="sxs-lookup"><span data-stu-id="e2dcc-273">Preserving Type Information</span></span>

<span data-ttu-id="e2dcc-274">正如前文所述，JSON 中支持多态性，但有一些限制。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-274">As stated earlier, polymorphism is supported in JSON with some limitations.</span></span> <span data-ttu-id="e2dcc-275">JavaScript 是一种弱类型语言，类型标识通常并不会产生问题。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-275">JavaScript is a weakly-typed language and type identity is normally not an issue.</span></span> <span data-ttu-id="e2dcc-276">但是，当使用 JSON 在强类型系统 (.NET) 与弱类型系统 (JavaScript) 之间进行通信时，保留类型标识将十分有用。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-276">However, when using JSON to communicate between a strongly-typed system (.NET) and a weakly-typed system (JavaScript), it is useful to preserve type identity.</span></span> <span data-ttu-id="e2dcc-277">例如，数据协定名称为“Square”和“Circle”的类型派生自数据协定名称为“Shape”的类型。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-277">For example, types with data contract names "Square" and "Circle" derive from a type with a data contract name of "Shape".</span></span> <span data-ttu-id="e2dcc-278">如果将“Circle”从 .NET 发送至 JavaScript，随后又将其返回给某个需要“Shape”的 .NET 方法，则 .NET 端就需要它以知道该对象最初为“Circle”，否则任何特定于派生类型的信息（例如，“Circle”上的“radius”数据成员）都可能丢失。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-278">If "Circle" is sent from .NET to JavaScript and is later returned to a .NET method that expects "Shape", it is useful for the .NET side to know that the object in question was originally a "Circle" - otherwise any information specific to the derived type (for example, "radius" data member on "Circle") may be lost.</span></span>

<span data-ttu-id="e2dcc-279">若要保留类型标识，可以在将复杂类型序列化为 JSON 时添加“类型提示”。这样，反序列化程序在识别该提示后，便可以执行相应的操作。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-279">To preserve type identity, when serializing complex types to JSON a "type hint" can be added, and the deserializer recognizes the hint and acts appropriately.</span></span> <span data-ttu-id="e2dcc-280">"类型提示" 是键名称为 "\_\_类型" 的 JSON 键/值对（后跟单词 "type" 的两个下划线）。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-280">The "type hint" is a JSON key/value pair with the key name of "\_\_type" (two underscores followed by the word "type").</span></span> <span data-ttu-id="e2dcc-281">该值是一个 JSON 字符串，其形式为“数据协定名称:数据协定命名空间”（第一个冒号前的所有内容都是名称）。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-281">The value is a JSON string of the form "DataContractName:DataContractNamespace" (anything up to the first colon is the name).</span></span> <span data-ttu-id="e2dcc-282">在前面的示例中，“Circle”可以按以下方式进行序列化。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-282">Using the earlier example, "Circle" can be serialized as follows.</span></span>

```json
{"__type":"Circle:http://example.com/myNamespace","x":50,"y":70,"radius":10}
```

<span data-ttu-id="e2dcc-283">类型提示与 `xsi:type` 属性非常相似，此属性由 XML 架构实例标准定义，供序列化/反序列化 XML 时使用。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-283">The type hint is very similar to the `xsi:type` attribute defined by the XML Schema Instance standard and used when serializing/deserializing XML.</span></span>

<span data-ttu-id="e2dcc-284">由于与类型提示的潜在冲突，禁止了名为 "\_\_类型" 的数据成员。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-284">Data members called "\_\_type" are forbidden due to potential conflict with the type hint.</span></span>

#### <a name="reducing-the-size-of-type-hints"></a><span data-ttu-id="e2dcc-285">减小类型提示的大小</span><span class="sxs-lookup"><span data-stu-id="e2dcc-285">Reducing the Size of Type Hints</span></span>

<span data-ttu-id="e2dcc-286">为了减小 JSON 消息的大小，默认的数据协定命名空间前缀（`http://schemas.datacontract.org/2004/07/`）将替换为 "#" 字符。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-286">To reduce the size of JSON messages, the default data contract namespace prefix (`http://schemas.datacontract.org/2004/07/`) is replaced with the "#" character.</span></span> <span data-ttu-id="e2dcc-287">（若要使此替换成为可逆的，请使用转义规则：如果命名空间以 "#" 或 "\\" 字符开头，则使用额外的 "\\" 字符追加它们。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-287">(To make this replacement reversible, an escaping rule is used: if the namespace starts with the "#" or "\\" characters, they are appended with an extra "\\" character).</span></span> <span data-ttu-id="e2dcc-288">因此，如果"Circle"是.NET 命名空间"MyApp.Shapes"中的类型，其默认数据协定命名空间是 `http://schemas.datacontract.org/2004/07/MyApp` 。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-288">Thus, if "Circle" is a type in the .NET namespace "MyApp.Shapes", its default data contract namespace is `http://schemas.datacontract.org/2004/07/MyApp`.</span></span> <span data-ttu-id="e2dcc-289">下面是 Shapes 及其 JSON 表示形式。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-289">Shapes and the JSON representation is as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50,"y":70,"radius":10}
```

<span data-ttu-id="e2dcc-290">在反序列化时，会了解截断的（#MyApp 形状）和完整的（ http://schemas.datacontract.org/2004/07/MyApp.Shapes) 名称。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-290">Both the truncated (#MyApp.Shapes) and the full (http://schemas.datacontract.org/2004/07/MyApp.Shapes) names is understood on deserialization.</span></span>

#### <a name="type-hint-position-in-json-objects"></a><span data-ttu-id="e2dcc-291">JSON 对象中的类型提示位置</span><span class="sxs-lookup"><span data-stu-id="e2dcc-291">Type Hint Position in JSON Objects</span></span>

<span data-ttu-id="e2dcc-292">请注意，类型提示必须出现在 JSON 表示形式的开头。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-292">Note that the type hint must appear first in the JSON representation.</span></span> <span data-ttu-id="e2dcc-293">这是 JSON 处理中唯一一种重视键/值对顺序的情况。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-293">This is the only case where order of key/value pairs is important in JSON processing.</span></span> <span data-ttu-id="e2dcc-294">例如，下面不是指定类型提示的有效方式。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-294">For example, the following is not a valid way to specify the type hint.</span></span>

```json
{"x":50,"y":70,"radius":10,"__type":"Circle:#MyApp.Shapes"}
```

<span data-ttu-id="e2dcc-295">WCF 和 ASP.NET AJAX 客户端页使用的 <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> 始终首先发出类型提示。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-295">Both the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> used by WCF and ASP.NET AJAX client pages always emit the type hint first.</span></span>

#### <a name="type-hints-apply-only-to-complex-types"></a><span data-ttu-id="e2dcc-296">类型提示仅适用于复杂类型</span><span class="sxs-lookup"><span data-stu-id="e2dcc-296">Type Hints Apply Only to Complex Types</span></span>

<span data-ttu-id="e2dcc-297">对于非复杂类型，无法发出类型提示。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-297">There is no way to emit a type hint for non-complex types.</span></span> <span data-ttu-id="e2dcc-298">例如，如果操作的返回类型为 <xref:System.Object>，但却返回了 Circle，则 JSON 表示形式可能像前面显示的那样保留了类型信息。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-298">For example, if an operation has an <xref:System.Object> return type but returns a Circle, the JSON representation can be as shown earlier and the type information is preserved.</span></span> <span data-ttu-id="e2dcc-299">但是，如果返回了 URI，则 JSON 表示形式将是一个字符串，而该字符串原来用于表示 URI 的事实将丢失。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-299">However, if Uri is returned, the JSON representation is a string and the fact that the string used to represent a Uri is lost.</span></span> <span data-ttu-id="e2dcc-300">这不仅适用于基元类型，也适用于集合和数组。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-300">This applies not only to primitive types but also to collections and arrays.</span></span>

#### <a name="when-are-type-hints-emitted"></a><span data-ttu-id="e2dcc-301">发出类型提示的时机</span><span class="sxs-lookup"><span data-stu-id="e2dcc-301">When Are Type Hints Emitted</span></span>

<span data-ttu-id="e2dcc-302">类型提示可能会显著增大消息的大小（缓解此问题的一种方式是尽量使用较短的数据协定命名空间）。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-302">Type hints may increase message size significantly (one way to mitigate this is to use shorter data contract namespaces if possible).</span></span> <span data-ttu-id="e2dcc-303">因此，在确定是否发出类型提示时，应循序下列规则：</span><span class="sxs-lookup"><span data-stu-id="e2dcc-303">Therefore, the following rules govern whether type hints are emitted:</span></span>

- <span data-ttu-id="e2dcc-304">使用 ASP.NET AJAX 时，始终都应尽可能多地发出类型提示，即使不存在基分配/派生分配（例如，将 Circle 分配给 Circle）也不例外。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-304">When using ASP.NET AJAX, type hints are always emitted whenever possible, even if there is no base/derived assignment - for example, even if a Circle is assigned to a Circle.</span></span> <span data-ttu-id="e2dcc-305">（这是完全实现从弱类型的 JSON 环境调入强类型的 .NET 环境，又不造成大量信息丢失所必需的。）</span><span class="sxs-lookup"><span data-stu-id="e2dcc-305">(This is required to fully enable the process of calling from the weakly-typed JSON environment into the strongly-typed .NET environment with no surprising loss of information.)</span></span>

- <span data-ttu-id="e2dcc-306">如果在未与 ASP.NET 集成的情况下使用 AJAX 服务，则只有当存在基分配/派生分配时才应发出类型提示，即在将 Circle 分配给 Shape 或 <xref:System.Object> 而不是分配给 Circle 时发出。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-306">When using AJAX services with no ASP.NET integration, type hints are only emitted when there is a base/derived assignment - that is, emitted when Circle is assigned to Shape or <xref:System.Object> but not when assigned to Circle.</span></span> <span data-ttu-id="e2dcc-307">这不仅满足了正确实现 JavaScript 客户端所需的信息，而且在最大程度上减少了这些信息，从而提高了性能。但是，如果客户端的设计有误，则无法防止类型信息丢失。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-307">This provides the minimum information required to correctly implement a JavaScript client, thus improving performance, but does not protect against type information loss in incorrectly-designed clients.</span></span> <span data-ttu-id="e2dcc-308">如果要避免处理此客户端问题，请同时避免服务器上的基分配/派生分配。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-308">Avoid base/derived assignments altogether on the server if you want to avoid dealing with this issue on the client.</span></span>

- <span data-ttu-id="e2dcc-309">使用 <xref:System.Runtime.Serialization.DataContractSerializer> 类型时，`alwaysEmitTypeInformation` 构造函数参数允许您在前面两种模式之间进行选择，其默认值为“`false`”（仅在需要时才发出类型提示）。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-309">When using the <xref:System.Runtime.Serialization.DataContractSerializer> type, the `alwaysEmitTypeInformation` constructor parameter allows you to choose between the preceding two modes, with the default being "`false`" (only emit type hints when required).</span></span>

#### <a name="duplicate-data-member-names"></a><span data-ttu-id="e2dcc-310">重复的数据成员名称</span><span class="sxs-lookup"><span data-stu-id="e2dcc-310">Duplicate Data Member Names</span></span>

<span data-ttu-id="e2dcc-311">派生类型信息和基类型信息共同存在于同一个 JSON 对象中，且可以按任意顺序出现。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-311">Derived type information is present in the same JSON object together with base type information, and can occur in any order.</span></span> <span data-ttu-id="e2dcc-312">例如，`Shape` 可以按如下方式表示。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-312">For example, `Shape` may be represented as follows.</span></span>

```json
{"__type":"Shape:#MyApp.Shapes","x":50,"y":70}
```

<span data-ttu-id="e2dcc-313">而 Circle 则可以表示为以下形式。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-313">Whereas Circle may be represented as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50, "radius":10,"y":70}
```

<span data-ttu-id="e2dcc-314">如果基 `Shape` 类型还包含名为 "`radius`" 的数据成员，则这会导致两个序列化（因为 JSON 对象不能有重复的键名）和反序列化（因为不清楚 "radius" 是否引用 `Shape.radius` 或 `Circle.radius`）。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-314">If the base `Shape` type also contained a data member called "`radius`", this leads to a collision on both serialization (because JSON objects cannot have repeating key names) and deserialization (because it is unclear whether "radius" refers to `Shape.radius` or `Circle.radius`).</span></span> <span data-ttu-id="e2dcc-315">因此，虽然一般不建议在数据协定类中使用“属性隐藏”概念（基类和派生类中的数据成员同名），但 JSON 中实际上禁止这种情况。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-315">Therefore, while the concept of "property hiding" (data members of the same name on based and derived classes) is generally not recommended in data contract classes, it is actually forbidden in the case of JSON.</span></span>

#### <a name="polymorphism-and-ixmlserializable-types"></a><span data-ttu-id="e2dcc-316">多态性和 IXmlSerializable 类型</span><span class="sxs-lookup"><span data-stu-id="e2dcc-316">Polymorphism and IXmlSerializable Types</span></span>

<span data-ttu-id="e2dcc-317">根据常规数据协定规则，只要满足已知类型需求，就可以用多态形式将 <xref:System.Xml.Serialization.IXmlSerializable> 类型正常分配给彼此。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-317"><xref:System.Xml.Serialization.IXmlSerializable> types may be polymorphically assigned to each other as usual as long as Known Types requirements are met, according to usual data contract rules.</span></span> <span data-ttu-id="e2dcc-318">但是，如果用序列化 <xref:System.Xml.Serialization.IXmlSerializable> 类型代替序列化 <xref:System.Object>，则会像 JSON 字符串那样导致类型信息丢失。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-318">However, serializing an <xref:System.Xml.Serialization.IXmlSerializable> type in place of <xref:System.Object> results in loss of type information as the result is a JSON string.</span></span>

#### <a name="polymorphism-and-certain-interface-types"></a><span data-ttu-id="e2dcc-319">多态性和某些接口类型</span><span class="sxs-lookup"><span data-stu-id="e2dcc-319">Polymorphism and Certain Interface Types</span></span>

<span data-ttu-id="e2dcc-320">在需要非 <xref:System.Xml.Serialization.IXmlSerializable> 的非集合类型（<xref:System.Xml.Serialization.IXmlSerializable> 除外）时，禁止序列化集合类型或实现 <xref:System.Object> 的类型。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-320">It is forbidden to serialize a collection type or a type that implements <xref:System.Xml.Serialization.IXmlSerializable> where a non-collection type that is not <xref:System.Xml.Serialization.IXmlSerializable> (except for <xref:System.Object>) is expected.</span></span> <span data-ttu-id="e2dcc-321">例如，名为的自定义接口 `IMyInterface` 和实现 `int` 和 `IMyInterface`类型 <xref:System.Collections.Generic.IEnumerable%601> 的类型 `MyType`。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-321">For example, a custom interface called `IMyInterface` and a type `MyType` that implement both <xref:System.Collections.Generic.IEnumerable%601> of type `int` and `IMyInterface`.</span></span> <span data-ttu-id="e2dcc-322">禁止通过返回类型为 `IMyInterface`的操作返回 `MyType`。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-322">It is forbidden to return `MyType` from an operation whose return type is `IMyInterface`.</span></span> <span data-ttu-id="e2dcc-323">这是因为 `MyType` 必须序列化为 JSON 数组并需要类型提示，并在不能将类型提示添加到数组中之前所述，而不能包含复杂类型。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-323">This is because `MyType` must be serialized as a JSON array and requires a type hint, and as stated before you cannot include a type hint with arrays, only with complex types.</span></span>

#### <a name="known-types-and-configuration"></a><span data-ttu-id="e2dcc-324">已知类型和配置</span><span class="sxs-lookup"><span data-stu-id="e2dcc-324">Known Types and Configuration</span></span>

<span data-ttu-id="e2dcc-325"><xref:System.Runtime.Serialization.DataContractSerializer> 使用的所有已知类型机制同样受 <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> 支持。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-325">All of the Known Type mechanisms used by the <xref:System.Runtime.Serialization.DataContractSerializer> are also supported in the same way by the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="e2dcc-326">这两个序列化程序读取相同的配置元素， [\<dataContractSerializer >](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md)中[\<的 >](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) ，以发现通过配置文件添加的已知类型。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-326">Both serializers read the same configuration element, [\<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) in [\<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), to discover known types added through a configuration file.</span></span>

#### <a name="collections-assigned-to-object"></a><span data-ttu-id="e2dcc-327">分配给对象的集合</span><span class="sxs-lookup"><span data-stu-id="e2dcc-327">Collections Assigned to Object</span></span>

<span data-ttu-id="e2dcc-328">序列化分配给对象的集合时，会将它们视为实现 <xref:System.Collections.Generic.IEnumerable%601> 的集合：一个 JSON 数组，其中属于复杂类型的每一项都具有类型提示。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-328">Collections assigned to Object are serialized as if they are collections that implement <xref:System.Collections.Generic.IEnumerable%601>: a JSON array with each entry that has a type hint if it is a complex type.</span></span> <span data-ttu-id="e2dcc-329">例如，分配给 <xref:System.Object> `Shape` 类型 <xref:System.Collections.Generic.List%601> 如下所示。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-329">For example, a <xref:System.Collections.Generic.List%601> of type `Shape` assigned to <xref:System.Object> looks like the following.</span></span>

```json
[{"__type":"Shape:#MyApp.Shapes","x":50,"y":70},
{"__type":"Shape:#MyApp.Shapes","x":58,"y":73},
{"__type":"Shape:#MyApp.Shapes","x":41,"y":32}]
```

<span data-ttu-id="e2dcc-330">当反序列化回 <xref:System.Object> 时：</span><span class="sxs-lookup"><span data-stu-id="e2dcc-330">When deserialized back into <xref:System.Object>:</span></span>

- <span data-ttu-id="e2dcc-331">`Shape` 必须在已知类型列表中。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-331">`Shape` must be in the Known Types list.</span></span> <span data-ttu-id="e2dcc-332">已知类型中 `Shape` 类型的 <xref:System.Collections.Generic.List%601> 不起作用。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-332">Having <xref:System.Collections.Generic.List%601> of type `Shape` in known types has no effect.</span></span> <span data-ttu-id="e2dcc-333">请注意，在这种情况下，不需要将 `Shape` 添加到已知类型中-这是自动完成的。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-333">Note that you do not have to add `Shape` to known types on serialization in this case - this is done automatically.</span></span>

- <span data-ttu-id="e2dcc-334">集合将反序列化为包含 `Shape` 实例的类型 <xref:System.Object> 的 <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-334">The collection is deserialized as an <xref:System.Array> of type <xref:System.Object> that contains `Shape` instances.</span></span>

#### <a name="derived-collections-assigned-to-base-collections"></a><span data-ttu-id="e2dcc-335">分配给基集合的派生集合</span><span class="sxs-lookup"><span data-stu-id="e2dcc-335">Derived Collections Assigned to Base Collections</span></span>

<span data-ttu-id="e2dcc-336">将派生集合分配给基集合时，通常会将该集合作为基类型的集合进行序列化。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-336">When a derived collection is assigned to a base collection, the collection is usually serialized as if it was a collection of the base type.</span></span> <span data-ttu-id="e2dcc-337">但是，如果派生集合的项类型不能分配给基集合的项类型，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-337">However, if the item type of the derived collection cannot be assigned to the item type of the base collection, an exception is thrown.</span></span>

#### <a name="type-hints-and-dictionaries"></a><span data-ttu-id="e2dcc-338">类型提示和字典</span><span class="sxs-lookup"><span data-stu-id="e2dcc-338">Type Hints and Dictionaries</span></span>

<span data-ttu-id="e2dcc-339">将字典分配给 <xref:System.Object> 时，字典中的每个键和值项都将被视为已分配给 <xref:System.Object> 并会获得类型提示。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-339">When a dictionary is assigned to an <xref:System.Object>, each Key and Value entry in the dictionary is treated as if it was assigned to <xref:System.Object> and gets a type hint.</span></span>

<span data-ttu-id="e2dcc-340">序列化字典类型时，包含“Key”和“Value”成员的 JSON 对象不会受 `alwaysEmitTypeInformation` 设置的影响，并只有在前面的集合规则需要时才会包含类型提示。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-340">When serializing dictionary types, the JSON object that contains the "Key" and "Value" members is unaffected by the `alwaysEmitTypeInformation` setting and only contains a type hint when the preceding collection rules require it.</span></span>

### <a name="valid-json-key-names"></a><span data-ttu-id="e2dcc-341">有效的 JSON 键名</span><span class="sxs-lookup"><span data-stu-id="e2dcc-341">Valid JSON Key Names</span></span>

<span data-ttu-id="e2dcc-342">序列化程序 XML 编码的键名不是有效的 XML 名称。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-342">The serializer XML-encodes key names that are not valid XML names.</span></span> <span data-ttu-id="e2dcc-343">例如，名称为 "123" 的数据成员将具有编码名称，如 "\_x0031\_\_x0032\_\_x0033\_"，因为 "123" 是无效的 XML 元素名称（以数字开头）。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-343">For example, a data member with the name of "123" would have an encoded name such as "\_x0031\_\_x0032\_\_x0033\_" because "123" is an invalid XML element name (starts with a digit).</span></span> <span data-ttu-id="e2dcc-344">在 XML 名称中，如果某些国际字符集无效，也会出现类似的情况。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-344">A similar situation may arise with some international character sets not valid in XML names.</span></span> <span data-ttu-id="e2dcc-345">有关 XML 对 JSON 处理的影响的说明，请参阅[json 和 XML 之间的映射](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md)。</span><span class="sxs-lookup"><span data-stu-id="e2dcc-345">For an explanation of this effect of XML on JSON processing, see [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="e2dcc-346">另请参阅</span><span class="sxs-lookup"><span data-stu-id="e2dcc-346">See also</span></span>

- [<span data-ttu-id="e2dcc-347">支持 JSON 和其他数据传输格式</span><span class="sxs-lookup"><span data-stu-id="e2dcc-347">Support for JSON and Other Data Transfer Formats</span></span>](../../../../docs/framework/wcf/feature-details/support-for-json-and-other-data-transfer-formats.md)
