---
title: 病毒消息处理
ms.date: 03/30/2017
ms.assetid: 8d1c5e5a-7928-4a80-95ed-d8da211b8595
ms.openlocfilehash: 704f1a837b7d70f401eaaf7d23847b08972cff50
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/08/2019
ms.locfileid: "59146518"
---
# <a name="poison-message-handling"></a><span data-ttu-id="a7e06-102">病毒消息处理</span><span class="sxs-lookup"><span data-stu-id="a7e06-102">Poison Message Handling</span></span>
<span data-ttu-id="a7e06-103">一个*有害消息*是一条消息，已超出向应用程序的交付尝试最大数目。</span><span class="sxs-lookup"><span data-stu-id="a7e06-103">A *poison message* is a message that has exceeded the maximum number of delivery attempts to the application.</span></span> <span data-ttu-id="a7e06-104">当基于队列的应用程序由于错误而无法处理消息时，可能会引起这种情况。</span><span class="sxs-lookup"><span data-stu-id="a7e06-104">This situation can arise when a queue-based application cannot process a message because of errors.</span></span> <span data-ttu-id="a7e06-105">为符合可靠性要求，排队的应用程序是在事务中接收消息的。</span><span class="sxs-lookup"><span data-stu-id="a7e06-105">To meet reliability demands, a queued application receives messages under a transaction.</span></span> <span data-ttu-id="a7e06-106">中止已接收某个排队消息的事务时，该消息仍会保留在队列中，这样当开始一个新事务时，将对该消息重试操作。</span><span class="sxs-lookup"><span data-stu-id="a7e06-106">Aborting the transaction in which a queued message was received leaves the message in the queue so that the message is retried under a new transaction.</span></span> <span data-ttu-id="a7e06-107">如果导致事务中止的问题未得到更正，则直到超出最大传递尝试次数并导致产生病毒消息时，接收应用程序才会中断接收和中止同一消息的循环。</span><span class="sxs-lookup"><span data-stu-id="a7e06-107">If the problem that caused the transaction to abort is not corrected, the receiving application can get stuck in a loop receiving and aborting the same message until the maximum number of delivery attempts has been exceeded and a poison message results.</span></span>  
  
 <span data-ttu-id="a7e06-108">消息变为病毒消息的原因有很多。</span><span class="sxs-lookup"><span data-stu-id="a7e06-108">A message can become a poison message for many reasons.</span></span> <span data-ttu-id="a7e06-109">最常见的是应用程序特定的原因。</span><span class="sxs-lookup"><span data-stu-id="a7e06-109">The most common reasons are application specific.</span></span> <span data-ttu-id="a7e06-110">例如，如果某个应用程序从队列中读取消息，并执行某些数据库处理，则该应用程序在获取数据库锁时可能会失败，导致中止事务。</span><span class="sxs-lookup"><span data-stu-id="a7e06-110">For example, if an application reads a message from a queue and performs some database processing, the application may fail to get a lock on the database, causing it to abort the transaction.</span></span> <span data-ttu-id="a7e06-111">因为数据库事务已中止，所以消息仍保留在队列中，这会导致应用程序再次读取消息，并再次尝试获取数据库锁。</span><span class="sxs-lookup"><span data-stu-id="a7e06-111">Because the database transaction was aborted, the message remains in the queue, which causes the application to reread the message a second time and make another attempt to acquire a lock on the database.</span></span> <span data-ttu-id="a7e06-112">如果消息包含无效信息，则也可能变为病毒消息。</span><span class="sxs-lookup"><span data-stu-id="a7e06-112">Messages can also become poison if they contain invalid information.</span></span> <span data-ttu-id="a7e06-113">例如，采购订单可能包含无效的客户编号。</span><span class="sxs-lookup"><span data-stu-id="a7e06-113">For example, a purchase order may contain an invalid customer number.</span></span> <span data-ttu-id="a7e06-114">这种情况下，应用程序可能会自动中止事务，将该消息强制变为病毒消息。</span><span class="sxs-lookup"><span data-stu-id="a7e06-114">In these cases, the application may voluntarily abort the transaction and force the message to become a poison message.</span></span>  
  
 <span data-ttu-id="a7e06-115">有时消息可能无法被调度到应用程序，不过，这种情况比较少见。</span><span class="sxs-lookup"><span data-stu-id="a7e06-115">On rare occasions, messages can fail to get dispatched to the application.</span></span> <span data-ttu-id="a7e06-116">Windows Communication Foundation (WCF) 层可能会发现问题的消息，如无效的消息凭据的消息具有错误的框架，如果附加到它，或无效的 action 标头。</span><span class="sxs-lookup"><span data-stu-id="a7e06-116">The Windows Communication Foundation (WCF) layer may find a problem with the message, such as if the message has the wrong frame, invalid message credentials attached to it, or an invalid action header.</span></span> <span data-ttu-id="a7e06-117">在上述情况下，应用程序绝不会收到消息；不过，消息仍可能变为病毒消息，可以对其进行手动处理。</span><span class="sxs-lookup"><span data-stu-id="a7e06-117">In these cases, the application never receives the message; however, the message can still become a poison message and be processed manually.</span></span>  
  
## <a name="handling-poison-messages"></a><span data-ttu-id="a7e06-118">处理病毒消息</span><span class="sxs-lookup"><span data-stu-id="a7e06-118">Handling Poison Messages</span></span>  
 <span data-ttu-id="a7e06-119">在 WCF 中，病毒消息处理提供了用于接收应用程序处理消息无法调度到应用程序或那些虽然调度到应用程序，但其失败由于特定于应用程序要处理的消息的机制原因。</span><span class="sxs-lookup"><span data-stu-id="a7e06-119">In WCF, poison message handling provides a mechanism for a receiving application to deal with messages that cannot be dispatched to the application, or messages that are dispatched to the application but which fail to be processed because of application-specific reasons.</span></span> <span data-ttu-id="a7e06-120">病毒消息处理是由每个可用排队绑定中的下列属性配置的：</span><span class="sxs-lookup"><span data-stu-id="a7e06-120">Poison message handling is configured by the following properties in each of the available queued bindings:</span></span>  
  
-   `ReceiveRetryCount`<span data-ttu-id="a7e06-121">.</span><span class="sxs-lookup"><span data-stu-id="a7e06-121">.</span></span> <span data-ttu-id="a7e06-122">一个整数值，指示将某个消息从应用程序队列传递到应用程序的最大重试次数。</span><span class="sxs-lookup"><span data-stu-id="a7e06-122">An integer value that indicates the maximum number of times to retry delivery of a message from the application queue to the application.</span></span> <span data-ttu-id="a7e06-123">默认值为 5。</span><span class="sxs-lookup"><span data-stu-id="a7e06-123">The default value is 5.</span></span> <span data-ttu-id="a7e06-124">对于立即重试就可以修复问题（如数据库出现临时死锁）的情况，这个数值已足够了。</span><span class="sxs-lookup"><span data-stu-id="a7e06-124">This is sufficient in cases where an immediate retry fixes the problem, such as with a temporary deadlock on a database.</span></span>  
  
-   `MaxRetryCycles`<span data-ttu-id="a7e06-125">.</span><span class="sxs-lookup"><span data-stu-id="a7e06-125">.</span></span> <span data-ttu-id="a7e06-126">一个整数值，指示最大重试周期数。</span><span class="sxs-lookup"><span data-stu-id="a7e06-126">An integer value that indicates the maximum number of retry cycles.</span></span> <span data-ttu-id="a7e06-127">一个重试周期包括将消息从应用程序队列传送到重试子队列，在经过可配置的延迟后，从重试子队列将消息传送回应用程序队列以便重新尝试传递。</span><span class="sxs-lookup"><span data-stu-id="a7e06-127">A retry cycle consists of transferring a message from the application queue to the retry subqueue and, after a configurable delay, from the retry subqueue back into the application queue to reattempt delivery.</span></span> <span data-ttu-id="a7e06-128">默认值为 2。</span><span class="sxs-lookup"><span data-stu-id="a7e06-128">The default value is 2.</span></span> <span data-ttu-id="a7e06-129">在 [!INCLUDE[wv](../../../../includes/wv-md.md)] 中，消息尝试最多 (`ReceiveRetryCount` +1) \* (`MaxRetryCycles` + 1) 次。</span><span class="sxs-lookup"><span data-stu-id="a7e06-129">On [!INCLUDE[wv](../../../../includes/wv-md.md)], the message is tried a maximum of (`ReceiveRetryCount` +1) \* (`MaxRetryCycles` + 1) times.</span></span> `MaxRetryCycles` <span data-ttu-id="a7e06-130">上，将忽略[!INCLUDE[ws2003](../../../../includes/ws2003-md.md)]和[!INCLUDE[wxp](../../../../includes/wxp-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="a7e06-130">is ignored on [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span></span>  
  
-   `RetryCycleDelay`<span data-ttu-id="a7e06-131">.</span><span class="sxs-lookup"><span data-stu-id="a7e06-131">.</span></span> <span data-ttu-id="a7e06-132">重试周期之间的时间延迟。</span><span class="sxs-lookup"><span data-stu-id="a7e06-132">The time delay between retry cycles.</span></span> <span data-ttu-id="a7e06-133">默认值为 30 分钟。</span><span class="sxs-lookup"><span data-stu-id="a7e06-133">The default value is 30 minutes.</span></span> `MaxRetryCycles` <span data-ttu-id="a7e06-134">和`RetryCycleDelay`共同提供了一种机制来解决周期性延迟之后重试可修复该问题。</span><span class="sxs-lookup"><span data-stu-id="a7e06-134">and `RetryCycleDelay` together provide a mechanism to address the problem where a retry after a periodic delay fixes the problem.</span></span> <span data-ttu-id="a7e06-135">例如，这种机制可以处理 SQL Server 挂起的事务提交中锁定的行集。</span><span class="sxs-lookup"><span data-stu-id="a7e06-135">For example, this handles a locked row set in SQL Server pending transaction commit.</span></span>  
  
-   `ReceiveErrorHandling`<span data-ttu-id="a7e06-136">.</span><span class="sxs-lookup"><span data-stu-id="a7e06-136">.</span></span> <span data-ttu-id="a7e06-137">一个枚举，指示对在已尝试过最大重试次数后仍无法传递的消息所采取的操作。</span><span class="sxs-lookup"><span data-stu-id="a7e06-137">An enumeration that indicates the action to take for a message that has failed delivery after the maximum number of retries has been attempted.</span></span> <span data-ttu-id="a7e06-138">可能的值包括“错误”、“删除”、“拒绝”和“移动”。</span><span class="sxs-lookup"><span data-stu-id="a7e06-138">The values can be Fault, Drop, Reject, and Move.</span></span> <span data-ttu-id="a7e06-139">默认选项为“错误”。</span><span class="sxs-lookup"><span data-stu-id="a7e06-139">The default option is Fault.</span></span>  
  
-   <span data-ttu-id="a7e06-140">错误。</span><span class="sxs-lookup"><span data-stu-id="a7e06-140">Fault.</span></span> <span data-ttu-id="a7e06-141">此选项会向导致 `ServiceHost` 出现错误的侦听器发送一个错误。</span><span class="sxs-lookup"><span data-stu-id="a7e06-141">This option sends a fault to the listener that caused the `ServiceHost` to fault.</span></span> <span data-ttu-id="a7e06-142">必须利用其他一些外部机制将该消息从应用程序中移除，应用程序才能继续处理队列中的消息。</span><span class="sxs-lookup"><span data-stu-id="a7e06-142">The message must be removed from the application queue by some external mechanism before the application can continue to process messages from the queue.</span></span>  
  
-   <span data-ttu-id="a7e06-143">删除。</span><span class="sxs-lookup"><span data-stu-id="a7e06-143">Drop.</span></span> <span data-ttu-id="a7e06-144">此选项删除病毒消息，该消息永远不会再传递到应用程序。</span><span class="sxs-lookup"><span data-stu-id="a7e06-144">This option drops the poison message and the message is never delivered to the application.</span></span> <span data-ttu-id="a7e06-145">如果该消息的 `TimeToLive` 属性在此时已过期，那么此消息可能会显示在发送方的死信队列中。</span><span class="sxs-lookup"><span data-stu-id="a7e06-145">If the message's `TimeToLive` property has expired at this point, then the message may appear in the sender's dead-letter queue.</span></span> <span data-ttu-id="a7e06-146">如果不是这种情况，则该消息将不会显示在任何位置。</span><span class="sxs-lookup"><span data-stu-id="a7e06-146">If not, the message does not appear anywhere.</span></span> <span data-ttu-id="a7e06-147">此选项指示用户尚未指定丢失消息时该如何处理。</span><span class="sxs-lookup"><span data-stu-id="a7e06-147">This option indicates that the user has not specified what to do if the message is lost.</span></span>  
  
-   <span data-ttu-id="a7e06-148">拒绝。</span><span class="sxs-lookup"><span data-stu-id="a7e06-148">Reject.</span></span> <span data-ttu-id="a7e06-149">此选项仅在 [!INCLUDE[wv](../../../../includes/wv-md.md)] 中可用。</span><span class="sxs-lookup"><span data-stu-id="a7e06-149">This option is available only on [!INCLUDE[wv](../../../../includes/wv-md.md)].</span></span> <span data-ttu-id="a7e06-150">选择此选项会指示消息队列 (MSMQ) 将否定确认发送回发送队列管理器，以说明应用程序无法接收该消息。</span><span class="sxs-lookup"><span data-stu-id="a7e06-150">This instructs Message Queuing (MSMQ) to send a negative acknowledgement back to the sending queue manager that the application cannot receive the message.</span></span> <span data-ttu-id="a7e06-151">该消息会放入发送队列管理器的死信队列中。</span><span class="sxs-lookup"><span data-stu-id="a7e06-151">The message is placed in the sending queue manager's dead-letter queue.</span></span>  
  
-   <span data-ttu-id="a7e06-152">移动。</span><span class="sxs-lookup"><span data-stu-id="a7e06-152">Move.</span></span> <span data-ttu-id="a7e06-153">此选项仅在 [!INCLUDE[wv](../../../../includes/wv-md.md)] 中可用。</span><span class="sxs-lookup"><span data-stu-id="a7e06-153">This option is available only on [!INCLUDE[wv](../../../../includes/wv-md.md)].</span></span> <span data-ttu-id="a7e06-154">选择此选项会将病毒消息移动到病毒消息队列，以供以后由病毒消息处理应用程序进行处理。</span><span class="sxs-lookup"><span data-stu-id="a7e06-154">This moves the poison message to a poison-message queue for later processing by a poison-message handling application.</span></span> <span data-ttu-id="a7e06-155">病毒消息队列是应用程序队列的子队列。</span><span class="sxs-lookup"><span data-stu-id="a7e06-155">The poison-message queue is a subqueue of the application queue.</span></span> <span data-ttu-id="a7e06-156">病毒消息处理应用程序可作为从病毒队列中读取消息的 WCF 服务。</span><span class="sxs-lookup"><span data-stu-id="a7e06-156">A poison-message handling application can be a WCF service that reads messages out of the poison queue.</span></span> <span data-ttu-id="a7e06-157">病毒队列是应用程序队列的子队列，其地址为 net.msmq://\<*机器名*>/*applicationQueue*; poison，其中*计算机名*是该队列所驻留的计算机的名称和*applicationQueue*是特定于应用程序队列的名称。</span><span class="sxs-lookup"><span data-stu-id="a7e06-157">The poison queue is a subqueue of the application queue and can be addressed as net.msmq://\<*machine-name*>/*applicationQueue*;poison, where *machine-name* is the name of the computer on which the queue resides and the *applicationQueue* is the name of the application-specific queue.</span></span>  
  
 <span data-ttu-id="a7e06-158">下面是对消息尝试传递的最大次数：</span><span class="sxs-lookup"><span data-stu-id="a7e06-158">The following are the maximum number of delivery attempts made for a message:</span></span>  
  
-   <span data-ttu-id="a7e06-159">对于 [!INCLUDE[wv](../../../../includes/wv-md.md)]，请用 ((ReceiveRetryCount+1) \* (MaxRetryCycles + 1)) 计算。</span><span class="sxs-lookup"><span data-stu-id="a7e06-159">((ReceiveRetryCount+1) \* (MaxRetryCycles + 1)) on [!INCLUDE[wv](../../../../includes/wv-md.md)].</span></span>  
  
-   <span data-ttu-id="a7e06-160">对于 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 和 [!INCLUDE[wxp](../../../../includes/wxp-md.md)]，请用 (ReceiveRetryCount + 1) 计算。</span><span class="sxs-lookup"><span data-stu-id="a7e06-160">(ReceiveRetryCount + 1) on [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a7e06-161">对于成功传递的消息，不会再重试传递。</span><span class="sxs-lookup"><span data-stu-id="a7e06-161">No retries are made for a message that is delivered successfully.</span></span>  
  
 <span data-ttu-id="a7e06-162">为了跟踪尝试读取消息的次数，[!INCLUDE[wv](../../../../includes/wv-md.md)] 保留了一个持久性消息属性（用于对中止次数进行计数）和一个移动计数属性（用于对消息在应用程序队列和子队列之间移动的次数进行计数）。</span><span class="sxs-lookup"><span data-stu-id="a7e06-162">To keep track of the number of times a message read is attempted, [!INCLUDE[wv](../../../../includes/wv-md.md)] maintains a durable message property that counts the number of aborts and a move count property that counts the number of times the message moves between the application queue and subqueues.</span></span> <span data-ttu-id="a7e06-163">WCF 通道使用上述属性计算接收重试计数和重试周期计数。</span><span class="sxs-lookup"><span data-stu-id="a7e06-163">The WCF channel uses these to compute the receive retry count and the retry cycles count.</span></span> <span data-ttu-id="a7e06-164">上[!INCLUDE[ws2003](../../../../includes/ws2003-md.md)]和[!INCLUDE[wxp](../../../../includes/wxp-md.md)]，中止计数由 WCF 通道在内存中维护，并且如果应用程序失败会重置。</span><span class="sxs-lookup"><span data-stu-id="a7e06-164">On [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)], the abort count is maintained in memory by the WCF channel and is reset if the application fails.</span></span> <span data-ttu-id="a7e06-165">此外，WCF 通道可以保留在任何时候，中止计数最多 256 个内存中的消息。</span><span class="sxs-lookup"><span data-stu-id="a7e06-165">Also, the WCF channel can hold the abort counts for up to 256 messages in memory at any time.</span></span> <span data-ttu-id="a7e06-166">如果读取了第 257 条消息，则时间最早的消息中止计数会被重置。</span><span class="sxs-lookup"><span data-stu-id="a7e06-166">If a 257th message is read, then the oldest message's abort count is reset.</span></span>  
  
 <span data-ttu-id="a7e06-167">中止计数和移动计数属性均可用于通过操作上下文进行的服务操作。</span><span class="sxs-lookup"><span data-stu-id="a7e06-167">The abort count and move count properties are available to the service operation through the operation context.</span></span> <span data-ttu-id="a7e06-168">下面的代码示例演示如何访问上述两个属性。</span><span class="sxs-lookup"><span data-stu-id="a7e06-168">The following code example shows how to access them.</span></span>  
  
 [!code-csharp[S_UE_MSMQ_Poison#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_ue_msmq_poison/cs/service.cs#1)]  
  
 <span data-ttu-id="a7e06-169">WCF 提供了两个标准排队的绑定：</span><span class="sxs-lookup"><span data-stu-id="a7e06-169">WCF provides two standard queued bindings:</span></span>  
  
-   <xref:System.ServiceModel.NetMsmqBinding><span data-ttu-id="a7e06-170">.</span><span class="sxs-lookup"><span data-stu-id="a7e06-170">.</span></span> <span data-ttu-id="a7e06-171">一个[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]适合于执行基于队列的通信与其他 WCF 终结点的绑定。</span><span class="sxs-lookup"><span data-stu-id="a7e06-171">A [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] binding suitable for performing queue-based communication with other WCF endpoints.</span></span>  
  
-   <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding><span data-ttu-id="a7e06-172">.</span><span class="sxs-lookup"><span data-stu-id="a7e06-172">.</span></span> <span data-ttu-id="a7e06-173">这种绑定适用于与现有消息队列应用程序之间的通信。</span><span class="sxs-lookup"><span data-stu-id="a7e06-173">A binding suitable for communicating with existing Message Queuing applications.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a7e06-174">您可以更改基于您的 WCF 服务的要求这些绑定中的属性。</span><span class="sxs-lookup"><span data-stu-id="a7e06-174">You can alter properties in these bindings based on the requirements of your WCF service.</span></span> <span data-ttu-id="a7e06-175">对于接收应用程序来说，整个病毒消息处理机制都是本地的。</span><span class="sxs-lookup"><span data-stu-id="a7e06-175">The entire poison message handling mechanism is local to the receiving application.</span></span> <span data-ttu-id="a7e06-176">处理过程对于发送应用程序是不可见的，除非接收应用程序最终停止接收并将否定确认发送回发送方。</span><span class="sxs-lookup"><span data-stu-id="a7e06-176">The process is invisible to the sending application unless the receiving application ultimately stops and sends a negative acknowledgment back to the sender.</span></span> <span data-ttu-id="a7e06-177">这种情况下，该消息会移动到发送方的死信队列中。</span><span class="sxs-lookup"><span data-stu-id="a7e06-177">In that case, the message is moved to the sender's dead-letter queue.</span></span>  
  
## <a name="best-practice-handling-msmqpoisonmessageexception"></a><span data-ttu-id="a7e06-178">最佳做法：Handling MsmqPoisonMessageException</span><span class="sxs-lookup"><span data-stu-id="a7e06-178">Best Practice: Handling MsmqPoisonMessageException</span></span>  
 <span data-ttu-id="a7e06-179">当服务确定某个消息是病毒消息时，排队传输会引发一个 <xref:System.ServiceModel.MsmqPoisonMessageException>，其中包含病毒消息的 `LookupId`。</span><span class="sxs-lookup"><span data-stu-id="a7e06-179">When the service determines that a message is poison, the queued transport throws a <xref:System.ServiceModel.MsmqPoisonMessageException> that contains the `LookupId` of the poison message.</span></span>  
  
 <span data-ttu-id="a7e06-180">接收应用程序可以实现 <xref:System.ServiceModel.Dispatcher.IErrorHandler> 接口，以处理应用程序要求处理的任何错误。</span><span class="sxs-lookup"><span data-stu-id="a7e06-180">A receiving application can implement the <xref:System.ServiceModel.Dispatcher.IErrorHandler> interface to handle any errors that the application requires.</span></span> <span data-ttu-id="a7e06-181">有关详细信息，请参阅[扩展控件上的错误处理和报告](../../../../docs/framework/wcf/samples/extending-control-over-error-handling-and-reporting.md)。</span><span class="sxs-lookup"><span data-stu-id="a7e06-181">For more information, see [Extending Control Over Error Handling and Reporting](../../../../docs/framework/wcf/samples/extending-control-over-error-handling-and-reporting.md).</span></span>  
  
 <span data-ttu-id="a7e06-182">应用程序可能要求对病毒消息能进行某种自动处理，也就是将病毒消息移动至病毒消息队列，以便服务可以访问队列中的其他消息。</span><span class="sxs-lookup"><span data-stu-id="a7e06-182">The application may require some kind of automated handling of poison messages that moves the poison messages to a poison message queue so that the service can access the rest of the messages in the queue.</span></span> <span data-ttu-id="a7e06-183">唯一需要使用错误处理程序机制来侦听病毒消息异常情况的情形是 <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveErrorHandling%2A> 设置被设置为 <xref:System.ServiceModel.ReceiveErrorHandling.Fault> 时。</span><span class="sxs-lookup"><span data-stu-id="a7e06-183">The only scenario for using the error-handler mechanism to listen for poison-message exceptions is when the <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveErrorHandling%2A> setting is set to <xref:System.ServiceModel.ReceiveErrorHandling.Fault>.</span></span> <span data-ttu-id="a7e06-184">Message Queuing 3.0 的病毒消息示例阐释了这一行为。</span><span class="sxs-lookup"><span data-stu-id="a7e06-184">The poison-message sample for Message Queuing 3.0 demonstrates this behavior.</span></span> <span data-ttu-id="a7e06-185">下面说明了处理病毒消息应执行的步骤，包括最佳方案：</span><span class="sxs-lookup"><span data-stu-id="a7e06-185">The following outlines the steps to take to handle poison messages, including best practices:</span></span>  
  
1.  <span data-ttu-id="a7e06-186">确保您的病毒消息设置可以反映您的应用程序需求。</span><span class="sxs-lookup"><span data-stu-id="a7e06-186">Ensure your poison settings reflect the requirements of your application.</span></span> <span data-ttu-id="a7e06-187">在进行设置时，确保您对 [!INCLUDE[wv](../../../../includes/wv-md.md)]、[!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 和 [!INCLUDE[wxp](../../../../includes/wxp-md.md)] 之间消息队列功能的差异有所了解。</span><span class="sxs-lookup"><span data-stu-id="a7e06-187">When working with the settings, ensure that you understand the differences between the capabilities of Message Queuing on [!INCLUDE[wv](../../../../includes/wv-md.md)], [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)], and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span></span>  
  
2.  <span data-ttu-id="a7e06-188">如果需要，请实现 `IErrorHandler` 以处理病毒消息错误。</span><span class="sxs-lookup"><span data-stu-id="a7e06-188">If required, implement the `IErrorHandler` to handle poison-message errors.</span></span> <span data-ttu-id="a7e06-189">由于将 `ReceiveErrorHandling` 设置为 `Fault` 需要一个手动机制以便将病毒消息移出队列或更正外部相关问题，因此当 `IErrorHandler` 设置为 `ReceiveErrorHandling` 时，该机制的典型用法就是实现 `Fault`，如下面的代码中所示。</span><span class="sxs-lookup"><span data-stu-id="a7e06-189">Because setting `ReceiveErrorHandling` to `Fault` requires a manual mechanism to move the poison message out of the queue or to correct an external dependent issue, the typical usage is to implement `IErrorHandler` when `ReceiveErrorHandling` is set to `Fault`, as shown in the following code.</span></span>  
  
     [!code-csharp[S_UE_MSMQ_Poison#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_ue_msmq_poison/cs/poisonerrorhandler.cs#2)]  
  
3.  <span data-ttu-id="a7e06-190">创建服务行为可以使用的 `PoisonBehaviorAttribute`。</span><span class="sxs-lookup"><span data-stu-id="a7e06-190">Create a `PoisonBehaviorAttribute` that the service behavior can use.</span></span> <span data-ttu-id="a7e06-191">该行为会在调度程序上安装 `IErrorHandler`。</span><span class="sxs-lookup"><span data-stu-id="a7e06-191">The behavior installs the `IErrorHandler` on the dispatcher.</span></span> <span data-ttu-id="a7e06-192">请参见下面的代码示例。</span><span class="sxs-lookup"><span data-stu-id="a7e06-192">See the following code example.</span></span>  
  
     [!code-csharp[S_UE_MSMQ_Poison#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_ue_msmq_poison/cs/poisonbehaviorattribute.cs#3)]  
  
4.  <span data-ttu-id="a7e06-193">确保你的服务已使用病毒行为属性批注过。</span><span class="sxs-lookup"><span data-stu-id="a7e06-193">Ensure that your service is annotated with the poison behavior attribute.</span></span>  

 <span data-ttu-id="a7e06-194">另外，如果 `ReceiveErrorHandling` 设置为 `Fault`，则 `ServiceHost` 会在遇到病毒消息时出现错误。</span><span class="sxs-lookup"><span data-stu-id="a7e06-194">In addition, if the `ReceiveErrorHandling` is set to `Fault`, the `ServiceHost` faults when encountering the poison message.</span></span> <span data-ttu-id="a7e06-195">您可以挂钩出错的事件，并关闭服务，采取更正措施，然后重新启动。</span><span class="sxs-lookup"><span data-stu-id="a7e06-195">You can hook up to the faulted event and shut down the service, take corrective actions, and restart.</span></span> <span data-ttu-id="a7e06-196">例如，可以记下传播到 `LookupId` 的 <xref:System.ServiceModel.MsmqPoisonMessageException> 中的 `IErrorHandler`，当服务主机出错时，您可以使用 `System.Messaging` API 从队列接收消息，同时使用 `LookupId` 从队列中移除该消息，并将该消息存储在外部存储区或其他队列中。</span><span class="sxs-lookup"><span data-stu-id="a7e06-196">For example, the `LookupId` in the <xref:System.ServiceModel.MsmqPoisonMessageException> propagated to the `IErrorHandler` can be noted and when the service host faults, you could use the `System.Messaging` API to receive the message from the queue using the `LookupId` to remove the message from the queue and store the message in some external store or another queue.</span></span> <span data-ttu-id="a7e06-197">然后，您可以重新启动 `ServiceHost` 以继续正常处理。</span><span class="sxs-lookup"><span data-stu-id="a7e06-197">You can then restart `ServiceHost` to resume normal processing.</span></span> <span data-ttu-id="a7e06-198">[MSMQ 4.0 中的病毒消息处理](../../../../docs/framework/wcf/samples/poison-message-handling-in-msmq-4-0.md)演示此行为。</span><span class="sxs-lookup"><span data-stu-id="a7e06-198">The [Poison Message Handling in MSMQ 4.0](../../../../docs/framework/wcf/samples/poison-message-handling-in-msmq-4-0.md) demonstrates this behavior.</span></span>  
  
## <a name="transaction-time-out-and-poison-messages"></a><span data-ttu-id="a7e06-199">事务超时和病毒消息</span><span class="sxs-lookup"><span data-stu-id="a7e06-199">Transaction Time-Out and Poison Messages</span></span>  
 <span data-ttu-id="a7e06-200">在排队传输通道和用户代码之间可能会出现一类错误。</span><span class="sxs-lookup"><span data-stu-id="a7e06-200">A class of errors can occur between the queued transport channel and the user code.</span></span> <span data-ttu-id="a7e06-201">这类错误可以在中间层（如消息安全层）或服务调度逻辑中检测到。</span><span class="sxs-lookup"><span data-stu-id="a7e06-201">These errors can be detected by layers in-between, such as the message security layer or the service dispatching logic.</span></span> <span data-ttu-id="a7e06-202">例如，无论是在 SOAP 安全层中检测到缺少 X.509 证书，还是缺少操作，都会导致不将消息调度到应用程序。</span><span class="sxs-lookup"><span data-stu-id="a7e06-202">For example, a missing X.509 certificate detected in the SOAP security layer and a missing action are cases where the message does get dispatched to the application.</span></span> <span data-ttu-id="a7e06-203">出现这种情况时，服务模型会删除该消息。</span><span class="sxs-lookup"><span data-stu-id="a7e06-203">When this happens, the service model drops the message.</span></span> <span data-ttu-id="a7e06-204">因为该消息是在事务中读取的，并且无法提供此事务的结果，所以事务最终会超时、中止，同时该消息会传送回队列中。</span><span class="sxs-lookup"><span data-stu-id="a7e06-204">Because the message is read in a transaction and an outcome for that transaction cannot be provided, the transaction eventually times out, aborts, and the message is put back into the queue.</span></span> <span data-ttu-id="a7e06-205">也就是说，对于某一类错误，事务不会立即中止，而是一直等待，直到事务超时。您可以使用 <xref:System.ServiceModel.ServiceBehaviorAttribute> 修改服务的事务超时时间。</span><span class="sxs-lookup"><span data-stu-id="a7e06-205">In other words, for a certain class of errors, the transaction does not immediately abort but waits until the transaction times out. You can modify the transaction time-out for a service using <xref:System.ServiceModel.ServiceBehaviorAttribute>.</span></span>  
  
 <span data-ttu-id="a7e06-206">若要在计算机范围内更改事务超时时间，请修改 machine.config 文件并设置适当的事务超时时间。需要特别注意，根据在事务中设置的超时时间，事务最终会中止并返回到队列，其中止计数会递增。</span><span class="sxs-lookup"><span data-stu-id="a7e06-206">To change the transaction time-out on a computer-wide basis, modify the machine.config file and set the appropriate transaction time-out. It is important to note that, depending on the time-out set in the transaction, the transaction eventually aborts and goes back to the queue and its abort count is incremented.</span></span> <span data-ttu-id="a7e06-207">最后，消息变为病毒消息，并按照用户的设置进行正确处理。</span><span class="sxs-lookup"><span data-stu-id="a7e06-207">Eventually, the message becomes poison and the right disposition is made according to the user settings.</span></span>  
  
## <a name="sessions-and-poison-messages"></a><span data-ttu-id="a7e06-208">会话和病毒消息</span><span class="sxs-lookup"><span data-stu-id="a7e06-208">Sessions and Poison Messages</span></span>  
 <span data-ttu-id="a7e06-209">会话所经历的重试和病毒消息处理过程与单个消息的经历是一样的。</span><span class="sxs-lookup"><span data-stu-id="a7e06-209">A session undergoes the same retry and poison-message handling procedures as a single message.</span></span> <span data-ttu-id="a7e06-210">前面列出的病毒消息属性适用于整个会话。</span><span class="sxs-lookup"><span data-stu-id="a7e06-210">The properties previously listed for poison messages apply to the entire session.</span></span> <span data-ttu-id="a7e06-211">这意味着整个会话将会重试，并前进到最终病毒消息队列或发送方的死信队列（如果消息被拒绝）。</span><span class="sxs-lookup"><span data-stu-id="a7e06-211">This means that the entire session is retried and goes to a final poison-message queue or the sender’s dead-letter queue if the message is rejected.</span></span>  
  
## <a name="batching-and-poison-messages"></a><span data-ttu-id="a7e06-212">批处理和病毒消息</span><span class="sxs-lookup"><span data-stu-id="a7e06-212">Batching and Poison Messages</span></span>  
 <span data-ttu-id="a7e06-213">如果某条消息变为病毒消息，并且是某个批处理的一部分，则整个批处理将回滚，通道会返回到一次读取一条消息的状态。</span><span class="sxs-lookup"><span data-stu-id="a7e06-213">If a message becomes a poison message and is part of a batch, then the entire batch is rolled back and the channel returns to reading one message at a time.</span></span> <span data-ttu-id="a7e06-214">有关批处理的详细信息，请参阅[在事务中的批处理消息](../../../../docs/framework/wcf/feature-details/batching-messages-in-a-transaction.md)</span><span class="sxs-lookup"><span data-stu-id="a7e06-214">For more information about batching, see [Batching Messages in a Transaction](../../../../docs/framework/wcf/feature-details/batching-messages-in-a-transaction.md)</span></span>  
  
## <a name="poison-message-handling-for-messages-in-a-poison-queue"></a><span data-ttu-id="a7e06-215">对病毒队列中的消息进行病毒消息处理</span><span class="sxs-lookup"><span data-stu-id="a7e06-215">Poison-message Handling for Messages in a Poison Queue</span></span>  
 <span data-ttu-id="a7e06-216">只要有消息放入病毒消息队列中，病毒消息处理就不会结束。</span><span class="sxs-lookup"><span data-stu-id="a7e06-216">Poison-message handling does not end when a message is placed in the poison-message queue.</span></span> <span data-ttu-id="a7e06-217">还必须读取和处理病毒消息队列中的消息。</span><span class="sxs-lookup"><span data-stu-id="a7e06-217">Messages in the poison-message queue must still be read and handled.</span></span> <span data-ttu-id="a7e06-218">当从最终病毒子队列读取消息时，可以使用病毒消息处理设置的子集。</span><span class="sxs-lookup"><span data-stu-id="a7e06-218">You can use a subset of the poison-message handling settings when reading messages from the final poison subqueue.</span></span> <span data-ttu-id="a7e06-219">适用的设置有 `ReceiveRetryCount` 和 `ReceiveErrorHandling`。</span><span class="sxs-lookup"><span data-stu-id="a7e06-219">The applicable settings are `ReceiveRetryCount` and `ReceiveErrorHandling`.</span></span> <span data-ttu-id="a7e06-220">您可以将 `ReceiveErrorHandling` 设置为“删除”、“拒绝”或“错误”。</span><span class="sxs-lookup"><span data-stu-id="a7e06-220">You can set `ReceiveErrorHandling` to Drop, Reject, or Fault.</span></span> `MaxRetryCycles` <span data-ttu-id="a7e06-221">将被忽略，如果将引发异常`ReceiveErrorHandling`设置为移动。</span><span class="sxs-lookup"><span data-stu-id="a7e06-221">is ignored and an exception is thrown if `ReceiveErrorHandling` is set to Move.</span></span>  
  
## <a name="windows-vista-windows-server-2003-and-windows-xp-differences"></a><span data-ttu-id="a7e06-222">Windows Vista、Windows Server 2003 和 Windows XP 之间的差异</span><span class="sxs-lookup"><span data-stu-id="a7e06-222">Windows Vista, Windows Server 2003, and Windows XP Differences</span></span>  
 <span data-ttu-id="a7e06-223">如上所述，并非所有病毒消息处理设置均适用于 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 和 [!INCLUDE[wxp](../../../../includes/wxp-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="a7e06-223">As noted earlier, not all poison-message handling settings apply to [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span></span> <span data-ttu-id="a7e06-224">下面列出了 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)]、[!INCLUDE[wxp](../../../../includes/wxp-md.md)] 和 [!INCLUDE[wv](../../../../includes/wv-md.md)] 上的消息队列在病毒消息处理方面的主要差异：</span><span class="sxs-lookup"><span data-stu-id="a7e06-224">The following key differences between Message Queuing on [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)], [!INCLUDE[wxp](../../../../includes/wxp-md.md)], and [!INCLUDE[wv](../../../../includes/wv-md.md)] are relevant to poison-message handling:</span></span>  
  
-   <span data-ttu-id="a7e06-225">[!INCLUDE[wv](../../../../includes/wv-md.md)] 中的消息队列支持子队列，而 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 和 [!INCLUDE[wxp](../../../../includes/wxp-md.md)] 中的消息队列不支持子队列。</span><span class="sxs-lookup"><span data-stu-id="a7e06-225">Message Queuing in [!INCLUDE[wv](../../../../includes/wv-md.md)] supports subqueues, while [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)] do not support subqueues.</span></span> <span data-ttu-id="a7e06-226">子队列用于病毒消息处理。</span><span class="sxs-lookup"><span data-stu-id="a7e06-226">Subqueues are used in poison-message handling.</span></span> <span data-ttu-id="a7e06-227">重试队列和病毒队列是应用程序队列的子队列，是基于病毒消息处理设置创建的。</span><span class="sxs-lookup"><span data-stu-id="a7e06-227">The retry queues and the poison queue are subqueues to the application queue that is created based on the poison-message handling settings.</span></span> <span data-ttu-id="a7e06-228">`MaxRetryCycles` 用于指示要创建的重试子队列的数量。</span><span class="sxs-lookup"><span data-stu-id="a7e06-228">The `MaxRetryCycles` dictates how many retry subqueues to create.</span></span> <span data-ttu-id="a7e06-229">因此，当在 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 或 [!INCLUDE[wxp](../../../../includes/wxp-md.md)] 上运行时，`MaxRetryCycles` 会被忽略，并且不允许 `ReceiveErrorHandling.Move`。</span><span class="sxs-lookup"><span data-stu-id="a7e06-229">Therefore, when running on [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] or [!INCLUDE[wxp](../../../../includes/wxp-md.md)], `MaxRetryCycles` are ignored and `ReceiveErrorHandling.Move` is not allowed.</span></span>  
  
-   <span data-ttu-id="a7e06-230">[!INCLUDE[wv](../../../../includes/wv-md.md)] 中的消息队列支持否定确认，而 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 和 [!INCLUDE[wxp](../../../../includes/wxp-md.md)] 中的消息队列不支持。</span><span class="sxs-lookup"><span data-stu-id="a7e06-230">Message Queuing in [!INCLUDE[wv](../../../../includes/wv-md.md)] supports negative acknowledgment, while [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)] do not.</span></span> <span data-ttu-id="a7e06-231">来自接收队列管理器的否定确认会致使发送队列管理器将被拒绝的消息放入死信队列。</span><span class="sxs-lookup"><span data-stu-id="a7e06-231">A negative acknowledgment from the receiving queue manager causes the sending queue manager to place the rejected message in the dead-letter queue.</span></span> <span data-ttu-id="a7e06-232">因此，在 `ReceiveErrorHandling.Reject` 和 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 中不允许 [!INCLUDE[wxp](../../../../includes/wxp-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="a7e06-232">As such, `ReceiveErrorHandling.Reject` is not allowed with [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span></span>  
  
-   <span data-ttu-id="a7e06-233">[!INCLUDE[wv](../../../../includes/wv-md.md)] 中的消息队列支持用于记录消息传递尝试次数的消息属性。</span><span class="sxs-lookup"><span data-stu-id="a7e06-233">Message Queuing in [!INCLUDE[wv](../../../../includes/wv-md.md)] supports a message property that keeps count of the number of times message delivery is attempted.</span></span> <span data-ttu-id="a7e06-234">此中止计数属性在 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 和 [!INCLUDE[wxp](../../../../includes/wxp-md.md)] 中不可用。</span><span class="sxs-lookup"><span data-stu-id="a7e06-234">This abort count property is not available on [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span></span> <span data-ttu-id="a7e06-235">WCF 会维护中止计数在内存中，所以，此属性可能包含不精确的值时由场中的多个 WCF 服务读取同一条消息。</span><span class="sxs-lookup"><span data-stu-id="a7e06-235">WCF maintains the abort count in memory, so it is possible that this property may not contain an accurate value when the same message is read by more than one WCF service in a farm.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a7e06-236">请参阅</span><span class="sxs-lookup"><span data-stu-id="a7e06-236">See also</span></span>

- [<span data-ttu-id="a7e06-237">队列概述</span><span class="sxs-lookup"><span data-stu-id="a7e06-237">Queues Overview</span></span>](../../../../docs/framework/wcf/feature-details/queues-overview.md)
- [<span data-ttu-id="a7e06-238">Windows Vista、Windows Server 2003 和 Windows XP 在排队功能方面的差异</span><span class="sxs-lookup"><span data-stu-id="a7e06-238">Differences in Queuing Features in Windows Vista, Windows Server 2003, and Windows XP</span></span>](../../../../docs/framework/wcf/feature-details/diff-in-queue-in-vista-server-2003-windows-xp.md)
- [<span data-ttu-id="a7e06-239">在协定和服务中指定和处理错误</span><span class="sxs-lookup"><span data-stu-id="a7e06-239">Specifying and Handling Faults in Contracts and Services</span></span>](../../../../docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md)
