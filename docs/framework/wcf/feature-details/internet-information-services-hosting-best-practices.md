---
title: Internet 信息服务承载最佳实践
ms.date: 03/30/2017
ms.assetid: 0834768e-9665-46bf-86eb-d4b09ab91af5
ms.openlocfilehash: 0ca5e20b846a1b10f5a52748ff06a4af958b2f4c
ms.sourcegitcommit: 64f4baed249341e5bf64d1385bf48e3f2e1a0211
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/07/2018
ms.locfileid: "44079573"
---
# <a name="internet-information-services-hosting-best-practices"></a><span data-ttu-id="ac7f5-102">Internet 信息服务承载最佳实践</span><span class="sxs-lookup"><span data-stu-id="ac7f5-102">Internet Information Services Hosting Best Practices</span></span>
<span data-ttu-id="ac7f5-103">本主题概述了用于承载 Windows Communication Foundation (WCF) 服务的一些最佳做法。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-103">This topic outlines some best practices for hosting Windows Communication Foundation (WCF) services.</span></span>  
  
## <a name="implementing-wcf-services-as-dlls"></a><span data-ttu-id="ac7f5-104">将 WCF 服务实现为 DLL</span><span class="sxs-lookup"><span data-stu-id="ac7f5-104">Implementing WCF Services as DLLs</span></span>  
 <span data-ttu-id="ac7f5-105">实现 WCF 服务作为 DLL 部署到 Web 应用程序的 \bin 目录允许你重复使用服务模型外的 Web 应用程序，例如，可能没有 Internet 信息服务 (IIS) 部署的测试环境中。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-105">Implementing a WCF service as a DLL that is deployed to the \bin directory of a Web application allows you reuse the service outside of the Web application model, for example, in a test environment that may not have Internet Information Services (IIS) deployed.</span></span>  
  
## <a name="service-hosts-in-iis-hosted-applications"></a><span data-ttu-id="ac7f5-106">承载于 IIS 中的应用程序中的服务主机</span><span class="sxs-lookup"><span data-stu-id="ac7f5-106">Service Hosts in IIS-Hosted Applications</span></span>  
 <span data-ttu-id="ac7f5-107">不要使用强制性自承载 API 创建用于侦听 IIS 承载环境本身不支持的网络传输的新服务主机（例如，承载 TCP 服务的 [!INCLUDE[iis601](../../../../includes/iis601-md.md)]，因为 [!INCLUDE[iis601](../../../../includes/iis601-md.md)] 本身不支持 TCP 通信）。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-107">Do not use the imperative self-host APIs to create new service hosts that listen on network transports not natively supported by the IIS hosting environment (For example, [!INCLUDE[iis601](../../../../includes/iis601-md.md)] to host TCP services, because TCP communication is not natively supported on [!INCLUDE[iis601](../../../../includes/iis601-md.md)]).</span></span> <span data-ttu-id="ac7f5-108">建议不要使用此方法。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-108">This approach is not recommended.</span></span> <span data-ttu-id="ac7f5-109">强制创建的服务主机在 IIS 承载环境内是未知的。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-109">Service hosts created imperatively are not known within the IIS hosting environment.</span></span> <span data-ttu-id="ac7f5-110">很重要的一点是，在 IIS 确定承载应用程序池是否空闲时，它未说明强制创建的服务所进行的处理。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-110">The critical point is that processing done by imperatively created services is not accounted for by IIS when it determines whether the hosting application pool is idle.</span></span> <span data-ttu-id="ac7f5-111">结果是具有这样强制创建的服务主机的应用程序具有主动处置 IIS 宿主进程的 IIS 承载环境。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-111">The result is that applications that have such imperatively created service hosts have an IIS hosting environment that aggressively disposes of IIS host processes.</span></span>  
  
## <a name="uris-and-iis-hosted-endpoints"></a><span data-ttu-id="ac7f5-112">URI 和承载于 IIS 中的终结点</span><span class="sxs-lookup"><span data-stu-id="ac7f5-112">URIs and IIS-Hosted Endpoints</span></span>  
 <span data-ttu-id="ac7f5-113">承载于 IIS 中的服务的终结点应该使用相对统一资源标识符 (URI) 而不是绝对地址进行配置。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-113">Endpoints for an IIS-hosted service should be configured using relative Uniform Resource Identifiers (URIs), not absolute addresses.</span></span> <span data-ttu-id="ac7f5-114">这保证终结点地址在属于承载应用程序的 URI 地址集范围内，并确保像预期的那样发生基于消息的激活。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-114">This guarantees that the endpoint address falls within the set of URI addresses that belong to the hosting application and ensures that message-based activation happens as expected.</span></span>  
  
## <a name="state-management-and-process-recycling"></a><span data-ttu-id="ac7f5-115">状态管理和进程回收</span><span class="sxs-lookup"><span data-stu-id="ac7f5-115">State Management and Process Recycling</span></span>  
 <span data-ttu-id="ac7f5-116">为不在内存中维护本地状态的服务优化了 IIS 承载环境。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-116">The IIS hosting environment is optimized for services that do not maintain local state in memory.</span></span> <span data-ttu-id="ac7f5-117">IIS 回收宿主进程以响应各种外部和内部事件，导致仅存储在内存中的任何可变状态丢失。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-117">IIS recycles the host process in response to a variety of external and internal events, causing any volatile state stored exclusively in memory to be lost.</span></span> <span data-ttu-id="ac7f5-118">寄宿在 IIS 中的服务应该在进程外存储其状态（例如，在数据库中），或者在出现应用程序回收事件时可以轻松重新创建的内存中缓存中存储其状态。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-118">Services hosted in IIS should store their state external to the process (for example, in a database) or in an in-memory cache that can easily be re-created if an application recycle event occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ac7f5-119">使 WCF 用于消息层可靠性和安全性的协议使用的易失性内存中状态。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-119">The protocols WCF uses for message-layer reliability and security make use of the volatile in-memory state.</span></span> <span data-ttu-id="ac7f5-120">WCF 可靠会话和安全会话可能由于应用程序回收而意外终止。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-120">WCF reliable sessions and security sessions may terminate unexpectedly due to application recycles.</span></span> <span data-ttu-id="ac7f5-121">这些协议的使用 IIS 承载的应用程序应该依赖于以外的关联应用程序层状态 （例如，应用程序层结构或自定义关联标头） 或禁用的 WCF 提供的会话密钥IIS 进程回收的托管应用程序。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-121">IIS-hosted applications that make use of these protocols should either depend on something other than the WCF-provided session key for correlating application-layer state (for example, an application-layer construct or custom correlation header) or disable IIS process recycling for the hosted application.</span></span>  
  
## <a name="optimizing-performance-in-middle-tier-scenarios"></a><span data-ttu-id="ac7f5-122">在中间层方案中优化性能</span><span class="sxs-lookup"><span data-stu-id="ac7f5-122">Optimizing Performance in Middle-Tier Scenarios</span></span>  
 <span data-ttu-id="ac7f5-123">中获得最佳性能*中间层方案*— 即会调用响应传入消息中的其他服务的服务 — 一次实例化远程服务的 WCF 服务客户端并将其重复跨多个传入请求数。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-123">For optimal performance in a *middle-tier scenario*—a service that calls out to other services in response to incoming messages—instantiate the WCF service client to the remote service once and reuse it across multiple incoming requests.</span></span> <span data-ttu-id="ac7f5-124">实例化 WCF 服务客户端是相对于进行服务调用对预先存在的客户端实例，代价高昂的操作和中间层方案通过跨请求缓存远程客户端来产生明显的性能提升。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-124">Instantiating WCF service clients is an expensive operation relative to making a service call on a pre-existing client instance, and middle-tier scenarios produce distinct performance gains by caching remote clients across requests.</span></span> <span data-ttu-id="ac7f5-125">WCF 服务客户端是线程安全的因此不需要跨多个线程同步对客户端访问。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-125">WCF service clients are thread-safe, so it is not necessary to synchronize access to a client across multiple threads.</span></span>  
  
 <span data-ttu-id="ac7f5-126">中间层方案还通过使用由 `svcutil /a` 选项生成的异步 API 来产生性能提升。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-126">Middle-tier scenarios also produce performance gains by using the asynchronous APIs generated by the `svcutil /a` option.</span></span> <span data-ttu-id="ac7f5-127">`/a`选项使[ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)生成`BeginXXX/EndXXX`对于每个服务操作，它允许对远程服务可能需要长时间运行调用，使其上的方法后台线程。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-127">The `/a` option causes the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) to generate `BeginXXX/EndXXX` methods for each service operation, which allows potentially long-running calls to remote services to be made on background threads.</span></span>  
  
## <a name="wcf-in-multi-homed-or-multi-named-scenarios"></a><span data-ttu-id="ac7f5-128">多宿主或多名称方案中的 WCF</span><span class="sxs-lookup"><span data-stu-id="ac7f5-128">WCF in Multi-Homed or Multi-named scenarios</span></span>  
 <span data-ttu-id="ac7f5-129">你可以部署 WCF 服务内部的 IIS Web 场，其中的一组计算机共享公共外部名称 (如 http://www.contoso.com)但由不同的主机名单独寻址 (例如， http://www.contoso.com可能会将流量定向到两个不同的计算机名为 http://machine1.internal.contoso.com和 http://machine2.internal.contoso.com)。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-129">You can deploy WCF services inside of an IIS Web farm, where a set of computers share a common external name (such as http://www.contoso.com) but are individually addressed by different hostnames (for example, http://www.contoso.com might direct traffic to two different machines named http://machine1.internal.contoso.com and http://machine2.internal.contoso.com).</span></span> <span data-ttu-id="ac7f5-130">此部署方案中完全支持由 WCF，但需要承载 WCF 服务在服务的元数据 （Web 服务描述语言） 中显示正确的 （外部） 主机名的 IIS 网站的特殊配置。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-130">This deployment scenario is fully supported by WCF, but requires special configuration of the IIS Web site hosting WCF services to display the correct (external) hostname in the service's metadata (Web Services Description Language).</span></span>  
  
 <span data-ttu-id="ac7f5-131">若要确保正确的主机名显示在 WCF 服务元数据生成、 托管 WCF 服务以使用显式主机名的 IIS 网站的默认标识配置。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-131">To ensure that the correct hostname appears in the service metadata WCF generates, configure the default identity for the IIS Web site that hosts WCF services to use an explicit hostname.</span></span> <span data-ttu-id="ac7f5-132">例如，驻留在 www.contoso.com 场内的计算机应使用的 IIS 站点绑定 \*:80:www.contoso.com 为 HTTP 和\*: 443:www.contoso.com 为支持 HTTPS。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-132">For example, computers that reside inside of the www.contoso.com farm should use an IIS site binding of \*:80:www.contoso.com for HTTP and \*:443:www.contoso.com for HTTPS.</span></span>  
  
 <span data-ttu-id="ac7f5-133">可以使用 IIS Microsoft 管理控制台 (MMC) 管理单元配置 IIS 网站绑定。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-133">You can configure IIS Web site bindings by using the IIS Microsoft Management Console (MMC) snap-in.</span></span>  
  
## <a name="application-pools-running-in-different-user-contexts-overwrite-assemblies-from-other-accounts-in-the-temporary-folder"></a><span data-ttu-id="ac7f5-134">在不同用户上下文中运行的应用程序池覆盖来自临时文件夹中其他帐户的程序集</span><span class="sxs-lookup"><span data-stu-id="ac7f5-134">Application Pools Running in Different User Contexts Overwrite Assemblies from Other Accounts in the Temporary Folder</span></span>  
 <span data-ttu-id="ac7f5-135">若要确保在不同用户上下文中运行的应用程序池无法覆盖来自临时 [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] 文件夹中其他帐户的程序集，请对不同的应用程序使用不同的标识和临时文件夹。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-135">To ensure that application pools running in different user contexts cannot overwrite assemblies from other accounts in the temporary [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] files folder, use different identities and temporary folders for different applications.</span></span> <span data-ttu-id="ac7f5-136">例如，如果具有两个虚拟应用程序 /Application1 和 / Application2，则可以创建两个应用程序池 A 和 B，它们具有不同的标识。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-136">For example, if you have two virtual applications /Application1 and / Application2, you can create two Application pools, A and B, with two different identities.</span></span> <span data-ttu-id="ac7f5-137">应用程序池 A 可以使用一个用户标识 (user1) 运行，而应用程序池 B 可以使用其他用户标识 (user2) 运行，并将 /Application1 配置为使用 A，将 /Application2 配置为使用 B。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-137">Application pool A can run under one user identity (user1) while application pool B can run under another user identity (user2), and configure /Application1 to use A and /Application2 to use B.</span></span>  
  
 <span data-ttu-id="ac7f5-138">在 Web.config 文件中，你可以配置临时文件夹使用\< system.web/compilation/@tempFolder>。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-138">In Web.config, you can configure the temporary folder using \<system.web/compilation/@tempFolder>.</span></span> <span data-ttu-id="ac7f5-139">有关/application1，它可以"c:\tempForUser1"并且对于应用程序 2 可以是"c:\tempForUser2"。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-139">For /Application1, it can be "c:\tempForUser1" and for application2 it can be "c:\tempForUser2".</span></span> <span data-ttu-id="ac7f5-140">将相应的写入权限授予两个标识的这些文件夹。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-140">Grant corresponding write permission to these folders for the two identities.</span></span>  
  
 <span data-ttu-id="ac7f5-141">之后，user2 无法更改 /application2 的代码生成文件夹（在 c:\tempForUser1 下）。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-141">Then user2 cannot change the code-generation folder for /application2 (under c:\tempForUser1).</span></span>  
  
## <a name="enabling-asynchronous-processing"></a><span data-ttu-id="ac7f5-142">启用异步处理</span><span class="sxs-lookup"><span data-stu-id="ac7f5-142">Enabling asynchronous processing</span></span>  
 <span data-ttu-id="ac7f5-143">默认情况下以同步方式处理发送到承载在 IIS 6.0 及更早版本的 WCF 服务的消息。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-143">By default messages sent to a WCF service hosted under IIS 6.0 and earlier are processed in a synchronous manner.</span></span> <span data-ttu-id="ac7f5-144">ASP.NET 在它自己的线程 （ASP.NET 工作线程） 上调用 WCF 和 WCF 使用另一个线程来处理该请求。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-144">ASP.NET calls into WCF on its own thread (the ASP.NET worker thread) and WCF uses another thread to process the request.</span></span> <span data-ttu-id="ac7f5-145">WCF 在完成其处理之前会保持 ASP.NET 工作线程。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-145">WCF holds onto the ASP.NET worker thread until it completes its processing.</span></span> <span data-ttu-id="ac7f5-146">这将导致同步处理请求。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-146">This leads to synchronous processing of requests.</span></span> <span data-ttu-id="ac7f5-147">以异步方式处理请求能够实现更高版本的可伸缩性，因为它减少了处理的请求 – WCF 不保持 ASP.NET 线程处理请求时所需的线程数。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-147">Processing requests asynchronously enables greater scalability because it reduces the number of threads required to process a request –WCF does not hold on to the ASP.NET thread while processing the request.</span></span> <span data-ttu-id="ac7f5-148">运行 IIS 6.0，因为没有方法来限制到服务器的传入请求的计算机不建议使用异步行为*拒绝服务*(DOS) 攻击。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-148">Use of asynchronous behavior is not recommended for machines running IIS 6.0 because there is no way to throttle incoming requests that open up the server to *Denial Of Service* (DOS) attacks.</span></span> <span data-ttu-id="ac7f5-149">从 IIS 7.0 开始，引入了并发请求限制：`[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\ASP.NET\2.0.50727.0]"MaxConcurrentRequestsPerCpu`。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-149">Starting with IIS 7.0, a concurrent request throttle has been introduced: `[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\ASP.NET\2.0.50727.0]"MaxConcurrentRequestsPerCpu`.</span></span> <span data-ttu-id="ac7f5-150">借助这一新的限制，可安全地使用异步处理。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-150">With this new throttle it is safe to use the asynchronous processing.</span></span>  <span data-ttu-id="ac7f5-151">默认情况下，在 IIS 7.0 中会注册异步处理程序和模块。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-151">By default in IIS 7.0, the asynchronous handler and module are registered.</span></span> <span data-ttu-id="ac7f5-152">如果关闭了此功能，可在应用程序的 Web.config 文件中手动启用对请求的异步处理。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-152">If this has been turned off, you can manually enable asynchronous processing of requests in your application's Web.config file.</span></span> <span data-ttu-id="ac7f5-153">所使用的设置取决于 `aspNetCompatibilityEnabled` 设置。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-153">The settings you use depend on your `aspNetCompatibilityEnabled` setting.</span></span> <span data-ttu-id="ac7f5-154">如果已将 `aspNetCompatibilityEnabled` 设置为 `false`，请按照下面的配置代码段所示配置 `System.ServiceModel.Activation.ServiceHttpModule`。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-154">If you have `aspNetCompatibilityEnabled` set to `false`, configure the `System.ServiceModel.Activation.ServiceHttpModule` as shown in the following configuration snippet.</span></span>  
  
```xml  
<system.serviceModel>  
    <serviceHostingEnvironment aspNetCompatibilityEnabled="false" />      
  </system.serviceModel>  
  <system.webServer>  
    <modules>  
      <remove name="ServiceModel"/>  
      <add name="ServiceModel"   
           preCondition="integratedMode,runtimeVersionv2.0"   
           type="System.ServiceModel.Activation.ServiceHttpModule, System.ServiceModel,Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"/>  
    </modules>  
    </system.webServer>  
```  
  
 <span data-ttu-id="ac7f5-155">如果已将 `aspNetCompatibilityEnabled` 设置为 `true`，请按照下面的配置代码段所示配置 `System.ServiceModel.Activation.ServiceHttpHandlerFactory`。</span><span class="sxs-lookup"><span data-stu-id="ac7f5-155">If you have `aspNetCompatibilityEnabled` set to `true`, configure the `System.ServiceModel.Activation.ServiceHttpHandlerFactory` as shown in the following config snippet.</span></span>  
  
```xml  
<system.serviceModel>  
    <serviceHostingEnvironment aspNetCompatibilityEnabled="true" />      
  </system.serviceModel>  
  <system.webServer>  
    <handlers>  
          <clear/>  
          <add name="TestAsyncHttpHandler"   
               path="*.svc"   
               verb="*"   
               type="System.ServiceModel.Activation.ServiceHttpHandlerFactory, System.ServiceModel, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"           
               />  
    </handlers>      
  </system.webServer>  
```  
  
## <a name="see-also"></a><span data-ttu-id="ac7f5-156">请参阅</span><span class="sxs-lookup"><span data-stu-id="ac7f5-156">See Also</span></span>  
 [<span data-ttu-id="ac7f5-157">服务承载示例</span><span class="sxs-lookup"><span data-stu-id="ac7f5-157">Service Hosting Samples</span></span>](https://msdn.microsoft.com/library/f703a3f6-0fba-418a-a92f-7ce75ccfa47e)  
 [<span data-ttu-id="ac7f5-158">Windows Server App Fabric 承载功能</span><span class="sxs-lookup"><span data-stu-id="ac7f5-158">Windows Server App Fabric Hosting Features</span></span>](https://go.microsoft.com/fwlink/?LinkId=201276)
