---
title: 最佳做法：数据协定版本管理
ms.custom: ''
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: ''
ms.suite: ''
ms.technology:
- dotnet-clr
ms.tgt_pltfrm: ''
ms.topic: article
helpviewer_keywords:
- data contracts
- service contracts
- best practices [WCF], data contract versioning
- Windows Communication Foundation, data contracts
ms.assetid: bf0ab338-4d36-4e12-8002-8ebfdeb346cb
caps.latest.revision: 24
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload:
- dotnet
ms.openlocfilehash: dfb3d781a570db6a929a7d984aa45c224dda66bd
ms.sourcegitcommit: 03ee570f6f528a7d23a4221dcb26a9498edbdf8c
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/28/2018
---
# <a name="best-practices-data-contract-versioning"></a><span data-ttu-id="8bceb-102">最佳做法：数据协定版本管理</span><span class="sxs-lookup"><span data-stu-id="8bceb-102">Best Practices: Data Contract Versioning</span></span>
<span data-ttu-id="8bceb-103">本主题列出了创建容易随时间而改变的数据协定的最佳做法。</span><span class="sxs-lookup"><span data-stu-id="8bceb-103">This topic lists the best practices for creating data contracts that can evolve easily over time.</span></span> [!INCLUDE[crabout](../../../includes/crabout-md.md)]<span data-ttu-id="8bceb-104"> 数据协定，请参阅中的主题[使用数据协定](../../../docs/framework/wcf/feature-details/using-data-contracts.md)。</span><span class="sxs-lookup"><span data-stu-id="8bceb-104"> data contracts, see the topics in [Using Data Contracts](../../../docs/framework/wcf/feature-details/using-data-contracts.md).</span></span>  
  
## <a name="note-on-schema-validation"></a><span data-ttu-id="8bceb-105">有关架构验证的说明</span><span class="sxs-lookup"><span data-stu-id="8bceb-105">Note on Schema Validation</span></span>  
 <span data-ttu-id="8bceb-106">讨论数据协定版本管理时，注意除非元素被默认标记为可选之外，由 [!INCLUDE[indigo1](../../../includes/indigo1-md.md)] 导出的数据协定架构不具有任何版本管理支持，这很重要。</span><span class="sxs-lookup"><span data-stu-id="8bceb-106">In discussing data contract versioning, it is important to note that the data contract schema exported by [!INCLUDE[indigo1](../../../includes/indigo1-md.md)] does not have any versioning support, other than the fact that elements are marked as optional by default.</span></span>  
  
 <span data-ttu-id="8bceb-107">这意味着即使是最常用的版本管理方案（例如添加新的数据成员）也不能通过与给定架构无缝相关的方法实现。</span><span class="sxs-lookup"><span data-stu-id="8bceb-107">This means that even the most common versioning scenario, such as adding a new data member, cannot be implemented in a way that is seamless with regard to a given schema.</span></span> <span data-ttu-id="8bceb-108">较新版本的数据协定（例如新添数据成员）不会使用旧架构进行验证。</span><span class="sxs-lookup"><span data-stu-id="8bceb-108">The newer versions of a data contract (with a new data member, for example) do not validate using the old schema.</span></span>  
  
 <span data-ttu-id="8bceb-109">但是，有许多方案不需要严格遵从架构。</span><span class="sxs-lookup"><span data-stu-id="8bceb-109">However, there are many scenarios in which strict schema compliance is not required.</span></span> <span data-ttu-id="8bceb-110">许多 Web 服务平台（包括 [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] 和使用 ASP.NET 创建的 XML Web services）默认不执行架构验证，因此允许使用架构未描述过的其他元素。</span><span class="sxs-lookup"><span data-stu-id="8bceb-110">Many Web services platforms, including [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] and XML Web services created using ASP.NET, do not perform schema validation by default and therefore tolerate extra elements that are not described by the schema.</span></span> <span data-ttu-id="8bceb-111">使用这样的平台工作时，许多版本管理方案更容易实现。</span><span class="sxs-lookup"><span data-stu-id="8bceb-111">When working with such platforms, many versioning scenarios are easier to implement.</span></span>  
  
 <span data-ttu-id="8bceb-112">因此，存在两套数据协定版本管理准则：一套用于严格架构有效性十分重要的方案；另一套用于严格架构有效性不太重要的方案。</span><span class="sxs-lookup"><span data-stu-id="8bceb-112">Thus, there are two sets of data contract versioning guidelines: one set for scenarios where strict schema validity is important, and another set for scenarios when it is not.</span></span>  
  
## <a name="versioning-when-schema-validation-is-required"></a><span data-ttu-id="8bceb-113">需要进行架构验证时的版本管理</span><span class="sxs-lookup"><span data-stu-id="8bceb-113">Versioning When Schema Validation Is Required</span></span>  
 <span data-ttu-id="8bceb-114">如果所有方向（从新到旧和从旧到新）都需要严格架构有效性，则应将数据协定视为不可变的。</span><span class="sxs-lookup"><span data-stu-id="8bceb-114">If strict schema validity is required in all directions (new-to-old and old-to-new), data contracts should be considered immutable.</span></span> <span data-ttu-id="8bceb-115">如果需要进行版本管理，则应使用不同名称或命名空间创建新的数据协定，并且应相应地对使用该数据类型的服务协定进行版本管理。</span><span class="sxs-lookup"><span data-stu-id="8bceb-115">If versioning is required, a new data contract should be created, with a different name or namespace, and the service contract using the data type should be versioned accordingly.</span></span>  
  
 <span data-ttu-id="8bceb-116">例如，假设一个名为 `PoProcessing` 的采购订单处理服务协定具有 `PostPurchaseOrder` 操作，并采用一个符合 `PurchaseOrder` 数据协定的参数。</span><span class="sxs-lookup"><span data-stu-id="8bceb-116">For example, a purchase order processing service contract named `PoProcessing` with a `PostPurchaseOrder` operation takes a parameter that conforms to a `PurchaseOrder` data contract.</span></span> <span data-ttu-id="8bceb-117">如果必须更改 `PurchaseOrder` 协定，则需要创建一个新数据协定，即包含更改的 `PurchaseOrder2`。</span><span class="sxs-lookup"><span data-stu-id="8bceb-117">If the `PurchaseOrder` contract has to change, you must create a new data contract, that is, `PurchaseOrder2`, which includes the changes.</span></span> <span data-ttu-id="8bceb-118">然后，必须在服务协定级别处理版本管理。</span><span class="sxs-lookup"><span data-stu-id="8bceb-118">You must then handle the versioning at the service contract level.</span></span> <span data-ttu-id="8bceb-119">例如，可创建一个 `PostPurchaseOrder2` 操作，该操作采用 `PurchaseOrder2` 参数；也可创建一个 `PoProcessing2` 服务协定，其中 `PostPurchaseOrder` 操作采用 `PurchaseOrder2` 数据协定。</span><span class="sxs-lookup"><span data-stu-id="8bceb-119">For example, by creating a `PostPurchaseOrder2` operation that takes the `PurchaseOrder2` parameter, or by creating a `PoProcessing2` service contract where the `PostPurchaseOrder` operation takes a `PurchaseOrder2` data contract.</span></span>  
  
 <span data-ttu-id="8bceb-120">请注意，数据协定中由其他数据协定引用的更改也会扩展到服务模型层。</span><span class="sxs-lookup"><span data-stu-id="8bceb-120">Note that changes in data contracts that are referenced by other data contracts also extend to the service model layer.</span></span> <span data-ttu-id="8bceb-121">例如，在前面的方案中，不需要更改 `PurchaseOrder` 数据协定。</span><span class="sxs-lookup"><span data-stu-id="8bceb-121">For example, in the previous scenario the `PurchaseOrder` data contract does not need to change.</span></span> <span data-ttu-id="8bceb-122">但是，该协定包含 `Customer` 数据协定的一个数据成员，而后者又包含了不需要更改的 `Address` 数据协定的一个数据成员。</span><span class="sxs-lookup"><span data-stu-id="8bceb-122">However, it contains a data member of a `Customer` data contract, which in turn contained a data member of the `Address` data contract, which does need to be changed.</span></span> <span data-ttu-id="8bceb-123">在此情况下，需要创建一个包含所需更改的 `Address2` 数据协定、一个包含 `Customer2` 数据成员的 `Address2` 数据协定和一个包含 `PurchaseOrder2` 数据成员的 `Customer2` 数据协定。</span><span class="sxs-lookup"><span data-stu-id="8bceb-123">In that case, you would need to create an `Address2` data contract with the required changes, a `Customer2` data contract that contains the `Address2` data member, and a `PurchaseOrder2` data contract that contains a `Customer2` data member.</span></span> <span data-ttu-id="8bceb-124">与前面的情况一样，也必须对服务协定进行版本管理。</span><span class="sxs-lookup"><span data-stu-id="8bceb-124">As in the previous case, the service contract would have to be versioned as well.</span></span>  
  
 <span data-ttu-id="8bceb-125">在这些示例中，虽然名称发生了改变（追加了一个“2”），但建议不要更改名称，而是通过对新命名空间追加版本号或日期来更改命名空间。</span><span class="sxs-lookup"><span data-stu-id="8bceb-125">Although in these examples names are changed (by appending a "2"), the recommendation is to change namespaces instead of names by appending new namespaces with a version number or a date.</span></span> <span data-ttu-id="8bceb-126">例如，`http://schemas.contoso.com/2005/05/21/PurchaseOrder` 数据协定应更改为 `http://schemas.contoso.com/2005/10/14/PurchaseOrder` 数据协定。</span><span class="sxs-lookup"><span data-stu-id="8bceb-126">For example, the `http://schemas.contoso.com/2005/05/21/PurchaseOrder` data contract would change to the `http://schemas.contoso.com/2005/10/14/PurchaseOrder` data contract.</span></span>  
  
 <span data-ttu-id="8bceb-127">有关详细信息，请参阅最佳实践：[服务版本控制](../../../docs/framework/wcf/service-versioning.md)。</span><span class="sxs-lookup"><span data-stu-id="8bceb-127">For more information, see Best Practices: [Service Versioning](../../../docs/framework/wcf/service-versioning.md).</span></span>  
  
 <span data-ttu-id="8bceb-128">有时，您必须保证应用程序发送的消息严格遵从架构，但不能依赖要严格遵从架构的传入消息。</span><span class="sxs-lookup"><span data-stu-id="8bceb-128">Occasionally, you must guarantee strict schema compliance for messages sent by your application, but cannot rely on the incoming messages to be strictly schema-compliant.</span></span> <span data-ttu-id="8bceb-129">在这种情况下，存在传入消息中包含某些外来数据的危险。</span><span class="sxs-lookup"><span data-stu-id="8bceb-129">In this case, there is a danger that an incoming message might contain extraneous data.</span></span> <span data-ttu-id="8bceb-130">这些外来值由 [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] 进行存储并返回，因此会导致发送对架构无效的消息。</span><span class="sxs-lookup"><span data-stu-id="8bceb-130">The extraneous values are stored and returned by [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] and thus results in schema-invalid messages being sent.</span></span> <span data-ttu-id="8bceb-131">若要避免此问题，应关闭往返功能。</span><span class="sxs-lookup"><span data-stu-id="8bceb-131">To avoid this problem, the round-tripping feature should be turned off.</span></span> <span data-ttu-id="8bceb-132">有两种方法可以实现此目的。</span><span class="sxs-lookup"><span data-stu-id="8bceb-132">There are two ways to do this.</span></span>  
  
-   <span data-ttu-id="8bceb-133">请勿在任何类型上实现 <xref:System.Runtime.Serialization.IExtensibleDataObject> 接口。</span><span class="sxs-lookup"><span data-stu-id="8bceb-133">Do not implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface on any of your types.</span></span>  
  
-   <span data-ttu-id="8bceb-134">对 <xref:System.ServiceModel.ServiceBehaviorAttribute> 属性 (Property) 设置为 <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> 的服务协定应用 `true` 属性 (Attribute)。</span><span class="sxs-lookup"><span data-stu-id="8bceb-134">Apply a <xref:System.ServiceModel.ServiceBehaviorAttribute> attribute to your service contract with the <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> property set to `true`.</span></span>  
  
 [!INCLUDE[crabout](../../../includes/crabout-md.md)]<span data-ttu-id="8bceb-135"> 往返，请参阅[向前兼容的数据协定](../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)。</span><span class="sxs-lookup"><span data-stu-id="8bceb-135"> round-tripping, see [Forward-Compatible Data Contracts](../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span></span>  
  
## <a name="versioning-when-schema-validation-is-not-required"></a><span data-ttu-id="8bceb-136">不要求进行架构验证时的版本管理</span><span class="sxs-lookup"><span data-stu-id="8bceb-136">Versioning When Schema Validation Is Not Required</span></span>  
 <span data-ttu-id="8bceb-137">一般不要求严格遵从架构。</span><span class="sxs-lookup"><span data-stu-id="8bceb-137">Strict schema compliance is rarely required.</span></span> <span data-ttu-id="8bceb-138">许多平台允许使用不是架构描述的其他元素。</span><span class="sxs-lookup"><span data-stu-id="8bceb-138">Many platforms tolerate extra elements not described by a schema.</span></span> <span data-ttu-id="8bceb-139">完整的功能集，这容忍，只要中所述[数据协定版本管理](../../../docs/framework/wcf/feature-details/data-contract-versioning.md)和[向前兼容的数据协定](../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)可用。</span><span class="sxs-lookup"><span data-stu-id="8bceb-139">As long as this is tolerated, the full set of features described in [Data Contract Versioning](../../../docs/framework/wcf/feature-details/data-contract-versioning.md) and [Forward-Compatible Data Contracts](../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md) can be used.</span></span> <span data-ttu-id="8bceb-140">下面是一些建议的准则。</span><span class="sxs-lookup"><span data-stu-id="8bceb-140">The following guidelines are recommended.</span></span>  
  
 <span data-ttu-id="8bceb-141">必须严格遵守其中某些准则，以便能在接受类型的旧版本的地方发送类型的新版本，或在接受类型的新版本的地方发送类型的旧版本。</span><span class="sxs-lookup"><span data-stu-id="8bceb-141">Some of the guidelines must be followed exactly in order to send new versions of a type where an older one is expected or send an old one where the new one is expected.</span></span> <span data-ttu-id="8bceb-142">而其他准则，我们则不需要严格遵守，但此处也列出了，因为它们可能会受将来架构版本管理的影响。</span><span class="sxs-lookup"><span data-stu-id="8bceb-142">Other guidelines are not strictly required, but are listed here because they may be affected by the future of schema versioning.</span></span>  
  
1.  <span data-ttu-id="8bceb-143">不要尝试通过类型继承对数据协定进行版本管理。</span><span class="sxs-lookup"><span data-stu-id="8bceb-143">Do not attempt to version data contracts by type inheritance.</span></span> <span data-ttu-id="8bceb-144">若要创建较新的版本，可更改现有类型上的数据协定，也可创建新的不相关类型。</span><span class="sxs-lookup"><span data-stu-id="8bceb-144">To create later versions, either change the data contract on an existing type or create a new unrelated type.</span></span>  
  
2.  <span data-ttu-id="8bceb-145">可以结合使用继承和数据协定，前提是不将继承用作版本管理机制，并且遵守某些规则。</span><span class="sxs-lookup"><span data-stu-id="8bceb-145">The use of inheritance together with data contracts is allowed, provided that inheritance is not used as a versioning mechanism and that certain rules are followed.</span></span> <span data-ttu-id="8bceb-146">如果某个类型派生于某个基类型，则在将来的版本中不要使它派生于其他基类型（除非版本具有相同的数据协定）。</span><span class="sxs-lookup"><span data-stu-id="8bceb-146">If a type derives from a certain base type, do not make it derive from a different base type in a future version (unless it has the same data contract).</span></span> <span data-ttu-id="8bceb-147">其中存在一个例外，您可以将类型插入到数据协定类型及其基类型之间的层次结构中，但前提是该类型包含的数据成员名称与该层次结构中其他类型的任何可能版本中的其他成员名称不同。</span><span class="sxs-lookup"><span data-stu-id="8bceb-147">There is one exception to this: you can insert a type into the hierarchy between a data contract type and its base type, but only if it does not contain data members with the same names as other members in any possible versions of the other types in the hierarchy.</span></span> <span data-ttu-id="8bceb-148">通常情况下，在同一继承层次结构的不同级别使用具有相同名称的数据成员可导致严重的版本管理问题，因此应该避免。</span><span class="sxs-lookup"><span data-stu-id="8bceb-148">In general, using data members with the same names at different levels of the same inheritance hierarchy can lead to serious versioning problems and should be avoided.</span></span>  
  
3.  <span data-ttu-id="8bceb-149">从数据协定的第一个版本开始，始终实现 <xref:System.Runtime.Serialization.IExtensibleDataObject> 可启用往返。</span><span class="sxs-lookup"><span data-stu-id="8bceb-149">Starting with the first version of a data contract, always implement <xref:System.Runtime.Serialization.IExtensibleDataObject> to enable round-tripping.</span></span> <span data-ttu-id="8bceb-150">有关详细信息，请参阅[向前兼容的数据协定](../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)。</span><span class="sxs-lookup"><span data-stu-id="8bceb-150">For more information, see [Forward-Compatible Data Contracts](../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span></span> <span data-ttu-id="8bceb-151">如果已经释放了某个类型的一个或多个版本，而没有实现此接口，则在该类型的下一个版本中实现它。</span><span class="sxs-lookup"><span data-stu-id="8bceb-151">If you have released one or more versions of a type without implementing this interface, implement it in the next version of the type.</span></span>  
  
4.  <span data-ttu-id="8bceb-152">在较新的版本中，不要更改数据协定名称或命名空间。</span><span class="sxs-lookup"><span data-stu-id="8bceb-152">In later versions, do not change the data contract name or namespace.</span></span> <span data-ttu-id="8bceb-153">如果更改该类型在数据协定下的名称或命名空间，请确保使用适当的机制（例如 <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> 的 <xref:System.Runtime.Serialization.DataContractAttribute> 属性）保留数据协定名称和命名空间。</span><span class="sxs-lookup"><span data-stu-id="8bceb-153">If changing the name or namespace of the type underlying the data contract, be sure to preserve the data contract name and namespace by using the appropriate mechanisms, such as the <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> property of the <xref:System.Runtime.Serialization.DataContractAttribute>.</span></span> [!INCLUDE[crabout](../../../includes/crabout-md.md)]<span data-ttu-id="8bceb-154"> 命名，请参阅[数据协定名称](../../../docs/framework/wcf/feature-details/data-contract-names.md)。</span><span class="sxs-lookup"><span data-stu-id="8bceb-154"> naming, see [Data Contract Names](../../../docs/framework/wcf/feature-details/data-contract-names.md).</span></span>  
  
5.  <span data-ttu-id="8bceb-155">在以后的版本中，不要更改任何数据成员的名称。</span><span class="sxs-lookup"><span data-stu-id="8bceb-155">In later versions, do not change the names of any data members.</span></span> <span data-ttu-id="8bceb-156">如果更改数据成员下的字段、属性或事件的名称，请使用 `Name` 的 <xref:System.Runtime.Serialization.DataMemberAttribute> 属性以保留现有数据成员名称。</span><span class="sxs-lookup"><span data-stu-id="8bceb-156">If changing the name of the field, property, or event underlying the data member, use the `Name` property of the <xref:System.Runtime.Serialization.DataMemberAttribute> to preserve the existing data member name.</span></span>  
  
6.  <span data-ttu-id="8bceb-157">在以后的版本中，不要更改数据成员下的任何字段、属性或事件的类型，否则该数据成员的结果数据协定会发生变化。</span><span class="sxs-lookup"><span data-stu-id="8bceb-157">In later versions, do not change the type of any field, property, or event underlying a data member such that the resulting data contract for that data member changes.</span></span> <span data-ttu-id="8bceb-158">请记住，接口类型等效于 <xref:System.Object>，用于确定需要的数据协定。</span><span class="sxs-lookup"><span data-stu-id="8bceb-158">Keep in mind that interface types are equivalent to <xref:System.Object> for the purposes of determining the expected data contract.</span></span>  
  
7.  <span data-ttu-id="8bceb-159">在以后的版本中，不要通过调整 <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> 属性 (Attribute) 的 <xref:System.Runtime.Serialization.DataMemberAttribute> 属性 (Property) 来更改现有数据成员的顺序。</span><span class="sxs-lookup"><span data-stu-id="8bceb-159">In later versions, do not change the order of the existing data members by adjusting the <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute.</span></span>  
  
8.  <span data-ttu-id="8bceb-160">在以后的版本中，可以添加新的数据成员。</span><span class="sxs-lookup"><span data-stu-id="8bceb-160">In later versions, new data members can be added.</span></span> <span data-ttu-id="8bceb-161">它们应始终遵循以下规则：</span><span class="sxs-lookup"><span data-stu-id="8bceb-161">They should always follow these rules:</span></span>  
  
    1.  <span data-ttu-id="8bceb-162"><xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> 属性应始终保留其默认值 `false`。</span><span class="sxs-lookup"><span data-stu-id="8bceb-162">The <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property should always be left at its default value of `false`.</span></span>  
  
    2.  <span data-ttu-id="8bceb-163">如果对于成员，默认值为 `null` 或零是不可接受的，则应使用 <xref:System.Runtime.Serialization.OnDeserializingAttribute> 提供一个回调方法，以便在传入流中不存在该成员时提供一个合理的默认值。</span><span class="sxs-lookup"><span data-stu-id="8bceb-163">If a default value of `null` or zero for the member is unacceptable, a callback method should be provided using the <xref:System.Runtime.Serialization.OnDeserializingAttribute> to provide a reasonable default in case the member is not present in the incoming stream.</span></span> [!INCLUDE[crabout](../../../includes/crabout-md.md)]<span data-ttu-id="8bceb-164"> 回调，请参阅[版本容错序列化回调](../../../docs/framework/wcf/feature-details/version-tolerant-serialization-callbacks.md)。</span><span class="sxs-lookup"><span data-stu-id="8bceb-164"> the callback, see [Version-Tolerant Serialization Callbacks](../../../docs/framework/wcf/feature-details/version-tolerant-serialization-callbacks.md).</span></span>  
  
    3.  <span data-ttu-id="8bceb-165">应使用 `Order` 上的 `DataMemberAttribute` 属性，以确保所有新添加的数据成员显示在现有数据成员之后。</span><span class="sxs-lookup"><span data-stu-id="8bceb-165">The `Order` property on the `DataMemberAttribute` should be used to make sure that all of the newly added data members appear after the existing data members.</span></span> <span data-ttu-id="8bceb-166">达到此目的的建议方法为：不应设置数据协定的第一个版本中的任何数据成员的 `Order` 属性。</span><span class="sxs-lookup"><span data-stu-id="8bceb-166">The recommended way of doing this is as follows: None of the data members in the first version of the data contract should have their `Order` property set.</span></span> <span data-ttu-id="8bceb-167">应将添加到数据协定版本 2 中的所有数据成员的 `Order` 属性设置为 2。</span><span class="sxs-lookup"><span data-stu-id="8bceb-167">All of the data members added in version 2 of the data contract should have their `Order` property set to 2.</span></span> <span data-ttu-id="8bceb-168">将添加到数据协定版本 3 中的所有数据成员的 `Order` 设置为 3，依次类推。</span><span class="sxs-lookup"><span data-stu-id="8bceb-168">All of the data members added in version 3 of the data contract should have their `Order` set to 3, and so on.</span></span> <span data-ttu-id="8bceb-169">允许将多个数据成员集设置为同一个 `Order` 编号。</span><span class="sxs-lookup"><span data-stu-id="8bceb-169">It is permissible to have more than one data member set to the same `Order` number.</span></span>  
  
9. <span data-ttu-id="8bceb-170">在以后的版本中，不要移除数据成员，即使在以前的版本中 <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> 属性保留为其默认属性 `false`。</span><span class="sxs-lookup"><span data-stu-id="8bceb-170">Do not remove data members in later versions, even if the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property was left at its default property of `false` in prior versions.</span></span>  
  
10. <span data-ttu-id="8bceb-171">在各个版本中，不要更改任何现有数据成员上的 `IsRequired` 属性。</span><span class="sxs-lookup"><span data-stu-id="8bceb-171">Do not change the `IsRequired` property on any existing data members from version to version.</span></span>  
  
11. <span data-ttu-id="8bceb-172">对于必需的数据成员（其中 `IsRequired` 为 `true`），不要更改各版本中的 `EmitDefaultValue` 属性。</span><span class="sxs-lookup"><span data-stu-id="8bceb-172">For required data members (where `IsRequired` is `true`), do not change the `EmitDefaultValue` property from version to version.</span></span>  
  
12. <span data-ttu-id="8bceb-173">不要尝试创建分支版本管理层次结构。</span><span class="sxs-lookup"><span data-stu-id="8bceb-173">Do not attempt to create branched versioning hierarchies.</span></span> <span data-ttu-id="8bceb-174">即，从任意版本到任何其他版本的至少一个方向上，应始终有一个路径仅使用这些准则允许的更改。</span><span class="sxs-lookup"><span data-stu-id="8bceb-174">That is, there should always be a path in at least one direction from any version to any other version using only the changes permitted by these guidelines.</span></span>  
  
     <span data-ttu-id="8bceb-175">例如，如果 Person 数据协定的版本 1 仅包含 Name 数据成员，则不应创建仅添加 Age 成员的协定版本 2a，以及仅添加 Address 成员的版本 2b。</span><span class="sxs-lookup"><span data-stu-id="8bceb-175">For example, if version 1 of a Person data contract contains only the Name data member, you should not create version 2a of the contract adding only the Age member and version 2b adding only the Address member.</span></span> <span data-ttu-id="8bceb-176">从 2a 到 2b 需要移除 Age 和添加 Address，从 2b 到 2a 需要移除 Address 和添加 Age。</span><span class="sxs-lookup"><span data-stu-id="8bceb-176">Going from 2a to 2b would involve removing Age and adding Address; going in the other direction would entail removing Address and adding Age.</span></span> <span data-ttu-id="8bceb-177">这些准则不允许移除成员。</span><span class="sxs-lookup"><span data-stu-id="8bceb-177">Removing members is not permitted by these guidelines.</span></span>  
  
13. <span data-ttu-id="8bceb-178">通常不应在您的应用程序的新版本中创建现有数据协定类型的新子类型。</span><span class="sxs-lookup"><span data-stu-id="8bceb-178">You should generally not create new subtypes of existing data contract types in a new version of your application.</span></span> <span data-ttu-id="8bceb-179">同样，不应创建新的数据协定以代替声明为对象或接口类型的数据成员。</span><span class="sxs-lookup"><span data-stu-id="8bceb-179">Likewise, you should not create new data contracts that are used in place of data members declared as Object or as interface types.</span></span> <span data-ttu-id="8bceb-180">仅当您知道可以向旧应用程序的所有实例的已知类型列表中添加新类型时，才允许创建这些新类。</span><span class="sxs-lookup"><span data-stu-id="8bceb-180">Creating these new classes is allowed only when you know that you can add the new types to the known types list of all instances of your old application.</span></span> <span data-ttu-id="8bceb-181">例如，在应用程序的版本 1 中，可能已为 LibraryItem 数据协定类型添加了 Book 和 Newspaper 数据协定子类型。</span><span class="sxs-lookup"><span data-stu-id="8bceb-181">For example, in version 1 of your application, you may have the LibraryItem data contract type with the Book and Newspaper data contract subtypes.</span></span> <span data-ttu-id="8bceb-182">LibraryItem 随后应具有一个包含 Book 和 Newspaper 的已知类型列表。</span><span class="sxs-lookup"><span data-stu-id="8bceb-182">LibraryItem would then have a known types list that contains Book and Newspaper.</span></span> <span data-ttu-id="8bceb-183">假设您现在向版本 2 中添加一个 Magazine 类型，该类型是 LibraryItem 的一个子类型。</span><span class="sxs-lookup"><span data-stu-id="8bceb-183">Suppose you now add a Magazine type in version 2 which is a subtype of LibraryItem.</span></span> <span data-ttu-id="8bceb-184">如果您从版本 2 向版本 1 发送一个 Magazine 实例，则在已知类型列表中找不到 Magazine 数据协定，因而会引发异常。</span><span class="sxs-lookup"><span data-stu-id="8bceb-184">If you send a Magazine instance from version 2 to version 1, the Magazine data contract is not found in the list of known types and an exception is thrown.</span></span>  
  
14. <span data-ttu-id="8bceb-185">不应在版本间添加或移除枚举成员。</span><span class="sxs-lookup"><span data-stu-id="8bceb-185">You should not add or remove enumeration members between versions.</span></span> <span data-ttu-id="8bceb-186">也不应重命名枚举成员，除非使用 `EnumMemberAttribute` 属性 (Attribute) 上的 Name 属性 (Property) 使这些成员在数据协定模型中的名称保持不变。</span><span class="sxs-lookup"><span data-stu-id="8bceb-186">You should also not rename enumeration members, unless you use the Name property on the `EnumMemberAttribute` attribute to keep their names in the data contract model the same.</span></span>  
  
15. <span data-ttu-id="8bceb-187">集合是可互换的数据协定模型中所述[数据协定中的集合类型](../../../docs/framework/wcf/feature-details/collection-types-in-data-contracts.md)。</span><span class="sxs-lookup"><span data-stu-id="8bceb-187">Collections are interchangeable in the data contract model as described in [Collection Types in Data Contracts](../../../docs/framework/wcf/feature-details/collection-types-in-data-contracts.md).</span></span> <span data-ttu-id="8bceb-188">这提供了极大的灵活性。</span><span class="sxs-lookup"><span data-stu-id="8bceb-188">This allows for a great degree of flexibility.</span></span> <span data-ttu-id="8bceb-189">但是，请确保不会以不可互换的方式不慎更改版本间的集合类型。</span><span class="sxs-lookup"><span data-stu-id="8bceb-189">However, make sure that you do not inadvertently change a collection type in a non-interchangeable way from version to version.</span></span> <span data-ttu-id="8bceb-190">例如，不要将非自定义集合（即没有 `CollectionDataContractAttribute` 属性的集合）更改为自定义集合，也不要将自定义集合更改为非自定义集合。</span><span class="sxs-lookup"><span data-stu-id="8bceb-190">For example, do not change from a non-customized collection (that is, without the `CollectionDataContractAttribute` attribute) to a customized one or a customized collection to a non-customized one.</span></span> <span data-ttu-id="8bceb-191">同样，不要更改不同版本间 `CollectionDataContractAttribute` 上的属性。</span><span class="sxs-lookup"><span data-stu-id="8bceb-191">Also, do not change the properties on the `CollectionDataContractAttribute` from version to version.</span></span> <span data-ttu-id="8bceb-192">唯一允许更改的是添加一个 Name 或 Namespace 属性，前提是基础集合类型的名称或命名空间已更改，且需要使其数据协定名称和命名空间与以前版本中的相同。</span><span class="sxs-lookup"><span data-stu-id="8bceb-192">The only allowed change is adding a Name or Namespace property if the underlying collection type's name or namespace has changed and you need to make its data contract name and namespace the same as in a previous version.</span></span>  
  
 <span data-ttu-id="8bceb-193">在某些特殊的情况中，可以安全地忽略此处列出的某些准则。</span><span class="sxs-lookup"><span data-stu-id="8bceb-193">Some of the guidelines listed here can be safely ignored when special circumstances apply.</span></span> <span data-ttu-id="8bceb-194">确保在背离这些准则之前，已充分理解所涉及的序列化、反序列化和架构机制。</span><span class="sxs-lookup"><span data-stu-id="8bceb-194">Make sure you fully understand the serialization, deserialization, and schema mechanisms involved before deviating from the guidelines.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8bceb-195">请参阅</span><span class="sxs-lookup"><span data-stu-id="8bceb-195">See Also</span></span>  
 <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A>  
 <xref:System.Runtime.Serialization.DataContractAttribute>  
 <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>  
 <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A>  
 <xref:System.Runtime.Serialization.IExtensibleDataObject>  
 <xref:System.ServiceModel.ServiceBehaviorAttribute>  
 <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A>  
 <xref:System.Runtime.Serialization.ExtensionDataObject>  
 <xref:System.Runtime.Serialization.OnDeserializingAttribute>  
 [<span data-ttu-id="8bceb-196">使用数据协定</span><span class="sxs-lookup"><span data-stu-id="8bceb-196">Using Data Contracts</span></span>](../../../docs/framework/wcf/feature-details/using-data-contracts.md)  
 [<span data-ttu-id="8bceb-197">数据协定版本控制</span><span class="sxs-lookup"><span data-stu-id="8bceb-197">Data Contract Versioning</span></span>](../../../docs/framework/wcf/feature-details/data-contract-versioning.md)  
 [<span data-ttu-id="8bceb-198">数据协定名称</span><span class="sxs-lookup"><span data-stu-id="8bceb-198">Data Contract Names</span></span>](../../../docs/framework/wcf/feature-details/data-contract-names.md)  
 [<span data-ttu-id="8bceb-199">向前兼容的数据协定</span><span class="sxs-lookup"><span data-stu-id="8bceb-199">Forward-Compatible Data Contracts</span></span>](../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)  
 [<span data-ttu-id="8bceb-200">版本容错序列化回调</span><span class="sxs-lookup"><span data-stu-id="8bceb-200">Version-Tolerant Serialization Callbacks</span></span>](../../../docs/framework/wcf/feature-details/version-tolerant-serialization-callbacks.md)
