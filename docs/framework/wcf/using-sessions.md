---
title: "使用会话"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords: sessions [WCF]
ms.assetid: 864ba12f-3331-4359-a359-6d6d387f1035
caps.latest.revision: "32"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.openlocfilehash: 82fab5b5d7c702bc9f5e595572b8eba821159cd7
ms.sourcegitcommit: ce279f2d7fe2220e6ea0a25a8a7a5370ddf8d9f0
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/02/2017
---
# <a name="using-sessions"></a><span data-ttu-id="6c39b-102">使用会话</span><span class="sxs-lookup"><span data-stu-id="6c39b-102">Using Sessions</span></span>
<span data-ttu-id="6c39b-103">在 [!INCLUDE[indigo1](../../../includes/indigo1-md.md)] 应用程序中，“会话”  将一组消息相互关联，从而形成对话。</span><span class="sxs-lookup"><span data-stu-id="6c39b-103">In [!INCLUDE[indigo1](../../../includes/indigo1-md.md)] applications, a *session* correlates a group of messages into a conversation.</span></span> [!INCLUDE[indigo2](../../../includes/indigo2-md.md)]<span data-ttu-id="6c39b-104"> 会话与 [!INCLUDE[vstecasp](../../../includes/vstecasp-md.md)] 应用程序中提供的会话对象不同，它们支持不同的行为，并且可通过不同的方式进行控制。</span><span class="sxs-lookup"><span data-stu-id="6c39b-104"> sessions are different than the session object available in [!INCLUDE[vstecasp](../../../includes/vstecasp-md.md)] applications, support different behaviors, and are controlled in different ways.</span></span> <span data-ttu-id="6c39b-105">本主题描述了会话在 [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] 应用程序中启用的功能以及如何使用这些功能。</span><span class="sxs-lookup"><span data-stu-id="6c39b-105">This topic describes the features that sessions enable in [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] applications and how to use them.</span></span>  
  
## <a name="sessions-in-windows-communication-foundation-applications"></a><span data-ttu-id="6c39b-106">Windows Communication Foundation 应用程序中的会话</span><span class="sxs-lookup"><span data-stu-id="6c39b-106">Sessions in Windows Communication Foundation Applications</span></span>  
 <span data-ttu-id="6c39b-107">当某个服务协定指定它需要会话时，该协定会指定所有调用（即，支持调用的基础消息交换）必须是同一对话的一部分。</span><span class="sxs-lookup"><span data-stu-id="6c39b-107">When a service contract specifies that it requires a session, that contract is specifying that all calls (that is, the underlying message exchanges that support the calls) must be part of the same conversation.</span></span> <span data-ttu-id="6c39b-108">如果某个协定指定它允许使用会话但不要求使用会话，则客户端可以进行连接，并选择建立会话或不建立会话。</span><span class="sxs-lookup"><span data-stu-id="6c39b-108">If a contract specifies that it allows sessions but does not require one, clients can connect and either establish a session or not establish a session.</span></span> <span data-ttu-id="6c39b-109">如果会话结束，然后在同一个通道上发送消息，将会引发异常。</span><span class="sxs-lookup"><span data-stu-id="6c39b-109">If the session ends and a message is sent through the same channel an exception is thrown.</span></span>  
  
 [!INCLUDE[indigo2](../../../includes/indigo2-md.md)]<span data-ttu-id="6c39b-110"> 会话具有下列主要概念性功能：</span><span class="sxs-lookup"><span data-stu-id="6c39b-110"> sessions have the following main conceptual features:</span></span>  
  
-   <span data-ttu-id="6c39b-111">它们由调用应用程序（WCF 客户端）显式启动和终止。</span><span class="sxs-lookup"><span data-stu-id="6c39b-111">They are explicitly initiated and terminated by the calling application (the WCF client).</span></span>  
  
-   <span data-ttu-id="6c39b-112">会话期间传递的消息按照接收消息的顺序进行处理。</span><span class="sxs-lookup"><span data-stu-id="6c39b-112">Messages delivered during a session are processed in the order in which they are received.</span></span>  
  
-   <span data-ttu-id="6c39b-113">会话将一组消息相互关联，从而形成对话。</span><span class="sxs-lookup"><span data-stu-id="6c39b-113">Sessions correlate a group of messages into a conversation.</span></span> <span data-ttu-id="6c39b-114">可以有不同类型的关联。</span><span class="sxs-lookup"><span data-stu-id="6c39b-114">Different types of correlation are possible.</span></span> <span data-ttu-id="6c39b-115">例如，一个基于会话的通道可能会根据共享网络连接来关联消息，而另一个基于会话的通道可能会根据消息正文中的共享标记来关联消息。</span><span class="sxs-lookup"><span data-stu-id="6c39b-115">For instance, one session-based channel may correlate messages based on a shared network connection while another session-based channel may correlate messages based on a shared tag in the message body.</span></span> <span data-ttu-id="6c39b-116">可以从会话派生的功能取决于关联的性质。</span><span class="sxs-lookup"><span data-stu-id="6c39b-116">The features that can be derived from the session depend on the nature of the correlation.</span></span>  
  
-   <span data-ttu-id="6c39b-117">不存在与 [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] 会话相关联的常规数据存储区。</span><span class="sxs-lookup"><span data-stu-id="6c39b-117">There is no general data store associated with a [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] session.</span></span>  
  
 <span data-ttu-id="6c39b-118">如果您熟悉 <xref:System.Web.SessionState.HttpSessionState?displayProperty=nameWithType> 应用程序中的 [!INCLUDE[vstecasp](../../../includes/vstecasp-md.md)] 类以及该类提供的功能，则您可能会注意到，该类型的会话和 [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] 会话之间存在以下区别：</span><span class="sxs-lookup"><span data-stu-id="6c39b-118">If you are familiar with the <xref:System.Web.SessionState.HttpSessionState?displayProperty=nameWithType> class in [!INCLUDE[vstecasp](../../../includes/vstecasp-md.md)] applications and the functionality it provides, you might notice the following differences between that kind of session and [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] sessions:</span></span>  
  
-   [!INCLUDE[vstecasp](../../../includes/vstecasp-md.md)]<span data-ttu-id="6c39b-119"> 会话总是由服务器启动。</span><span class="sxs-lookup"><span data-stu-id="6c39b-119"> sessions are always server-initiated.</span></span>  
  
-   [!INCLUDE[vstecasp](../../../includes/vstecasp-md.md)]<span data-ttu-id="6c39b-120"> 会话原本是无序的。</span><span class="sxs-lookup"><span data-stu-id="6c39b-120"> sessions are implicitly unordered.</span></span>  
  
-   [!INCLUDE[vstecasp](../../../includes/vstecasp-md.md)]<span data-ttu-id="6c39b-121"> 会话提供了一种跨请求的常规数据存储机制。</span><span class="sxs-lookup"><span data-stu-id="6c39b-121"> sessions provide a general data storage mechanism across requests.</span></span>  
  
 <span data-ttu-id="6c39b-122">本主题描述：</span><span class="sxs-lookup"><span data-stu-id="6c39b-122">This topic describes:</span></span>  
  
-   <span data-ttu-id="6c39b-123">在服务模型层中使用基于会话的绑定时的默认执行行为。</span><span class="sxs-lookup"><span data-stu-id="6c39b-123">The default execution behavior when using session-based bindings in the service model layer.</span></span>  
  
-   <span data-ttu-id="6c39b-124">基于 [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] 会话的、系统提供的绑定所提供的功能的类型。</span><span class="sxs-lookup"><span data-stu-id="6c39b-124">The types of features that the [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] session-based, system-provided bindings provide.</span></span>  
  
-   <span data-ttu-id="6c39b-125">如何创建声明会话要求的协定。</span><span class="sxs-lookup"><span data-stu-id="6c39b-125">How to create a contract that declares a session requirement.</span></span>  
  
-   <span data-ttu-id="6c39b-126">如何了解和控制会话的创建和终止以及会话与服务实例的关系。</span><span class="sxs-lookup"><span data-stu-id="6c39b-126">How to understand and control the creation and termination of the session and the relationship of the session to the service instance.</span></span>  
  
## <a name="default-execution-behavior-using-sessions"></a><span data-ttu-id="6c39b-127">使用会话的默认执行行为</span><span class="sxs-lookup"><span data-stu-id="6c39b-127">Default Execution Behavior Using Sessions</span></span>  
 <span data-ttu-id="6c39b-128">尝试启动会话的绑定称为基于会话的  绑定。</span><span class="sxs-lookup"><span data-stu-id="6c39b-128">A binding that attempts to initiate a session is called a *session-based* binding.</span></span> <span data-ttu-id="6c39b-129">通过将服务协定接口（或类）上的 <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> 属性设置为 <xref:System.ServiceModel.SessionMode?displayProperty=nameWithType> 枚举值之一，服务协定指定它们要求、允许或拒绝基于会话的绑定。</span><span class="sxs-lookup"><span data-stu-id="6c39b-129">Service contracts specify that they require, permit, or refuse session-based bindings by setting the <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> property on the service contract interface (or class) to one of the <xref:System.ServiceModel.SessionMode?displayProperty=nameWithType> enumeration values.</span></span> <span data-ttu-id="6c39b-130">默认情况下，此属性的值为 <xref:System.ServiceModel.SessionMode.Allowed>，这意味着，如果客户端将基于会话的绑定用于 [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] 服务实现，则服务将建立并使用提供的会话。</span><span class="sxs-lookup"><span data-stu-id="6c39b-130">By default, the value of this property is <xref:System.ServiceModel.SessionMode.Allowed>, which means that if a client uses a session-based binding with a [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] service implementation, the service establishes and uses the session provided.</span></span>  
  
 <span data-ttu-id="6c39b-131">当 [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] 服务接受客户端会话时，默认情况下启用以下功能：</span><span class="sxs-lookup"><span data-stu-id="6c39b-131">When a [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] service accepts a client session, the following features are enabled by default:</span></span>  
  
1.  <span data-ttu-id="6c39b-132">通过同一服务实例来处理 [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] 客户端对象之间的所有调用。</span><span class="sxs-lookup"><span data-stu-id="6c39b-132">All calls between a [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] client object are handled by the same service instance.</span></span>  
  
2.  <span data-ttu-id="6c39b-133">不同的基于会话的绑定还会提供其他功能。</span><span class="sxs-lookup"><span data-stu-id="6c39b-133">Different session-based bindings provide additional features.</span></span>  
  
## <a name="system-provided-session-types"></a><span data-ttu-id="6c39b-134">系统提供的会话类型</span><span class="sxs-lookup"><span data-stu-id="6c39b-134">System-Provided Session Types</span></span>  
 <span data-ttu-id="6c39b-135">基于会话的绑定支持服务实例与特定会话的默认关联。</span><span class="sxs-lookup"><span data-stu-id="6c39b-135">A session-based binding supports the default association of a service instance with a particular session.</span></span> <span data-ttu-id="6c39b-136">但是，除了启用前面介绍的基于会话的实例化控制之外，不同的基于会话的绑定还支持不同的功能。</span><span class="sxs-lookup"><span data-stu-id="6c39b-136">However, different session-based bindings support different features in addition to enabling the session-based instancing control previously described.</span></span>  
  
 [!INCLUDE[indigo2](../../../includes/indigo2-md.md)]<span data-ttu-id="6c39b-137"> 提供下列类型的基于会话的应用程序行为：</span><span class="sxs-lookup"><span data-stu-id="6c39b-137"> provides the following types of session-based application behavior:</span></span>  
  
-   <span data-ttu-id="6c39b-138"><xref:System.ServiceModel.Channels.SecurityBindingElement?displayProperty=nameWithType> 支持基于安全的会话，其中，两个通信端采用统一的安全对话。</span><span class="sxs-lookup"><span data-stu-id="6c39b-138">The <xref:System.ServiceModel.Channels.SecurityBindingElement?displayProperty=nameWithType> supports security-based sessions, in which both ends of communication have agreed upon a specific secure conversation.</span></span> [!INCLUDE[crdefault](../../../includes/crdefault-md.md)]<span data-ttu-id="6c39b-139">[保护服务](../../../docs/framework/wcf/securing-services.md)。</span><span class="sxs-lookup"><span data-stu-id="6c39b-139"> [Securing Services](../../../docs/framework/wcf/securing-services.md).</span></span> <span data-ttu-id="6c39b-140">例如，<xref:System.ServiceModel.WSHttpBinding?displayProperty=nameWithType> 绑定（包含对安全会话和可靠会话的支持）默认情况下只使用对消息进行加密和数字签名的安全会话。</span><span class="sxs-lookup"><span data-stu-id="6c39b-140">For example, the <xref:System.ServiceModel.WSHttpBinding?displayProperty=nameWithType> binding, which contains support for both security sessions and reliable sessions, by default uses only a secure session that encrypts and digitally signs messages.</span></span>  
  
-   <span data-ttu-id="6c39b-141"><xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType> 绑定支持基于 TCP/IP 的会话，以确保所有消息都由套接字级别的连接进行关联。</span><span class="sxs-lookup"><span data-stu-id="6c39b-141">The <xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType> binding supports TCP/IP-based sessions to ensure that all messages are correlated by the connection at the socket level.</span></span>  
  
-   <span data-ttu-id="6c39b-142"><xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType> 元素实现 WS-ReliableMessaging 规范，并提供对可靠会话的支持。在可靠会话中，可以配置消息以按顺序传递并且只传递一次，从而使消息在对话期间即使经过多个节点也可以确保收到。</span><span class="sxs-lookup"><span data-stu-id="6c39b-142">The <xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType> element, which implements the WS-ReliableMessaging specification, provides support for reliable sessions in which messages can be configured to be delivered in order and exactly once, ensuring messages are received even when messages travel across multiple nodes during the conversation.</span></span> [!INCLUDE[crdefault](../../../includes/crdefault-md.md)]<span data-ttu-id="6c39b-143">[可靠会话](../../../docs/framework/wcf/feature-details/reliable-sessions.md)。</span><span class="sxs-lookup"><span data-stu-id="6c39b-143"> [Reliable Sessions](../../../docs/framework/wcf/feature-details/reliable-sessions.md).</span></span>  
  
-   <span data-ttu-id="6c39b-144"><xref:System.ServiceModel.NetMsmqBinding?displayProperty=nameWithType> 绑定提供 MSMQ 数据报会话。</span><span class="sxs-lookup"><span data-stu-id="6c39b-144">The <xref:System.ServiceModel.NetMsmqBinding?displayProperty=nameWithType> binding provides MSMQ datagram sessions.</span></span> [!INCLUDE[crdefault](../../../includes/crdefault-md.md)]<span data-ttu-id="6c39b-145">[WCF 中的队列](../../../docs/framework/wcf/feature-details/queues-in-wcf.md)。</span><span class="sxs-lookup"><span data-stu-id="6c39b-145"> [Queues in WCF](../../../docs/framework/wcf/feature-details/queues-in-wcf.md).</span></span>  
  
 <span data-ttu-id="6c39b-146">设置 <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> 属性并不指定协定需要的会话类型，而只是指定协定需要一个会话。</span><span class="sxs-lookup"><span data-stu-id="6c39b-146">Setting the <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> property does not specify the type of session the contract requires, only that it requires one.</span></span>  
  
## <a name="creating-a-contract-that-requires-a-session"></a><span data-ttu-id="6c39b-147">创建一个需要会话的协定</span><span class="sxs-lookup"><span data-stu-id="6c39b-147">Creating a Contract That Requires a Session</span></span>  
 <span data-ttu-id="6c39b-148">创建需要会话的协定的原则是，必须在同一会话内执行服务协定声明的所有操作组，并且必须按顺序传递消息。</span><span class="sxs-lookup"><span data-stu-id="6c39b-148">Creating a contract that requires a session states that the group of operations that the service contract declares must all be executed within the same session and that messages must be delivered in order.</span></span> <span data-ttu-id="6c39b-149">若要断言服务协定需要的会话支持级别，请将服务协定接口或类上的 <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> 属性设置为 <xref:System.ServiceModel.SessionMode?displayProperty=nameWithType> 枚举的值以指定协定是否：</span><span class="sxs-lookup"><span data-stu-id="6c39b-149">To assert the level of session support that a service contract requires, set the <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> property on your service contract interface or class to the value of the <xref:System.ServiceModel.SessionMode?displayProperty=nameWithType> enumeration to specify whether the contract:</span></span>  
  
-   <span data-ttu-id="6c39b-150">需要会话。</span><span class="sxs-lookup"><span data-stu-id="6c39b-150">Requires a session.</span></span>  
  
-   <span data-ttu-id="6c39b-151">允许客户端建立会话。</span><span class="sxs-lookup"><span data-stu-id="6c39b-151">Allows a client to establish a session.</span></span>  
  
-   <span data-ttu-id="6c39b-152">禁止会话。</span><span class="sxs-lookup"><span data-stu-id="6c39b-152">Prohibits a session.</span></span>  
  
 <span data-ttu-id="6c39b-153">但是，设置 <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> 属性并不指定协定需要的基于会话的行为的类型。</span><span class="sxs-lookup"><span data-stu-id="6c39b-153">Setting the <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> property does not, however, specify the type of session-based behavior the contract requires.</span></span> <span data-ttu-id="6c39b-154">它指示 [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] 在运行时确认：在实现服务时，为服务配置的绑定（用于创建通信通道）是执行会话、不执行会话还是可以建立会话。</span><span class="sxs-lookup"><span data-stu-id="6c39b-154">It instructs [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] to confirm at runtime that the configured binding (which creates the communication channel) for the service does, does not, or can establish a session when implementing a service.</span></span> <span data-ttu-id="6c39b-155">同样，绑定可以使用它选择的任何类型的基于会话的行为（安全、传输、可靠或某种组合）来满足该要求。</span><span class="sxs-lookup"><span data-stu-id="6c39b-155">Again, the binding can satisfy that requirement with any type of session-based behavior it chooses—security, transport, reliable, or some combination.</span></span> <span data-ttu-id="6c39b-156">具体的行为取决于选择的 <xref:System.ServiceModel.SessionMode?displayProperty=nameWithType> 值。</span><span class="sxs-lookup"><span data-stu-id="6c39b-156">The exact behavior depends on the <xref:System.ServiceModel.SessionMode?displayProperty=nameWithType> value selected.</span></span> <span data-ttu-id="6c39b-157">如果为服务配置的绑定不符合 <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A>的值，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="6c39b-157">If the configured binding of the service does not conform to the value of <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A>, an exception is thrown.</span></span> <span data-ttu-id="6c39b-158">绑定及其创建的支持会话的通道可认为是基于会话的。</span><span class="sxs-lookup"><span data-stu-id="6c39b-158">Bindings and the channels they create that support sessions are said to be session-based.</span></span>  
  
 <span data-ttu-id="6c39b-159">下面的服务协定指定 `ICalculatorSession` 中的所有操作必须在会话中进行交换。</span><span class="sxs-lookup"><span data-stu-id="6c39b-159">The following service contract specifies that all operations in the `ICalculatorSession` must be exchanged within a session.</span></span> <span data-ttu-id="6c39b-160">除了 `Equals` 方法之外，任何操作都不会向调用方返回值。</span><span class="sxs-lookup"><span data-stu-id="6c39b-160">None of the operations returns a value to the caller except the `Equals` method.</span></span> <span data-ttu-id="6c39b-161">但是， `Equals` 方法不使用参数，因此，在已将其中的数据传递到其他操作的会话内部只可以返回非零值。</span><span class="sxs-lookup"><span data-stu-id="6c39b-161">However, the `Equals` method takes no parameters and, therefore, can only return a non-zero value inside a session in which data has already been passed to the other operations.</span></span> <span data-ttu-id="6c39b-162">此协定需要会话正常工作。</span><span class="sxs-lookup"><span data-stu-id="6c39b-162">This contract requires a session to function properly.</span></span> <span data-ttu-id="6c39b-163">如果没有与特定客户端相关联的会话，则服务实例无法知道此客户端前面已经发送了哪些数据。</span><span class="sxs-lookup"><span data-stu-id="6c39b-163">Without a session associated with a specific client, the service instance has no way of knowing what previous data this client has sent.</span></span>  
  
 [!code-csharp[S_Service_Session#1](../../../samples/snippets/csharp/VS_Snippets_CFX/s_service_session/cs/service.cs#1)]
 [!code-vb[S_Service_Session#1](../../../samples/snippets/visualbasic/VS_Snippets_CFX/s_service_session/vb/service.vb#1)]  
  
 <span data-ttu-id="6c39b-164">如果服务允许会话，则当客户端启动一个会话时将建立并使用该会话；否则，不建立会话。</span><span class="sxs-lookup"><span data-stu-id="6c39b-164">If a service allows a session, then a session is established and used if the client initiates one; otherwise, no session is established.</span></span>  
  
## <a name="sessions-and-service-instances"></a><span data-ttu-id="6c39b-165">会话和服务实例</span><span class="sxs-lookup"><span data-stu-id="6c39b-165">Sessions and Service Instances</span></span>  
 <span data-ttu-id="6c39b-166">如果使用 [!INCLUDE[indigo2](../../../includes/indigo2-md.md)]中的默认实例化行为，则通过同一服务实例来处理 [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] 客户端对象之间的所有调用。</span><span class="sxs-lookup"><span data-stu-id="6c39b-166">If you use the default instancing behavior in [!INCLUDE[indigo2](../../../includes/indigo2-md.md)], all calls between a [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] client object are handled by the same service instance.</span></span> <span data-ttu-id="6c39b-167">因此，在应用程序级别上，可以将会话视为启用与本地调用行为相似的应用程序行为。</span><span class="sxs-lookup"><span data-stu-id="6c39b-167">Therefore, at the application level, you can think of a session as enabling application behavior similar to local call behavior.</span></span> <span data-ttu-id="6c39b-168">例如，在创建本地对象时：</span><span class="sxs-lookup"><span data-stu-id="6c39b-168">For example, when you create a local object:</span></span>  
  
-   <span data-ttu-id="6c39b-169">调用构造函数。</span><span class="sxs-lookup"><span data-stu-id="6c39b-169">A constructor is called.</span></span>  
  
-   <span data-ttu-id="6c39b-170">由同一个对象实例来处理对 [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] 客户端对象引用所做的所有后续调用。</span><span class="sxs-lookup"><span data-stu-id="6c39b-170">All subsequent calls made to the [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] client object reference are processed by the same object instance.</span></span>  
  
-   <span data-ttu-id="6c39b-171">在销毁对象引用时调用析构函数。</span><span class="sxs-lookup"><span data-stu-id="6c39b-171">A destructor is called when the object reference is destroyed.</span></span>  
  
 <span data-ttu-id="6c39b-172">只要使用默认的服务实例行为，会话就会在客户端和服务之间启用一个相似的行为。</span><span class="sxs-lookup"><span data-stu-id="6c39b-172">Sessions enable a similar behavior between clients and services as long as the default service instance behavior is used.</span></span> <span data-ttu-id="6c39b-173">如果服务协定需要或支持会话，则通过设置 <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> 和 <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A> 属性，可以将一个或多个协定操作标记为启动或终止会话。</span><span class="sxs-lookup"><span data-stu-id="6c39b-173">If a service contract requires or supports sessions, one or more contract operations can be marked as initiating or terminating a session by setting the <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> and <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A> properties.</span></span>  
  
 <span data-ttu-id="6c39b-174">启动操作 是必须作为新会话的第一个操作而调用的操作。</span><span class="sxs-lookup"><span data-stu-id="6c39b-174">*Initiating operations* are those that must be called as the first operation of a new session.</span></span> <span data-ttu-id="6c39b-175">只有在已调用至少一个启动操作之后才可以调用非启动操作。</span><span class="sxs-lookup"><span data-stu-id="6c39b-175">Non-initiating operations can be called only after at least one initiating operation has been called.</span></span> <span data-ttu-id="6c39b-176">因此，可以通过声明一个启动操作来为服务创建某种会话构造函数，启动操作应设计为从与服务实例的开始相对应的客户端接收输入。</span><span class="sxs-lookup"><span data-stu-id="6c39b-176">You can therefore create a kind of session constructor for your service by declaring initiating operations designed to take input from clients appropriate to the beginning of the service instance.</span></span> <span data-ttu-id="6c39b-177">（状态与会话相关联，但是，不与服务对象相关联。）</span><span class="sxs-lookup"><span data-stu-id="6c39b-177">(The state is associated with the session, however, and not the service object.)</span></span>  
  
 <span data-ttu-id="6c39b-178">相反，终止操作是必须作为现有会话中的最后消息而调用的操作。</span><span class="sxs-lookup"><span data-stu-id="6c39b-178">*Terminating operations*, conversely, are those that must be called as the last message in an existing session.</span></span> <span data-ttu-id="6c39b-179">默认情况下，在关闭与服务关联的会话之后， [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] 将回收服务对象及其上下文。</span><span class="sxs-lookup"><span data-stu-id="6c39b-179">In the default case, [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] recycles the service object and its context after the session with which the service was associated is closed.</span></span> <span data-ttu-id="6c39b-180">因此，可以通过声明终止操作来创建某种析构函数，终止操作应设计为执行与服务实例的结束相对应的函数。</span><span class="sxs-lookup"><span data-stu-id="6c39b-180">You can, therefore, create a kind of destructor by declaring terminating operations designed to perform a function appropriate to the end of the service instance.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6c39b-181">尽管默认的行为与本地构造函数和析构函数有相似之处，但仅仅是相似。</span><span class="sxs-lookup"><span data-stu-id="6c39b-181">Although the default behavior bears a resemblance to local constructors and destructors, it is only a resemblance.</span></span> <span data-ttu-id="6c39b-182">任何 [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] 服务操作都可以是启动或终止操作，或同时为这两种操作。</span><span class="sxs-lookup"><span data-stu-id="6c39b-182">Any [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] service operation can be an initiating or terminating operation, or both at the same time.</span></span> <span data-ttu-id="6c39b-183">另外，在默认情况下，可以按任意顺序调用启动操作任意次数；一旦建立会话并与实例相关联后，便不会再创建其他会话，除非显式控制服务实例的生存期（通过操作 <xref:System.ServiceModel.InstanceContext?displayProperty=nameWithType> 对象）。</span><span class="sxs-lookup"><span data-stu-id="6c39b-183">In addition, in the default case, initiating operations can be called any number of times in any order; no additional sessions are created once the session is established and associated with an instance unless you explicitly control the lifetime of the service instance (by manipulating the <xref:System.ServiceModel.InstanceContext?displayProperty=nameWithType> object).</span></span> <span data-ttu-id="6c39b-184">最后，状态与会话相关联，而不是与服务对象相关联。</span><span class="sxs-lookup"><span data-stu-id="6c39b-184">Finally, the state is associated with the session and not the service object.</span></span>  
  
 <span data-ttu-id="6c39b-185">例如，在上一实例中使用的 `ICalculatorSession` 协定需要 [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] 客户端对象在任何其他操作之前调用 `Clear` 操作，并且在它调用 [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] 操作时与此 `Equals` 客户端对象的会话应该终止。</span><span class="sxs-lookup"><span data-stu-id="6c39b-185">For example, the `ICalculatorSession` contract used in the preceding example requires that the [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] client object first call the `Clear` operation prior to any other operation and that the session with this [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] client object should terminate when it calls the `Equals` operation.</span></span> <span data-ttu-id="6c39b-186">下面的代码示例演示强制执行这些要求的协定。</span><span class="sxs-lookup"><span data-stu-id="6c39b-186">The following code example shows a contract that enforces these requirements.</span></span> <span data-ttu-id="6c39b-187">必须首先调用`Clear` 来启动会话，并且会话在调用 `Equals` 时结束。</span><span class="sxs-lookup"><span data-stu-id="6c39b-187">`Clear` must be called first to initiate a session, and that session ends when `Equals` is called.</span></span>  
  
 [!code-csharp[SCA.IsInitiatingIsTerminating#1](../../../samples/snippets/csharp/VS_Snippets_CFX/sca.isinitiatingisterminating/cs/service.cs#1)]
 [!code-vb[SCA.IsInitiatingIsTerminating#1](../../../samples/snippets/visualbasic/VS_Snippets_CFX/sca.isinitiatingisterminating/vb/service.vb#1)]  
  
 <span data-ttu-id="6c39b-188">服务不会启动与客户端的会话。</span><span class="sxs-lookup"><span data-stu-id="6c39b-188">Services do not start sessions with clients.</span></span> <span data-ttu-id="6c39b-189">在 [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] 客户端应用程序中，直接关系存在于基于会话的通道的生存期和会话本身的生存期之间。</span><span class="sxs-lookup"><span data-stu-id="6c39b-189">In [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] client applications, a direct relationship exists between the lifetime of the session-based channel and the lifetime of the session itself.</span></span> <span data-ttu-id="6c39b-190">因此，客户端可通过创建新的基于会话的通道来创建新会话，并通过正常关闭基于会话的通道来关闭现有的会话。</span><span class="sxs-lookup"><span data-stu-id="6c39b-190">As such, clients create new sessions by creating new session-based channels and tear down existing sessions by closing session-based channels gracefully.</span></span> <span data-ttu-id="6c39b-191">客户端通过调用以下项目之一来启动与服务终结点的会话：</span><span class="sxs-lookup"><span data-stu-id="6c39b-191">A client starts a session with a service endpoint by calling one of the following:</span></span>  
  
-   <span data-ttu-id="6c39b-192">通过调用 <xref:System.ServiceModel.ICommunicationObject.Open%2A?displayProperty=nameWithType> 返回的通道上的 <xref:System.ServiceModel.ChannelFactory%601.CreateChannel%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6c39b-192"><xref:System.ServiceModel.ICommunicationObject.Open%2A?displayProperty=nameWithType> on the channel returned by a call to <xref:System.ServiceModel.ChannelFactory%601.CreateChannel%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="6c39b-193"><xref:System.ServiceModel.ClientBase%601.Open%2A?displayProperty=nameWithType>上[!INCLUDE[indigo2](../../../includes/indigo2-md.md)]由生成的客户端对象[ServiceModel 元数据实用工具 (Svcutil.exe)](../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)。</span><span class="sxs-lookup"><span data-stu-id="6c39b-193"><xref:System.ServiceModel.ClientBase%601.Open%2A?displayProperty=nameWithType> on the [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] client object generated by the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span>  
  
-   <span data-ttu-id="6c39b-194">任一类型的 [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] 客户端对象上的启动操作（默认情况下，所有操作都会启动）。</span><span class="sxs-lookup"><span data-stu-id="6c39b-194">An initiating operation on either type of [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] client object (by default, all operations are initiating).</span></span> <span data-ttu-id="6c39b-195">当调用第一个操作时， [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] 客户端对象自动打开通道并启动会话。</span><span class="sxs-lookup"><span data-stu-id="6c39b-195">When the first operation is called, the [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] client object automatically opens the channel and initiates a session.</span></span>  
  
 <span data-ttu-id="6c39b-196">通常，客户端通过调用以下项目之一来结束与服务终结点的会话：</span><span class="sxs-lookup"><span data-stu-id="6c39b-196">Typically a client ends a session with a service endpoint by calling one of the following:</span></span>  
  
-   <span data-ttu-id="6c39b-197">通过调用 <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> 返回的通道上的 <xref:System.ServiceModel.ChannelFactory%601.CreateChannel%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6c39b-197"><xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> on the channel returned by a call to <xref:System.ServiceModel.ChannelFactory%601.CreateChannel%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="6c39b-198">由 Svcutil.exe 生成的 <xref:System.ServiceModel.ClientBase%601.Close%2A?displayProperty=nameWithType> 客户端对象上的 [!INCLUDE[indigo2](../../../includes/indigo2-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="6c39b-198"><xref:System.ServiceModel.ClientBase%601.Close%2A?displayProperty=nameWithType> on the [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] client object generated by Svcutil.exe.</span></span>  
  
-   <span data-ttu-id="6c39b-199">任一类型 [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] 客户端对象上的终止操作（默认情况下，不终止任何操作；协定必须显式指定终止操作）。</span><span class="sxs-lookup"><span data-stu-id="6c39b-199">A terminating operation on either type of [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] client object (by default, no operations are terminating; the contract must explicitly specify a terminating operation).</span></span> <span data-ttu-id="6c39b-200">当调用第一个操作时， [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] 客户端对象自动打开通道并启动会话。</span><span class="sxs-lookup"><span data-stu-id="6c39b-200">When the first operation is called, the [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] client object automatically opens the channel and initiates a session.</span></span>  
  
 <span data-ttu-id="6c39b-201">有关示例，请参阅 [How to: Create a Service That Requires Sessions](../../../docs/framework/wcf/feature-details/how-to-create-a-service-that-requires-sessions.md) 以及 [Default Service Behavior](../../../docs/framework/wcf/samples/default-service-behavior.md) 和 [Instancing](../../../docs/framework/wcf/samples/instancing.md) 示例。</span><span class="sxs-lookup"><span data-stu-id="6c39b-201">For examples, see [How to: Create a Service That Requires Sessions](../../../docs/framework/wcf/feature-details/how-to-create-a-service-that-requires-sessions.md) as well as the [Default Service Behavior](../../../docs/framework/wcf/samples/default-service-behavior.md) and [Instancing](../../../docs/framework/wcf/samples/instancing.md) samples.</span></span>  
  
 [!INCLUDE[crabout](../../../includes/crabout-md.md)]<span data-ttu-id="6c39b-202">客户端和会话，请参阅[使用 WCF 客户端访问服务](../../../docs/framework/wcf/feature-details/accessing-services-using-a-client.md)。</span><span class="sxs-lookup"><span data-stu-id="6c39b-202"> clients and sessions, see [Accessing Services Using a WCF Client](../../../docs/framework/wcf/feature-details/accessing-services-using-a-client.md).</span></span>  
  
## <a name="sessions-interact-with-instancecontext-settings"></a><span data-ttu-id="6c39b-203">会话与 InstanceContext 设置进行交互</span><span class="sxs-lookup"><span data-stu-id="6c39b-203">Sessions Interact with InstanceContext Settings</span></span>  
 <span data-ttu-id="6c39b-204">协定中的 <xref:System.ServiceModel.SessionMode> 枚举与 <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> 属性之间存在交互，该属性可控制通道和特定服务对象之间的关联。</span><span class="sxs-lookup"><span data-stu-id="6c39b-204">There is an interaction between the <xref:System.ServiceModel.SessionMode> enumeration in a contract and the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> property, which controls the association between channels and specific service objects.</span></span> [!INCLUDE[crdefault](../../../includes/crdefault-md.md)]<span data-ttu-id="6c39b-205">[会话，实例化和并发](../../../docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md)。</span><span class="sxs-lookup"><span data-stu-id="6c39b-205"> [Sessions, Instancing, and Concurrency](../../../docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).</span></span>  
  
### <a name="sharing-instancecontext-objects"></a><span data-ttu-id="6c39b-206">共享 InstanceContext 对象</span><span class="sxs-lookup"><span data-stu-id="6c39b-206">Sharing InstanceContext Objects</span></span>  
 <span data-ttu-id="6c39b-207">通过自己执行关联，您还可以控制将哪个基于会话的通道或调用与哪个 <xref:System.ServiceModel.InstanceContext> 对象相关联。</span><span class="sxs-lookup"><span data-stu-id="6c39b-207">You can also control which session-based channel or call is associated with which <xref:System.ServiceModel.InstanceContext> object by performing that association yourself.</span></span> <span data-ttu-id="6c39b-208">有关完整示例，请参见 [InstanceContextSharing](http://msdn.microsoft.com/en-us/4a6a46d7-b7d7-4bb5-a0dd-03ffa3cbc230)。</span><span class="sxs-lookup"><span data-stu-id="6c39b-208">For a complete example, see [InstanceContextSharing](http://msdn.microsoft.com/en-us/4a6a46d7-b7d7-4bb5-a0dd-03ffa3cbc230).</span></span>  
  
## <a name="sessions-and-streaming"></a><span data-ttu-id="6c39b-209">会话和流</span><span class="sxs-lookup"><span data-stu-id="6c39b-209">Sessions and Streaming</span></span>  
 <span data-ttu-id="6c39b-210">当您有大量的数据要传输时， [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] 中的流传输模式是整个在内存中缓冲和处理消息的默认行为的一个可行的替代方法。</span><span class="sxs-lookup"><span data-stu-id="6c39b-210">When you have a large amount of data to transfer, the streaming transfer mode in [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] is a feasible alternative to the default behavior of buffering and processing messages in memory in their entirety.</span></span> <span data-ttu-id="6c39b-211">在流与基于会话的绑定一起调用时可能会产生意外行为。</span><span class="sxs-lookup"><span data-stu-id="6c39b-211">You may get unexpected behavior when streaming calls with a session-based binding.</span></span> <span data-ttu-id="6c39b-212">可通过单一通道（数据报通道）执行所有流调用，该通道不支持会话，即使将正在使用的绑定配置为使用会话也是如此。</span><span class="sxs-lookup"><span data-stu-id="6c39b-212">All streaming calls are made through a single channel (the datagram channel) that does not support sessions even if the binding being used is configured to use sessions.</span></span> <span data-ttu-id="6c39b-213">如果多个客户端通过基于会话的绑定对相同的服务对象进行流调用，并且将服务对象的并发模式设置为 single，同时将其实例上下文模式设置为 `PerSession`，则所用的调用必须经过数据报通道，因此一次只处理一个调用。</span><span class="sxs-lookup"><span data-stu-id="6c39b-213">If multiple clients make streaming calls to the same service object over a session-based binding, and the service object's concurrency mode is set to single and its instance context mode is set to `PerSession`, all calls must go through the datagram channel and so only one call is processed at a time.</span></span> <span data-ttu-id="6c39b-214">一个或多个客户端因此可能会超时。通过将服务对象的 `InstanceContextMode` 设置为 `PerCall` 或者将 Concurrency 设置为 multiple，可以解决此问题。</span><span class="sxs-lookup"><span data-stu-id="6c39b-214">One or more clients may then time out. You can work around this issue by either setting the service object's `InstanceContextMode` to `PerCall` or Concurrency to multiple.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6c39b-215">MaxConcurrentSessions 在此情况下不会产生任何影响，因为只有一个“会话”可用。</span><span class="sxs-lookup"><span data-stu-id="6c39b-215">MaxConcurrentSessions have no effect in this case because there is only one "session" available.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="6c39b-216">另请参阅</span><span class="sxs-lookup"><span data-stu-id="6c39b-216">See Also</span></span>  
 <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A>  
 <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A>
