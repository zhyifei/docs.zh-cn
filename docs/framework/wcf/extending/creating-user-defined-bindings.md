---
title: 创建用户定义的绑定
ms.date: 03/30/2017
helpviewer_keywords:
- user-defined bindings [WCF]
ms.assetid: c4960675-d701-4bc9-b400-36a752fdd08b
ms.openlocfilehash: 54a1c8e06991729ea8556d82d31897c522f6d173
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/23/2019
ms.locfileid: "61923235"
---
# <a name="creating-user-defined-bindings"></a><span data-ttu-id="ebe9a-102">创建用户定义的绑定</span><span class="sxs-lookup"><span data-stu-id="ebe9a-102">Creating User-Defined Bindings</span></span>
<span data-ttu-id="ebe9a-103">有多种方式可以创建系统未提供的绑定：</span><span class="sxs-lookup"><span data-stu-id="ebe9a-103">There are several ways to create bindings not provided by the system:</span></span>  
  
-   <span data-ttu-id="ebe9a-104">基于 <xref:System.ServiceModel.Channels.CustomBinding> 类（可向其中填充绑定元素的容器）创建一个自定义绑定。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-104">Create a custom binding, based on the <xref:System.ServiceModel.Channels.CustomBinding> class, which is a container that you fill with binding elements.</span></span> <span data-ttu-id="ebe9a-105">然后将自定义绑定添加到服务终结点。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-105">The custom binding is then added to a service endpoint.</span></span> <span data-ttu-id="ebe9a-106">可以通过编程方式或者在应用程序配置文件中创建自定义绑定。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-106">You can create the custom binding either programmatically or in an application configuration file.</span></span> <span data-ttu-id="ebe9a-107">若要从应用程序配置文件中使用绑定元素，该绑定元素必须扩展 <xref:System.ServiceModel.Configuration.BindingElementExtensionElement>。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-107">To use a binding element from an application configuration file, the binding element must extend <xref:System.ServiceModel.Configuration.BindingElementExtensionElement>.</span></span> <span data-ttu-id="ebe9a-108">有关自定义绑定的详细信息，请参阅[自定义绑定](../../../../docs/framework/wcf/extending/custom-bindings.md)和<xref:System.ServiceModel.Channels.CustomBinding>。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-108">For more information about custom bindings, see [Custom Bindings](../../../../docs/framework/wcf/extending/custom-bindings.md) and <xref:System.ServiceModel.Channels.CustomBinding>.</span></span>  
  
-   <span data-ttu-id="ebe9a-109">可以创建一个从标准绑定派生的类。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-109">You can create a class that derives from a standard binding.</span></span> <span data-ttu-id="ebe9a-110">例如，可以从 <xref:System.ServiceModel.WSHttpBinding> 派生一个类并重写 <xref:System.ServiceModel.Channels.CustomBinding.CreateBindingElements%2A> 方法，以获取绑定元素并插入自定义绑定元素或建立一个特定的安全值。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-110">For example, you can derive a class from <xref:System.ServiceModel.WSHttpBinding> and override <xref:System.ServiceModel.Channels.CustomBinding.CreateBindingElements%2A> method to obtain the binding elements and insert a custom binding element or establish a particular value for security.</span></span>  
  
-   <span data-ttu-id="ebe9a-111">可以创建一个新的 <xref:System.ServiceModel.Channels.Binding> 类型来完全控制整个绑定实现。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-111">You can create a new <xref:System.ServiceModel.Channels.Binding> type to completely control the entire binding implementation.</span></span>  
  
## <a name="the-order-of-binding-elements"></a><span data-ttu-id="ebe9a-112">绑定元素的顺序</span><span class="sxs-lookup"><span data-stu-id="ebe9a-112">The Order of Binding Elements</span></span>  
 <span data-ttu-id="ebe9a-113">发送或接收消息时，每个绑定元素都表示一个处理步骤。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-113">Each binding element represents a processing step when sending or receiving messages.</span></span> <span data-ttu-id="ebe9a-114">在运行时，绑定元素会创建必要的通道和侦听器，用以生成传出和传入通道堆栈。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-114">At runtime, binding elements create the channels and listeners necessary to build outgoing and incoming channel stacks.</span></span>  
  
 <span data-ttu-id="ebe9a-115">有三种主要类型的绑定元素：协议绑定元素、 编码绑定元素和传输绑定元素。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-115">There are three main types of binding elements: Protocol Binding Elements, Encoding Binding Elements and Transport Binding Elements.</span></span>  
  
 <span data-ttu-id="ebe9a-116">协议绑定元素 – 这些元素表示对消息执行的更高级别的处理步骤。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-116">Protocol Binding Elements – These elements represent higher-level processing steps that act on messages.</span></span> <span data-ttu-id="ebe9a-117">由这些绑定元素创建的通道和侦听器可以添加、移除或修改消息内容。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-117">Channels and listeners created by these binding elements can add, remove, or modify the message content.</span></span> <span data-ttu-id="ebe9a-118">给定的绑定可以具有任意数量的协议绑定元素，每一个元素都从 <xref:System.ServiceModel.Channels.BindingElement> 继承。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-118">A given binding may have an arbitrary number of protocol binding elements, each inheriting from <xref:System.ServiceModel.Channels.BindingElement>.</span></span> <span data-ttu-id="ebe9a-119">Windows Communication Foundation (WCF) 包括多个协议绑定元素，其中包括<xref:System.ServiceModel.Channels.ReliableSessionBindingElement>和<xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement>。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-119">Windows Communication Foundation (WCF) includes several protocol binding elements, including the <xref:System.ServiceModel.Channels.ReliableSessionBindingElement> and the <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement>.</span></span>  
  
 <span data-ttu-id="ebe9a-120">编码绑定元素 – 这些元素表示消息与准备用于网络传输的编码之间的转换。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-120">Encoding Binding Element – These elements represent transformations between a message and an encoding ready for transmission on the wire.</span></span> <span data-ttu-id="ebe9a-121">典型的 WCF 绑定包含一个编码绑定元素。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-121">Typical WCF bindings include exactly one encoding binding element.</span></span> <span data-ttu-id="ebe9a-122">编码绑定元素的示例包括 <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>、<xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> 和 <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-122">Examples of encoding binding elements include the <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>, the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>, and the <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>.</span></span> <span data-ttu-id="ebe9a-123">如果未对绑定指定编码绑定元素，则使用默认的编码。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-123">If an encoding binding element is not specified for a binding, a default encoding is used.</span></span> <span data-ttu-id="ebe9a-124">当传输协议是 HTTP 时，默认编码为文本，对于其他传输协议，默认编码为二进制。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-124">The default is text when the transport is HTTP and binary otherwise.</span></span>  
  
 <span data-ttu-id="ebe9a-125">传输绑定元素 – 这些元素表示传输协议上编码消息的传输。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-125">Transport Binding Element – These elements represent the transmission of an encoding message on a transport protocol.</span></span> <span data-ttu-id="ebe9a-126">典型的 WCF 绑定包括一个传输绑定元素，继承自<xref:System.ServiceModel.Channels.TransportBindingElement>。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-126">Typical WCF bindings include exactly one transport binding element, which inherits from <xref:System.ServiceModel.Channels.TransportBindingElement>.</span></span> <span data-ttu-id="ebe9a-127">传输绑定元素的示例包括 <xref:System.ServiceModel.Channels.TcpTransportBindingElement>、<xref:System.ServiceModel.Channels.HttpTransportBindingElement> 和 <xref:System.ServiceModel.Channels.NamedPipeTransportBindingElement>。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-127">Examples of transport binding elements include the <xref:System.ServiceModel.Channels.TcpTransportBindingElement>, the <xref:System.ServiceModel.Channels.HttpTransportBindingElement>, and the <xref:System.ServiceModel.Channels.NamedPipeTransportBindingElement>.</span></span>  
  
 <span data-ttu-id="ebe9a-128">创建新的绑定时，添加绑定元素的顺序很重要。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-128">When creating new bindings, the order of the added binding elements is important.</span></span> <span data-ttu-id="ebe9a-129">应始终按照以下顺序添加绑定元素：</span><span class="sxs-lookup"><span data-stu-id="ebe9a-129">Always add binding elements in the following order:</span></span>  
  
|<span data-ttu-id="ebe9a-130">层</span><span class="sxs-lookup"><span data-stu-id="ebe9a-130">Layer</span></span>|<span data-ttu-id="ebe9a-131">选项</span><span class="sxs-lookup"><span data-stu-id="ebe9a-131">Options</span></span>|<span data-ttu-id="ebe9a-132">必需</span><span class="sxs-lookup"><span data-stu-id="ebe9a-132">Required</span></span>|  
|-----------|-------------|--------------|  
|<span data-ttu-id="ebe9a-133">事务流</span><span class="sxs-lookup"><span data-stu-id="ebe9a-133">Transaction Flow</span></span>|<xref:System.ServiceModel.Channels.TransactionFlowBindingElement?displayProperty=nameWithType>|<span data-ttu-id="ebe9a-134">否</span><span class="sxs-lookup"><span data-stu-id="ebe9a-134">No</span></span>|  
|<span data-ttu-id="ebe9a-135">可靠性</span><span class="sxs-lookup"><span data-stu-id="ebe9a-135">Reliability</span></span>|<xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType>|<span data-ttu-id="ebe9a-136">否</span><span class="sxs-lookup"><span data-stu-id="ebe9a-136">No</span></span>|  
|<span data-ttu-id="ebe9a-137">安全性</span><span class="sxs-lookup"><span data-stu-id="ebe9a-137">Security</span></span>|<xref:System.ServiceModel.Channels.SecurityBindingElement?displayProperty=nameWithType>|<span data-ttu-id="ebe9a-138">否</span><span class="sxs-lookup"><span data-stu-id="ebe9a-138">No</span></span>|  
|<span data-ttu-id="ebe9a-139">复合双工</span><span class="sxs-lookup"><span data-stu-id="ebe9a-139">Composite Duplex</span></span>|<xref:System.ServiceModel.Channels.CompositeDuplexBindingElement?displayProperty=nameWithType>|<span data-ttu-id="ebe9a-140">否</span><span class="sxs-lookup"><span data-stu-id="ebe9a-140">No</span></span>|  
|<span data-ttu-id="ebe9a-141">编码</span><span class="sxs-lookup"><span data-stu-id="ebe9a-141">Encoding</span></span>|<span data-ttu-id="ebe9a-142">文本、二进制、MTOM、自定义</span><span class="sxs-lookup"><span data-stu-id="ebe9a-142">Text, Binary, MTOM, Custom</span></span>|<span data-ttu-id="ebe9a-143">是\*</span><span class="sxs-lookup"><span data-stu-id="ebe9a-143">Yes\*</span></span>|  
|<span data-ttu-id="ebe9a-144">传输</span><span class="sxs-lookup"><span data-stu-id="ebe9a-144">Transport</span></span>|<span data-ttu-id="ebe9a-145">TCP、命名管道、HTTP、HTTPS、MSMQ、自定义</span><span class="sxs-lookup"><span data-stu-id="ebe9a-145">TCP, Named Pipes, HTTP, HTTPS, MSMQ, Custom</span></span>|<span data-ttu-id="ebe9a-146">是</span><span class="sxs-lookup"><span data-stu-id="ebe9a-146">Yes</span></span>|  
  
 <span data-ttu-id="ebe9a-147">\* 因为如果未指定的编码，都需要为每个绑定，一个编码，WCF 将添加一个默认编码。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-147">\*Because an encoding is required for each binding, if an encoding is not specified, WCF adds a default encoding for you.</span></span> <span data-ttu-id="ebe9a-148">对于 HTTP 和 HTTPS 传输，默认编码为 Text/XML，对于其他传输，默认编码为二进制。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-148">The default is Text/XML for the HTTP and HTTPS transports, and Binary otherwise.</span></span>  
  
## <a name="creating-a-new-binding-element"></a><span data-ttu-id="ebe9a-149">创建新的绑定元素</span><span class="sxs-lookup"><span data-stu-id="ebe9a-149">Creating a new Binding Element</span></span>  
 <span data-ttu-id="ebe9a-150">除了类型派生自<xref:System.ServiceModel.Channels.BindingElement>所提供的 WCF，可以创建自己的绑定元素。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-150">In addition to the types derived from <xref:System.ServiceModel.Channels.BindingElement> that are provided by WCF, you can create your own binding elements.</span></span> <span data-ttu-id="ebe9a-151">这样，您就可以通过创建自己的、可与堆栈中其他的系统提供的类型组合的 <xref:System.ServiceModel.Channels.BindingElement>，自定义创建绑定堆栈的方式和进入其中的组件。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-151">This lets you customize the way the stack of bindings is created and the components that go in it by creating your own <xref:System.ServiceModel.Channels.BindingElement> that can be composed with the other system-provided types in the stack.</span></span>  
  
 <span data-ttu-id="ebe9a-152">例如，如果实现一个 `LoggingBindingElement` 以提供将消息记录到数据库中的能力，则必须将其放置在通道堆栈中传输通道的上方。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-152">For example, if you implement a `LoggingBindingElement` that provides the ability to log the message to a database, you must place it above a transport channel in the channel stack.</span></span> <span data-ttu-id="ebe9a-153">在此情况下，应用程序创建一个将 `LoggingBindingElement` 与 `TcpTransportBindingElement` 组合在一起的自定义绑定，如以下示例中所示。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-153">In this case, the application creates a custom binding that composed the `LoggingBindingElement` with `TcpTransportBindingElement`, as in the following example.</span></span>  
  
```csharp  
Binding customBinding = new CustomBinding(  
  new LoggingBindingElement(),   
  new TcpTransportBindingElement()  
);  
```  
  
 <span data-ttu-id="ebe9a-154">写入新的绑定元素的方式取决于元素的确切功能。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-154">How you write your new binding element depends on its exact functionality.</span></span> <span data-ttu-id="ebe9a-155">其中一个示例，[传输：UDP](../../../../docs/framework/wcf/samples/transport-udp.md)，提供了如何实现一种类型的绑定元素的详细的说明。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-155">One of the samples, [Transport: UDP](../../../../docs/framework/wcf/samples/transport-udp.md), provides a detailed description of how to implement one kind of binding element.</span></span>  
  
## <a name="creating-a-new-binding"></a><span data-ttu-id="ebe9a-156">创建新的绑定</span><span class="sxs-lookup"><span data-stu-id="ebe9a-156">Creating a New Binding</span></span>  
 <span data-ttu-id="ebe9a-157">可以通过两种方式使用用户创建的绑定元素。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-157">A user-created binding element can be used in two ways.</span></span> <span data-ttu-id="ebe9a-158">上一节演示了第一种方式：通过自定义绑定。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-158">The previous section illustrates the first way: through a custom binding.</span></span> <span data-ttu-id="ebe9a-159">自定义绑定允许用户基于任意一组绑定元素（包括用户创建的绑定元素）创建自己的绑定。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-159">A custom binding allows the user to create their own binding based on an arbitrary set of binding elements, including user-created ones.</span></span>  
  
 <span data-ttu-id="ebe9a-160">如果在多个应用程序中使用绑定，则可创建自己的绑定并扩展 <xref:System.ServiceModel.Channels.Binding>。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-160">If you use the binding in more than one application, create your own binding and extend the <xref:System.ServiceModel.Channels.Binding>.</span></span> <span data-ttu-id="ebe9a-161">这样就避免了在每次使用时都需要手动创建自定义绑定。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-161">This avoids manually creating a custom binding every time you want to use it.</span></span> <span data-ttu-id="ebe9a-162">用户定义的绑定允许你定义绑定的行为并包括用户定义的绑定元素。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-162">A user-defined binding allows you to define the binding’s behavior and include user-defined binding elements.</span></span> <span data-ttu-id="ebe9a-163">它是*预先打包*： 无需每次使用它重新绑定。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-163">And it is *pre-packaged*: you do not have to rebuild the binding every time you use it.</span></span>  
  
 <span data-ttu-id="ebe9a-164">用户定义的绑定至少必须实现 <xref:System.ServiceModel.Channels.Binding.CreateBindingElements%2A> 方法和 <xref:System.ServiceModel.Channels.Binding.Scheme%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-164">At a minimum, a user-defined binding must implement the <xref:System.ServiceModel.Channels.Binding.CreateBindingElements%2A> method and the <xref:System.ServiceModel.Channels.Binding.Scheme%2A> property.</span></span>  
  
 <span data-ttu-id="ebe9a-165"><xref:System.ServiceModel.Channels.Binding.CreateBindingElements%2A> 方法返回一个新的 <xref:System.ServiceModel.Channels.BindingElementCollection>，其中包含绑定的绑定元素。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-165">The <xref:System.ServiceModel.Channels.Binding.CreateBindingElements%2A> method returns a new <xref:System.ServiceModel.Channels.BindingElementCollection> that contains the binding elements for the binding.</span></span> <span data-ttu-id="ebe9a-166">此集合已经过排序，应首先包含协议绑定元素，接下来是编码绑定元素，再接下来是传输绑定元素。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-166">The collection is ordered, and should contain the protocol binding elements first, followed by the encoding binding element, followed by the transport binding element.</span></span> <span data-ttu-id="ebe9a-167">当使用 WCF 系统提供的绑定元素，您必须遵循排序规则中指定的绑定元素[自定义绑定](../../../../docs/framework/wcf/extending/custom-bindings.md)。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-167">When using the WCF system-provided binding elements, you must follow the binding element ordering rules specified in [Custom Bindings](../../../../docs/framework/wcf/extending/custom-bindings.md).</span></span> <span data-ttu-id="ebe9a-168">此集合不得引用在用户定义的绑定类中引用的对象；因此，绑定作者必须在每次调用 `Clone()` 时返回 <xref:System.ServiceModel.Channels.BindingElementCollection> 的 <xref:System.ServiceModel.Channels.Binding.CreateBindingElements%2A>。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-168">This collection should never reference objects referenced within the user-defined binding class; consequently, binding authors must return a `Clone()` of the <xref:System.ServiceModel.Channels.BindingElementCollection> on each call to <xref:System.ServiceModel.Channels.Binding.CreateBindingElements%2A>.</span></span>  
  
 <span data-ttu-id="ebe9a-169"><xref:System.ServiceModel.Channels.Binding.Scheme%2A> 属性表示在绑定上使用的传输协议的 URI 方案。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-169">The <xref:System.ServiceModel.Channels.Binding.Scheme%2A> property represents the URI scheme for the transport protocol in use on the binding.</span></span> <span data-ttu-id="ebe9a-170">例如， *WSHttpBinding*并*NetTcpBinding*返回其各自的"http"和"net.tcp"<xref:System.ServiceModel.Channels.Binding.Scheme%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-170">For example, the *WSHttpBinding* and the *NetTcpBinding* return "http" and "net.tcp" from their respective <xref:System.ServiceModel.Channels.Binding.Scheme%2A> properties.</span></span>  
  
 <span data-ttu-id="ebe9a-171">有关用户定义的绑定的可选方法和属性的完整列表，请参见 <xref:System.ServiceModel.Channels.Binding>。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-171">For a complete list of optional methods and properties for user-defined bindings, see <xref:System.ServiceModel.Channels.Binding>.</span></span>  
  
### <a name="example"></a><span data-ttu-id="ebe9a-172">示例</span><span class="sxs-lookup"><span data-stu-id="ebe9a-172">Example</span></span>  
 <span data-ttu-id="ebe9a-173">本示例在派生自 `SampleProfileUdpBinding` 的 <xref:System.ServiceModel.Channels.Binding> 中实现配置文件绑定。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-173">This example implements profile binding in `SampleProfileUdpBinding`, which derives from <xref:System.ServiceModel.Channels.Binding>.</span></span> <span data-ttu-id="ebe9a-174">`SampleProfileUdpBinding`包含最多四个绑定元素： 一个用户创建`UdpTransportBindingElement`; 和三个系统提供： `TextMessageEncodingBindingElement`， `CompositeDuplexBindingElement`，和`ReliableSessionBindingElement`。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-174">The `SampleProfileUdpBinding` contains up to four binding elements within it: one user-created `UdpTransportBindingElement`; and three system-provided: `TextMessageEncodingBindingElement`, `CompositeDuplexBindingElement`, and `ReliableSessionBindingElement`.</span></span>  
  
```csharp
public override BindingElementCollection CreateBindingElements()  
{     
    BindingElementCollection bindingElements = new BindingElementCollection();  
    if (ReliableSessionEnabled)  
    {  
        bindingElements.Add(session);  
        bindingElements.Add(compositeDuplex);  
    }  
    bindingElements.Add(encoding);  
    bindingElements.Add(transport);  
    return bindingElements.Clone();  
}  
```  
  
## <a name="security-restrictions-with-duplex-contracts"></a><span data-ttu-id="ebe9a-175">双工协定的安全限制</span><span class="sxs-lookup"><span data-stu-id="ebe9a-175">Security Restrictions with Duplex Contracts</span></span>  
 <span data-ttu-id="ebe9a-176">不是所有绑定元素都彼此兼容。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-176">Not all binding elements are compatible with each other.</span></span> <span data-ttu-id="ebe9a-177">具体而言，安全绑定元素在用于双工协定时存在一些限制。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-177">In particular, there are some restrictions on security binding elements when used with duplex contracts.</span></span>  
  
### <a name="one-shot-security"></a><span data-ttu-id="ebe9a-178">单步安全</span><span class="sxs-lookup"><span data-stu-id="ebe9a-178">One-Shot Security</span></span>  
 <span data-ttu-id="ebe9a-179">可以实现"单稳"安全性，其中所有必要的安全凭据会在单个消息中，通过设置`negotiateServiceCredential`的属性\<消息 > 配置元素`false`。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-179">You can implement "one-shot" security, where all the necessary security credentials are sent in a single message, by setting the `negotiateServiceCredential` attribute of the \<message> configuration element to `false`.</span></span>  
  
 <span data-ttu-id="ebe9a-180">单步身份验证无法与双工协定一起工作。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-180">One-shot authentication does not work with duplex contracts.</span></span>  
  
 <span data-ttu-id="ebe9a-181">对于请求-答复协定，只有在安全绑定元素下的绑定堆栈支持创建 <xref:System.ServiceModel.Channels.IRequestChannel> 或 <xref:System.ServiceModel.Channels.IRequestSessionChannel> 实例的情况下，单步身份验证才可以工作。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-181">For Request-Reply contracts, one-shot authentication works only if the binding stack below the security binding element supports creating <xref:System.ServiceModel.Channels.IRequestChannel> or <xref:System.ServiceModel.Channels.IRequestSessionChannel> instances.</span></span>  
  
 <span data-ttu-id="ebe9a-182">对于单向协定，如果安全绑定元素下的绑定堆栈支持创建 <xref:System.ServiceModel.Channels.IRequestChannel>、<xref:System.ServiceModel.Channels.IRequestSessionChannel>、<xref:System.ServiceModel.Channels.IOutputChannel> 或 <xref:System.ServiceModel.Channels.IOutputSessionChannel> 实例，则单步身份验证可以工作。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-182">For one-way contracts, one-shot authentication works if the binding stack below the security binding element supports creating <xref:System.ServiceModel.Channels.IRequestChannel>, <xref:System.ServiceModel.Channels.IRequestSessionChannel>, <xref:System.ServiceModel.Channels.IOutputChannel> or <xref:System.ServiceModel.Channels.IOutputSessionChannel> instances.</span></span>  
  
### <a name="cookie-mode-security-context-tokens"></a><span data-ttu-id="ebe9a-183">Cookie 模式安全上下文标记</span><span class="sxs-lookup"><span data-stu-id="ebe9a-183">Cookie-mode Security Context Tokens</span></span>  
 <span data-ttu-id="ebe9a-184">Cookie 模式安全上下文标记不能与双工协定一起使用。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-184">Cookie mode security context tokens cannot be used with duplex contracts.</span></span>  
  
 <span data-ttu-id="ebe9a-185">对于请求-答复协定，只有在安全绑定元素下的绑定堆栈支持创建 <xref:System.ServiceModel.Channels.IRequestChannel> 或 <xref:System.ServiceModel.Channels.IRequestSessionChannel> 实例的情况下，Cookie 模式安全上下文标记才可以工作。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-185">For Request-Reply contracts, cookie-mode security context tokens work only if the binding stack below the security binding element supports creating <xref:System.ServiceModel.Channels.IRequestChannel> or <xref:System.ServiceModel.Channels.IRequestSessionChannel> instances.</span></span>  
  
 <span data-ttu-id="ebe9a-186">对于单向协定，如果安全绑定元素下的绑定堆栈支持创建 <xref:System.ServiceModel.Channels.IRequestChannel> 或 <xref:System.ServiceModel.Channels.IRequestSessionChannel> 实例，则 Cookie 模式安全上下文标记可以工作。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-186">For one-way contracts, cookie-mode security context tokens works if the binding stack below the security binding element supports creating <xref:System.ServiceModel.Channels.IRequestChannel> or <xref:System.ServiceModel.Channels.IRequestSessionChannel> instances.</span></span>  
  
### <a name="session-mode-security-context-tokens"></a><span data-ttu-id="ebe9a-187">会话模式安全上下文标记</span><span class="sxs-lookup"><span data-stu-id="ebe9a-187">Session-mode Security Context Tokens</span></span>  
 <span data-ttu-id="ebe9a-188">如果安全绑定元素下的绑定堆栈支持创建 <xref:System.ServiceModel.Channels.IDuplexChannel> 或 <xref:System.ServiceModel.Channels.IDuplexSessionChannel> 实例，则会话模式 SCT 适用于双工协定。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-188">Session mode SCT works for duplex contracts if the binding stack below the security binding element supports creating <xref:System.ServiceModel.Channels.IDuplexChannel> or <xref:System.ServiceModel.Channels.IDuplexSessionChannel> instances.</span></span>  
  
 <span data-ttu-id="ebe9a-189">如果安全绑定元素下的绑定堆栈支持创建 <xref:System.ServiceModel.Channels.IDuplexChannel>、<xref:System.ServiceModel.Channels.IDuplexSessionChannel>、<xref:System.ServiceModel.Channels.IRequestChannel> 或 <xref:System.ServiceModel.Channels.IRequestSessionChannel> 实例，则会话模式 SCT 适用于请求-答复协定。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-189">Session mode SCT works for Request-Reply contracts if the binding stack below the security binding element supports creating <xref:System.ServiceModel.Channels.IDuplexChannel>, <xref:System.ServiceModel.Channels.IDuplexSessionChannel>, <xref:System.ServiceModel.Channels.IRequestChannel> or <xref:System.ServiceModel.Channels.IRequestSessionChannel>, instances.</span></span>  
  
 <span data-ttu-id="ebe9a-190">如果安全绑定元素下的绑定堆栈支持创建 <xref:System.ServiceModel.Channels.IDuplexChannel>、<xref:System.ServiceModel.Channels.IDuplexSessionChannel>、<xref:System.ServiceModel.Channels.IRequestChannel> 或 <xref:System.ServiceModel.Channels.IRequestSessionChannel> 实例，则会话模式 SCT 适用于单向协定。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-190">Session mode SCT works for 1-way contracts if the binding stack below the security binding element supports creating <xref:System.ServiceModel.Channels.IDuplexChannel>, <xref:System.ServiceModel.Channels.IDuplexSessionChannel>, <xref:System.ServiceModel.Channels.IRequestChannel> or <xref:System.ServiceModel.Channels.IRequestSessionChannel> instances.</span></span>  
  
## <a name="deriving-from-a-standard-binding"></a><span data-ttu-id="ebe9a-191">派生自标准绑定</span><span class="sxs-lookup"><span data-stu-id="ebe9a-191">Deriving from a Standard Binding</span></span>  
 <span data-ttu-id="ebe9a-192">也许可以扩展一个现有的系统提供的绑定，而不用创建一个全新的绑定类。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-192">Instead of creating an entirely new binding class, it may be possible for you to extend one of the existing system-provided bindings.</span></span> <span data-ttu-id="ebe9a-193">与上一个示例非常类似，必须重写 <xref:System.ServiceModel.Channels.Binding.CreateBindingElements%2A> 方法和 <xref:System.ServiceModel.Channels.Binding.Scheme%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="ebe9a-193">Much like the preceding case, you must override the <xref:System.ServiceModel.Channels.Binding.CreateBindingElements%2A> method and the <xref:System.ServiceModel.Channels.Binding.Scheme%2A> property.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ebe9a-194">请参阅</span><span class="sxs-lookup"><span data-stu-id="ebe9a-194">See also</span></span>

- <xref:System.ServiceModel.Channels.Binding>
- [<span data-ttu-id="ebe9a-195">自定义绑定</span><span class="sxs-lookup"><span data-stu-id="ebe9a-195">Custom Bindings</span></span>](../../../../docs/framework/wcf/extending/custom-bindings.md)
