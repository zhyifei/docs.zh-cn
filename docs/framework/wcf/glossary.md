---
title: "针对 .NET Framework 4.5 的 Windows Communication Foundation 词汇表"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- Windows Communication Foundation [WCF], glossary
- WCF [WCF], glossary
ms.assetid: 39cd36f4-8a28-4d0b-a830-98d55c9d30ae
caps.latest.revision: "243"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: 76cc8f456701d65b675ce7b89436da5213ea9430
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/22/2017
---
# <a name="windows-communication-foundation-glossary-for-net-framework-45"></a><span data-ttu-id="0f423-102">针对 .NET Framework 4.5 的 Windows Communication Foundation 词汇表</span><span class="sxs-lookup"><span data-stu-id="0f423-102">Windows Communication Foundation Glossary for .NET Framework 4.5</span></span>
<span data-ttu-id="0f423-103">针对 Windows Communication Foundation 文档定义了以下术语。</span><span class="sxs-lookup"><span data-stu-id="0f423-103">The following terms are defined for Windows Communication Foundation documentation.</span></span>  
  
## <a name="terms"></a><span data-ttu-id="0f423-104">术语</span><span class="sxs-lookup"><span data-stu-id="0f423-104">Terms</span></span>  
  
|<span data-ttu-id="0f423-105">术语</span><span class="sxs-lookup"><span data-stu-id="0f423-105">Term</span></span>|<span data-ttu-id="0f423-106">定义</span><span class="sxs-lookup"><span data-stu-id="0f423-106">Definition</span></span>|  
|----------|----------------|  
|<span data-ttu-id="0f423-107">address</span><span class="sxs-lookup"><span data-stu-id="0f423-107">address</span></span>|<span data-ttu-id="0f423-108">地址用于指定接收消息的位置。</span><span class="sxs-lookup"><span data-stu-id="0f423-108">Specifies the location where messages are received.</span></span> <span data-ttu-id="0f423-109">地址以统一资源标识符 (URI) 的形式指定。</span><span class="sxs-lookup"><span data-stu-id="0f423-109">It is specified as a Uniform Resource Identifier (URI).</span></span> <span data-ttu-id="0f423-110">URI 架构部分指定用于到达地址的传输机制，如 HTTP 和 TCP。</span><span class="sxs-lookup"><span data-stu-id="0f423-110">The URI schema part names the transport mechanism to use to reach the address, such as HTTP and TCP.</span></span> <span data-ttu-id="0f423-111">URI 的层次结构部分包含一个唯一的位置，其格式取决于传输机制。</span><span class="sxs-lookup"><span data-stu-id="0f423-111">The hierarchical part of the URI contains a unique location whose format is dependent on the transport mechanism.</span></span>|  
|<span data-ttu-id="0f423-112">application endpoint（应用程序终结点）</span><span class="sxs-lookup"><span data-stu-id="0f423-112">application endpoint</span></span>|<span data-ttu-id="0f423-113">一个终结点，由应用程序公开并对应于该应用程序实现的服务协定。</span><span class="sxs-lookup"><span data-stu-id="0f423-113">An endpoint exposed by the application and that corresponds to a service contract implemented by the application.</span></span>|  
|<span data-ttu-id="0f423-114">行为</span><span class="sxs-lookup"><span data-stu-id="0f423-114">behavior</span></span>|<span data-ttu-id="0f423-115">行为是控制服务、终结点、特定操作或客户端的各种运行时特性的要素。</span><span class="sxs-lookup"><span data-stu-id="0f423-115">A behavior is a component that controls various run-time aspects of a service, an endpoint, a particular operation, or a client.</span></span> <span data-ttu-id="0f423-116">行为按照范围进行分组：常见行为在全局范围内影响所有终结点，服务行为仅影响与服务相关的方面，终结点行为仅影响与终结点相关的属性，操作级行为影响特定操作。</span><span class="sxs-lookup"><span data-stu-id="0f423-116">Behaviors are grouped according to scope: common behaviors affect all endpoints globally, service behaviors affect only service-related aspects, endpoint behaviors affect only endpoint-related properties, and operation-level behaviors affect particular operations.</span></span>|  
|<span data-ttu-id="0f423-117">绑定</span><span class="sxs-lookup"><span data-stu-id="0f423-117">binding</span></span>|<span data-ttu-id="0f423-118">定义用于与 WCF 服务进行通信的通信协议。</span><span class="sxs-lookup"><span data-stu-id="0f423-118">Defines which communication protocols are used to communicate with WCF services.</span></span> <span data-ttu-id="0f423-119">它由一组称为绑定元素的要素构造而成，这些元素一个个地叠起来形成通信基础结构。</span><span class="sxs-lookup"><span data-stu-id="0f423-119">It is constructed of a set of components called binding elements that stack one on top of the other to create the communication infrastructure.</span></span>  <span data-ttu-id="0f423-120">请参见“终结点”。</span><span class="sxs-lookup"><span data-stu-id="0f423-120">See endpoint.</span></span>|  
|<span data-ttu-id="0f423-121">channel（通道）</span><span class="sxs-lookup"><span data-stu-id="0f423-121">channel</span></span>|<span data-ttu-id="0f423-122">通道是绑定元素的具体实现。</span><span class="sxs-lookup"><span data-stu-id="0f423-122">A concrete implementation of a binding element.</span></span> <span data-ttu-id="0f423-123">绑定表示配置，而通道是与该配置相关联的实现。</span><span class="sxs-lookup"><span data-stu-id="0f423-123">The binding represents the configuration, and the channel is the implementation associated with that configuration.</span></span> <span data-ttu-id="0f423-124">因此，每个绑定元素都有一个相关联的通道。</span><span class="sxs-lookup"><span data-stu-id="0f423-124">Therefore, there is a channel associated with each binding element.</span></span> <span data-ttu-id="0f423-125">通道堆叠在一起以形成绑定的具体实现：通道堆栈。</span><span class="sxs-lookup"><span data-stu-id="0f423-125">Channels stack on top of each other to create the concrete implementation of the binding: the channel stack.</span></span>|  
|<span data-ttu-id="0f423-126">claims-based security（基于声明的安全性）</span><span class="sxs-lookup"><span data-stu-id="0f423-126">claims-based security</span></span>|<span data-ttu-id="0f423-127">允许基于声明对受保护资源进行授权访问。</span><span class="sxs-lookup"><span data-stu-id="0f423-127">Allows authorized access to protected resources based on claims.</span></span>|  
|<span data-ttu-id="0f423-128">client application（客户端应用程序）</span><span class="sxs-lookup"><span data-stu-id="0f423-128">client application</span></span>|<span data-ttu-id="0f423-129">客户端应用程序是与一个或多个终结点交换消息的程序。</span><span class="sxs-lookup"><span data-stu-id="0f423-129">A client application is a program that exchanges messages with one or more endpoints.</span></span> <span data-ttu-id="0f423-130">客户端应用程序可通过创建 WCF 客户端的实例和调用该 WCF 客户端的方法来启动。</span><span class="sxs-lookup"><span data-stu-id="0f423-130">The client application begins by creating an instance of a WCF client and calling methods of the WCF client.</span></span> <span data-ttu-id="0f423-131">需要注意的是，单个应用程序既可以充当客户端，也可以充当服务。</span><span class="sxs-lookup"><span data-stu-id="0f423-131">It is important to note that a single application can be both a client and a service.</span></span>|  
|<span data-ttu-id="0f423-132">编码</span><span class="sxs-lookup"><span data-stu-id="0f423-132">coding</span></span>|<span data-ttu-id="0f423-133">通过代码编写，开发人员可以对服务或客户端的所有组件进行严格控制，他们不仅能够对通过配置完成的所有设置进行检查，还能够根据需要利用代码将其重写。</span><span class="sxs-lookup"><span data-stu-id="0f423-133">Allows the developer to retain strict control over all components of the service or client, and any settings done through the configuration can be inspected and if needed overridden by the code.</span></span> <span data-ttu-id="0f423-134">可以通过代码编写、配置或将两者结合在一起对应用程序进行控制。</span><span class="sxs-lookup"><span data-stu-id="0f423-134">Control of an application can be done either through coding, through configuration, or through a combination of both.</span></span>|  
|<span data-ttu-id="0f423-135">配置</span><span class="sxs-lookup"><span data-stu-id="0f423-135">configuration</span></span>|<span data-ttu-id="0f423-136">配置的优点在于，它使非开发人员（如网络管理员）可以在代码编写完成后直接对客户端和服务参数进行设置，而不必重新进行编译。</span><span class="sxs-lookup"><span data-stu-id="0f423-136">Configuration has the advantage of allowing someone other than the developer (for example, a network administrator) to set client and service parameters after the code is written and without having to recompile.</span></span> <span data-ttu-id="0f423-137">使用配置不仅可以设置值（如终结点地址），还可以通过添加终结点、绑定和行为来实施进一步的控制。</span><span class="sxs-lookup"><span data-stu-id="0f423-137">Configuration not only enables you to set values like endpoint addresses, but also allows further control by enabling you to add endpoints, bindings, and behaviors.</span></span> <span data-ttu-id="0f423-138">可以通过配置、代码编写或将两者结合在一起对应用程序进行控制。</span><span class="sxs-lookup"><span data-stu-id="0f423-138">Control of an application can be done either through configuration, through coding, or through a combination of both.</span></span>|  
|<span data-ttu-id="0f423-139">Contract — 协定</span><span class="sxs-lookup"><span data-stu-id="0f423-139">contract</span></span>|<span data-ttu-id="0f423-140">协定是对其所属的特定协定类型的支持规范。</span><span class="sxs-lookup"><span data-stu-id="0f423-140">A contract is a specification of support for the particular type of contract that it is.</span></span> <span data-ttu-id="0f423-141">例如，服务协定是一组操作的规范。</span><span class="sxs-lookup"><span data-stu-id="0f423-141">A service contract, for example, is a specification for a group of operations.</span></span> <span data-ttu-id="0f423-142">在 WCF 中，协定具有一个层次结构，此结构在 System.ServiceModel.Description 命名空间的说明对象中进行了镜像。</span><span class="sxs-lookup"><span data-stu-id="0f423-142">In WCF, contracts have a hierarchy that is mirrored in the description objects located in the System.ServiceModel.Description namespace.</span></span> <span data-ttu-id="0f423-143">服务协定是 WCF 中最大的协定范围。</span><span class="sxs-lookup"><span data-stu-id="0f423-143">A service contract is the largest contract scope in WCF.</span></span> <span data-ttu-id="0f423-144">服务协定中的每个服务操作都具有一个操作协定，用于指定该操作可以交换的消息（包括错误消息）以及交换的方向。</span><span class="sxs-lookup"><span data-stu-id="0f423-144">Each service operation in a service contract has an operation contract, which specifies the messages -- including fault messages -- the operation can exchange, and in which direction.</span></span> <span data-ttu-id="0f423-145">操作中的每条消息都具有一个消息协定（即 SOAP 消息信封的结构规范），而每个消息协定又都具有一个数据协定，用于指定消息中包含的数据结构。</span><span class="sxs-lookup"><span data-stu-id="0f423-145">Each message in an operation has a message contract, a specification for the structure of the SOAP message envelope, and each message contract has a data contract, which specifies the data structures contained in the messages.</span></span>|  
|<span data-ttu-id="0f423-146">数据协定</span><span class="sxs-lookup"><span data-stu-id="0f423-146">data contract</span></span>|<span data-ttu-id="0f423-147">服务使用的数据类型必须在元数据中进行描述，以使其他各方可以与该服务进行交互操作。</span><span class="sxs-lookup"><span data-stu-id="0f423-147">The data types a service uses must be described in metadata to enable others to interoperate with the service.</span></span> <span data-ttu-id="0f423-148">数据类型的说明称为数据协定，而这些类型可以在消息的任何部分使用（例如，作为参数或返回类型）。</span><span class="sxs-lookup"><span data-stu-id="0f423-148">The descriptions of the data types are known as the data contract, and the types can be used in any part of a message, for example, as parameters or return types.</span></span> <span data-ttu-id="0f423-149">如果服务仅使用简单类型，则无需显式使用数据协定。</span><span class="sxs-lookup"><span data-stu-id="0f423-149">If the service is using only simple types, there is no need to explicitly use data contracts.</span></span>|  
|<span data-ttu-id="0f423-150">declarative application（声明性应用程序）</span><span class="sxs-lookup"><span data-stu-id="0f423-150">declarative application</span></span>|<span data-ttu-id="0f423-151">具有充分的描述以便无需运行命令性指令即可在运行时创建的应用程序。</span><span class="sxs-lookup"><span data-stu-id="0f423-151">An application that is described sufficiently to be created at runtime without running imperative instructions.</span></span>|  
|<span data-ttu-id="0f423-152">endpoint（终结点）</span><span class="sxs-lookup"><span data-stu-id="0f423-152">endpoint</span></span>|<span data-ttu-id="0f423-153">包含一个地址、一个绑定和一个用于与 WCF 服务进行通信的协定。</span><span class="sxs-lookup"><span data-stu-id="0f423-153">Consists of an address, a binding, and a contract used for communicating with a WCF service.</span></span>|  
|<span data-ttu-id="0f423-154">endpoint address（终结点地址）</span><span class="sxs-lookup"><span data-stu-id="0f423-154">endpoint address</span></span>|<span data-ttu-id="0f423-155">您可以为服务中的每个终结点均创建一个具有唯一性的终结点地址，还可以在一定的条件下跨多个终结点共享一个地址。</span><span class="sxs-lookup"><span data-stu-id="0f423-155">Enables you to create unique endpoint addresses for each endpoint in a service, or under certain conditions share an address across endpoints.</span></span>|  
|<span data-ttu-id="0f423-156">fault contract（错误协定）</span><span class="sxs-lookup"><span data-stu-id="0f423-156">fault contract</span></span>|<span data-ttu-id="0f423-157">可以将错误协定与服务操作进行关联，以指示可能返回到调用方的错误。</span><span class="sxs-lookup"><span data-stu-id="0f423-157">A fault contract can be associated with a service operation to denote errors that can be returned to the caller.</span></span> <span data-ttu-id="0f423-158">一个操作可以具有零个或更多个与其相关联的错误。</span><span class="sxs-lookup"><span data-stu-id="0f423-158">An operation can have zero or more faults associated with it.</span></span> <span data-ttu-id="0f423-159">这些错误是在编程模型中作为异常建模的 SOAP 错误。</span><span class="sxs-lookup"><span data-stu-id="0f423-159">These errors are SOAP faults that are modeled as exceptions in the programming model.</span></span> <span data-ttu-id="0f423-160">这些异常将转换为 SOAP 错误，然后可以发送到客户端。</span><span class="sxs-lookup"><span data-stu-id="0f423-160">The exception is converted into a SOAP fault that can then be sent to the client.</span></span>|  
|<span data-ttu-id="0f423-161">Hosting — 承载</span><span class="sxs-lookup"><span data-stu-id="0f423-161">hosting</span></span>|<span data-ttu-id="0f423-162">服务必须承载于某个进程中。</span><span class="sxs-lookup"><span data-stu-id="0f423-162">A service must be hosted in some process.</span></span> <span data-ttu-id="0f423-163">宿主是控制服务的生存期的应用程序。</span><span class="sxs-lookup"><span data-stu-id="0f423-163">A host is an application that controls the lifetime of the service.</span></span> <span data-ttu-id="0f423-164">服务可以是自承载的，也可以由现有的宿主进程进行管理。</span><span class="sxs-lookup"><span data-stu-id="0f423-164">Services can be self-hosted or managed by an existing hosting process.</span></span>|  
|<span data-ttu-id="0f423-165">承载进程</span><span class="sxs-lookup"><span data-stu-id="0f423-165">hosting process</span></span>|<span data-ttu-id="0f423-166">宿主进程是专为承载服务而设计的应用程序。</span><span class="sxs-lookup"><span data-stu-id="0f423-166">A hosting process is an application that is designed to host services.</span></span> <span data-ttu-id="0f423-167">这些宿主进程包括 Internet 信息服务 (IIS)、Windows 激活服务 (WAS) 和 Windows 服务。</span><span class="sxs-lookup"><span data-stu-id="0f423-167">These include Internet Information Services (IIS), Windows Activation Services (WAS), and Windows Services.</span></span> <span data-ttu-id="0f423-168">在这些宿主方案中，由宿主控制服务的生存期。</span><span class="sxs-lookup"><span data-stu-id="0f423-168">In these hosted scenarios, the host controls the lifetime of the service.</span></span> <span data-ttu-id="0f423-169">例如，使用 IIS 可以设置包含服务程序集和配置文件的虚拟目录。</span><span class="sxs-lookup"><span data-stu-id="0f423-169">For example, using IIS you can set up a virtual directory that contains the service assembly and configuration file.</span></span> <span data-ttu-id="0f423-170">在收到消息时，IIS 将启动服务并控制服务的生存期。</span><span class="sxs-lookup"><span data-stu-id="0f423-170">When a message is received, IIS starts the service and controls its lifetime.</span></span>|  
|<span data-ttu-id="0f423-171">initiating operation（启动操作）</span><span class="sxs-lookup"><span data-stu-id="0f423-171">initiating operation</span></span>|<span data-ttu-id="0f423-172">作为新会话的第一个操作而调用的操作。</span><span class="sxs-lookup"><span data-stu-id="0f423-172">An operation that is called as the first operation of a new session.</span></span> <span data-ttu-id="0f423-173">只有在已调用至少一个启动操作之后才可以调用非启动操作。</span><span class="sxs-lookup"><span data-stu-id="0f423-173">Non-initiating operations can be called only after at least one initiating operation has been called.</span></span>|  
|<span data-ttu-id="0f423-174">instancing model（实例化模型）</span><span class="sxs-lookup"><span data-stu-id="0f423-174">instancing model</span></span>|<span data-ttu-id="0f423-175">每个服务都具有一个实例化模型。</span><span class="sxs-lookup"><span data-stu-id="0f423-175">A service has an instancing model.</span></span> <span data-ttu-id="0f423-176">有三种实例化模式：&quot;单个，&quot;客户端提供; 服务在其中单个 CLR 对象&quot;每次调用，&quot;在其中一个新的 CLR 对象创建用于处理每个客户端调用; 和&quot;每个会话，&quot;中的一组 CLR 对象创建的一个用于每个单独的会话。</span><span class="sxs-lookup"><span data-stu-id="0f423-176">There are three instancing models: &quot;single,&quot; in which a single CLR object services all the clients; &quot;per call,&quot; in which a new CLR object is created to handle each client call; and &quot;per session,&quot; in which a set of CLR objects are created, one for each separate session.</span></span> <span data-ttu-id="0f423-177">实例化模型的选择取决于应用程序需求和服务的预期使用模式。</span><span class="sxs-lookup"><span data-stu-id="0f423-177">The choice of an instancing model depends on the application requirements and the expected usage pattern of the service.</span></span>|  
|<span data-ttu-id="0f423-178">消息</span><span class="sxs-lookup"><span data-stu-id="0f423-178">message</span></span>|<span data-ttu-id="0f423-179">消息是一个独立的数据单元，它可能由几个部分组成，包括消息正文和消息头。</span><span class="sxs-lookup"><span data-stu-id="0f423-179">A message is a self-contained unit of data that may consist of several parts, including a body and headers.</span></span>|  
|<span data-ttu-id="0f423-180">消息协定</span><span class="sxs-lookup"><span data-stu-id="0f423-180">message contract</span></span>|<span data-ttu-id="0f423-181">消息协定描述消息的格式。</span><span class="sxs-lookup"><span data-stu-id="0f423-181">A message contract describes the format of a message.</span></span> <span data-ttu-id="0f423-182">例如，它会声明消息元素应包含在消息头中还是包含在消息正文中，应该对消息的何种元素应用何种级别的安全性，等等。</span><span class="sxs-lookup"><span data-stu-id="0f423-182">For example, it declares whether message elements should go in headers versus the body, what level of security should be applied to what elements of the message, and so on.</span></span>|  
|<span data-ttu-id="0f423-183">消息安全模式</span><span class="sxs-lookup"><span data-stu-id="0f423-183">message security mode</span></span>|<span data-ttu-id="0f423-184">消息安全模式指定通过实现一种或多种安全规范来保证安全。</span><span class="sxs-lookup"><span data-stu-id="0f423-184">Message security mode specifies that security is provided by implementing one or more of the security specifications.</span></span> <span data-ttu-id="0f423-185">每个消息都包含必要的安全机制，用于在消息传输过程中保证安全，并使接收方能够检测到篡改和对消息进行解密。</span><span class="sxs-lookup"><span data-stu-id="0f423-185">Each message contains the necessary mechanisms to provide security during its transit, and to enable the receivers to detect tampering and to decrypt the messages.</span></span> <span data-ttu-id="0f423-186">从这种意义上说，安全信息包装在每个消息中，从而提供了跨多个跃点的端到端安全。</span><span class="sxs-lookup"><span data-stu-id="0f423-186">In this sense, the security is encapsulated within every message, providing end-to-end security across multiple hops.</span></span> <span data-ttu-id="0f423-187">由于安全信息成为消息的一部分，因此还可以在消息中包含多种凭据（这些凭据称为“声明”）。</span><span class="sxs-lookup"><span data-stu-id="0f423-187">Because security information becomes part of the message, it is also possible to include multiple kinds of credentials with the message (these are referred to as claims).</span></span> <span data-ttu-id="0f423-188">这种方法还具有这样一个优点，即消息可以通过任意传输协议（包括在其起点和目标之间的多个传输协议）安全地传送。</span><span class="sxs-lookup"><span data-stu-id="0f423-188">This approach also has the advantage of enabling the message to travel securely over any transport, including multiple transports between its origin and destination.</span></span> <span data-ttu-id="0f423-189">这种方法的缺点在于所使用的加密机制较为复杂，使性能受到影响。</span><span class="sxs-lookup"><span data-stu-id="0f423-189">The disadvantage of this approach is the complexity of the cryptographic mechanisms employed, resulting in performance implications.</span></span>|  
|<span data-ttu-id="0f423-190">元数据</span><span class="sxs-lookup"><span data-stu-id="0f423-190">metadata</span></span>|<span data-ttu-id="0f423-191">服务的元数据描述服务的各种特征，外部实体需要了解这些特征以便与该服务进行通信。</span><span class="sxs-lookup"><span data-stu-id="0f423-191">The metadata of a service describes the characteristics of the service that an external entity needs to understand to communicate with the service.</span></span> <span data-ttu-id="0f423-192">ServiceModel 元数据实用工具 (Svcutil.exe) 可以使用元数据生成 WCF 客户端以及客户端应用程序用来与服务进行交互的伴随配置。</span><span class="sxs-lookup"><span data-stu-id="0f423-192">Metadata can be consumed by the ServiceModel Metadata Utility Tool (Svcutil.exe) to generate a WCF client and accompanying configuration that a client application can use to interact with the service.</span></span>  <span data-ttu-id="0f423-193">服务所公开的元数据包括 XML 架构文档（用于定义服务的数据协定）和 WSDL 文档（用于描述服务的方法）。</span><span class="sxs-lookup"><span data-stu-id="0f423-193">The metadata exposed by the service includes XML schema documents, which define the data contract of the service, and WSDL documents, which describe the methods of the service.</span></span>  <span data-ttu-id="0f423-194">启用元数据后，WCF 可通过检查服务及其终结点来自动生成服务的元数据。</span><span class="sxs-lookup"><span data-stu-id="0f423-194">When enabled, metadata for the service is automatically generated by WCF by inspecting the service and its endpoints.</span></span> <span data-ttu-id="0f423-195">若要发布服务的元数据，必须显式启用元数据行为。</span><span class="sxs-lookup"><span data-stu-id="0f423-195">To publish metadata from a service, you must explicitly enable the metadata behavior.</span></span>|  
|<span data-ttu-id="0f423-196">操作协定</span><span class="sxs-lookup"><span data-stu-id="0f423-196">operation contract</span></span>|<span data-ttu-id="0f423-197">操作协定定义参数并返回操作的类型。</span><span class="sxs-lookup"><span data-stu-id="0f423-197">An operation contract defines the parameters and return type of an operation.</span></span> <span data-ttu-id="0f423-198">在创建定义服务协定的接口时，可以通过将 T:System.ServiceModel.OperationContractAttribute 属性应用于协定中包含的每个方法定义来表示一个操作协定。</span><span class="sxs-lookup"><span data-stu-id="0f423-198">When creating an interface that defines the service contract, you signify an operation contract by applying the T:System.ServiceModel.OperationContractAttribute attribute to each method definition that is part of the contract.</span></span> <span data-ttu-id="0f423-199">可以将操作建模为采用单个消息作为参数并返回单个消息，或者建模为采用一组类型作为参数并返回一个类型。</span><span class="sxs-lookup"><span data-stu-id="0f423-199">The operations can be modeled as taking a single message and returning a single message, or as taking a set of types and returning a type.</span></span> <span data-ttu-id="0f423-200">在后一种情况下，将由系统来确定需要为该操作交换的消息的格式。</span><span class="sxs-lookup"><span data-stu-id="0f423-200">In the latter case, the system determines the format for the messages that are exchanged for that operation.</span></span>|  
|<span data-ttu-id="0f423-201">Projection — 投影</span><span class="sxs-lookup"><span data-stu-id="0f423-201">projection</span></span>|<span data-ttu-id="0f423-202">网络上的数据的表示形式。</span><span class="sxs-lookup"><span data-stu-id="0f423-202">The representation of data on the wire.</span></span> <span data-ttu-id="0f423-203">例如，SOAP 投影会作为 SOAP 信封发送消息；Web 投影会以 JSON 格式发送消息。</span><span class="sxs-lookup"><span data-stu-id="0f423-203">For example, a SOAP projection sends messages as SOAP envelopes and a Web projection sends messages in JSON format.</span></span>|  
|<span data-ttu-id="0f423-204">安全性</span><span class="sxs-lookup"><span data-stu-id="0f423-204">security</span></span>|<span data-ttu-id="0f423-205">WCF 中的安全性包括保密性（为防止窃听而进行的消息加密）、完整性（用于检测消息篡改行为的方法）、身份验证（用于验证服务器和客户端的方法）以及授权（资源访问控制）。</span><span class="sxs-lookup"><span data-stu-id="0f423-205">Security in WCF includes confidentiality (encryption of messages to prevent eavesdropping), integrity (the means for detection of tampering with the message), authentication (the means for validation of servers and clients), and authorization (the control of access to resources).</span></span> <span data-ttu-id="0f423-206">通过利用现有安全机制（如 TLS over HTTP，也称为 HTTPS）或通过实现各种 WS-* 安全规范中的一个或多个规范，可以提供这些功能。</span><span class="sxs-lookup"><span data-stu-id="0f423-206">These functions are provided by either leveraging existing security mechanisms, such as TLS over HTTP (also known as HTTPS), or by implementing one or more of the various WS-* security specifications.</span></span>|  
|<span data-ttu-id="0f423-207">自我承载的服务</span><span class="sxs-lookup"><span data-stu-id="0f423-207">self-hosted service</span></span>|<span data-ttu-id="0f423-208">自承载服务是在开发人员创建的进程应用程序中运行的服务。</span><span class="sxs-lookup"><span data-stu-id="0f423-208">A self-hosted service is one that runs within a process application that the developer created.</span></span> <span data-ttu-id="0f423-209">开发人员控制服务的生存期、设置服务的属性、打开服务（这会将服务设置为侦听模式）以及关闭服务。</span><span class="sxs-lookup"><span data-stu-id="0f423-209">The developer controls its lifetime, sets the properties of the service, opens the service (which sets it into a listening mode), and closes the service.</span></span>|  
|<span data-ttu-id="0f423-210">service</span><span class="sxs-lookup"><span data-stu-id="0f423-210">service</span></span>|<span data-ttu-id="0f423-211">公开一个或多个终结点的程序或进程，其中每个终结点都会公开一个或多个操作。</span><span class="sxs-lookup"><span data-stu-id="0f423-211">A program or process that exposes one or more endpoints, with each endpoint exposing one or more operations.</span></span>|  
|<span data-ttu-id="0f423-212">service contract（服务协定）</span><span class="sxs-lookup"><span data-stu-id="0f423-212">service contract</span></span>|<span data-ttu-id="0f423-213">服务协定将多个相关的操作联系在一起，组成单个功能单元。</span><span class="sxs-lookup"><span data-stu-id="0f423-213">The service contract ties together multiple related operations into a single functional unit.</span></span> <span data-ttu-id="0f423-214">协定可以定义服务级设置，如服务的命名空间、对应的回调协定以及其他此类设置。</span><span class="sxs-lookup"><span data-stu-id="0f423-214">The contract can define service-level settings, such as the namespace of the service, a corresponding callback contract, and other such settings.</span></span> <span data-ttu-id="0f423-215">在大多数情况下，协定的定义方法是用所选的编程语言创建一个接口，然后将 T:System.ServiceModel.ServiceContractAttribute 属性应用于该接口。</span><span class="sxs-lookup"><span data-stu-id="0f423-215">In most cases, the contract is defined by creating an interface in the programming language of your choice and applying the T:System.ServiceModel.ServiceContractAttribute attribute to the interface.</span></span> <span data-ttu-id="0f423-216">通过实现该接口，可生成实际的服务代码。</span><span class="sxs-lookup"><span data-stu-id="0f423-216">The actual service code results by implementing the interface.</span></span>|  
|<span data-ttu-id="0f423-217">服务操作</span><span class="sxs-lookup"><span data-stu-id="0f423-217">service operation</span></span>|<span data-ttu-id="0f423-218">服务操作是在服务的代码中定义的过程，用于实现某种操作的功能。</span><span class="sxs-lookup"><span data-stu-id="0f423-218">A service operation is a procedure defined in a service's code that implements the functionality for an operation.</span></span> <span data-ttu-id="0f423-219">此操作作为 WCF 客户端上的方法向客户端公开。</span><span class="sxs-lookup"><span data-stu-id="0f423-219">This operation is exposed to clients as methods on a WCF client.</span></span> <span data-ttu-id="0f423-220">该方法可能返回一个值，并可能采用数量可选的自变量，或是不采用任何自变量且不返回任何响应。</span><span class="sxs-lookup"><span data-stu-id="0f423-220">The method may return a value, and may take an optional number of arguments, or take no arguments, and return no response.</span></span> <span data-ttu-id="0f423-221">例如，充当操作&quot;Hello&quot;可以用作通知客户端的状态并可以开始一系列操作。</span><span class="sxs-lookup"><span data-stu-id="0f423-221">For example, an operation that functions as a &quot;Hello&quot; can be used as a notification of a client's presence and to begin a series of operations.</span></span>|  
|<span data-ttu-id="0f423-222">系统提供的绑定</span><span class="sxs-lookup"><span data-stu-id="0f423-222">system-provided bindings</span></span>|<span data-ttu-id="0f423-223">WCF 包含许多系统提供的绑定。</span><span class="sxs-lookup"><span data-stu-id="0f423-223">WCF includes a number of system-provided bindings.</span></span> <span data-ttu-id="0f423-224">这些绑定是针对特定方案进行优化的绑定元素的集合。</span><span class="sxs-lookup"><span data-stu-id="0f423-224">These are collections of binding elements that are optimized for specific scenarios.</span></span> <span data-ttu-id="0f423-225">例如，T:System.ServiceModel.WSHttpBinding 是为了与实现各种 WS* 规范的服务进行互操作而专门设计的。</span><span class="sxs-lookup"><span data-stu-id="0f423-225">For example, the T:System.ServiceModel.WSHttpBinding is designed for interoperability with services that implement various WS-* specifications.</span></span> <span data-ttu-id="0f423-226">通过仅提供那些可以正确应用于特定方案的选项，这些绑定可以节省时间。</span><span class="sxs-lookup"><span data-stu-id="0f423-226">These bindings save time by presenting only those options that can be correctly applied to the specific scenario.</span></span> <span data-ttu-id="0f423-227">如果其中的某个绑定不能满足您的要求，也可以创建您自己的自定义绑定。</span><span class="sxs-lookup"><span data-stu-id="0f423-227">If one of these bindings does not meet your requirements, you can create your own custom binding.</span></span>|  
|<span data-ttu-id="0f423-228">terminating operation（终止操作）</span><span class="sxs-lookup"><span data-stu-id="0f423-228">terminating operation</span></span>|<span data-ttu-id="0f423-229">作为现有会话的最后一个消息而调用的操作。</span><span class="sxs-lookup"><span data-stu-id="0f423-229">An operation that is called as the last message in an existing session.</span></span> <span data-ttu-id="0f423-230">默认情况下，在关闭与服务相关联的会话之后，WCF 会回收服务对象及其上下文。</span><span class="sxs-lookup"><span data-stu-id="0f423-230">In the default case, WCF recycles the service object and its context after the session with which the service was associated is closed.</span></span>|  
|<span data-ttu-id="0f423-231">传输安全模式</span><span class="sxs-lookup"><span data-stu-id="0f423-231">transport security mode</span></span>|<span data-ttu-id="0f423-232">可以通过以下三种模式之一来保证安全：传输模式、消息安全模式和使用消息凭据的传输模式。</span><span class="sxs-lookup"><span data-stu-id="0f423-232">Security can be provided by one of three modes: transport mode, message security mode, and transport with message credential mode.</span></span> <span data-ttu-id="0f423-233">传输安全模式指定由传输层机制（如 HTTPS）提供保密性、完整性和身份验证。</span><span class="sxs-lookup"><span data-stu-id="0f423-233">The transport security mode specifies that confidentiality, integrity, and authentication are provided by the transport layer mechanisms (such as HTTPS).</span></span> <span data-ttu-id="0f423-234">在使用像 HTTPS 这样的传输协议时，此模式的优点在于性能出色，而且由于它在 Internet 上非常流行，因此很容易理解。</span><span class="sxs-lookup"><span data-stu-id="0f423-234">When using a transport like HTTPS, this mode has the advantage of being efficient in its performance, and well understood because of its prevalence on the Internet.</span></span> <span data-ttu-id="0f423-235">缺点是这种安全分别应用于通信路径，使得通信容易遭受中每个跃点&quot;中间人&quot;攻击。</span><span class="sxs-lookup"><span data-stu-id="0f423-235">The disadvantage is that this kind of security is applied separately on each hop in the communication path, making the communication susceptible to a &quot;man in the middle&quot; attack.</span></span>|  
|<span data-ttu-id="0f423-236">使用消息凭据的传输安全模式</span><span class="sxs-lookup"><span data-stu-id="0f423-236">transport with message credential security mode</span></span>|<span data-ttu-id="0f423-237">此模式使用传输层来提供消息的保密性、身份验证和完整性，并且每个消息都可以包含消息接收方所要求的多个凭据（声明）。</span><span class="sxs-lookup"><span data-stu-id="0f423-237">This mode uses the transport layer to provide confidentiality, authentication, and integrity of the messages, while each of the messages can contain multiple credentials (claims) required by the receivers of the message.</span></span>|  
|<span data-ttu-id="0f423-238">type converter（类型转换器）</span><span class="sxs-lookup"><span data-stu-id="0f423-238">type converter</span></span>|<span data-ttu-id="0f423-239">CLR 类型可以与一个或多个 System.ComponentModel.TypeConverter 派生类型关联，这些派生类型使 CLR 类型的实例与其他类型的实例之间能够互相转换。</span><span class="sxs-lookup"><span data-stu-id="0f423-239">A CLR type can be associated with one or more System.ComponentModel.TypeConverter derived types that enable converting instances of the CLR type to and from instances of other types.</span></span> <span data-ttu-id="0f423-240">类型转换器使用 System.ComponentModel.TypeConverterAttribute 特性与 CLR 类型相关联。</span><span class="sxs-lookup"><span data-stu-id="0f423-240">A type converterr is associated with a CLR type using the System.ComponentModel.TypeConverterAttribute attribute.</span></span>  <span data-ttu-id="0f423-241">可以在 CLR 类型或属性上直接指定 TypeConverterAttribute。</span><span class="sxs-lookup"><span data-stu-id="0f423-241">A TypeConverterAttribute can be specified directly on the CLR type or on a property.</span></span> <span data-ttu-id="0f423-242">在属性上指定的类型转换器始终优先于在属性的 CLR 类型上指定的类型转换器。</span><span class="sxs-lookup"><span data-stu-id="0f423-242">A type converter specified on a property always takes precedence over a type converter specified on the CLR type of the property.</span></span>|  
|<span data-ttu-id="0f423-243">WCF client（WCF 客户端）</span><span class="sxs-lookup"><span data-stu-id="0f423-243">WCF client</span></span>|<span data-ttu-id="0f423-244">WCF 客户端是一个客户端应用程序构造，可将服务操作作为方法公开（使用所选的 .NET Framework 编程语言，如 Visual Basic 或 Visual C#）。</span><span class="sxs-lookup"><span data-stu-id="0f423-244">A WCF client is a client-application construct that exposes the service operations as methods (in the .NET Framework programming language of your choice, such as Visual Basic or Visual C#).</span></span> <span data-ttu-id="0f423-245">任何应用程序都可以承载 WCF 客户端，包括承载服务的应用程序。</span><span class="sxs-lookup"><span data-stu-id="0f423-245">Any application can host a WCF client, including an application that hosts a service.</span></span> <span data-ttu-id="0f423-246">因此，可以创建一个包含其他服务的 WCF 客户端的服务。</span><span class="sxs-lookup"><span data-stu-id="0f423-246">Therefore, it is possible to create a service that includes WCF clients of other services.</span></span>  <span data-ttu-id="0f423-247">使用 ServiceModel 元数据实用工具 (Svcutil.exe) 并将其指向正在运行的元数据发布服务，可以自动生成 WCF 客户端。</span><span class="sxs-lookup"><span data-stu-id="0f423-247">A WCF client can be automatically generated by using the ServiceModel Metadata Utility Tool (Svcutil.exe) and pointing it at a running service that publishes metadata.</span></span>|  
|<span data-ttu-id="0f423-248">工作流服务</span><span class="sxs-lookup"><span data-stu-id="0f423-248">workflow services</span></span>|<span data-ttu-id="0f423-249">工作流服务是作为工作流实现的 WCF 服务。</span><span class="sxs-lookup"><span data-stu-id="0f423-249">A workflow service is a WCF service that is implemented as a workflow.</span></span> <span data-ttu-id="0f423-250">工作流包含发送和/或接收 WCF 消息的消息传递活动。</span><span class="sxs-lookup"><span data-stu-id="0f423-250">The workflow contains messaging activities that send and/or receive WCF messages.</span></span>|  
|<span data-ttu-id="0f423-251">WS-*</span><span class="sxs-lookup"><span data-stu-id="0f423-251">WS-*</span></span>|<span data-ttu-id="0f423-252">一组不断增加的、在 WCF 中实现的 Web 服务 (WS) 规范（如 WS-Security、WS-ReliableMessaging 等）的简写。</span><span class="sxs-lookup"><span data-stu-id="0f423-252">Shorthand for the growing set of Web Service (WS) specifications, such as WS-Security, WS-ReliableMessaging, and so on, that are implemented in WCF.</span></span>|  
|<span data-ttu-id="0f423-253">XAML</span><span class="sxs-lookup"><span data-stu-id="0f423-253">XAML</span></span>|<span data-ttu-id="0f423-254">可扩展应用程序标记语言</span><span class="sxs-lookup"><span data-stu-id="0f423-254">eXtensible Application Markup Language</span></span>|  
|<span data-ttu-id="0f423-255">XAML schema（XAML 架构）</span><span class="sxs-lookup"><span data-stu-id="0f423-255">XAML schema</span></span>|<span data-ttu-id="0f423-256">在 XAML 中用于定义自定义类型的标记架构。</span><span class="sxs-lookup"><span data-stu-id="0f423-256">A markup schema used to define custome types in XAML.</span></span>|
