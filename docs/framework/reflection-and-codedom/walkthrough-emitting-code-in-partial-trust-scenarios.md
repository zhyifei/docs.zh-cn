---
title: "演练：在部分信任应用场景中发出代码"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- reflection emit, anonymously hosted dynamic methods
- partial trust, reflection
- partial trust, emitting dynamic methods
- reflection emit, partial trust scenarios
- anonymously hosted dynamic methods [.NET Framework]
- emitting dynamic assemblies,partial trust scenarios
- reflection emit, dynamic methods
- dynamic methods
ms.assetid: c45be261-2a9d-4c4e-9bd6-27f0931b7d25
caps.latest.revision: "15"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: 835483d740b60f98c3170a590edbfbfbe970d783
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/22/2017
---
# <a name="walkthrough-emitting-code-in-partial-trust-scenarios"></a><span data-ttu-id="ee5fb-102">演练：在部分信任应用场景中发出代码</span><span class="sxs-lookup"><span data-stu-id="ee5fb-102">Walkthrough: Emitting Code in Partial Trust Scenarios</span></span>
<span data-ttu-id="ee5fb-103">反射发出以完全信任或部分信任形式使用相同的 API 集，但某些功能在部分受信任代码中需要特殊权限。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-103">Reflection emit uses the same API set in full or partial trust, but some features require special permissions in partially trusted code.</span></span> <span data-ttu-id="ee5fb-104">此外，反射发出具有一个功能，即匿名托管动态方法，旨在由安全透明的程序集采用部分信任的形式使用。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-104">In addition, reflection emit has a feature, anonymously hosted dynamic methods, that is designed to be used with partial trust and by security-transparent assemblies.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ee5fb-105">在 [!INCLUDE[net_v35_long](../../../includes/net-v35-long-md.md)] 之前，发出代码需要带 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 标记的<xref:System.Security.Permissions.ReflectionPermission>。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-105">Before [!INCLUDE[net_v35_long](../../../includes/net-v35-long-md.md)], emitting code required <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="ee5fb-106">默认情况下，此权限包含在 `FullTrust` 和 `Intranet` 命名权限集中，而不在 `Internet` 权限集中。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-106">This permission is included by default in the `FullTrust` and `Intranet` named permission sets, but not in the `Internet` permission set.</span></span> <span data-ttu-id="ee5fb-107">因此，只有当库具有 <xref:System.Security.SecurityCriticalAttribute> 特性并对 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit> 执行了 <xref:System.Security.PermissionSet.Assert%2A> 方法时，才能在部分信任环境下使用该库。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-107">Therefore, a library could be used from partial trust only if it had the <xref:System.Security.SecurityCriticalAttribute> attribute and also executed an <xref:System.Security.PermissionSet.Assert%2A> method for <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>.</span></span> <span data-ttu-id="ee5fb-108">这种库需要进行仔细的安全检查，因为编码错误可能会导致安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-108">Such libraries require careful security review because coding errors could result in security holes.</span></span> <span data-ttu-id="ee5fb-109">[!INCLUDE[net_v35_short](../../../includes/net-v35-short-md.md)] 允许以部分信任形式发出代码而无需发出任何安全请求，因为生成代码本身不是一项特权操作。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-109">The [!INCLUDE[net_v35_short](../../../includes/net-v35-short-md.md)] allows code to be emitted in partial trust scenarios without issuing any security demands, because generating code is not inherently a privileged operation.</span></span> <span data-ttu-id="ee5fb-110">也就是说，生成的代码不会具有比发出它的程序集更多的权限。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-110">That is, the generated code has no more permissions than the assembly that emits it.</span></span> <span data-ttu-id="ee5fb-111">这使发出代码的库具有安全-透明性且无需断言 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>，因此编写安全库无需彻底的安全检查。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-111">This enables libraries that emit code to be security-transparent and removes the need to assert <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>, so that writing a secure library does not require such a thorough security review.</span></span>  
  
 <span data-ttu-id="ee5fb-112">本演练阐释了以下任务：</span><span class="sxs-lookup"><span data-stu-id="ee5fb-112">This walkthrough illustrates the following tasks:</span></span>  
  
-   <span data-ttu-id="ee5fb-113">[为测试部分受信任的代码设置简单沙盒](#Setting_up)。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-113">[Setting up a simple sandbox for testing partially trusted code](#Setting_up).</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="ee5fb-114">这是一种以部门信任形式试验代码的简单方法。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-114">This is a simple way to experiment with code in partial trust.</span></span> <span data-ttu-id="ee5fb-115">要运行实际来自不可信位置的代码，请参阅[如何：运行沙盒中部分受信任的代码](../../../docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md)。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-115">To run code that actually comes from untrusted locations, see [How to: Run Partially Trusted Code in a Sandbox](../../../docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).</span></span>  
  
-   <span data-ttu-id="ee5fb-116">[在部分受信任的应用程序域中运行代码](#Running_code)。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-116">[Running code in partially trusted application domains](#Running_code).</span></span>  
  
-   <span data-ttu-id="ee5fb-117">[使用匿名托管动态方法以部分信任形式发出和执行代码](#Using_methods)。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-117">[Using anonymously hosted dynamic methods to emit and execute code in partial trust](#Using_methods).</span></span>  
  
 <span data-ttu-id="ee5fb-118">有关在部分信任方案中发出代码的详细信息，请参阅[反射发出中的安全问题](../../../docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-118">For more information about emitting code in partial trust scenarios, see [Security Issues in Reflection Emit](../../../docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span></span>  
  
 <span data-ttu-id="ee5fb-119">有关这些过程中所显示代码的完整列表，请参阅本演练末的[示例部分](#Example)。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-119">For a complete listing of the code shown in these procedures, see the [Example section](#Example) at the end of this walkthrough.</span></span>  
  
<a name="Setting_up"></a>   
## <a name="setting-up-partially-trusted-locations"></a><span data-ttu-id="ee5fb-120">设置部分信任的位置</span><span class="sxs-lookup"><span data-stu-id="ee5fb-120">Setting up Partially Trusted Locations</span></span>  
 <span data-ttu-id="ee5fb-121">以下两个过程显示如何设置可以测试部分信任的代码的位置。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-121">The following two procedures show how to set up locations from which you can test code with partial trust.</span></span>  
  
-   <span data-ttu-id="ee5fb-122">过程一演示如何创建沙盒应用程序域，其中已授予代码 Internet 权限。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-122">The first procedure shows how to create a sandboxed application domain in which code is granted Internet permissions.</span></span>  
  
-   <span data-ttu-id="ee5fb-123">过程二演示如何将带 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 标记的 <xref:System.Security.Permissions.ReflectionPermission> 添加到部分信任的应用程序域，以便访问信任级别相同或更低的程序集中的专用数据。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-123">The second procedure shows how to add <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag to a partially trusted application domain, to enable access to private data in assemblies of equal or lesser trust.</span></span>  
  
### <a name="creating-sandboxed-application-domains"></a><span data-ttu-id="ee5fb-124">创建沙盒应用程序域</span><span class="sxs-lookup"><span data-stu-id="ee5fb-124">Creating Sandboxed Application Domains</span></span>  
 <span data-ttu-id="ee5fb-125">要创建使用部分信任形式运行程序集的应用程序域，必须使用 <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> 方法重载来指定要授予程序集的权限集，以创建应用程序域。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-125">To create an application domain in which your assemblies run with partial trust, you must specify the set of permissions to be granted to the assemblies by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload to create the application domain.</span></span> <span data-ttu-id="ee5fb-126">指定授予集最简单的方法是从安全策略检索命名权限集。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-126">The easiest way to specify the grant set is to retrieve a named permission set from security policy.</span></span>  
  
 <span data-ttu-id="ee5fb-127">下列过程创建沙盒应用程序域，它运行部分信任的代码，从而测试方案，方案中发出的代码只能访问公共类型的公共成员。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-127">The following procedure creates a sandboxed application domain that runs your code with partial trust, to test scenarios in which emitted code can access only public members of public types.</span></span> <span data-ttu-id="ee5fb-128">随后的过程演示如何添加 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> 来测试方案，方案中发出的代码可以访问程序集中的非公共类型和成员（授予了程序集相同权限或较低权限）。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-128">A subsequent procedure shows how to add <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>, to test scenarios in which emitted code can access nonpublic types and members in assemblies that are granted equal or lesser permissions.</span></span>  
  
##### <a name="to-create-an-application-domain-with-partial-trust"></a><span data-ttu-id="ee5fb-129">创建部分信任的应用程序域</span><span class="sxs-lookup"><span data-stu-id="ee5fb-129">To create an application domain with partial trust</span></span>  
  
1.  <span data-ttu-id="ee5fb-130">创建一个权限集，将其授予沙盒应用程序域中的程序集。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-130">Create a permission set to grant to the assemblies in the sandboxed application domain.</span></span> <span data-ttu-id="ee5fb-131">在这种情况下，使用的是 Internet 区域的权限集。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-131">In this case, the permission set of the Internet zone is used.</span></span>  
  
     [!code-csharp[HowToEmitCodeInPartialTrust#2](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#2)]
     [!code-vb[HowToEmitCodeInPartialTrust#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#2)]  
  
2.  <span data-ttu-id="ee5fb-132">创建一个 <xref:System.AppDomainSetup> 对象，使用应用程序路径初始化应用程序域。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-132">Create an <xref:System.AppDomainSetup> object to initialize the application domain with an application path.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="ee5fb-133">为简单起见，此代码示例使用当前文件夹。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-133">For simplicity, this code example uses the current folder.</span></span> <span data-ttu-id="ee5fb-134">要运行实际来自 Internet 的代码，请为不受信任的代码使用单独的文件夹，如[如何：运行沙盒中部分受信任的代码](../../../docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md)中所述。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-134">To run code that actually comes from the Internet, use a separate folder for the untrusted code, as described in [How to: Run Partially Trusted Code in a Sandbox](../../../docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).</span></span>  
  
     [!code-csharp[HowToEmitCodeInPartialTrust#3](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#3)]
     [!code-vb[HowToEmitCodeInPartialTrust#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#3)]  
  
3.  <span data-ttu-id="ee5fb-135">创建应用程序域，为在应用程序域中执行的所有程序集指定应用程序域设置信息和授予集。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-135">Create the application domain, specifying the application domain setup information and the grant set for all assemblies that execute in the application domain.</span></span>  
  
     [!code-csharp[HowToEmitCodeInPartialTrust#5](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#5)]
     [!code-vb[HowToEmitCodeInPartialTrust#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#5)]  
  
     <span data-ttu-id="ee5fb-136">可通过 <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> 方法重载的最后一个参数来指定要授予完全信任的一组程序集，而不是应用程序域的授予集。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-136">The last parameter of the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload enables you to specify a set of assemblies that are to be granted full trust, instead of the grant set of the application domain.</span></span> <span data-ttu-id="ee5fb-137">无需指定应用程序所使用的 [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] 程序集，因为它们位于全局程序集缓存中。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-137">You do not have to specify the [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] assemblies that your application uses, because those assemblies are in the global assembly cache.</span></span> <span data-ttu-id="ee5fb-138">全局程序集缓存中的程序集始终是完全受信任的。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-138">Assemblies in the global assembly cache are always fully trusted.</span></span> <span data-ttu-id="ee5fb-139">可使用此参数指定全局程序集缓存之外的强名称程序集。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-139">You can use this parameter to specify strong-named assemblies that are not in the global assembly cache.</span></span>  
  
### <a name="adding-restrictedmemberaccess-to-sandboxed-domains"></a><span data-ttu-id="ee5fb-140">将 RestrictedMemberAccess 添加到沙盒域</span><span class="sxs-lookup"><span data-stu-id="ee5fb-140">Adding RestrictedMemberAccess to Sandboxed Domains</span></span>  
 <span data-ttu-id="ee5fb-141">主机应用程序可允许匿名托管动态方法访问程序集中的专用数据，该程序集具有与发出代码的程序集相同或更低的信任级别。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-141">Host applications can allow anonymously hosted dynamic methods to have access to private data in assemblies that have trust levels equal to or less than the trust level of the assembly that emits the code.</span></span> <span data-ttu-id="ee5fb-142">要启用此受限能力跳过实时 (JIT) 可见性检查，主机应用程序需使用 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> (RMA) 标记向授予集添加 <xref:System.Security.Permissions.ReflectionPermission> 对象。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-142">To enable this restricted ability to skip just-in-time (JIT) visibility checks, the host application adds a <xref:System.Security.Permissions.ReflectionPermission> object with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> (RMA) flag to the grant set.</span></span>  
  
 <span data-ttu-id="ee5fb-143">例如，主机可能授予 Internet 应用程序 Internet 权限和 RMA，以便 Internet 应用程序能发出访问自身程序集中专用数据的代码。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-143">For example, a host might grant Internet applications Internet permissions plus RMA, so that an Internet application can emit code that accesses private data in its own assemblies.</span></span> <span data-ttu-id="ee5fb-144">由于访问仅限于具有相同和较低信任级别的程序集，因此 Internet 应用程序无法访问完全信任的程序集（如 [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] 程序集）的成员。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-144">Because the access is limited to assemblies of equal or lesser trust, an Internet application cannot access members of fully trusted assemblies such as [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] assemblies.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ee5fb-145">为防止特权提升，在构造匿名托管动态方法时，将包含发出程序集的堆栈信息。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-145">To prevent elevation of privilege, stack information for the emitting assembly is included when anonymously hosted dynamic methods are constructed.</span></span> <span data-ttu-id="ee5fb-146">调用方法时检查堆栈信息。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-146">When the method is invoked, the stack information is checked.</span></span> <span data-ttu-id="ee5fb-147">因此，从完全信任的代码调用的匿名托管动态方法仍被限制为发出程序集的信任等级。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-147">Thus, an anonymously hosted dynamic method that is invoked from fully trusted code is still limited to the trust level of the emitting assembly.</span></span>  
  
##### <a name="to-create-an-application-domain-with-partial-trust-plus-rma"></a><span data-ttu-id="ee5fb-148">创建部分信任的应用程序域和 RMA</span><span class="sxs-lookup"><span data-stu-id="ee5fb-148">To create an application domain with partial trust plus RMA</span></span>  
  
1.  <span data-ttu-id="ee5fb-149">创建一个具有 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> (RMA) 标记的 <xref:System.Security.Permissions.ReflectionPermission> 新对象，并使用 <xref:System.Security.PermissionSet.SetPermission%2A?displayProperty=nameWithType> 方法向授予集添加该权限。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-149">Create a new <xref:System.Security.Permissions.ReflectionPermission> object with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> (RMA) flag, and use the <xref:System.Security.PermissionSet.SetPermission%2A?displayProperty=nameWithType> method to add the permission to the grant set.</span></span>  
  
     [!code-csharp[HowToEmitCodeInPartialTrust#7](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#7)]
     [!code-vb[HowToEmitCodeInPartialTrust#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#7)]  
  
     <span data-ttu-id="ee5fb-150">如果授予集中尚未包含该权限，则 <xref:System.Security.PermissionSet.AddPermission%2A> 方法向其中添加该权限。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-150">The <xref:System.Security.PermissionSet.AddPermission%2A> method adds the permission to the grant set if it is not already included.</span></span> <span data-ttu-id="ee5fb-151">如果授予集中已包含该权限，则向现有权限添加指定的标记。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-151">If the permission is already included in the grant set, the specified flags are added to the existing permission.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="ee5fb-152">RMA 是匿名托管动态方法的一项功能。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-152">RMA is a feature of anonymously hosted dynamic methods.</span></span> <span data-ttu-id="ee5fb-153">当普通动态方法跳过 JIT 可见性检查时，发出的代码要求完全信任。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-153">When ordinary dynamic methods skip JIT visibility checks, the emitted code requires full trust.</span></span>  
  
2.  <span data-ttu-id="ee5fb-154">创建应用程序域，指定应用程序域设置信息和授予集。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-154">Create the application domain, specifying the application domain setup information and the grant set.</span></span>  
  
     [!code-csharp[HowToEmitCodeInPartialTrust#8](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#8)]
     [!code-vb[HowToEmitCodeInPartialTrust#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#8)]  
  
<a name="Running_code"></a>   
## <a name="running-code-in-sandboxed-application-domains"></a><span data-ttu-id="ee5fb-155">在沙盒应用程序域中运行代码</span><span class="sxs-lookup"><span data-stu-id="ee5fb-155">Running Code in Sandboxed Application Domains</span></span>  
 <span data-ttu-id="ee5fb-156">下列过程说明如何使用可在应用程序域中执行的方法来定义类，如何在域中创建类的实例，以及如何执行其方法。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-156">The following procedure explains how to define a class by using methods that can be executed in an application domain, how to create an instance of the class in the domain, and how to execute its methods.</span></span>  
  
#### <a name="to-define-and-execute-a-method-in-an-application-domain"></a><span data-ttu-id="ee5fb-157">在应用程序域中定义和执行方法</span><span class="sxs-lookup"><span data-stu-id="ee5fb-157">To define and execute a method in an application domain</span></span>  
  
1.  <span data-ttu-id="ee5fb-158">定义一个从 <xref:System.MarshalByRefObject> 派生的类。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-158">Define a class that derives from <xref:System.MarshalByRefObject>.</span></span> <span data-ttu-id="ee5fb-159">这使你可在其它应用程序域中创建类的实例，并在应用程序域边界之间进行方法调用。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-159">This enables you to create instances of the class in other application domains and to make method calls across application domain boundaries.</span></span> <span data-ttu-id="ee5fb-160">此例中将该类命名为 `Worker`。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-160">The class in this example is named `Worker`.</span></span>  
  
     [!code-csharp[HowToEmitCodeInPartialTrust#10](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#10)]
     [!code-vb[HowToEmitCodeInPartialTrust#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#10)]  
  
2.  <span data-ttu-id="ee5fb-161">定义包含要执行的代码的公共方法。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-161">Define a public method that contains the code you want to execute.</span></span> <span data-ttu-id="ee5fb-162">在此示例中，代码发出一个简单的动态方法，创建一个委托来执行方法，并调用该委托。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-162">In this example, the code emits a simple dynamic method, creates a delegate to execute the method, and invokes the delegate.</span></span>  
  
     [!code-csharp[HowToEmitCodeInPartialTrust#11](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#11)]
     [!code-vb[HowToEmitCodeInPartialTrust#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#11)]  
  
3.  <span data-ttu-id="ee5fb-163">在主程序中，获取程序集的显示名称。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-163">In your main program, get the display name of your assembly.</span></span> <span data-ttu-id="ee5fb-164">在沙盒应用程序域中创建 `Worker` 类的实例时，将用到此名称。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-164">This name is used when you create instances of the `Worker` class in the sandboxed application domain.</span></span>  
  
     [!code-csharp[HowToEmitCodeInPartialTrust#14](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#14)]
     [!code-vb[HowToEmitCodeInPartialTrust#14](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#14)]  
  
4.  <span data-ttu-id="ee5fb-165">在主程序中，按本演练[过程一](#Setting_up)中所述，创建一个沙盒应用程序域。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-165">In your main program, create a sandboxed application domain, as described in [the first procedure](#Setting_up) in this walkthrough.</span></span> <span data-ttu-id="ee5fb-166">无需向 `Internet` 权限集添加任何权限，因为 `SimpleEmitDemo` 方法仅使用公共方法。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-166">You do not have to add any permissions to the `Internet` permission set, because the `SimpleEmitDemo` method uses only public methods.</span></span>  
  
5.  <span data-ttu-id="ee5fb-167">在主程序中，在沙盒应用程序域中创建 `Worker` 类的实例。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-167">In your main program, create an instance of the `Worker` class in the sandboxed application domain.</span></span>  
  
     [!code-csharp[HowToEmitCodeInPartialTrust#12](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#12)]
     [!code-vb[HowToEmitCodeInPartialTrust#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#12)]  
  
     <span data-ttu-id="ee5fb-168"><xref:System.AppDomain.CreateInstanceAndUnwrap%2A> 方法在目标应用程序域中创建该对象，并返回一个可用于调用该对象的属性和方法的代理。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-168">The <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> method creates the object in the target application domain and returns a proxy that can be used to call the properties and methods of the object.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="ee5fb-169">如果在 [!INCLUDE[vsprvs](../../../includes/vsprvs-md.md)] 中使用该代码，则必须更改类的名称以包括命名空间。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-169">If you use this code in [!INCLUDE[vsprvs](../../../includes/vsprvs-md.md)], you must change the name of the class to include the namespace.</span></span> <span data-ttu-id="ee5fb-170">默认情况下，命名空间是项目的名称。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-170">By default, the namespace is the name of the project.</span></span> <span data-ttu-id="ee5fb-171">例如，如果项目是“PartialTrust”，那么类名必须为“PartialTrust.Worker”。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-171">For example, if the project is "PartialTrust", the class name must be "PartialTrust.Worker".</span></span>  
  
6.  <span data-ttu-id="ee5fb-172">添加用于调用 `SimpleEmitDemo` 方法的代码。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-172">Add code to call the `SimpleEmitDemo` method.</span></span> <span data-ttu-id="ee5fb-173">跨应用程序域边界对调用进行封送，并在沙盒应用程序域中执行该代码。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-173">The call is marshaled across the application domain boundary, and the code is executed in the sandboxed application domain.</span></span>  
  
     [!code-csharp[HowToEmitCodeInPartialTrust#13](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#13)]
     [!code-vb[HowToEmitCodeInPartialTrust#13](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#13)]  
  
<a name="Using_methods"></a>   
## <a name="using-anonymously-hosted-dynamic-methods"></a><span data-ttu-id="ee5fb-174">使用匿名托管动态方法</span><span class="sxs-lookup"><span data-stu-id="ee5fb-174">Using Anonymously Hosted Dynamic Methods</span></span>  
 <span data-ttu-id="ee5fb-175">匿名托管动态方法与系统提供的透明程序集相关联。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-175">Anonymously hosted dynamic methods are associated with a transparent assembly that is provided by the system.</span></span> <span data-ttu-id="ee5fb-176">因此，它们所包含的代码是透明的。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-176">Therefore, the code they contain is transparent.</span></span> <span data-ttu-id="ee5fb-177">普通动态方法则相反，它必须与现有模块（无论是直接指定，还是从关联的类型推断而出）相关联，并从该模块获取安全级别。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-177">Ordinary dynamic methods, on the other hand, must be associated with an existing module (whether directly specified or inferred from an associated type), and take their security level from that module.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ee5fb-178">将动态方法与提供匿名托管的程序集相关联的唯一途径，是使用下列过程中所述的构造函数。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-178">The only way to associate a dynamic method with the assembly that provides anonymous hosting is to use the constructors that are described in the following procedure.</span></span> <span data-ttu-id="ee5fb-179">在匿名托管程序集中，不可显式指定模块。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-179">You cannot explicitly specify a module in the anonymous hosting assembly.</span></span>  
  
 <span data-ttu-id="ee5fb-180">普通动态方法可以访问与之相关联的模块的内部成员，或访问与之相关联的类型的私有成员。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-180">Ordinary dynamic methods have access to the internal members of the module they are associated with, or to the private members of the type they are associated with.</span></span> <span data-ttu-id="ee5fb-181">由于匿名托管动态方法独立于其他代码，因此它们无需访问专用数据。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-181">Because anonymously hosted dynamic methods are isolated from other code, they do not have access to private data.</span></span> <span data-ttu-id="ee5fb-182">但是，它们拥有跳过 JIT 可见性检查，访问专用数据的有限能力。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-182">However, they do have a restricted ability to skip JIT visibility checks to gain access to private data.</span></span> <span data-ttu-id="ee5fb-183">此功能仅限具有与发出代码的程序集相同或较低信任等级的程序集。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-183">This ability is limited to assemblies that have trust levels equal to or less than the trust level of the assembly that emits the code.</span></span>  
  
 <span data-ttu-id="ee5fb-184">为防止特权提升，在构造匿名托管动态方法时，将包含发出程序集的堆栈信息。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-184">To prevent elevation of privilege, stack information for the emitting assembly is included when anonymously hosted dynamic methods are constructed.</span></span> <span data-ttu-id="ee5fb-185">调用方法时检查堆栈信息。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-185">When the method is invoked, the stack information is checked.</span></span> <span data-ttu-id="ee5fb-186">从完全信任的代码调用的匿名托管动态方法仍被限制为发出该方法的程序集的信任等级。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-186">An anonymously hosted dynamic method that is invoked from fully trusted code is still limited to the trust level of the assembly that emitted it.</span></span>  
  
#### <a name="to-use-anonymously-hosted-dynamic-methods"></a><span data-ttu-id="ee5fb-187">使用匿名托管动态方法</span><span class="sxs-lookup"><span data-stu-id="ee5fb-187">To use anonymously hosted dynamic methods</span></span>  
  
-   <span data-ttu-id="ee5fb-188">使用不指定关联模块或类型的构造函数，创建匿名托管动态方法。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-188">Create an anonymously hosted dynamic method by using a constructor that does not specify an associated module or type.</span></span>  
  
     [!code-csharp[HowToEmitCodeInPartialTrust#15](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#15)]
     [!code-vb[HowToEmitCodeInPartialTrust#15](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#15)]  
  
     <span data-ttu-id="ee5fb-189">如果匿名托管动态方法仅使用公共类型和方法，则它无需受限的成员访问，且无需跳过 JIT 可见性检查。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-189">If an anonymously hosted dynamic method uses only public types and methods, it does not require restricted member access and does not have to skip JIT visibility checks.</span></span>  
  
     <span data-ttu-id="ee5fb-190">发出动态方法无需任何特殊权限，但发出的代码需要它使用的类型和方法所需的权限。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-190">No special permissions are required to emit a dynamic method, but the emitted code requires the permissions that are demanded by the types and methods it uses.</span></span> <span data-ttu-id="ee5fb-191">例如，如果发出的代码调用访问某个文件的方法，则它需要 <xref:System.Security.Permissions.FileIOPermission>。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-191">For example, if the emitted code calls a method that accesses a file, it requires <xref:System.Security.Permissions.FileIOPermission>.</span></span> <span data-ttu-id="ee5fb-192">如果信任级别不包含该权限，那么在执行发出的代码时，将引发安全性异常。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-192">If the trust level does not include that permission, a security exception is thrown when the emitted code is executed.</span></span> <span data-ttu-id="ee5fb-193">此处显示的代码发出一个动态方法，该方法仅使用 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-193">The code shown here emits a dynamic method that uses only the <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ee5fb-194">因此，可以从部分信任的位置执行该代码。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-194">Therefore, the code can be executed from partially trusted locations.</span></span>  
  
-   <span data-ttu-id="ee5fb-195">或者，使用 <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29> 构造函数并为 `restrictedSkipVisibility` 参数指定 `true`，从而创建一个匿名托管动态方法，该方法具有跳过 JIT 可见性检查的受限能力。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-195">Alternatively, create an anonymously hosted dynamic method with restricted ability to skip JIT visibility checks, by using the <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29> constructor and specifying `true` for the `restrictedSkipVisibility` parameter.</span></span>  
  
     [!code-csharp[HowToEmitCodeInPartialTrust#16](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#16)]
     [!code-vb[HowToEmitCodeInPartialTrust#16](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#16)]  
  
     <span data-ttu-id="ee5fb-196">限制在于，匿名托管动态方法仅可访问具有与发出程序集相同或比其更低的信任级别的程序集中的专用数据。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-196">The restriction is that the anonymously hosted dynamic method can access private data only in assemblies with trust levels equal to or less than the trust level of the emitting assembly.</span></span> <span data-ttu-id="ee5fb-197">例如，如果通过 Internet 信任来执行动态方法，则它可以访问同样以 Internet 信任执行的其他程序集中的专用数据，但无法访问 [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] 程序集中的专用数据。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-197">For example, if the dynamic method is executing with Internet trust, it can access private data in other assemblies that are also executing with Internet trust, but it cannot access private data of [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] assemblies.</span></span> [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)]<span data-ttu-id="ee5fb-198"> 程序集安装在全局程序集缓存中，且始终是完全受信任的。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-198"> assemblies are installed in the global assembly cache and are always fully trusted.</span></span>  
  
     <span data-ttu-id="ee5fb-199">仅当主机应用程序通过 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 标记授予 <xref:System.Security.Permissions.ReflectionPermission> 时，匿名托管动态方法才可使用此受限能力跳过 JIT 可见性检查。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-199">Anonymously hosted dynamic methods can use this restricted ability to skip JIT visibility checks only if the host application grants <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="ee5fb-200">调用方法时发出对此权限的请求。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-200">The demand for this permission is made when the method is invoked.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="ee5fb-201">构造动态方法时，包括发出程序集的调用堆栈信息。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-201">Call stack information for the emitting assembly is included when the dynamic method is constructed.</span></span> <span data-ttu-id="ee5fb-202">因此，是针对发出程序集的权限提出请求，而不是针对调用方法的程序集提出请求。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-202">Therefore, the demand is made against the permissions of the emitting assembly instead of the assembly that invokes the method.</span></span> <span data-ttu-id="ee5fb-203">这样可防止使用提升的权限执行发出的代码。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-203">This prevents the emitted code from being executed with elevated permissions.</span></span>  
  
     <span data-ttu-id="ee5fb-204">此演练末的[完整代码示例](#Example)说明了受限成员访问的使用和限制。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-204">The [complete code example](#Example) at the end of this walkthrough demonstrates the use and limitations of restricted member access.</span></span> <span data-ttu-id="ee5fb-205">它的 `Worker` 类包括可创建具有或不具有跳过可见性检查这一受限能力的匿名托管动态方法，且示例显示在具有不同信任级别的应用程序域中执行此方法的结果。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-205">Its `Worker` class includes a method that can create anonymously hosted dynamic methods with or without the restricted ability to skip visibility checks, and the example shows the result of executing this method in application domains that have different trust levels.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="ee5fb-206">跳过可见性检查这一受限能力是匿名托管动态方法的一种功能。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-206">The restricted ability to skip visibility checks is a feature of anonymously hosted dynamic methods.</span></span> <span data-ttu-id="ee5fb-207">当普通动态方法跳过 JIT 可见性检查时，向它们授予的信任级别必须是完全信任。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-207">When ordinary dynamic methods skip JIT visibility checks, they must be granted full trust.</span></span>  
  
<a name="Example"></a>   
## <a name="example"></a><span data-ttu-id="ee5fb-208">示例</span><span class="sxs-lookup"><span data-stu-id="ee5fb-208">Example</span></span>  
  
### <a name="description"></a><span data-ttu-id="ee5fb-209">描述</span><span class="sxs-lookup"><span data-stu-id="ee5fb-209">Description</span></span>  
 <span data-ttu-id="ee5fb-210">下列代码示例演示如何使用 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> 标记允许匿名托管动态方法跳过 JIT 可见性检查，但仅当目标成员与发出代码的程序集具有相同或较低信任级别时才适用。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-210">The following code example demonstrates the use of the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> flag to allow anonymously hosted dynamic methods to skip JIT visibility checks, but only when the target member is at an equal or lower level of trust than the assembly that emits the code.</span></span>  
  
 <span data-ttu-id="ee5fb-211">此示例定义了可跨应用程序域边界封送的 `Worker` 类。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-211">The example defines a `Worker` class that can be marshaled across application domain boundaries.</span></span> <span data-ttu-id="ee5fb-212">该类具有两个发出和执行动态方法的 `AccessPrivateMethod` 方法重载。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-212">The class has two `AccessPrivateMethod` method overloads that emit and execute dynamic methods.</span></span> <span data-ttu-id="ee5fb-213">第一个重载发出调用 `Worker` 类的私有 `PrivateMethod` 方法的动态方法，而且它发出具有或不具有 JIT 可见性检查的动态方法。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-213">The first overload emits a dynamic method that calls the private `PrivateMethod` method of the `Worker` class, and it can emit the dynamic method with or without JIT visibility checks.</span></span> <span data-ttu-id="ee5fb-214">第二个重载发出访问 <xref:System.String> 类的 `internal` 属性（Visual Basic 中的 `Friend` 属性）的动态方法。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-214">The second overload emits a dynamic method that accesses an `internal` property (`Friend` property in Visual Basic) of the <xref:System.String> class.</span></span>  
  
 <span data-ttu-id="ee5fb-215">示例使用 Helper 方法创建限制为 `Internet` 权限的授予集，然后创建应用程序域，使用 <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> 方法重载来指定域中执行的全部代码均使用此授予集。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-215">The example uses a helper method to create a grant set limited to `Internet` permissions, and then creates an application domain, using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload to specify that all code that executes in the domain uses this grant set.</span></span> <span data-ttu-id="ee5fb-216">此示例在应用程序域中创建 `Worker` 类的一个实例，并执行 `AccessPrivateMethod` 方法两次。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-216">The example creates an instance of the `Worker` class in the application domain, and executes the `AccessPrivateMethod` method two times.</span></span>  
  
-   <span data-ttu-id="ee5fb-217">首次执行 `AccessPrivateMethod` 方法时，强制执行 JIT 可见性检查。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-217">The first time the `AccessPrivateMethod` method is executed, JIT visibility checks are enforced.</span></span> <span data-ttu-id="ee5fb-218">动态方法将在被调用时失败，这是由于 JIT 可见性检查阻止其访问私有方法。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-218">The dynamic method fails when it is invoked, because JIT visibility checks prevent it from accessing the private method.</span></span>  
  
-   <span data-ttu-id="ee5fb-219">第二次执行 `AccessPrivateMethod` 方法时，跳过 JIT 可见性检查。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-219">The second time the `AccessPrivateMethod` method is executed, JIT visibility checks are skipped.</span></span> <span data-ttu-id="ee5fb-220">动态方法将在被编译时失败，这是由于 `Internet` 授予集未授予充足的权限，不能跳过可见性检查。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-220">The dynamic method fails when it is compiled, because the `Internet` grant set does not grant sufficient permissions to skip visibility checks.</span></span>  
  
 <span data-ttu-id="ee5fb-221">此示例向授予集添加具有 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 的 <xref:System.Security.Permissions.ReflectionPermission>。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-221">The example adds <xref:System.Security.Permissions.ReflectionPermission> with <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> to the grant set.</span></span> <span data-ttu-id="ee5fb-222">然后创建第二个域，指定授予在此域中执行的所有代码新授予集中的权限。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-222">The example then creates a second domain, specifying that all code that executes in the domain is granted the permissions in the new grant set.</span></span> <span data-ttu-id="ee5fb-223">此示例在新应用程序域中创建 `Worker` 类的一个实例，并执行 `AccessPrivateMethod` 方法的两个重载。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-223">The example creates an instance of the `Worker` class in the new application domain, and executes both overloads of the `AccessPrivateMethod` method.</span></span>  
  
-   <span data-ttu-id="ee5fb-224">执行 `AccessPrivateMethod` 方法的第一个重载，跳过 JIT 可见性检查。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-224">The first overload of the `AccessPrivateMethod` method is executed, and JIT visibility checks are skipped.</span></span> <span data-ttu-id="ee5fb-225">动态方法将成功编译和执行，这是由于发出代码的程序集与包含私有方法的程序集相同。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-225">The dynamic method compiles and executes successfully, because the assembly that emits the code is the same as the assembly that contains the private method.</span></span> <span data-ttu-id="ee5fb-226">因此，其信任级别相同。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-226">Therefore, the trust levels are equal.</span></span> <span data-ttu-id="ee5fb-227">如果包含 `Worker` 类的应用程序拥有若干程序集，则对于任何一个程序集，相同的进程都将成功，因为它们具有相同的信任级别。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-227">If the application that contains the `Worker` class had several assemblies, the same process would succeed for any one of those assemblies, because they would all be at the same trust level.</span></span>  
  
-   <span data-ttu-id="ee5fb-228">执行 `AccessPrivateMethod` 方法的第二个重载，再次跳过 JIT 可见性检查。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-228">The second overload of the `AccessPrivateMethod` method is executed, and again JIT visibility checks are skipped.</span></span> <span data-ttu-id="ee5fb-229">这一次，动态方法在编译时失败，因为它尝试访问 <xref:System.String> 类的 `internal` `FirstChar` 属性。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-229">This time the dynamic method fails when it is compiled, because it tries to access the `internal` `FirstChar` property of the <xref:System.String> class.</span></span> <span data-ttu-id="ee5fb-230">包含 <xref:System.String> 类的程序集是完全信任的程序集。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-230">The assembly that contains the <xref:System.String> class is fully trusted.</span></span> <span data-ttu-id="ee5fb-231">因此，它比发出代码的程序集拥有更高的信任级别。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-231">Therefore, it is at a higher level of trust than the assembly that emits the code.</span></span>  
  
 <span data-ttu-id="ee5fb-232">此比较显示了 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 如何使部分受信任的代码为其它部分受信任的代码跳过可见性检查，而不影响受信任代码的安全性。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-232">This comparison shows how <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> enables partially trusted code to skip visibility checks for other partially trusted code without compromising the security of trusted code.</span></span>  
  
### <a name="code"></a><span data-ttu-id="ee5fb-233">代码</span><span class="sxs-lookup"><span data-stu-id="ee5fb-233">Code</span></span>  
 [!code-csharp[HowToEmitCodeInPartialTrust#1](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#1)]
 [!code-vb[HowToEmitCodeInPartialTrust#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#1)]  
  
## <a name="compiling-the-code"></a><span data-ttu-id="ee5fb-234">编译代码</span><span class="sxs-lookup"><span data-stu-id="ee5fb-234">Compiling the Code</span></span>  
  
-   <span data-ttu-id="ee5fb-235">如果在 [!INCLUDE[vsprvs](../../../includes/vsprvs-md.md)] 中生成此代码示例，必须更改类名，以便在将命名空间传递给 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> 方法时包括该命名空间。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-235">If you build this code example in [!INCLUDE[vsprvs](../../../includes/vsprvs-md.md)], you must change the name of the class to include the namespace when you pass it to the <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> method.</span></span> <span data-ttu-id="ee5fb-236">默认情况下，命名空间是项目的名称。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-236">By default, the namespace is the name of the project.</span></span> <span data-ttu-id="ee5fb-237">例如，如果项目是“PartialTrust”，那么类名必须为“PartialTrust.Worker”。</span><span class="sxs-lookup"><span data-stu-id="ee5fb-237">For example, if the project is "PartialTrust", the class name must be "PartialTrust.Worker".</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ee5fb-238">请参阅</span><span class="sxs-lookup"><span data-stu-id="ee5fb-238">See Also</span></span>  
 [<span data-ttu-id="ee5fb-239">反射发出中的安全问题</span><span class="sxs-lookup"><span data-stu-id="ee5fb-239">Security Issues in Reflection Emit</span></span>](../../../docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)  
 [<span data-ttu-id="ee5fb-240">如何：运行沙盒中部分受信任的代码</span><span class="sxs-lookup"><span data-stu-id="ee5fb-240">How to: Run Partially Trusted Code in a Sandbox</span></span>](../../../docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md)
