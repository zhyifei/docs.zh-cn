---
title: .NET에서의 리플렉션
ms.date: 03/30/2017
helpviewer_keywords:
- assemblies [.NET], reflection
- EventInfo class, reflection
- common language runtime, reflection
- FieldInfo class, reflection
- ParameterInfo class, reflection
- ConstructorInfo class, reflection
- Assembly class, reflection
- value types, reflection
- reflection, about reflection
- modules, reflection
- runtime, reflection
- Module class, reflection
- MethodInfo class, reflection
- PropertyInfo class, reflection
- type browsers
- reflection
- discovering type information at run time
- type system, reflection
ms.assetid: d1a58e7f-fb39-4d50-bf84-e3b8f9bf9775
ms.openlocfilehash: 42944d8267d2e99fd9eb1a2cb28c0c81d3e9af75
ms.sourcegitcommit: de17a7a0a37042f0d4406f5ae5393531caeb25ba
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/24/2020
ms.locfileid: "76744566"
---
# <a name="reflection-in-net"></a><span data-ttu-id="4b50d-102">.NET에서의 리플렉션</span><span class="sxs-lookup"><span data-stu-id="4b50d-102">Reflection in .NET</span></span>

<span data-ttu-id="4b50d-103"><xref:System.Reflection> 命名空间中的类连同 <xref:System.Type?displayProperty=nameWithType>，使你能够获取有关加载的[程序集](../../standard/assembly/index.md)和其中定义的类型的信息，如[类](../../standard/base-types/common-type-system.md#classes)、[接口](../../standard/base-types/common-type-system.md#interfaces)和值类型（即[结构](../../standard/base-types/common-type-system.md#structures)和[枚举](../../standard/base-types/common-type-system.md#enumerations)）。</span><span class="sxs-lookup"><span data-stu-id="4b50d-103">The classes in the <xref:System.Reflection> namespace, together with <xref:System.Type?displayProperty=nameWithType>, enable you to obtain information about loaded [assemblies](../../standard/assembly/index.md) and the types defined within them, such as [classes](../../standard/base-types/common-type-system.md#classes), [interfaces](../../standard/base-types/common-type-system.md#interfaces), and value types (that is, [structures](../../standard/base-types/common-type-system.md#structures) and [enumerations](../../standard/base-types/common-type-system.md#enumerations)).</span></span> <span data-ttu-id="4b50d-104">리플렉션을 사용하여 런타임에 형식 인스턴스를 만들고 이 인스턴스를 호출 및 액세스할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-104">You can also use reflection to create type instances at run time, and to invoke and access them.</span></span> <span data-ttu-id="4b50d-105">리플렉션의 특정 측면에 대한 항목은 이 개요의 끝부분에서 [관련 항목](#related_topics)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4b50d-105">For topics about specific aspects of reflection, see [Related Topics](#related_topics) at the end of this overview.</span></span>
  
<span data-ttu-id="4b50d-106">[공용 언어 런타임](../../standard/clr.md) 로더는 같은 애플리케이션 범위가 포함된 개체 주위의 경계를 구성하는 [애플리케이션 도메인](../app-domains/application-domains.md)을 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-106">The [common language runtime](../../standard/clr.md) loader manages [application domains](../app-domains/application-domains.md), which constitute defined boundaries around objects that have the same application scope.</span></span> <span data-ttu-id="4b50d-107">이 관리에는 각 어셈블리를 적절한 애플리케이션 도메인으로 로드하는 작업과 각 어셈블리 내에서 형식 계층 구조의 메모리 레이아웃을 제어하는 작업이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-107">This management includes loading each assembly into the appropriate application domain and controlling the memory layout of the type hierarchy within each assembly.</span></span>  
  
<span data-ttu-id="4b50d-108">[어셈블리](../app-domains/index.md)에는 모듈이 포함되고, 모듈에는 형식이 포함되고, 형식에는 멤버가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-108">[Assemblies](../app-domains/index.md) contain modules, modules contain types, and types contain members.</span></span> <span data-ttu-id="4b50d-109">리플렉션은 어셈블리, 모듈 및 형식을 캡슐화하는 개체를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-109">Reflection provides objects that encapsulate assemblies, modules, and types.</span></span> <span data-ttu-id="4b50d-110">리플렉션을 사용하여 동적으로 형식 인스턴스를 만들거나, 형식을 기존 개체에 바인딩하거나, 기존 개체에서 형식을 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-110">You can use reflection to dynamically create an instance of a type, bind the type to an existing object, or get the type from an existing object.</span></span> <span data-ttu-id="4b50d-111">그리고 나서 해당 형식의 메서드를 호출하거나 필드 및 속성에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-111">You can then invoke the type's methods or access its fields and properties.</span></span> <span data-ttu-id="4b50d-112">리플렉션의 일반적인 용도는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-112">Typical uses of reflection include the following:</span></span>  
  
- <span data-ttu-id="4b50d-113"><xref:System.Reflection.Assembly>를 사용하여 어셈블리를 정의 및 로드하고, 어셈블리 매니페스트에 나열된 모듈을 로드하고, 이 어셈블리에서 형식을 찾아 해당 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-113">Use <xref:System.Reflection.Assembly> to define and load assemblies, load modules that are listed in the assembly manifest, and locate a type from this assembly and create an instance of it.</span></span>  
  
- <span data-ttu-id="4b50d-114"><xref:System.Reflection.Module>을 사용하여 모듈 및 모듈의 클래스가 포함된 어셈블리와 같은 정보를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-114">Use <xref:System.Reflection.Module> to discover information such as the assembly that contains the module and the classes in the module.</span></span> <span data-ttu-id="4b50d-115">모듈에 정의된 모든 전역 메서드나 기타 특정 비전역 메서드를 가져올 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-115">You can also get all global methods or other specific, nonglobal methods defined on the module.</span></span>  
  
- <span data-ttu-id="4b50d-116"><xref:System.Reflection.ConstructorInfo>를 사용하여 생성자의 이름, 매개 변수, 액세스 한정자(예: `public` 또는 `private`), 구현 세부 정보(예: `abstract` 또는 `virtual`)와 같은 정보를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-116">Use <xref:System.Reflection.ConstructorInfo> to discover information such as the name, parameters, access modifiers (such as `public` or `private`), and implementation details (such as `abstract` or `virtual`) of a constructor.</span></span> <span data-ttu-id="4b50d-117"><xref:System.Type>의 <xref:System.Type.GetConstructors%2A> 또는 <xref:System.Type.GetConstructor%2A> 메서드를 사용하여 특정 생성자를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-117">Use the <xref:System.Type.GetConstructors%2A> or <xref:System.Type.GetConstructor%2A> method of a <xref:System.Type> to invoke a specific constructor.</span></span>  
  
- <span data-ttu-id="4b50d-118"><xref:System.Reflection.MethodInfo>를 사용하여 메서드의 이름, 반환 형식, 매개 변수, 액세스 한정자(예: `public` 또는 `private`), 구현 세부 정보(예: `abstract` 또는 `virtual`)와 같은 정보를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-118">Use <xref:System.Reflection.MethodInfo> to discover information such as the name, return type, parameters, access modifiers (such as `public` or `private`), and implementation details (such as `abstract` or `virtual`) of a method.</span></span> <span data-ttu-id="4b50d-119"><xref:System.Type>의 <xref:System.Type.GetMethods%2A> 또는 <xref:System.Type.GetMethod%2A> 메서드를 사용하여 특정 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-119">Use the <xref:System.Type.GetMethods%2A> or <xref:System.Type.GetMethod%2A> method of a <xref:System.Type> to invoke a specific method.</span></span>  
  
- <span data-ttu-id="4b50d-120"><xref:System.Reflection.FieldInfo>를 사용하여 필드의 이름, 액세스 한정자(예: `public` 또는 `private`), 구현 세부 정보(예: `static`)를 검색하고 필드 값을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-120">Use <xref:System.Reflection.FieldInfo> to discover information such as the name, access modifiers (such as `public` or `private`) and implementation details (such as `static`) of a field, and to get or set field values.</span></span>  
  
- <span data-ttu-id="4b50d-121"><xref:System.Reflection.EventInfo>를 사용하여 이벤트의 이름, 이벤트 처리기 데이터 형식, 사용자 지정 특성, 선언 형식, 리플렉션 형식과 같은 정보를 검색하고 이벤트 처리기를 추가하거나 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-121">Use <xref:System.Reflection.EventInfo> to discover information such as the name, event-handler data type, custom attributes, declaring type, and reflected type of an event, and to add or remove event handlers.</span></span>  
  
- <span data-ttu-id="4b50d-122"><xref:System.Reflection.PropertyInfo>를 사용하여 속성의 이름, 데이터 형식, 선언 형식, 리플렉션 형식, 읽기 전용/쓰기 가능 상태와 같은 정보를 검색하고 속성 값을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-122">Use <xref:System.Reflection.PropertyInfo> to discover information such as the name, data type, declaring type, reflected type, and read-only or writable status of a property, and to get or set property values.</span></span>  
  
- <span data-ttu-id="4b50d-123"><xref:System.Reflection.ParameterInfo>를 사용하여 매개 변수 이름, 데이터 형식, 매개 변수가 입력 또는 출력 매개 변수인지 여부, 메서드 서명에서 매개 변수의 위치와 같은 정보를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-123">Use <xref:System.Reflection.ParameterInfo> to discover information such as a parameter's name, data type, whether a parameter is an input or output parameter, and the position of the parameter in a method signature.</span></span>  
  
- <span data-ttu-id="4b50d-124"><xref:System.Reflection.CustomAttributeData>를 사용하여 애플리케이션 도메인의 리플렉션 전용 컨텍스트에서 작업할 때 사용자 지정 특성에 대한 정보를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-124">Use <xref:System.Reflection.CustomAttributeData> to discover information about custom attributes when you are working in the reflection-only context of an application domain.</span></span> <span data-ttu-id="4b50d-125"><xref:System.Reflection.CustomAttributeData>를 사용하면 특성 인스턴스를 만들지 않고 특성을 검사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-125"><xref:System.Reflection.CustomAttributeData> allows you to examine attributes without creating instances of them.</span></span>  
  
<span data-ttu-id="4b50d-126"><xref:System.Reflection.Emit> 네임스페이스의 클래스는 런타임에 빌드할 수 있는 특수한 형태의 리플렉션을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-126">The classes of the <xref:System.Reflection.Emit> namespace provide a specialized form of reflection that enables you to build types at run time.</span></span>  
  
<span data-ttu-id="4b50d-127">리플렉션을 사용하여 사용자가 형식을 선택하고 해당 형식에 대한 정보를 볼 수 있도록 하는 형식 브라우저라는 애플리케이션을 만들 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-127">Reflection can also be used to create applications called type browsers, which enable users to select types and then view the information about those types.</span></span>  
  
<span data-ttu-id="4b50d-128">리플렉션의 다른 용도는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-128">There are other uses for reflection.</span></span> <span data-ttu-id="4b50d-129">JScript와 같은 언어용 컴파일러에서는 리플렉션을 사용하여 기호 테이블을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-129">Compilers for languages such as JScript use reflection to construct symbol tables.</span></span> <span data-ttu-id="4b50d-130"><xref:System.Runtime.Serialization> 네임스페이스의 클래스에서는 리플렉션을 사용하여 데이터에 액세스하고 보관할 필드를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-130">The classes in the <xref:System.Runtime.Serialization> namespace use reflection to access data and to determine which fields to persist.</span></span> <span data-ttu-id="4b50d-131"><xref:System.Runtime.Remoting> 네임스페이스의 클래스에서는 직렬화를 통해 간접적으로 리플렉션을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-131">The classes in the <xref:System.Runtime.Remoting> namespace use reflection indirectly through serialization.</span></span>  
  
## <a name="runtime-types-in-reflection"></a><span data-ttu-id="4b50d-132">리플렉션의 런타임 형식</span><span class="sxs-lookup"><span data-stu-id="4b50d-132">Runtime Types in Reflection</span></span>  
<span data-ttu-id="4b50d-133">리플렉션은 형식, 멤버, 매개 변수, 기타 코드 엔터티를 나타내는 <xref:System.Type> 및 <xref:System.Reflection.MethodInfo>와 같은 클래스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-133">Reflection provides classes, such as <xref:System.Type> and <xref:System.Reflection.MethodInfo>, to represent types, members, parameters, and other code entities.</span></span> <span data-ttu-id="4b50d-134">하지만 리플렉션을 사용할 때 이들 클래스를 직접 사용하지 않습니다. 이들 클래스는 대부분 추상 클래스입니다(Visual Basic의 `MustInherit`).</span><span class="sxs-lookup"><span data-stu-id="4b50d-134">However, when you use reflection, you don't work directly with these classes, most of which are abstract (`MustInherit` in Visual Basic).</span></span> <span data-ttu-id="4b50d-135">대신에 CLR(공용 언어 런타임)에서 제공된 형식을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-135">Instead, you work with types provided by the common language runtime (CLR).</span></span>  
  
<span data-ttu-id="4b50d-136">예를 들어 C# `typeof` 연산자(Visual Basic의 `GetType`)를 사용하여 <xref:System.Type> 개체를 가져오면 개체가 실제로 `RuntimeType`입니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-136">For example, when you use the C# `typeof` operator (`GetType` in Visual Basic) to obtain a <xref:System.Type> object, the object is really a `RuntimeType`.</span></span> <span data-ttu-id="4b50d-137">`RuntimeType`은 <xref:System.Type>에서 파생되고 모든 추상 메서드의 구현을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-137">`RuntimeType` derives from <xref:System.Type> and provides implementations of all the abstract methods.</span></span>  
  
<span data-ttu-id="4b50d-138">이들 런타임 클래스는 `internal`(Visual Basic의 `Friend`)입니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-138">These runtime classes are `internal` (`Friend` in Visual Basic).</span></span> <span data-ttu-id="4b50d-139">이들 클래스의 동작은 기본 클래스 설명서에서 설명되므로 이들 클래스는 기본 클래스와 별도로 설명되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-139">They are not documented separately from their base classes, because their behavior is described by the base class documentation.</span></span>  
  
<a name="related_topics"></a>   

## <a name="related-topics"></a><span data-ttu-id="4b50d-140">관련 항목</span><span class="sxs-lookup"><span data-stu-id="4b50d-140">Related Topics</span></span>  
  
|<span data-ttu-id="4b50d-141">제목</span><span class="sxs-lookup"><span data-stu-id="4b50d-141">Title</span></span>|<span data-ttu-id="4b50d-142">설명</span><span class="sxs-lookup"><span data-stu-id="4b50d-142">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="4b50d-143">형식 정보 보기</span><span class="sxs-lookup"><span data-stu-id="4b50d-143">Viewing Type Information</span></span>](viewing-type-information.md)|<span data-ttu-id="4b50d-144"><xref:System.Type> 클래스를 설명하고 <xref:System.Type>과 여러 리플렉션 클래스를 함께 사용하여 생성자, 메서드, 필드, 속성, 이벤트에 대한 정보를 가져오는 방법을 보여 주는 코드 예제를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-144">Describes the <xref:System.Type> class and provides code examples that illustrate how to use <xref:System.Type> with several reflection classes to obtain information about constructors, methods, fields, properties, and events.</span></span>|  
|[<span data-ttu-id="4b50d-145">리플렉션 및 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="4b50d-145">Reflection and Generic Types</span></span>](reflection-and-generic-types.md)|<span data-ttu-id="4b50d-146">리플렉션이 제네릭 형식과 제네릭 메서드의 형식 매개 변수 및 형식 인수를 처리하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-146">Explains how reflection handles the type parameters and type arguments of generic types and generic methods.</span></span>|  
|[<span data-ttu-id="4b50d-147">리플렉션의 보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="4b50d-147">Security Considerations for Reflection</span></span>](security-considerations-for-reflection.md)|<span data-ttu-id="4b50d-148">리플렉션이 형식 정보 및 액세스 형식을 검색하는 데 사용될 수 있는 정도를 결정하는 규칙을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-148">Describes the rules that determine to what degree reflection can be used to discover type information and access types.</span></span>|  
|[<span data-ttu-id="4b50d-149">형식 동적 로드 및 사용</span><span class="sxs-lookup"><span data-stu-id="4b50d-149">Dynamically Loading and Using Types</span></span>](dynamically-loading-and-using-types.md)|<span data-ttu-id="4b50d-150">런타임 바인딩을 지원하는 리플렉션 사용자 지정 바인딩 인터페이스를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-150">Describes the reflection custom-binding interface that supports late binding.</span></span>|  
|[<span data-ttu-id="4b50d-151">방법: 리플렉션 전용 컨텍스트에 어셈블리 로드</span><span class="sxs-lookup"><span data-stu-id="4b50d-151">How to: Load Assemblies into the Reflection-Only Context</span></span>](how-to-load-assemblies-into-the-reflection-only-context.md)|<span data-ttu-id="4b50d-152">리플렉션 전용 로드 컨텍스트를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-152">Describes the reflection-only load context.</span></span> <span data-ttu-id="4b50d-153">어셈블리를 로드하는 방법, 컨텍스트를 테스트하는 방법, 리플렉션 전용 컨텍스트에서 어셈블리에 적용된 특성을 검사하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-153">Shows how to load an assembly, how to test the context, and how to examine attributes applied to an assembly in the reflection-only context.</span></span>|  
|[<span data-ttu-id="4b50d-154">사용자 지정 특성 액세스</span><span class="sxs-lookup"><span data-stu-id="4b50d-154">Accessing Custom Attributes</span></span>](accessing-custom-attributes.md)|<span data-ttu-id="4b50d-155">리플렉션을 사용하여 특성 존재 및 값을 쿼리하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-155">Demonstrates using reflection to query attribute existence and values.</span></span>|  
|[<span data-ttu-id="4b50d-156">정규화된 형식 이름 지정</span><span class="sxs-lookup"><span data-stu-id="4b50d-156">Specifying Fully Qualified Type Names</span></span>](specifying-fully-qualified-type-names.md)|<span data-ttu-id="4b50d-157">BNF(Backus-Naur 형식) 측면에서 정규화된 형식 이름의 형식에 대해 설명하고 특수 문자, 어셈블리 이름, 포인터, 참조, 배열을 지정하는 데 필요한 구문을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-157">Describes the format of fully qualified type names in terms of the Backus-Naur form (BNF), and the syntax required for specifying special characters, assembly names, pointers, references, and arrays.</span></span>|  
|[<span data-ttu-id="4b50d-158">방법: 리플렉션을 사용하여 대리자 후크</span><span class="sxs-lookup"><span data-stu-id="4b50d-158">How to: Hook Up a Delegate Using Reflection</span></span>](how-to-hook-up-a-delegate-using-reflection.md)|<span data-ttu-id="4b50d-159">메서드의 대리자를 만들고 대리자를 이벤트에 후크하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-159">Explains how to create a delegate for a method and hook the delegate up to an event.</span></span> <span data-ttu-id="4b50d-160">런타임에 <xref:System.Reflection.Emit.DynamicMethod>를 사용하여 이벤트 처리 메서드를 만드는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-160">Explains how to create an event-handling method at run time using <xref:System.Reflection.Emit.DynamicMethod>.</span></span>|  
|[<span data-ttu-id="4b50d-161">동적 메서드 및 어셈블리 내보내기</span><span class="sxs-lookup"><span data-stu-id="4b50d-161">Emitting Dynamic Methods and Assemblies</span></span>](emitting-dynamic-methods-and-assemblies.md)|<span data-ttu-id="4b50d-162">동적 어셈블리 및 동적 메서드를 생성하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="4b50d-162">Explains how to generate dynamic assemblies and dynamic methods.</span></span>|  
  
## <a name="reference"></a><span data-ttu-id="4b50d-163">참조</span><span class="sxs-lookup"><span data-stu-id="4b50d-163">Reference</span></span>  

<xref:System.Type?displayProperty=nameWithType>  
  
<xref:System.Reflection>  
  
<xref:System.Reflection.Emit>  
