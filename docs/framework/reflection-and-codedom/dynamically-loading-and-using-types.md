---
title: "动态加载和使用类型"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
- cpp
helpviewer_keywords:
- late binding, about late binding
- early binding
- dynamically loading and using types
- implicit late binding
- reflection, dynamically using types
ms.assetid: db985bec-5942-40ec-b13a-771ae98623dc
caps.latest.revision: "15"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: 0b924f1c1b46eb132070b6d582cf065f38a8a600
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/22/2017
---
# <a name="dynamically-loading-and-using-types"></a><span data-ttu-id="d040d-102">动态加载和使用类型</span><span class="sxs-lookup"><span data-stu-id="d040d-102">Dynamically Loading and Using Types</span></span>
<span data-ttu-id="d040d-103">反射提供语言编译器（如 [!INCLUDE[vbprvbext](../../../includes/vbprvbext-md.md)] 和 JScript）为实现隐式后期绑定所使用的基础结构。</span><span class="sxs-lookup"><span data-stu-id="d040d-103">Reflection provides infrastructure used by language compilers such as [!INCLUDE[vbprvbext](../../../includes/vbprvbext-md.md)] and JScript to implement implicit late binding.</span></span> <span data-ttu-id="d040d-104">声明与唯一指定的类型相对应，绑定是查找声明（即实现）的过程。</span><span class="sxs-lookup"><span data-stu-id="d040d-104">Binding is the process of locating the declaration (that is, the implementation) that corresponds to a uniquely specified type.</span></span> <span data-ttu-id="d040d-105">运行时（而非编译时）发生此进程就称为后期绑定。</span><span class="sxs-lookup"><span data-stu-id="d040d-105">When this process occurs at run time rather than at compile time, it is called late binding.</span></span> <span data-ttu-id="d040d-106">使用 [!INCLUDE[vbprvblong](../../../includes/vbprvblong-md.md)] 能够在代码中使用隐式后期绑定；Visual Basic 编译器会调用一种帮助程序方法，该方法使用反射来获取对象类型。</span><span class="sxs-lookup"><span data-stu-id="d040d-106">[!INCLUDE[vbprvblong](../../../includes/vbprvblong-md.md)] allows you to use implicit late binding in your code; the Visual Basic compiler calls a helper method that uses reflection to obtain the object type.</span></span> <span data-ttu-id="d040d-107">传递给帮助程序方法的参数会导致在运行时调用相应方法。</span><span class="sxs-lookup"><span data-stu-id="d040d-107">The arguments passed to the helper method cause the appropriate method to be invoked at run time.</span></span> <span data-ttu-id="d040d-108">这些参数是在其上调用方法的实例（对象）、被调用方法的名称（字符串）和传递给被调用方法的参数（对象数组）。</span><span class="sxs-lookup"><span data-stu-id="d040d-108">These arguments are the instance (an object) on which to invoke the method, the name of the invoked method (a string), and the arguments passed to the invoked method (an array of objects).</span></span>  
  
 <span data-ttu-id="d040d-109">在以下示例中，Visual Basic 编译器以隐式方式使用反射对某个对象调用一种方法，该对象的类型在编译时未知。</span><span class="sxs-lookup"><span data-stu-id="d040d-109">In the following example, the Visual Basic compiler uses reflection implicitly to call a method on an object whose type is not known at compile time.</span></span> <span data-ttu-id="d040d-110">HelloWorld 类具有 PrintHello 方法，该方法可以打印输出“Hello World”，且该文本与传递给 PrintHello 方法的一些文本相关联。</span><span class="sxs-lookup"><span data-stu-id="d040d-110">A **HelloWorld** class has a **PrintHello** method that prints out "Hello World" concatenated with some text that is passed to the **PrintHello** method.</span></span> <span data-ttu-id="d040d-111">本示例中调用的 PrintHello 方法实际上是 <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>；如果在编译时（早期绑定）而不是在运行时（后期绑定）知道对象的类型 (helloObj)，则 Visual Basic 代码允许调用 PrintHello 方法。</span><span class="sxs-lookup"><span data-stu-id="d040d-111">The **PrintHello** method called in this example is actually a <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>; the Visual Basic code allows the **PrintHello** method to be invoked as if the type of the object (helloObj) were known at compile time (early binding) rather than at run time (late binding).</span></span>  
  
```  
Imports System  
Module Hello  
    Sub Main()  
        ' Sets up the variable.  
        Dim helloObj As Object  
        ' Creates the object.  
        helloObj = new HelloWorld()  
        ' Invokes the print method as if it was early bound  
        ' even though it is really late bound.  
        helloObj.PrintHello("Visual Basic Late Bound")  
    End Sub  
End Module  
```  
  
## <a name="custom-binding"></a><span data-ttu-id="d040d-112">自定义绑定</span><span class="sxs-lookup"><span data-stu-id="d040d-112">Custom Binding</span></span>  
 <span data-ttu-id="d040d-113">除了被编译器隐式用于后期绑定之外，反射还可在代码中显式用于完成后期绑定。</span><span class="sxs-lookup"><span data-stu-id="d040d-113">In addition to being used implicitly by compilers for late binding, reflection can be used explicitly in code to accomplish late binding.</span></span>  
  
 <span data-ttu-id="d040d-114">[公共语言运行时](../../../docs/standard/clr.md)支持多种编程语言，而且这些语言的绑定规则各不相同。</span><span class="sxs-lookup"><span data-stu-id="d040d-114">The [common language runtime](../../../docs/standard/clr.md) supports multiple programming languages, and the binding rules of these languages differ.</span></span> <span data-ttu-id="d040d-115">在早期绑定的情况下，代码生成器可以完全控制此绑定。</span><span class="sxs-lookup"><span data-stu-id="d040d-115">In the early-bound case, code generators can completely control this binding.</span></span> <span data-ttu-id="d040d-116">但是在通过反射实现的后期绑定中，必须由自定义绑定来控制该绑定。</span><span class="sxs-lookup"><span data-stu-id="d040d-116">However, in late binding through reflection, binding must be controlled by customized binding.</span></span> <span data-ttu-id="d040d-117"><xref:System.Reflection.Binder> 类提供对成员选择和调用的自定义控制。</span><span class="sxs-lookup"><span data-stu-id="d040d-117">The <xref:System.Reflection.Binder> class provides custom control of member selection and invocation.</span></span>  
  
 <span data-ttu-id="d040d-118">使用自定义绑定可以在运行时加载程序集、获取该程序集中有关类型的信息、指定所需类型，并在之后调用该类型上的方法或访问该类型上的字段或属性。</span><span class="sxs-lookup"><span data-stu-id="d040d-118">Using custom binding, you can load an assembly at run time, obtain information about types in that assembly, specify the type that you want, and then invoke methods or access fields or properties on that type.</span></span> <span data-ttu-id="d040d-119">如果在编译时不知道对象的类型，则此方法非常有用，例如当对象类型取决于用户输入时。</span><span class="sxs-lookup"><span data-stu-id="d040d-119">This technique is useful if you do not know an object's type at compile time, such as when the object type is dependent on user input.</span></span>  
  
 <span data-ttu-id="d040d-120">下面的示例演示了一个简单的自定义联编程序，其中不提供参数类型转换。</span><span class="sxs-lookup"><span data-stu-id="d040d-120">The following example demonstrates a simple custom binder that provides no argument type conversion.</span></span> <span data-ttu-id="d040d-121">`Simple_Type.dll` 的代码位于示例主体之前。</span><span class="sxs-lookup"><span data-stu-id="d040d-121">Code for `Simple_Type.dll` precedes the main example.</span></span> <span data-ttu-id="d040d-122">务必生成 `Simple_Type.dll`，然后运行时在项目中包含对它的引用。</span><span class="sxs-lookup"><span data-stu-id="d040d-122">Be sure to build `Simple_Type.dll` and then include a reference to it in the project at build time.</span></span>  
  
 [!code-cpp[Conceptual.Types.Dynamic#1](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.types.dynamic/cpp/source1.cpp#1)]
 [!code-csharp[Conceptual.Types.Dynamic#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.dynamic/cs/source1.cs#1)]
 [!code-vb[Conceptual.Types.Dynamic#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.dynamic/vb/source1.vb#1)]  
  
### <a name="invokemember-and-createinstance"></a><span data-ttu-id="d040d-123">InvokeMember 和 CreateInstance</span><span class="sxs-lookup"><span data-stu-id="d040d-123">InvokeMember and CreateInstance</span></span>  
 <span data-ttu-id="d040d-124">使用 <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> 调用类型的成员。</span><span class="sxs-lookup"><span data-stu-id="d040d-124">Use <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> to invoke a member of a type.</span></span> <span data-ttu-id="d040d-125">InvokeMember 可以创建指定类型的新实例，而各种类的 CreateInstance 方法（例如 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 和 <xref:System.Reflection.Assembly.CreateInstance%2A?displayProperty=nameWithType>）是 InvokeMember 的专用形式。</span><span class="sxs-lookup"><span data-stu-id="d040d-125">The **CreateInstance** methods of various classes, such as <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> and <xref:System.Reflection.Assembly.CreateInstance%2A?displayProperty=nameWithType>, are specialized forms of **InvokeMember** that create new instances of the specified type.</span></span> <span data-ttu-id="d040d-126">Binder 类可在这些方法中用于重载解析和参数强制转换。</span><span class="sxs-lookup"><span data-stu-id="d040d-126">The **Binder** class is used for overload resolution and argument coercion in these methods.</span></span>  
  
 <span data-ttu-id="d040d-127">下面的示例演示了参数强制转换（类型转换）和成员选择的三种可能的组合方式。</span><span class="sxs-lookup"><span data-stu-id="d040d-127">The following example shows the three possible combinations of argument coercion (type conversion) and member selection.</span></span> <span data-ttu-id="d040d-128">在第 1 个例子中，无需进行参数强制转换或成员选择。</span><span class="sxs-lookup"><span data-stu-id="d040d-128">In Case 1, no argument coercion or member selection is needed.</span></span> <span data-ttu-id="d040d-129">在第 2 个例子中，只需进行成员选择。</span><span class="sxs-lookup"><span data-stu-id="d040d-129">In Case 2, only member selection is needed.</span></span> <span data-ttu-id="d040d-130">在第 3 种情况下，只需进行参数强制转换。</span><span class="sxs-lookup"><span data-stu-id="d040d-130">In Case 3, only argument coercion is needed.</span></span>  
  
 [!code-cpp[Conceptual.Types.Dynamic#2](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.types.dynamic/cpp/source2.cpp#2)]
 [!code-csharp[Conceptual.Types.Dynamic#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.dynamic/cs/source2.cs#2)]
 [!code-vb[Conceptual.Types.Dynamic#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.dynamic/vb/source2.vb#2)]  
  
 <span data-ttu-id="d040d-131">当有多个具有相同名称的成员可用时，需进行重载解析。</span><span class="sxs-lookup"><span data-stu-id="d040d-131">Overload resolution is needed when more than one member with the same name is available.</span></span> <span data-ttu-id="d040d-132"><xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> 和 <xref:System.Reflection.Binder.BindToField%2A?displayProperty=nameWithType> 方法可用于解析对单个成员的绑定。</span><span class="sxs-lookup"><span data-stu-id="d040d-132">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.Binder.BindToField%2A?displayProperty=nameWithType> methods are used to resolve binding to a single member.</span></span> <span data-ttu-id="d040d-133">Binder.BindToMethod 还通过 get 和 set 属性访问器提供属性解析。</span><span class="sxs-lookup"><span data-stu-id="d040d-133">**Binder.BindToMethod** also provides property resolution through the **get** and **set** property accessors.</span></span>  
  
 <span data-ttu-id="d040d-134">BindToMethod 返回 <xref:System.Reflection.MethodBase> 供调用，如果不可能发生此类调用，则返回空引用（在 Visual Basic 中则返回 Nothing）。</span><span class="sxs-lookup"><span data-stu-id="d040d-134">**BindToMethod** returns the <xref:System.Reflection.MethodBase> to invoke, or a null reference (**Nothing** in Visual Basic) if no such invocation is possible.</span></span> <span data-ttu-id="d040d-135">MethodBase 返回值不必是 match 参数中包含的值之一，虽然通常情况下都是这样。</span><span class="sxs-lookup"><span data-stu-id="d040d-135">The **MethodBase** return value need not be one of those contained in the *match* parameter, although that is the usual case.</span></span>  
  
 <span data-ttu-id="d040d-136">存在 ByRef 参数时，调用方可能想将其恢复。</span><span class="sxs-lookup"><span data-stu-id="d040d-136">When ByRef arguments are present, the caller might want to get them back.</span></span> <span data-ttu-id="d040d-137">因此，如果 BindToMethod 已操作参数数组，联编程序允许客户端将参数数组映射回其原始形式。</span><span class="sxs-lookup"><span data-stu-id="d040d-137">Therefore, **Binder** allows a client to map the array of arguments back to its original form if **BindToMethod** has manipulated the argument array.</span></span> <span data-ttu-id="d040d-138">为此，调用方必须确保参数顺序不变。</span><span class="sxs-lookup"><span data-stu-id="d040d-138">In order to do this, the caller must be guaranteed that the order of the arguments is unchanged.</span></span> <span data-ttu-id="d040d-139">按名称传递参数时，联编程序会对参数数组重新排序，该顺序即调用方所见顺序。</span><span class="sxs-lookup"><span data-stu-id="d040d-139">When arguments are passed by name, **Binder** reorders the argument array, and that is what the caller sees.</span></span> <span data-ttu-id="d040d-140">有关更多信息，请参见<xref:System.Reflection.Binder.ReorderArgumentArray%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d040d-140">For more information, see <xref:System.Reflection.Binder.ReorderArgumentArray%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d040d-141">可用成员集是在类型或任何基类型中定义的成员。</span><span class="sxs-lookup"><span data-stu-id="d040d-141">The set of available members are those members defined in the type or any base type.</span></span> <span data-ttu-id="d040d-142">如果指定了 <xref:System.Reflection.BindingFlags>，则会将所有可访问的成员返回到该集中。</span><span class="sxs-lookup"><span data-stu-id="d040d-142">If <xref:System.Reflection.BindingFlags> is specified, members of any accessibility will be returned in the set.</span></span> <span data-ttu-id="d040d-143">如果未指定 BindingFlags.NonPublic，则联编程序必须强制实施可访问性规则。</span><span class="sxs-lookup"><span data-stu-id="d040d-143">If **BindingFlags.NonPublic** is not specified, the binder must enforce accessibility rules.</span></span> <span data-ttu-id="d040d-144">指定公共或非公共绑定标志时，必须同时指定实例或静态绑定标志，否则不会返回任何成员。</span><span class="sxs-lookup"><span data-stu-id="d040d-144">When specifying the **Public** or **NonPublic** binding flag, you must also specify the **Instance** or **Static** binding flag, or no members will be returned.</span></span>  
  
 <span data-ttu-id="d040d-145">如果给定名称只有一个成员，则无需回调，已在该方法上完成绑定。</span><span class="sxs-lookup"><span data-stu-id="d040d-145">If there is only one member of the given name, no callback is necessary, and binding is done on that method.</span></span> <span data-ttu-id="d040d-146">第 1 个代码示例演示了这种情况：只有一种 PrintBob 方法可用，因此无需回调。</span><span class="sxs-lookup"><span data-stu-id="d040d-146">Case 1 of the code example illustrates this point: Only one **PrintBob** method is available, and therefore no callback is needed.</span></span>  
  
 <span data-ttu-id="d040d-147">如果可用集中存在多个成员，则所有方法都会传递给 BindToMethod，让它来选择适当的方法并返回结果。</span><span class="sxs-lookup"><span data-stu-id="d040d-147">If there is more than one member in the available set, all these methods are passed to **BindToMethod**, which selects the appropriate method and returns it.</span></span> <span data-ttu-id="d040d-148">第 2 个代码示例中，有两个名为 PrintValue 的方法。</span><span class="sxs-lookup"><span data-stu-id="d040d-148">In Case 2 of the code example, there are two methods named **PrintValue**.</span></span> <span data-ttu-id="d040d-149">通过调用 BindToMethod 选择适当的方法。</span><span class="sxs-lookup"><span data-stu-id="d040d-149">The appropriate method is selected by the call to **BindToMethod**.</span></span>  
  
 <span data-ttu-id="d040d-150"><xref:System.Reflection.Binder.ChangeType%2A> 执行参数强制转换（类型转换），将实参转换为所选方法的形参类型。</span><span class="sxs-lookup"><span data-stu-id="d040d-150"><xref:System.Reflection.Binder.ChangeType%2A> performs argument coercion (type conversion), which converts the actual arguments to the type of the formal arguments of the selected method.</span></span> <span data-ttu-id="d040d-151">会为每个参数调用 ChangeType，即使类型完全匹配。</span><span class="sxs-lookup"><span data-stu-id="d040d-151">**ChangeType** is called for every argument even if the types match exactly.</span></span>  
  
 <span data-ttu-id="d040d-152">第 3 个代码示例中，将值为“5.5”的字符串类型的实参传递给了具有 Double 类型形参的方法。</span><span class="sxs-lookup"><span data-stu-id="d040d-152">In Case 3 of the code example, an actual argument of type **String** with a value of "5.5" is passed to a method with a formal argument of type **Double**.</span></span> <span data-ttu-id="d040d-153">字符串值“5.5”必须转换成 double 值，调用才能成功。</span><span class="sxs-lookup"><span data-stu-id="d040d-153">For the invocation to succeed, the string value "5.5" must be converted to a double value.</span></span> <span data-ttu-id="d040d-154">ChangeType 执行此转换。</span><span class="sxs-lookup"><span data-stu-id="d040d-154">**ChangeType** performs this conversion.</span></span>  
  
 <span data-ttu-id="d040d-155">ChangeType 只执行无损转换或[扩大强制转换](../../../docs/standard/base-types/type-conversion.md)，如下表所示。</span><span class="sxs-lookup"><span data-stu-id="d040d-155">**ChangeType** performs only lossless or [widening coercions](../../../docs/standard/base-types/type-conversion.md), as shown in the following table.</span></span>  
  
|<span data-ttu-id="d040d-156">源类型</span><span class="sxs-lookup"><span data-stu-id="d040d-156">Source type</span></span>|<span data-ttu-id="d040d-157">目标类型</span><span class="sxs-lookup"><span data-stu-id="d040d-157">Target type</span></span>|  
|-----------------|-----------------|  
|<span data-ttu-id="d040d-158">任何类型</span><span class="sxs-lookup"><span data-stu-id="d040d-158">Any type</span></span>|<span data-ttu-id="d040d-159">其基类型</span><span class="sxs-lookup"><span data-stu-id="d040d-159">Its base type</span></span>|  
|<span data-ttu-id="d040d-160">任何类型</span><span class="sxs-lookup"><span data-stu-id="d040d-160">Any type</span></span>|<span data-ttu-id="d040d-161">实现的接口</span><span class="sxs-lookup"><span data-stu-id="d040d-161">Interface it implements</span></span>|  
|<span data-ttu-id="d040d-162">Char</span><span class="sxs-lookup"><span data-stu-id="d040d-162">Char</span></span>|<span data-ttu-id="d040d-163">UInt16、UInt32、Int32、UInt64、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="d040d-163">UInt16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="d040d-164">Byte</span><span class="sxs-lookup"><span data-stu-id="d040d-164">Byte</span></span>|<span data-ttu-id="d040d-165">Char、UInt16、Int16、UInt32、Int32、UInt64、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="d040d-165">Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="d040d-166">SByte</span><span class="sxs-lookup"><span data-stu-id="d040d-166">SByte</span></span>|<span data-ttu-id="d040d-167">Int16、Int32、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="d040d-167">Int16, Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="d040d-168">UInt16</span><span class="sxs-lookup"><span data-stu-id="d040d-168">UInt16</span></span>|<span data-ttu-id="d040d-169">UInt32、Int32、UInt64、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="d040d-169">UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="d040d-170">Int16</span><span class="sxs-lookup"><span data-stu-id="d040d-170">Int16</span></span>|<span data-ttu-id="d040d-171">Int32、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="d040d-171">Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="d040d-172">UInt32</span><span class="sxs-lookup"><span data-stu-id="d040d-172">UInt32</span></span>|<span data-ttu-id="d040d-173">UInt64、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="d040d-173">UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="d040d-174">Int32</span><span class="sxs-lookup"><span data-stu-id="d040d-174">Int32</span></span>|<span data-ttu-id="d040d-175">Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="d040d-175">Int64, Single, Double</span></span>|  
|<span data-ttu-id="d040d-176">UInt64</span><span class="sxs-lookup"><span data-stu-id="d040d-176">UInt64</span></span>|<span data-ttu-id="d040d-177">Single、Double</span><span class="sxs-lookup"><span data-stu-id="d040d-177">Single, Double</span></span>|  
|<span data-ttu-id="d040d-178">Int64</span><span class="sxs-lookup"><span data-stu-id="d040d-178">Int64</span></span>|<span data-ttu-id="d040d-179">Single、Double</span><span class="sxs-lookup"><span data-stu-id="d040d-179">Single, Double</span></span>|  
|<span data-ttu-id="d040d-180">Single</span><span class="sxs-lookup"><span data-stu-id="d040d-180">Single</span></span>|<span data-ttu-id="d040d-181">Double</span><span class="sxs-lookup"><span data-stu-id="d040d-181">Double</span></span>|  
|<span data-ttu-id="d040d-182">非引用类型</span><span class="sxs-lookup"><span data-stu-id="d040d-182">Nonreference type</span></span>|<span data-ttu-id="d040d-183">引用类型</span><span class="sxs-lookup"><span data-stu-id="d040d-183">Reference type</span></span>|  
  
 <span data-ttu-id="d040d-184"><xref:System.Type> 类具有 Get 方法，该方法使用联编程序类型的参数来解析对特定成员的引用。</span><span class="sxs-lookup"><span data-stu-id="d040d-184">The <xref:System.Type> class has **Get** methods that use parameters of type **Binder** to resolve references to a particular member.</span></span> <span data-ttu-id="d040d-185"><xref:System.Type.GetConstructor%2A?displayProperty=nameWithType>、<xref:System.Type.GetMethod%2A?displayProperty=nameWithType> 和 <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> 通过提供成员的签名信息来搜索当前类型的特定成员。</span><span class="sxs-lookup"><span data-stu-id="d040d-185"><xref:System.Type.GetConstructor%2A?displayProperty=nameWithType>, <xref:System.Type.GetMethod%2A?displayProperty=nameWithType>, and <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> search for a particular member of the current type by providing signature information for that member.</span></span> <span data-ttu-id="d040d-186">回调 <xref:System.Reflection.Binder.SelectMethod%2A?displayProperty=nameWithType> 和 <xref:System.Reflection.Binder.SelectProperty%2A?displayProperty=nameWithType> 以选择适当方法的给定签名信息。</span><span class="sxs-lookup"><span data-stu-id="d040d-186"><xref:System.Reflection.Binder.SelectMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.Binder.SelectProperty%2A?displayProperty=nameWithType> are called back on to select the given signature information of the appropriate methods.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d040d-187">请参阅</span><span class="sxs-lookup"><span data-stu-id="d040d-187">See Also</span></span>  
 <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>  
 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>  
 [<span data-ttu-id="d040d-188">查看类型信息</span><span class="sxs-lookup"><span data-stu-id="d040d-188">Viewing Type Information</span></span>](../../../docs/framework/reflection-and-codedom/viewing-type-information.md)  
 [<span data-ttu-id="d040d-189">.NET Framework 中的类型转换</span><span class="sxs-lookup"><span data-stu-id="d040d-189">Type Conversion in the .NET Framework</span></span>](../../../docs/standard/base-types/type-conversion.md)
