---
title: 在 UI 自动化客户端中缓存
ms.date: 03/30/2017
helpviewer_keywords:
- UI Automation caching in clients
- caching, UI Automation clients
ms.assetid: 94c15031-4975-43cc-bcd5-c9439ed21c9c
author: Xansky
ms.author: mhopkins
manager: markl
ms.openlocfilehash: fd695678b8bb30418899786e9670bb8274f9d751
ms.sourcegitcommit: ad99773e5e45068ce03b99518008397e1299e0d1
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/24/2018
ms.locfileid: "47027251"
---
# <a name="caching-in-ui-automation-clients"></a><span data-ttu-id="f0f5f-102">在 UI 自动化客户端中缓存</span><span class="sxs-lookup"><span data-stu-id="f0f5f-102">Caching in UI Automation Clients</span></span>
> [!NOTE]
>  <span data-ttu-id="f0f5f-103">本文档适用于想要使用 [!INCLUDE[TLA2#tla_uiautomation](../../../includes/tla2sharptla-uiautomation-md.md)] 命名空间中定义的托管 <xref:System.Windows.Automation> 类的 .NET Framework 开发人员。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-103">This documentation is intended for .NET Framework developers who want to use the managed [!INCLUDE[TLA2#tla_uiautomation](../../../includes/tla2sharptla-uiautomation-md.md)] classes defined in the <xref:System.Windows.Automation> namespace.</span></span> <span data-ttu-id="f0f5f-104">有关最新信息[!INCLUDE[TLA2#tla_uiautomation](../../../includes/tla2sharptla-uiautomation-md.md)]，请参阅[Windows 自动化 API: UI 自动化](https://go.microsoft.com/fwlink/?LinkID=156746)。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-104">For the latest information about [!INCLUDE[TLA2#tla_uiautomation](../../../includes/tla2sharptla-uiautomation-md.md)], see [Windows Automation API: UI Automation](https://go.microsoft.com/fwlink/?LinkID=156746).</span></span>  
  
 <span data-ttu-id="f0f5f-105">本主题介绍 [!INCLUDE[TLA2#tla_uiautomation](../../../includes/tla2sharptla-uiautomation-md.md)] 属性和控件模式的缓存。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-105">This topic introduces caching of [!INCLUDE[TLA2#tla_uiautomation](../../../includes/tla2sharptla-uiautomation-md.md)] properties and control patterns.</span></span>  
  
 <span data-ttu-id="f0f5f-106">在 [!INCLUDE[TLA2#tla_uiautomation](../../../includes/tla2sharptla-uiautomation-md.md)]中，缓存意味着预提取的数据。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-106">In [!INCLUDE[TLA2#tla_uiautomation](../../../includes/tla2sharptla-uiautomation-md.md)], caching means pre-fetching of data.</span></span> <span data-ttu-id="f0f5f-107">然后，无需进一步的跨进程通信即可访问数据。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-107">The data can then be accessed without further cross-process communication.</span></span> <span data-ttu-id="f0f5f-108">UI 自动化客户端应用程序通常使用缓存来批量检索属性和控件模式。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-108">Caching is typically used by UI Automation client applications to retrieve properties and control patterns in bulk.</span></span> <span data-ttu-id="f0f5f-109">然后，根据需要从缓存中检索信息。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-109">Information is then retrieved from the cache as needed.</span></span> <span data-ttu-id="f0f5f-110">应用程序会定期更新缓存，通常使为了响应表明 [!INCLUDE[TLA#tla_ui](../../../includes/tlasharptla-ui-md.md)] 中的内容发生更改的事件。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-110">The application updates the cache periodically, usually in response to events signifying that something in the [!INCLUDE[TLA#tla_ui](../../../includes/tlasharptla-ui-md.md)] has changed.</span></span>  
  
 <span data-ttu-id="f0f5f-111">缓存的优点是最为明显与 Windows Presentation Foundation (WPF) 控件和具有服务器端 UI 自动化提供程序的自定义控件。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-111">The benefits of caching are most noticeable with Windows Presentation Foundation (WPF) controls and custom controls that have server-side UI Automation providers.</span></span> <span data-ttu-id="f0f5f-112">在访问客户端提供程序（如 [!INCLUDE[TLA2#tla_win32](../../../includes/tla2sharptla-win32-md.md)] 控件的默认提供程序）时，其优势稍小一些。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-112">There is less benefit when accessing client-side providers such as the default providers for [!INCLUDE[TLA2#tla_win32](../../../includes/tla2sharptla-win32-md.md)] controls.</span></span>  
  
 <span data-ttu-id="f0f5f-113">当应用程序激活 <xref:System.Windows.Automation.CacheRequest> ，然后使用任何返回 <xref:System.Windows.Automation.AutomationElement>的方法或属性时，就会进行缓存；例如， <xref:System.Windows.Automation.AutomationElement.FindFirst%2A>和 <xref:System.Windows.Automation.AutomationElement.FindAll%2A>。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-113">Caching occurs when the application activates a <xref:System.Windows.Automation.CacheRequest> and then uses any method or property that returns an <xref:System.Windows.Automation.AutomationElement>; for example, <xref:System.Windows.Automation.AutomationElement.FindFirst%2A>, <xref:System.Windows.Automation.AutomationElement.FindAll%2A>.</span></span> <span data-ttu-id="f0f5f-114">方法<xref:System.Windows.Automation.TreeWalker>类是个例外; 如果仅进行缓存<xref:System.Windows.Automation.CacheRequest>指定为参数 (例如， <xref:System.Windows.Automation.TreeWalker.GetFirstChild%28System.Windows.Automation.AutomationElement%2CSystem.Windows.Automation.CacheRequest%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-114">The methods of the <xref:System.Windows.Automation.TreeWalker> class are an exception; caching is only done if a <xref:System.Windows.Automation.CacheRequest> is specified as a parameter (for example, <xref:System.Windows.Automation.TreeWalker.GetFirstChild%28System.Windows.Automation.AutomationElement%2CSystem.Windows.Automation.CacheRequest%29?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f0f5f-115">如果 <xref:System.Windows.Automation.CacheRequest> 处于活动状态时订阅事件，也会进行缓存。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-115">Caching also occurs when you subscribe to an event while a <xref:System.Windows.Automation.CacheRequest> is active.</span></span> <span data-ttu-id="f0f5f-116">作为事件来源传递到事件处理程序的 <xref:System.Windows.Automation.AutomationElement> 包含由原始 <xref:System.Windows.Automation.CacheRequest>指定的缓存属性和模式。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-116">The <xref:System.Windows.Automation.AutomationElement> passed to your event handler as the source of an event contains the cached properties and patterns specified by the original <xref:System.Windows.Automation.CacheRequest>.</span></span> <span data-ttu-id="f0f5f-117">在订阅事件后对 <xref:System.Windows.Automation.CacheRequest> 进行的任何更改都没有影响。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-117">Any changes made to the <xref:System.Windows.Automation.CacheRequest> after you subscribe to the event have no effect.</span></span>  
  
 <span data-ttu-id="f0f5f-118">可以缓存元素的 [!INCLUDE[TLA2#tla_uiautomation](../../../includes/tla2sharptla-uiautomation-md.md)] 属性和控件模式。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-118">The [!INCLUDE[TLA2#tla_uiautomation](../../../includes/tla2sharptla-uiautomation-md.md)] properties and control patterns of an element can be cached.</span></span>  
  
<a name="Options_for_Caching"></a>   
## <a name="options-for-caching"></a><span data-ttu-id="f0f5f-119">缓存选项</span><span class="sxs-lookup"><span data-stu-id="f0f5f-119">Options for Caching</span></span>  
 <span data-ttu-id="f0f5f-120"><xref:System.Windows.Automation.CacheRequest> 指定以下缓存选项。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-120">The <xref:System.Windows.Automation.CacheRequest> specifies the following options for caching.</span></span>  
  
<a name="Properties_to_Cache"></a>   
### <a name="properties-to-cache"></a><span data-ttu-id="f0f5f-121">要缓存的属性</span><span class="sxs-lookup"><span data-stu-id="f0f5f-121">Properties to Cache</span></span>  
 <span data-ttu-id="f0f5f-122">可以通过在激活请求之前为每个属性调用 <xref:System.Windows.Automation.CacheRequest.Add%28System.Windows.Automation.AutomationProperty%29> 来指定要缓存的属性。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-122">You can specify properties to cache by calling <xref:System.Windows.Automation.CacheRequest.Add%28System.Windows.Automation.AutomationProperty%29> for each property before activating the request.</span></span>  
  
<a name="Control_Patterns_to_Cache"></a>   
### <a name="control-patterns-to-cache"></a><span data-ttu-id="f0f5f-123">要缓存的控件模式</span><span class="sxs-lookup"><span data-stu-id="f0f5f-123">Control Patterns to Cache</span></span>  
 <span data-ttu-id="f0f5f-124">可以通过在激活请求之前为每个模式调用 <xref:System.Windows.Automation.CacheRequest.Add%28System.Windows.Automation.AutomationPattern%29> 来指定要缓存的控件模式。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-124">You can specify control patterns to cache by calling <xref:System.Windows.Automation.CacheRequest.Add%28System.Windows.Automation.AutomationPattern%29> for each pattern before activating the request.</span></span> <span data-ttu-id="f0f5f-125">一种模式缓存时，不自动缓存其属性;必须指定想通过使用缓存的属性<xref:System.Windows.Automation.CacheRequest.Add%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-125">When a pattern is cached, its properties are not automatically cached; you must specify the properties you want cached by using <xref:System.Windows.Automation.CacheRequest.Add%2A?displayProperty=nameWithType>.</span></span>  
  
<a name="Scope_of_the_Caching"></a>   
### <a name="scope-and-filtering-of-caching"></a><span data-ttu-id="f0f5f-126">缓存的范围和筛选</span><span class="sxs-lookup"><span data-stu-id="f0f5f-126">Scope and Filtering of Caching</span></span>  
 <span data-ttu-id="f0f5f-127">可以指定元素，其属性和模式，通过设置要缓存<xref:System.Windows.Automation.CacheRequest.TreeScope%2A?displayProperty=nameWithType>激活请求之前的属性。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-127">You can specify the elements whose properties and patterns you want to cache by setting the <xref:System.Windows.Automation.CacheRequest.TreeScope%2A?displayProperty=nameWithType> property before activating the request.</span></span> <span data-ttu-id="f0f5f-128">范围与请求处于活动状态时检索的元素有关。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-128">The scope is relative to the elements that are retrieved while the request is active.</span></span> <span data-ttu-id="f0f5f-129">例如，如果仅设置 <xref:System.Windows.Automation.TreeScope.Children>，然后检索 <xref:System.Windows.Automation.AutomationElement>，则会缓存该元素的子项的属性和模式，但不会缓存该元素本身的属性和模式。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-129">For example, if you set only <xref:System.Windows.Automation.TreeScope.Children>, and then retrieve an <xref:System.Windows.Automation.AutomationElement>, the properties and patterns of children of that element are cached, but not those of the element itself.</span></span> <span data-ttu-id="f0f5f-130">若要确保对检索的元素本身进行缓存，则必须在 <xref:System.Windows.Automation.TreeScope.Element> 属性中包括 <xref:System.Windows.Automation.CacheRequest.TreeScope%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-130">To ensure that caching is done for the retrieved element itself, you must include <xref:System.Windows.Automation.TreeScope.Element> in the <xref:System.Windows.Automation.CacheRequest.TreeScope%2A> property.</span></span> <span data-ttu-id="f0f5f-131">不可将范围设置为 <xref:System.Windows.Automation.TreeScope.Parent> 或 <xref:System.Windows.Automation.TreeScope.Ancestors>。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-131">It is not possible to set the scope to <xref:System.Windows.Automation.TreeScope.Parent> or <xref:System.Windows.Automation.TreeScope.Ancestors>.</span></span> <span data-ttu-id="f0f5f-132">但是，在缓存了子元素后，就可以缓存父元素；请参阅本主题中的“检索缓存的子项和父项”。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-132">However, a parent element can be cached when a child element is cached; see Retrieving Cached Children and Parents in this topic.</span></span>  
  
 <span data-ttu-id="f0f5f-133">缓存的范围也会影响<xref:System.Windows.Automation.CacheRequest.TreeFilter%2A?displayProperty=nameWithType>属性。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-133">The extent of caching is also affected by the <xref:System.Windows.Automation.CacheRequest.TreeFilter%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="f0f5f-134">默认情况下，只会对出现在 [!INCLUDE[TLA2#tla_uiautomation](../../../includes/tla2sharptla-uiautomation-md.md)] 树的控件视图中的元素执行缓存。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-134">By default, caching is performed only for elements that appear in the control view of the [!INCLUDE[TLA2#tla_uiautomation](../../../includes/tla2sharptla-uiautomation-md.md)] tree.</span></span> <span data-ttu-id="f0f5f-135">但是，可以更改此属性以将缓存应用于所有元素，或者只应用于出现在内容视图中的元素。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-135">However, you can change this property to apply caching to all elements, or only to elements that appear in the content view.</span></span>  
  
<a name="Strength_of_the_Element_References"></a>   
### <a name="strength-of-the-element-references"></a><span data-ttu-id="f0f5f-136">元素引用的强度</span><span class="sxs-lookup"><span data-stu-id="f0f5f-136">Strength of the Element References</span></span>  
 <span data-ttu-id="f0f5f-137">在检索 <xref:System.Windows.Automation.AutomationElement>时，默认情况下可以访问该元素的所有属性和模式，包括那些未缓存的属性和模式。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-137">When you retrieve an <xref:System.Windows.Automation.AutomationElement>, by default you have access to all properties and patterns of that element, including those that were not cached.</span></span> <span data-ttu-id="f0f5f-138">但是，为了提高效率，可以通过将 <xref:System.Windows.Automation.CacheRequest.AutomationElementMode%2A> 的 <xref:System.Windows.Automation.CacheRequest> 属性设置为 <xref:System.Windows.Automation.AutomationElementMode.None>来指定元素引用只引用缓存的数据。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-138">However, for greater efficiency you can specify that the reference to the element refers to cached data only, by setting the <xref:System.Windows.Automation.CacheRequest.AutomationElementMode%2A> property of the <xref:System.Windows.Automation.CacheRequest> to <xref:System.Windows.Automation.AutomationElementMode.None>.</span></span> <span data-ttu-id="f0f5f-139">在这种情况下，你没有权限访问所检索元素的任何未缓存属性和模式。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-139">In this case, you do not have access to any non-cached properties and patterns of retrieved elements.</span></span> <span data-ttu-id="f0f5f-140">这意味着你无法通过 <xref:System.Windows.Automation.AutomationElement.GetCurrentPropertyValue%2A> 或者 `Current` 的 <xref:System.Windows.Automation.AutomationElement> 属性或任何控件模式访问任何属性；也无法通过使用 <xref:System.Windows.Automation.AutomationElement.GetCurrentPattern%2A> 或 <xref:System.Windows.Automation.AutomationElement.TryGetCurrentPattern%2A>检索模式。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-140">This means that you cannot access any properties through <xref:System.Windows.Automation.AutomationElement.GetCurrentPropertyValue%2A> or the `Current` property of <xref:System.Windows.Automation.AutomationElement> or any control pattern; nor can you retrieve a pattern by using <xref:System.Windows.Automation.AutomationElement.GetCurrentPattern%2A> or <xref:System.Windows.Automation.AutomationElement.TryGetCurrentPattern%2A>.</span></span> <span data-ttu-id="f0f5f-141">在缓存的模式，可以调用方法检索数组属性，如<xref:System.Windows.Automation.SelectionPattern.SelectionPatternInformation.GetSelection%2A?displayProperty=nameWithType>，但不是在控件上执行的操作如<xref:System.Windows.Automation.InvokePattern.Invoke%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-141">On cached patterns, you can call methods that retrieve array properties, such as <xref:System.Windows.Automation.SelectionPattern.SelectionPatternInformation.GetSelection%2A?displayProperty=nameWithType>, but not any that perform actions on the control, such as <xref:System.Windows.Automation.InvokePattern.Invoke%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f0f5f-142">可能无需完全引用对象的应用程序的一个示例是屏幕阅读器，它将预提取窗口中的元素的 <xref:System.Windows.Automation.AutomationElement.AutomationElementInformation.Name%2A> 和 <xref:System.Windows.Automation.AutomationElement.AutomationElementInformation.ControlType%2A> 属性，但不需要 <xref:System.Windows.Automation.AutomationElement> 对象本身。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-142">An example of an application that might not need full references to objects is a screen reader, which would prefetch the <xref:System.Windows.Automation.AutomationElement.AutomationElementInformation.Name%2A> and <xref:System.Windows.Automation.AutomationElement.AutomationElementInformation.ControlType%2A> properties of elements in a window but would not need the <xref:System.Windows.Automation.AutomationElement> objects themselves.</span></span>  
  
<a name="Activating_the_CacheRequest"></a>   
## <a name="activating-the-cacherequest"></a><span data-ttu-id="f0f5f-143">激活 CacheRequest</span><span class="sxs-lookup"><span data-stu-id="f0f5f-143">Activating the CacheRequest</span></span>  
 <span data-ttu-id="f0f5f-144">仅当在 <xref:System.Windows.Automation.AutomationElement> 对于当前线程处于活动状态的情况下检索 <xref:System.Windows.Automation.CacheRequest> 对象时，才会执行缓存。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-144">Caching is performed only when <xref:System.Windows.Automation.AutomationElement> objects are retrieved while a <xref:System.Windows.Automation.CacheRequest> is active for the current thread.</span></span> <span data-ttu-id="f0f5f-145">有两种方法可激活 <xref:System.Windows.Automation.CacheRequest>。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-145">There are two ways to activate a <xref:System.Windows.Automation.CacheRequest>.</span></span>  
  
 <span data-ttu-id="f0f5f-146">通常的方法是调用 <xref:System.Windows.Automation.CacheRequest.Activate%2A>。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-146">The usual way is to call <xref:System.Windows.Automation.CacheRequest.Activate%2A>.</span></span> <span data-ttu-id="f0f5f-147">此方法返回实现 <xref:System.IDisposable>的对象。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-147">This method returns an object that implements <xref:System.IDisposable>.</span></span> <span data-ttu-id="f0f5f-148">只要 <xref:System.IDisposable> 对象存在，请求就将保持活动状态。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-148">The request remains active as long as the <xref:System.IDisposable> object exists.</span></span> <span data-ttu-id="f0f5f-149">控制对象生存期的最简单方法是调用括`using`(C#) 或`Using`(Visual Basic) 块。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-149">The easiest way to control the lifetime of the object is to enclose the call within a `using` (C#) or `Using` (Visual Basic) block.</span></span> <span data-ttu-id="f0f5f-150">这样即使引发异常也能确保请求从堆栈中弹出。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-150">This ensures that the request will be popped from the stack even if an exception is raised.</span></span>  
  
 <span data-ttu-id="f0f5f-151">另一种方法是调用 <xref:System.Windows.Automation.CacheRequest.Push%2A>，此方法在你想要嵌套缓存请求时非常有用。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-151">Another way, which is useful when you wish to nest cache requests, is to call <xref:System.Windows.Automation.CacheRequest.Push%2A>.</span></span> <span data-ttu-id="f0f5f-152">此方法将请求放在堆栈上，并激活请求。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-152">This puts the request on a stack and activates it.</span></span> <span data-ttu-id="f0f5f-153">在 <xref:System.Windows.Automation.CacheRequest.Pop%2A>从堆栈中删除请求之前，请求将保持活动状态。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-153">The request remains active until it is removed from the stack by <xref:System.Windows.Automation.CacheRequest.Pop%2A>.</span></span> <span data-ttu-id="f0f5f-154">如果将另一个请求推入堆栈，该请求将暂时变为非活动状态；只有堆栈顶部的请求才会处于活动状态。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-154">The request becomes temporarily inactive if another request is pushed onto the stack; only the top request on the stack is active.</span></span>  
  
<a name="Retrieving_Cached_Properties"></a>   
## <a name="retrieving-cached-properties"></a><span data-ttu-id="f0f5f-155">检索缓存的属性</span><span class="sxs-lookup"><span data-stu-id="f0f5f-155">Retrieving Cached Properties</span></span>  
 <span data-ttu-id="f0f5f-156">你可以通过以下方法和属性检索元素的缓存属性。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-156">You can retrieve the cached properties of an element through the following methods and properties.</span></span>  
  
-   <xref:System.Windows.Automation.AutomationElement.GetCachedPropertyValue%2A>  
  
-   <xref:System.Windows.Automation.AutomationElement.Cached%2A>  
  
 <span data-ttu-id="f0f5f-157">如果请求的属性不在缓存中，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-157">An exception is raised if the requested property is not in the cache.</span></span>  
  
 <span data-ttu-id="f0f5f-158"><xref:System.Windows.Automation.AutomationElement.Cached%2A>像 <xref:System.Windows.Automation.AutomationElement.Current%2A>，都以结构成员的方式公开各项属性。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-158"><xref:System.Windows.Automation.AutomationElement.Cached%2A>, like <xref:System.Windows.Automation.AutomationElement.Current%2A>, exposes individual properties as members of a structure.</span></span> <span data-ttu-id="f0f5f-159">但是，无需检索此结构；你可以直接访问各项属性。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-159">However, you do not need to retrieve this structure; you can access the individual properties directly.</span></span> <span data-ttu-id="f0f5f-160">例如，可以从 <xref:System.Windows.Automation.AutomationElement.AutomationElementInformation.Name%2A> 中获取 `element.Cached.Name`属性，其中 `element` 为 <xref:System.Windows.Automation.AutomationElement>。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-160">For example, the <xref:System.Windows.Automation.AutomationElement.AutomationElementInformation.Name%2A> property can be obtained from `element.Cached.Name`, where `element` is an <xref:System.Windows.Automation.AutomationElement>.</span></span>  
  
<a name="Retrieving_Cached_Control_Patterns"></a>   
## <a name="retrieving-cached-control-patterns"></a><span data-ttu-id="f0f5f-161">检索缓存的控件模式</span><span class="sxs-lookup"><span data-stu-id="f0f5f-161">Retrieving Cached Control Patterns</span></span>  
 <span data-ttu-id="f0f5f-162">可以通过以下方法检索元素的缓存控件模式。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-162">You can retrieve the cached control patterns of an element through the following methods.</span></span>  
  
-   <xref:System.Windows.Automation.AutomationElement.GetCachedPattern%2A>  
  
-   <xref:System.Windows.Automation.AutomationElement.TryGetCachedPattern%2A>  
  
 <span data-ttu-id="f0f5f-163">如果模式不在缓存中，则 <xref:System.Windows.Automation.AutomationElement.GetCachedPattern%2A> 会引发异常，并且 <xref:System.Windows.Automation.AutomationElement.TryGetCachedPattern%2A> 会返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-163">If the pattern is not in the cache, <xref:System.Windows.Automation.AutomationElement.GetCachedPattern%2A> raises an exception, and <xref:System.Windows.Automation.AutomationElement.TryGetCachedPattern%2A> returns `false`.</span></span>  
  
 <span data-ttu-id="f0f5f-164">可以通过使用模式对象的 `Cached` 属性来检索控件模式的缓存属性。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-164">You can retrieve the cached properties of a control pattern by using the `Cached` property of the pattern object.</span></span> <span data-ttu-id="f0f5f-165">也可以通过 `Current` 属性检索当前值，但只有当检索 <xref:System.Windows.Automation.AutomationElementMode.None> 时未指定 <xref:System.Windows.Automation.AutomationElement> 的情况下才能这样做。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-165">You can also retrieve the current values through the `Current` property, but only if <xref:System.Windows.Automation.AutomationElementMode.None> was not specified when the <xref:System.Windows.Automation.AutomationElement> was retrieved.</span></span> <span data-ttu-id="f0f5f-166">（默认值为<xref:System.Windows.Automation.AutomationElementMode.Full> ，并且此值允许访问当前值。）</span><span class="sxs-lookup"><span data-stu-id="f0f5f-166">(<xref:System.Windows.Automation.AutomationElementMode.Full> is the default value, and this permits access to the current values.)</span></span>  
  
<a name="Retrieving_Cached_Children_and_Parents"></a>   
## <a name="retrieving-cached-children-and-parents"></a><span data-ttu-id="f0f5f-167">检索缓存的子项和父项</span><span class="sxs-lookup"><span data-stu-id="f0f5f-167">Retrieving Cached Children and Parents</span></span>  
 <span data-ttu-id="f0f5f-168">如果检索 <xref:System.Windows.Automation.AutomationElement> 并通过请求的 <xref:System.Windows.Automation.CacheRequest.TreeScope%2A> 属性请求对该元素的子项进行缓存，随后将可以从所检索元素的 <xref:System.Windows.Automation.AutomationElement.CachedChildren%2A> 属性中获取子元素。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-168">When you retrieve an <xref:System.Windows.Automation.AutomationElement> and request caching for children of that element through the <xref:System.Windows.Automation.CacheRequest.TreeScope%2A> property of the request, it is subsequently possible to get the child elements from the <xref:System.Windows.Automation.AutomationElement.CachedChildren%2A> property of the element you retrieved.</span></span>  
  
 <span data-ttu-id="f0f5f-169">如果 <xref:System.Windows.Automation.TreeScope.Element> 已包含在缓存请求的范围内，则随后可从任何子元素的 <xref:System.Windows.Automation.AutomationElement.CachedParent%2A> 属性中获取请求的根元素。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-169">If <xref:System.Windows.Automation.TreeScope.Element> was included in the scope of the cache request, the root element of the request is subsequently available from the <xref:System.Windows.Automation.AutomationElement.CachedParent%2A> property of any of the child elements.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f0f5f-170">无法缓存请求根元素的父项或上级。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-170">You cannot cache parents or ancestors of the root element of the request.</span></span>  
  
<a name="Updating_the_Cache"></a>   
## <a name="updating-the-cache"></a><span data-ttu-id="f0f5f-171">更新缓存</span><span class="sxs-lookup"><span data-stu-id="f0f5f-171">Updating the Cache</span></span>  
 <span data-ttu-id="f0f5f-172">只要 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)]中没有更改，缓存就有效。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-172">The cache is valid only as long as nothing changes in the [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="f0f5f-173">应用程序负责更新缓存，通常是为了响应事件。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-173">Your application is responsible for updating the cache, typically in response to events.</span></span>  
  
 <span data-ttu-id="f0f5f-174">如果在 <xref:System.Windows.Automation.CacheRequest> 处于活动状态时订阅事件，则每次调用事件处理程序委托时都会获得一个使用更新的缓存作为事件源的 <xref:System.Windows.Automation.AutomationElement> 。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-174">If you subscribe to an event while a <xref:System.Windows.Automation.CacheRequest> is active, you obtain an <xref:System.Windows.Automation.AutomationElement> with an updated cache as the source of the event whenever your event-handler delegate is called.</span></span> <span data-ttu-id="f0f5f-175">还可以通过调用 <xref:System.Windows.Automation.AutomationElement.GetUpdatedCache%2A>来更新元素的缓存信息。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-175">You can also update cached information for an element by calling <xref:System.Windows.Automation.AutomationElement.GetUpdatedCache%2A>.</span></span> <span data-ttu-id="f0f5f-176">可以传入原始 <xref:System.Windows.Automation.CacheRequest> 来更新以前缓存的所有信息。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-176">You can pass in the original <xref:System.Windows.Automation.CacheRequest> to update all information that was previously cached.</span></span>  
  
 <span data-ttu-id="f0f5f-177">更新缓存不会更改任何现有 <xref:System.Windows.Automation.AutomationElement> 引用的属性。</span><span class="sxs-lookup"><span data-stu-id="f0f5f-177">Updating the cache does not alter the properties of any existing <xref:System.Windows.Automation.AutomationElement> references.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f0f5f-178">请参阅</span><span class="sxs-lookup"><span data-stu-id="f0f5f-178">See Also</span></span>  
 [<span data-ttu-id="f0f5f-179">客户端的 UI 自动化事件</span><span class="sxs-lookup"><span data-stu-id="f0f5f-179">UI Automation Events for Clients</span></span>](../../../docs/framework/ui-automation/ui-automation-events-for-clients.md)  
 [<span data-ttu-id="f0f5f-180">在 UI 自动化中使用缓存</span><span class="sxs-lookup"><span data-stu-id="f0f5f-180">Use Caching in UI Automation</span></span>](../../../docs/framework/ui-automation/use-caching-in-ui-automation.md)  
 [<span data-ttu-id="f0f5f-181">FetchTimer 示例</span><span class="sxs-lookup"><span data-stu-id="f0f5f-181">FetchTimer Sample</span></span>](https://msdn.microsoft.com/library/5b7d3294-de22-4f24-b2d6-d4785a304b90)
