---
title: 编译器错误 CS1540
ms.date: 07/20/2015
f1_keywords:
- CS1540
helpviewer_keywords:
- CS1540
ms.assetid: f35bbeb9-e2b2-4644-a7e6-cc2dbce1bd44
ms.openlocfilehash: 5ae3975ebe44b0159ee8274fd09998619fd484ca
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/23/2019
ms.locfileid: "54697928"
---
# <a name="compiler-error-cs1540"></a><span data-ttu-id="447f8-102">编译器错误 CS1540</span><span class="sxs-lookup"><span data-stu-id="447f8-102">Compiler Error CS1540</span></span>
<span data-ttu-id="447f8-103">无法通过“type1”类型的限定符访问受保护的成员“member”；限定符必须是“type2”类型（或从该类型派生）</span><span class="sxs-lookup"><span data-stu-id="447f8-103">Cannot access protected member 'member' via a qualifier of type 'type1'; the qualifier must be of type 'type2' (or derived from it)</span></span>  
  
 <span data-ttu-id="447f8-104">派生[类](../../../csharp/language-reference/keywords/class.md)无法通过基类的实例访问其基类的受保护成员。</span><span class="sxs-lookup"><span data-stu-id="447f8-104">A derived [class](../../../csharp/language-reference/keywords/class.md) cannot access protected members of its base class through an instance of the base class.</span></span> <span data-ttu-id="447f8-105">在运行时，派生类中声明的基类的实例可能是另一类型的实例，而后者是由同一基类派生，但与派生类无关的类型。</span><span class="sxs-lookup"><span data-stu-id="447f8-105">An instance of the base class declared in the derived class might, at run time, be an instance of another type that is derived from the same base but is not otherwise related to the derived class.</span></span> <span data-ttu-id="447f8-106">由于受保护的成员仅可由派生类型访问，因此在运行时对受保护成员可能无效的任何访问尝试，都会被编译器标记为无效。</span><span class="sxs-lookup"><span data-stu-id="447f8-106">Because protected members can be accessed only by derived types, any attempts to access protected members that might not be valid at run time are marked by the compiler as not valid.</span></span>  
  
 <span data-ttu-id="447f8-107">在以下示例中的 `Employee` 类中，在编译时 `emp2` 和 `emp3` 都具有类型 `Person`，但在运行时 `emp2` 具有类型 `Manager`。</span><span class="sxs-lookup"><span data-stu-id="447f8-107">In the `Employee` class in the following example, `emp2` and `emp3` both have type `Person` at compile time, but `emp2` has type `Manager` at run time.</span></span> <span data-ttu-id="447f8-108">由于 `Employee` 不是派生自 `Manager`，因此它不能通过 `Manager` 类的实例访问基类的受保护成员 `Person`。</span><span class="sxs-lookup"><span data-stu-id="447f8-108">Because `Employee` is not derived from `Manager`, it cannot access the protected members of the base class, `Person`, through an instance of the `Manager` class.</span></span> <span data-ttu-id="447f8-109">编译器无法确定两个 `Person` 对象的运行时类型。</span><span class="sxs-lookup"><span data-stu-id="447f8-109">The compiler cannot determine what the run-time type of the two `Person` objects will be.</span></span> <span data-ttu-id="447f8-110">因此，来自 `emp2` 的调用和来自 `emp3` 的调用都会导致编译器错误 CS1540。</span><span class="sxs-lookup"><span data-stu-id="447f8-110">Therefore, both the call from `emp2` and the call from `emp3` cause compiler error CS1540.</span></span>  
  
```csharp  
using System;  
using System.Text;  
  
namespace CS1540  
{  
    class Program1  
    {  
        static void Main()  
        {  
            Employee.PreparePayroll();  
        }  
    }  
  
    class Person  
    {  
        protected virtual void CalculatePay()   
        {  
            Console.WriteLine("CalculatePay in Person class.");  
        }  
    }  
  
    class Manager : Person  
    {  
        protected override void CalculatePay()   
        {  
            Console.WriteLine("CalculatePay in Manager class.");   
  
        }  
    }  
  
    class Employee : Person  
    {  
        public static void PreparePayroll()  
        {  
            Employee emp1 = new Employee();  
            Person emp2 = new Manager();  
            Person emp3 = new Employee();  
            // The following line calls the method in the Employee base class,  
            // Person.  
            emp1.CalculatePay();   
  
            // The following lines cause compiler error CS1540. The compiler   
            // cannot determine at compile time what the run-time types of   
            // emp2 and emp3 will be.  
            //emp2.CalculatePay();   
            //emp3.CalculatePay();  
  
        }  
    }  
}  
```  
  
## <a name="see-also"></a><span data-ttu-id="447f8-111">请参阅</span><span class="sxs-lookup"><span data-stu-id="447f8-111">See also</span></span>

- [<span data-ttu-id="447f8-112">继承</span><span class="sxs-lookup"><span data-stu-id="447f8-112">Inheritance</span></span>](../../../csharp/programming-guide/classes-and-structs/inheritance.md)
- [<span data-ttu-id="447f8-113">多态性</span><span class="sxs-lookup"><span data-stu-id="447f8-113">Polymorphism</span></span>](../../../csharp/programming-guide/classes-and-structs/polymorphism.md)
- [<span data-ttu-id="447f8-114">访问修饰符</span><span class="sxs-lookup"><span data-stu-id="447f8-114">Access Modifiers</span></span>](../../../csharp/programming-guide/classes-and-structs/access-modifiers.md)
- [<span data-ttu-id="447f8-115">抽象类、密封类及类成员</span><span class="sxs-lookup"><span data-stu-id="447f8-115">Abstract and Sealed Classes and Class Members</span></span>](../../../csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md)
