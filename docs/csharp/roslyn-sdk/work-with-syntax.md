---
title: 使用 .NET Compiler Platform SDK 语法模型
description: 此概述介绍了用于理解和操作语法节点的类型。
author: billwagner
ms.author: wiwagn
ms.date: 10/15/2017
ms.topic: conceptual
ms.prod: .net
ms.devlang: devlang-csharp
ms.custom: mvc
ms.openlocfilehash: 0230777c59185a6b50d5dac5066efc3afa347f44
ms.sourcegitcommit: b750a8e3979749b214e7e10c82efb0a0524dfcb1
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/10/2018
---
# <a name="work-with-syntax"></a><span data-ttu-id="8d994-103">使用语法</span><span class="sxs-lookup"><span data-stu-id="8d994-103">Work with syntax</span></span>

<span data-ttu-id="8d994-104">“语法树”是一种由编译器 API 公开的基础数据结构。</span><span class="sxs-lookup"><span data-stu-id="8d994-104">The **syntax tree** is a fundamental data structure exposed by the compiler APIs.</span></span> <span data-ttu-id="8d994-105">这些树表示源代码的词法和语法结构。</span><span class="sxs-lookup"><span data-stu-id="8d994-105">These trees represent the lexical and syntactic structure of source code.</span></span> <span data-ttu-id="8d994-106">它们有两个重要用途：</span><span class="sxs-lookup"><span data-stu-id="8d994-106">They serve two important purposes:</span></span>

1. <span data-ttu-id="8d994-107">支持使用工具（如 IDE、加载项、代码分析工具和重构）查看和处理用户项目中源代码的语法结构。</span><span class="sxs-lookup"><span data-stu-id="8d994-107">To allow tools - such as an IDE, add-ins, code analysis tools, and refactorings - to see and process the syntactic structure of source code in a user’s project.</span></span>
2. <span data-ttu-id="8d994-108">支持使用工具（如重构和 IDE）以自然的方式创建、修改和重新排列源代码，而无需直接编辑文本。</span><span class="sxs-lookup"><span data-stu-id="8d994-108">To enable tools - such as refactorings and an IDE - to create, modify, and rearrange source code in a natural manner without having use direct text edits.</span></span> <span data-ttu-id="8d994-109">通过创建和操作语法树，可轻松使用工具创建和重新排列源代码。</span><span class="sxs-lookup"><span data-stu-id="8d994-109">By creating and manipulating trees, tools can easily create and rearrange source code.</span></span>

## <a name="syntax-trees"></a><span data-ttu-id="8d994-110">语法树</span><span class="sxs-lookup"><span data-stu-id="8d994-110">Syntax trees</span></span>

<span data-ttu-id="8d994-111">语法树是用于编译、代码分析、绑定、重构、IDE 功能和代码生成的主要结构。</span><span class="sxs-lookup"><span data-stu-id="8d994-111">Syntax trees are the primary structure used for compilation, code analysis, binding, refactoring, IDE features, and code generation.</span></span> <span data-ttu-id="8d994-112">要理解任意部分的源代码，都必须先加以识别，然后将其分类为众多已知结构化语言元素之一。</span><span class="sxs-lookup"><span data-stu-id="8d994-112">No part of the source code is understood without it first being identified and categorized into one of many well-known structural language elements.</span></span> 

<span data-ttu-id="8d994-113">语法树具有三个关键特性。</span><span class="sxs-lookup"><span data-stu-id="8d994-113">Syntax trees have three key attributes.</span></span> <span data-ttu-id="8d994-114">第一个特性是语法树完全保真地保留所有源代码信息。</span><span class="sxs-lookup"><span data-stu-id="8d994-114">The first attribute is that syntax trees hold all the source information in full fidelity.</span></span> <span data-ttu-id="8d994-115">这意味着语法树包含可在源文本中找到的每份信息、每个语法结构、每个词法标记，以及它们之间的所有其他内容，包括空格、注释和预处理器指令。</span><span class="sxs-lookup"><span data-stu-id="8d994-115">This means that the syntax tree contains every piece of information found in the source text, every grammatical construct, every lexical token, and everything else in between, including white space, comments, and preprocessor directives.</span></span> <span data-ttu-id="8d994-116">例如，源中提及的所有文本都完全按照键入的形式表示。</span><span class="sxs-lookup"><span data-stu-id="8d994-116">For example, each literal mentioned in the source is represented exactly as it was typed.</span></span> <span data-ttu-id="8d994-117">语法树还可在程序不完整或格式错误时表示源代码中的错误，方法是在语法树中表示已跳过或缺少的标记。</span><span class="sxs-lookup"><span data-stu-id="8d994-117">The syntax trees also represent errors in source code when the program is incomplete or malformed by representing skipped or missing tokens in the syntax tree.</span></span>  

<span data-ttu-id="8d994-118">这造就了语法树的第二个特性。</span><span class="sxs-lookup"><span data-stu-id="8d994-118">This enables the second attribute of syntax trees.</span></span> <span data-ttu-id="8d994-119">从分析程序获取的语法树可生成从中分析出该语法树的确切文本。</span><span class="sxs-lookup"><span data-stu-id="8d994-119">A syntax tree obtained from the parser can produce the exact text it was parsed from.</span></span> <span data-ttu-id="8d994-120">可从任何语法节点获取以该节点为根的子树的文本表示形式。</span><span class="sxs-lookup"><span data-stu-id="8d994-120">From any syntax node, it is possible to get the text representation of the sub-tree rooted at that node.</span></span> <span data-ttu-id="8d994-121">这意味着语法树可以用作一种构造和编辑源文本的方法。</span><span class="sxs-lookup"><span data-stu-id="8d994-121">This means that syntax trees can be used as a way to construct and edit source text.</span></span> <span data-ttu-id="8d994-122">创建树即会隐式创建等效文本，编辑语法树会创建新的树，而不会更改现有树，通过这些操作，可高效编辑文本。</span><span class="sxs-lookup"><span data-stu-id="8d994-122">By creating a tree you have by implication created the equivalent text, and by editing a syntax tree, making a new tree out of changes to an existing tree, you have effectively edited the text.</span></span> 

<span data-ttu-id="8d994-123">语法树的第三个特性是它们是恒定不变的，也是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="8d994-123">The third attribute of syntax trees is that they are immutable and thread-safe.</span></span>  <span data-ttu-id="8d994-124">这意味着获取的树是代码当前状态的快照，不会更改。</span><span class="sxs-lookup"><span data-stu-id="8d994-124">This means that after a tree is obtained, it is a snapshot of the current state of the code, and never changes.</span></span> <span data-ttu-id="8d994-125">这可让多个用户同时在不同线程中与同一语法树进行交互，而不会锁定或重复。</span><span class="sxs-lookup"><span data-stu-id="8d994-125">This allows multiple users to interact with the same syntax tree at the same time in different threads without locking or duplication.</span></span> <span data-ttu-id="8d994-126">由于语法树恒定不变，并且不可直接对其进行修改，因此工厂方法可通过创建树的另一个快照来帮助创建和修改语法树。</span><span class="sxs-lookup"><span data-stu-id="8d994-126">Because the trees are immutable and no modifications can be made directly to a tree, factory methods help create and modify syntax trees by creating additional snapshots of the tree.</span></span> <span data-ttu-id="8d994-127">语法树可高效重用基础节点，因此几乎无需使用额外的内存便可快速重新生成新版本。</span><span class="sxs-lookup"><span data-stu-id="8d994-127">The trees are efficient in the way they reuse underlying nodes, so a new version can be rebuilt fast and with little extra memory.</span></span>

<span data-ttu-id="8d994-128">语法树实际上是一个树形数据结构，其中非终端结构化元素是其他元素的父元素。</span><span class="sxs-lookup"><span data-stu-id="8d994-128">A syntax tree is literally a tree data structure, where non-terminal structural elements parent other elements.</span></span> <span data-ttu-id="8d994-129">每个语法树都由节点、标记和琐碎内容组成。</span><span class="sxs-lookup"><span data-stu-id="8d994-129">Each syntax tree is made up of nodes, tokens, and trivia.</span></span>  

## <a name="syntax-nodes"></a><span data-ttu-id="8d994-130">语法节点</span><span class="sxs-lookup"><span data-stu-id="8d994-130">Syntax nodes</span></span>

<span data-ttu-id="8d994-131">语法节点是语法树的一个主要元素。</span><span class="sxs-lookup"><span data-stu-id="8d994-131">Syntax nodes are one of the primary elements of syntax trees.</span></span> <span data-ttu-id="8d994-132">这些节点表示声明、语句、子句和表达式等语法构造。</span><span class="sxs-lookup"><span data-stu-id="8d994-132">These nodes represent syntactic constructs such as declarations, statements, clauses, and expressions.</span></span> <span data-ttu-id="8d994-133">语法节点的每个类别都由派生自 <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType> 的单独类表示。</span><span class="sxs-lookup"><span data-stu-id="8d994-133">Each category of syntax nodes is represented by a separate class derived from <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8d994-134">节点类集是不可扩展的。</span><span class="sxs-lookup"><span data-stu-id="8d994-134">The set of node classes is not extensible.</span></span> 

<span data-ttu-id="8d994-135">所有语法节点都是语法树中的非终端节点，这意味着这些节点始终有其他节点和标记作为子元素。</span><span class="sxs-lookup"><span data-stu-id="8d994-135">All syntax nodes are non-terminal nodes in the syntax tree, which means they always have other nodes and tokens as children.</span></span> <span data-ttu-id="8d994-136">作为另一个节点的子级，每个节点都具有可通过 <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> 属性访问的父节点。</span><span class="sxs-lookup"><span data-stu-id="8d994-136">As a child of another node, each node has a parent node that can be accessed through the <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="8d994-137">由于节点和树恒定不变，因此节点的父节点永远不会更改。</span><span class="sxs-lookup"><span data-stu-id="8d994-137">Because nodes and trees are immutable, the parent of a node never changes.</span></span> <span data-ttu-id="8d994-138">树的根以 null 为父级。</span><span class="sxs-lookup"><span data-stu-id="8d994-138">The root of the tree has a null parent.</span></span>  

<span data-ttu-id="8d994-139">每个节点都包含 <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType> 方法，可根据子节点在源文本中的位置按顺序返回子节点列表。</span><span class="sxs-lookup"><span data-stu-id="8d994-139">Each node has a <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType> method, which returns a list of child nodes in sequential order based on their position in the source text.</span></span> <span data-ttu-id="8d994-140">此列表中不包含标记。</span><span class="sxs-lookup"><span data-stu-id="8d994-140">This list does not contain tokens.</span></span> <span data-ttu-id="8d994-141">每个节点还包含用于检查子代的方法，如 <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>、<xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A> 或 <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> - 表示包含以该节点为根的子树中存在的所有节点、标记或琐碎内容的列表。</span><span class="sxs-lookup"><span data-stu-id="8d994-141">Each node also has methods to examine Descendants, such as <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A>, or <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> - that represent a list of all the nodes, tokens, or trivia, that exist in the sub-tree rooted by that node.</span></span>  

<span data-ttu-id="8d994-142">此外，每个语法节点子类通过强类型属性公开所有相同的子级。</span><span class="sxs-lookup"><span data-stu-id="8d994-142">In addition, each syntax node subclass exposes all the same children through strongly typed properties.</span></span> <span data-ttu-id="8d994-143">例如，<xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> 节点类具有三个特定于二元运算符的其他属性：<xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>、<xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> 和 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>。</span><span class="sxs-lookup"><span data-stu-id="8d994-143">For example, a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> node class has three additional properties specific to binary operators: <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span></span> <span data-ttu-id="8d994-144"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> 和 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> 的类型为 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>，<xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> 的类型为 <xref:Microsoft.CodeAnalysis.SyntaxToken>。</span><span class="sxs-lookup"><span data-stu-id="8d994-144">The type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> is <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>, and the type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> is <xref:Microsoft.CodeAnalysis.SyntaxToken>.</span></span>

<span data-ttu-id="8d994-145">某些语法节点具有可选子级。</span><span class="sxs-lookup"><span data-stu-id="8d994-145">Some syntax nodes have optional children.</span></span> <span data-ttu-id="8d994-146">例如，<xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> 具有可选的 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>。</span><span class="sxs-lookup"><span data-stu-id="8d994-146">For example, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> has an optional <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>.</span></span> <span data-ttu-id="8d994-147">如果没有子级，则该属性返回 null。</span><span class="sxs-lookup"><span data-stu-id="8d994-147">If the child is not present, the property returns null.</span></span> 

## <a name="syntax-tokens"></a><span data-ttu-id="8d994-148">语法标记</span><span class="sxs-lookup"><span data-stu-id="8d994-148">Syntax tokens</span></span>

<span data-ttu-id="8d994-149">语法标记是语言语法的终端，表示代码的最小语法片段。</span><span class="sxs-lookup"><span data-stu-id="8d994-149">Syntax tokens are the terminals of the language grammar, representing the smallest syntactic fragments of the code.</span></span> <span data-ttu-id="8d994-150">它们从不作为其他节点或标记的父级。</span><span class="sxs-lookup"><span data-stu-id="8d994-150">They are never parents of other nodes or tokens.</span></span> <span data-ttu-id="8d994-151">语法标记包含关键字、标识符、文本和标点。</span><span class="sxs-lookup"><span data-stu-id="8d994-151">Syntax tokens consist of keywords, identifiers, literals, and punctuation.</span></span> 

<span data-ttu-id="8d994-152">为了提高效率，<xref:Microsoft.CodeAnalysis.SyntaxToken> 类型为 CLR 值类型。</span><span class="sxs-lookup"><span data-stu-id="8d994-152">For efficiency purposes, the <xref:Microsoft.CodeAnalysis.SyntaxToken> type is a CLR value type.</span></span> <span data-ttu-id="8d994-153">因此，与语法节点不同，所有类型的标记都采用同一结构，但包含各种属性，这些属性的意义取决于表示的标记类型。</span><span class="sxs-lookup"><span data-stu-id="8d994-153">Therefore, unlike syntax nodes, there is only one structure for all kinds of tokens with a mix of properties that have meaning depending on the kind of token that is being represented.</span></span>

<span data-ttu-id="8d994-154">例如，整数文本标记表示数字值。</span><span class="sxs-lookup"><span data-stu-id="8d994-154">For example, an integer literal token represents a numeric value.</span></span> <span data-ttu-id="8d994-155">除了原始源文本和标记范围外，文本标记还包含 <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> 属性，用于告知精确解码的整数值。</span><span class="sxs-lookup"><span data-stu-id="8d994-155">In addition to the raw source text the token spans, the literal token has a <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property that tells you the exact decoded integer value.</span></span> <span data-ttu-id="8d994-156">此属性类型化为 <xref:System.Object>，因为它可能属于多个基元类型之一。</span><span class="sxs-lookup"><span data-stu-id="8d994-156">This property is typed as <xref:System.Object> because it may be one of many primitive types.</span></span>

<span data-ttu-id="8d994-157"><xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> 属性与 <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> 属性告知相同的信息；但前者始终类型化为 <xref:System.String>。</span><span class="sxs-lookup"><span data-stu-id="8d994-157">The <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property tells you the same information as the <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property; however this property is always typed as <xref:System.String>.</span></span> <span data-ttu-id="8d994-158">C# 源文本中的标识符可能包括 Unicode 转义字符，但转义序列本身的语法不被视为标识符名称的一部分。</span><span class="sxs-lookup"><span data-stu-id="8d994-158">An identifier in C# source text may include Unicode escape characters, yet the syntax of the escape sequence itself is not considered part of the identifier name.</span></span> <span data-ttu-id="8d994-159">因此，虽然标记跨越的原始文本包含转义序列，但 <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> 属性却不包含转义序列。</span><span class="sxs-lookup"><span data-stu-id="8d994-159">So although the raw text spanned by the token does include the escape sequence, the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property does not.</span></span> <span data-ttu-id="8d994-160">而是包括转义识别的 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="8d994-160">Instead, it includes the Unicode characters identified by the escape.</span></span> <span data-ttu-id="8d994-161">例如，如果源文本包含写为 `\u03C0` 的标识符，则此标记的 <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> 属性返回 `π`。</span><span class="sxs-lookup"><span data-stu-id="8d994-161">For example, if the source text contains an identifier written as `\u03C0`, then the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property for this token will return `π`.</span></span>

## <a name="syntax-trivia"></a><span data-ttu-id="8d994-162">语法琐碎内容</span><span class="sxs-lookup"><span data-stu-id="8d994-162">Syntax trivia</span></span>

<span data-ttu-id="8d994-163">语法琐碎内容表示对正常理解代码基本上没有意义的源文本部分，例如空格、注释和预处理器指令。</span><span class="sxs-lookup"><span data-stu-id="8d994-163">Syntax trivia represent the parts of the source text that are largely insignificant for normal understanding of the code, such as white space, comments, and preprocessor directives.</span></span> <span data-ttu-id="8d994-164">与语法标记类似，琐碎内容为值类型。</span><span class="sxs-lookup"><span data-stu-id="8d994-164">Like syntax tokens, trivia are value types.</span></span> <span data-ttu-id="8d994-165">单个 <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> 类型用于描述各种类型的琐碎内容。</span><span class="sxs-lookup"><span data-stu-id="8d994-165">The single <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> type is used to describe all kinds of trivia.</span></span>

<span data-ttu-id="8d994-166">由于琐碎内容不是正常语言语法的一部分，并且可以出现在任意两个标记之间的任意位置，因此它们不会作为节点的子级包含在语法树中。</span><span class="sxs-lookup"><span data-stu-id="8d994-166">Because trivia are not part of the normal language syntax and can appear anywhere between any two tokens, they are not included in the syntax tree as a child of a node.</span></span> <span data-ttu-id="8d994-167">但由于它们对于实现重构等功能和完全保真地保留源文本非常重要，因此还是包含在语法树内。</span><span class="sxs-lookup"><span data-stu-id="8d994-167">Yet, because they are important when implementing a feature like refactoring and to maintain full fidelity with the source text, they do exist as part of the syntax tree.</span></span>

<span data-ttu-id="8d994-168">可通过检查标记的 <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> 或 <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> 集合来访问琐碎内容。</span><span class="sxs-lookup"><span data-stu-id="8d994-168">You can access trivia by inspecting a token’s <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> collections.</span></span> <span data-ttu-id="8d994-169">分析源文本时，琐碎内容序列与标记关联。</span><span class="sxs-lookup"><span data-stu-id="8d994-169">When source text is parsed, sequences of trivia are associated with tokens.</span></span> <span data-ttu-id="8d994-170">通常情况下，一个标记拥有其后位于同一行中下一个标记之前的任意琐碎内容。</span><span class="sxs-lookup"><span data-stu-id="8d994-170">In general, a token owns any trivia after it on the same line up to the next token.</span></span> <span data-ttu-id="8d994-171">该行之后的任意琐碎内容与下一个标记关联。</span><span class="sxs-lookup"><span data-stu-id="8d994-171">Any trivia after that line is associated with the following token.</span></span> <span data-ttu-id="8d994-172">源文件中的第一个标记可获取所有初始琐碎内容，而最后一个琐碎内容序列附加到文件尾标记，否则其宽度为零。</span><span class="sxs-lookup"><span data-stu-id="8d994-172">The first token in the source file gets all the initial trivia, and the last sequence of trivia in the file is tacked onto the end-of-file token, which otherwise has zero width.</span></span>

<span data-ttu-id="8d994-173">与语法节点和语法标记不同，语法琐碎内容没有父级。</span><span class="sxs-lookup"><span data-stu-id="8d994-173">Unlike syntax nodes and tokens, syntax trivia do not have parents.</span></span> <span data-ttu-id="8d994-174">但由于它们是树的一部分，且每个琐碎内容都与一个标记关联，因此可使用 <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType> 属性访问关联的标记。</span><span class="sxs-lookup"><span data-stu-id="8d994-174">Yet, because they are part of the tree and each is associated with a single token, you may access the token it is associated with using the <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType> property.</span></span>

## <a name="spans"></a><span data-ttu-id="8d994-175">范围</span><span class="sxs-lookup"><span data-stu-id="8d994-175">Spans</span></span>

<span data-ttu-id="8d994-176">每个节点、标记或琐碎内容都知道其在源文本内的位置和包含的字符数。</span><span class="sxs-lookup"><span data-stu-id="8d994-176">Each node, token, or trivia knows its position within the source text and the number of characters it consists of.</span></span> <span data-ttu-id="8d994-177">文本位置表示为一个 32 位整数，是一个从零开始的 `char` 索引。</span><span class="sxs-lookup"><span data-stu-id="8d994-177">A text position is represented as a 32-bit integer, which is a zero-based `char` index.</span></span> <span data-ttu-id="8d994-178"><xref:Microsoft.CodeAnalysis.Text.TextSpan> 对象表示开始位置和字符计数，都表示为整数。</span><span class="sxs-lookup"><span data-stu-id="8d994-178">A <xref:Microsoft.CodeAnalysis.Text.TextSpan> object is the beginning position and a count of characters, both represented as integers.</span></span> <span data-ttu-id="8d994-179">如果 <xref:Microsoft.CodeAnalysis.Text.TextSpan> 的长度为零，则其表示两个字符之间的位置。</span><span class="sxs-lookup"><span data-stu-id="8d994-179">If <xref:Microsoft.CodeAnalysis.Text.TextSpan> has a zero length, it refers to a location between two characters.</span></span>

<span data-ttu-id="8d994-180">每个节点具有两个 <xref:Microsoft.CodeAnalysis.Text.TextSpan> 属性：<xref:Microsoft.CodeAnalysis.SyntaxNode.Span*> 和 <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan*>。</span><span class="sxs-lookup"><span data-stu-id="8d994-180">Each node has two <xref:Microsoft.CodeAnalysis.Text.TextSpan> properties: <xref:Microsoft.CodeAnalysis.SyntaxNode.Span*> and <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan*>.</span></span> 

<span data-ttu-id="8d994-181"><xref:Microsoft.CodeAnalysis.SyntaxNode.Span*> 属性表示从节点子树中第一个标记的开头到最后一个标记末尾的文本范围。</span><span class="sxs-lookup"><span data-stu-id="8d994-181">The <xref:Microsoft.CodeAnalysis.SyntaxNode.Span*> property is the text span from the start of the first token in the node’s sub-tree to the end of the last token.</span></span> <span data-ttu-id="8d994-182">此范围不包括任何前导或尾随琐碎内容。</span><span class="sxs-lookup"><span data-stu-id="8d994-182">This span does not include any leading or trailing trivia.</span></span>

<span data-ttu-id="8d994-183"><xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan*> 属性表示的文本范围包括节点的正常范围，加上任何前导或尾随琐碎内容的范围。</span><span class="sxs-lookup"><span data-stu-id="8d994-183">The <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan*> property is the text span that includes the node’s normal span, plus the span of any leading or trailing trivia.</span></span>

<span data-ttu-id="8d994-184">例如:</span><span class="sxs-lookup"><span data-stu-id="8d994-184">For example:</span></span> 

``` csharp
      if (x > 3)
      {
||        // this is bad
          |throw new Exception("Not right.");|  // better exception?||
      }
```

<span data-ttu-id="8d994-185">块内语句节点的范围由单个竖线 (|) 指示。</span><span class="sxs-lookup"><span data-stu-id="8d994-185">The statement node inside the block has a span indicated by the single vertical bars (|).</span></span> <span data-ttu-id="8d994-186">它包含字符 `throw new Exception("Not right.");`。</span><span class="sxs-lookup"><span data-stu-id="8d994-186">It includes the characters `throw new Exception("Not right.");`.</span></span> <span data-ttu-id="8d994-187">完整的范围由双竖线 (||) 指示。</span><span class="sxs-lookup"><span data-stu-id="8d994-187">The full span is indicated by the double vertical bars (||).</span></span> <span data-ttu-id="8d994-188">它包含的字符与前导和尾随琐碎内容的相关范围和字符相同。</span><span class="sxs-lookup"><span data-stu-id="8d994-188">It includes the same characters as the span and the characters associated with the leading and trailing trivia.</span></span>

## <a name="kinds"></a><span data-ttu-id="8d994-189">种类</span><span class="sxs-lookup"><span data-stu-id="8d994-189">Kinds</span></span>

<span data-ttu-id="8d994-190">每个节点、标记或琐碎内容都具有 <xref:System.Int32?displayProperty=nameWithType> 类型的 <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> 属性，标识所表示的确切语法元素。</span><span class="sxs-lookup"><span data-stu-id="8d994-190">Each node, token, or trivia has a <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> property, of type <xref:System.Int32?displayProperty=nameWithType>, that identifies the exact syntax element represented.</span></span> <span data-ttu-id="8d994-191">此值可强制转换为特定语言枚举；每种语言（C# 或 VB）都具有单个 `SyntaxKind` 枚举（分别为 <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> 和 <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType>），列出了语法中所有可能的节点、标记和琐碎内容。</span><span class="sxs-lookup"><span data-stu-id="8d994-191">This value can be cast to a language-specific enumeration; each language, C# or VB, has a single `SyntaxKind` enumeration  (<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> and <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType>, respectively) that lists all the possible nodes, tokens, and trivia elements in the grammar.</span></span> <span data-ttu-id="8d994-192">可通过访问 <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind*?displayProperty=nameWithType> 或 <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind*?displayProperty=nameWithType> 扩展方法自动完成此转换。</span><span class="sxs-lookup"><span data-stu-id="8d994-192">This conversion can be done automatically by accessing the <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind*?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind*?displayProperty=nameWithType> extension methods.</span></span>

<span data-ttu-id="8d994-193"><xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> 属性可轻松消除共享同一节点类的语法节点类型的歧义。</span><span class="sxs-lookup"><span data-stu-id="8d994-193">The <xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> property allows for easy disambiguation of syntax node types that share the same node class.</span></span> <span data-ttu-id="8d994-194">对于标记和琐碎内容，此属性是区分不同元素类型的唯一方法。</span><span class="sxs-lookup"><span data-stu-id="8d994-194">For tokens and trivia, this property is the only way to distinguish one type of element from another.</span></span> 

<span data-ttu-id="8d994-195">例如，一个 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> 类具有 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>、<xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> 和 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> 作为子级。</span><span class="sxs-lookup"><span data-stu-id="8d994-195">For example, a single <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> class has <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> as children.</span></span> <span data-ttu-id="8d994-196"><xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind*> 属性可辨别它是 <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>、<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression> 还是 <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> 类型的语法节点。</span><span class="sxs-lookup"><span data-stu-id="8d994-196">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind*> property distinguishes whether it is an <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression>, or <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> kind of syntax node.</span></span>

## <a name="errors"></a><span data-ttu-id="8d994-197">错误</span><span class="sxs-lookup"><span data-stu-id="8d994-197">Errors</span></span>

<span data-ttu-id="8d994-198">即使源文本中包含语法错误，也会公开可与源双向转换的完整语法树。</span><span class="sxs-lookup"><span data-stu-id="8d994-198">Even when the source text contains syntax errors, a full syntax tree that is round-trippable to the source is exposed.</span></span> <span data-ttu-id="8d994-199">当分析程序遇到不符合语言定义语法的代码时，使用两种方法之一来创建语法树。</span><span class="sxs-lookup"><span data-stu-id="8d994-199">When the parser encounters code that does not conform to the defined syntax of the language, it uses one of two techniques to create a syntax tree.</span></span>

<span data-ttu-id="8d994-200">第一种方法是：如果分析程序需要特定种类的标记，但未找到该标记，则其可在语法树中所需标记位置插入缺失的标记。</span><span class="sxs-lookup"><span data-stu-id="8d994-200">First, if the parser expects a particular kind of token but does not find it, it may insert a missing token into the syntax tree in the location that the token was expected.</span></span> <span data-ttu-id="8d994-201">缺失的标记表示本应存在，但只有空范围的实际标记，并且其 <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> 属性返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="8d994-201">A missing token represents the actual token that was expected, but it has an empty span, and its <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> property returns `true`.</span></span>

<span data-ttu-id="8d994-202">第二种方法是：分析程序可能会跳过标记，直至发现可继续分析的标记。</span><span class="sxs-lookup"><span data-stu-id="8d994-202">Second, the parser may skip tokens until it finds one where it can continue parsing.</span></span> <span data-ttu-id="8d994-203">在这种情况下，跳过的令牌附加为 <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia> 类型的琐碎内容节点。</span><span class="sxs-lookup"><span data-stu-id="8d994-203">In this case, the skipped tokens are attached as a trivia node with the kind <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>.</span></span>
