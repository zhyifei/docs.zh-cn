### YamlMime:Tutorial
title: <span data-ttu-id="f452a-101">探索 C# 6 - C# 交互窗口 C# 教程</span><span class="sxs-lookup"><span data-stu-id="f452a-101">Explore C# 6 - C# interactive C# tutorial</span></span>
metadata:
  title: 探索 C# 6 - 使用浏览器以交互方式尝试 C# 6 中的新功能
  description: 在本教程中，你将使用浏览器以交互方式探索 C# 6。 你将探索可以与 C# 6 配合使用的新的习惯用语，这些习惯用语支持较简洁的可读代码。
  audience: Developer
  level: intermediate
  ms.date: 12/11/2018
  displayType: two-column
  interactive: csharp
  ms.openlocfilehash: b43400a0fdae338744c521cf7ddb2bfce79fc43c
  ms.sourcegitcommit: c4e9d05644c9cb89de5ce6002723de107ea2e2c4
  ms.translationtype: HT
  ms.contentlocale: zh-CN
  ms.lasthandoff: 05/19/2019
  ms.locfileid: "65881028"
items:
- durationInMinutes: 1
  content: >
    <span data-ttu-id="f452a-105">通过本教程，使用浏览器编写 C#，并查看代码编译和运行结果，以交互方式探索 C# 6。</span><span class="sxs-lookup"><span data-stu-id="f452a-105">This tutorial lets you explore C# 6 interactively, using your browser to write C# and see the results of compiling and running your code.</span></span> <span data-ttu-id="f452a-106">本教程包含一系列课程，这些课程修改了早期的 C# 做法，以使用更新、更简洁的 C# 6 功能。</span><span class="sxs-lookup"><span data-stu-id="f452a-106">It contains a series of lessons that modify earlier C# practices to use newer, more concise C# 6 features.</span></span> <span data-ttu-id="f452a-107">本文的其余部分是对每个功能的概述，并提供用于探索每个功能的链接。</span><span class="sxs-lookup"><span data-stu-id="f452a-107">The rest of this article provides an overview of each of these features, with a link to explore each feature.</span></span>
- title: <span data-ttu-id="f452a-108">只读自动属性支持只读类型</span><span class="sxs-lookup"><span data-stu-id="f452a-108">Read-only auto-properties enable read-only types</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"f452a-109\">通过自动属性语法的两个改进，可以更轻松地在更多位置使用自动属性：只读自动属性和自动属性初始值设定项。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-109\">Two enhancements to auto-property syntax make it easier to use auto-properties in more places: read-only auto-properties and auto-property initializers.</span></span> <span data-ttu-id=\"f452a-110\">请参考此小程序：</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-110\">Consider this small program:</span></span>\n\n[!code-csharp[Starter](../../../../samples/csharp/tutorials/exploration/csharp6-starter/Program.cs)]  \n\n    \n <span data-ttu-id=\"f452a-111\">进入焦点模式，将前面的代码复制到 C# 交互窗口。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-111\">Enter Focus mode, copy the preceding code into the C# interactive window.</span></span> <span data-ttu-id=\"f452a-112\">然后，单击“运行”查看代码效果。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-112\">Then, click *Run* to see what the code does.</span></span> <span data-ttu-id=\"f452a-113\">`AllCaps` 具有不良副作用，即它会修改属性值并返回大写字符串。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-113\">`AllCaps` has the undesirable side effect of modifying the property values along with returning the uppercase string.</span></span> <span data-ttu-id=\"f452a-114\">`Person` 类的创建者希望 `FirstName` 和 `LastName` 的字符串为只读字符串。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-114\">The author of the `Person` class intended the strings for `FirstName` and `LastName` to be read-only.</span></span> <span data-ttu-id=\"f452a-115\">使用 C#6，可以清楚地表达该意图。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-115\">With C# 6, you can make that intent clear.</span></span> <span data-ttu-id=\"f452a-116\">从这两个属性中删除 `private set` 以创建只读自动属性。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-116\">Remove the `private set` from both properties to create a read-only auto property.</span></span> <span data-ttu-id=\"f452a-117\">单击“运行”，可以看到编译器发现 `FirstName` 和 `LastName` 属性在两个位置发生了更改，而这两个属性在这两个位置本不应更改。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-117\">Click *Run* to see that the compiler spots the two locations where the `FirstName` and `LastName` properties are changed when they should not have been.</span></span> <span data-ttu-id=\"f452a-118\">可以将 `AllCaps` 方法更改为以下代码，以修复编译器错误：</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-118\">You can change the `AllCaps` method to the following code to fix the compiler error:</span></span>\n\n```csharp\npublic string AllCaps()\n{\n  return ToString().ToUpper();\n}\n```\n\n<span data-ttu-id=\"f452a-119\">使用这种新语法，编译器可以确保属性是不可变的。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-119\">Using this new syntax, the compiler ensures that the properties are immutable.</span></span>\n"
- title: <span data-ttu-id="f452a-120">初始化自动属性的支持字段</span><span class="sxs-lookup"><span data-stu-id="f452a-120">Initialize backing fields for auto-properties</span></span>
  durationInMinutes: 1
  content: "<span data-ttu-id=\"f452a-121\">C# 6 中的新语法支持使用自动属性的初始值设定项。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-121\">New syntax in C# 6 enables you to use initializers for auto-properties.</span></span> <span data-ttu-id=\"f452a-122\">随着类增加新的功能，这一点变得越来越重要。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-122\">This becomes more important as classes grow new capabilities.</span></span> <span data-ttu-id=\"f452a-123\">添加一个中间名称属性和一个新的构造函数，该构造函数会将三个字符串添加到 `Person` 类中：</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-123\">Add a middle name property, and a new constructor that takes three strings to your `Person` class:</span></span>\n\n[!code-csharp[MiddleName](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#MiddleName)]  \n\n<span data-ttu-id=\"f452a-124\">`MiddleName` 属性上的赋值为初始值设定项。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-124\">The assignment on the `MiddleName` property is an initializer.</span></span> <span data-ttu-id=\"f452a-125\">它初始化用于中间名称的由编译器生成的支持字段。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-125\">It initializes the compiler-generated backing field for the middle name.</span></span>\n"
- title: <span data-ttu-id="f452a-126">Expression-Bodied 成员</span><span class="sxs-lookup"><span data-stu-id="f452a-126">Expression-bodied members</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="f452a-127">Expression-bodied 成员为轻量级方法提供轻量级语法。</span><span class="sxs-lookup"><span data-stu-id="f452a-127">Expression-bodied members provide a lightweight syntax for lightweight methods.</span></span> <span data-ttu-id="f452a-128">`Person` 类有两个很好的候选项。</span><span class="sxs-lookup"><span data-stu-id="f452a-128">The `Person` class has two great candidates.</span></span> <span data-ttu-id="f452a-129">请查看 `ToString` 的声明：</span><span class="sxs-lookup"><span data-stu-id="f452a-129">Look at the declaration of `ToString`:</span></span>


    ```csharp

    public override string ToString()

    {
        return FirstName + " " + LastName;
    }

    ```


    <span data-ttu-id="f452a-130">将 `ToString` 声明替换为以下代码：</span><span class="sxs-lookup"><span data-stu-id="f452a-130">Replace that declaration of `ToString` with the following code:</span></span>


    ```csharp

    public override string ToString() => FirstName + " " + LastName;

    ```


    <span data-ttu-id="f452a-131">使用 `AllCaps` 方法，执行相同操作。</span><span class="sxs-lookup"><span data-stu-id="f452a-131">Try the same with the `AllCaps` method.</span></span> <span data-ttu-id="f452a-132">这是一个小的改进，但是如果使用得当，它会创建更具可读性的代码，特别是对于数据传输对象 (DTO) 和其他具有最小行为的类型。</span><span class="sxs-lookup"><span data-stu-id="f452a-132">This is a small improvement, but when used wisely it creates much more readable code, especially for Data Transfer Objects (DTOs) and other types with minimal behavior.</span></span>
- title: <span data-ttu-id="f452a-133">导入单个类</span><span class="sxs-lookup"><span data-stu-id="f452a-133">Importing a single class</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"f452a-134\">如果在整个代码中反复使用类的静态方法，则每次包含类名都会模糊代码的含义。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-134\">If you repeatedly use one class' static methods throughout your code, including the class name each time obscures the meaning of your code.</span></span> <span data-ttu-id=\"f452a-135\">`Person` 类目前导入 `System` 命名空间，尽管只会使用 <xref:System.Console?displayProperty=nameWithType>。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-135\">The `Person` class currently imports the `System` namespace, even though only <xref:System.Console?displayProperty=nameWithType> is used.</span></span> <span data-ttu-id=\"f452a-136\">修改 `using` 语句，如下所示：</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-136\">Modify the `using` statement as follows:</span></span>\n\n[!code-csharp[MiddleName](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#UsingStatic)]  \n\n<span data-ttu-id=\"f452a-137\">在广泛使用具有许多静态方法的单个类（比如 [`string`](xref:System.String) 类或 <xref:System.Math?displayProperty=nameWithType> 类）的大型程序中，`static using` 语句变得更加有用。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-137\">The `static using` statement becomes more useful in larger programs that make extensive use of a single class with many static methods, like the [`string`](xref:System.String) class or the <xref:System.Math?displayProperty=nameWithType> class.</span></span>\n"
- title: <span data-ttu-id="f452a-138">更好的字符串格式</span><span class="sxs-lookup"><span data-stu-id="f452a-138">A better string format</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"f452a-139\">C# 6 包含新语法，用于从字符串和嵌入的表达式编写字符串，可以通过计算这些字符串来生成其他字符串值。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-139\">C# 6 contains new syntax for composing strings from a string and embedded expressions that are evaluated to produce other string values.</span></span> <span data-ttu-id=\"f452a-140\">可以更改 `ToString` 和 `AllCaps` 方法，以使用以下语法：</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-140\">You can change the `ToString` and `AllCaps` methods to use this syntax:</span></span>\n\n[!code-csharp[StringInterpolation](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#StringInterpolation)]  \n\n<span data-ttu-id=\"f452a-141\">可以直接编写 C# 表达式，而不是 `{` 和 `}` 之间的位置参数。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-141\">Instead of positional arguments between the `{` and `}`, you write C# expressions directly.</span></span> <span data-ttu-id=\"f452a-142\">可以在 `Main` 方法中执行相同操作。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-142\">You can do the same in the `Main` method.</span></span> <span data-ttu-id=\"f452a-143\">将现有代码替换为以下代码：</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-143\">Replace the existing code with the following:</span></span>\n\n[!code-csharp[InterpolationMain](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#InterpolationMain)]  \n\n<span data-ttu-id=\"f452a-144\">不仅限于这些表达式中的单个变量。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-144\">You're not limited to a single variable in these expressions.</span></span> <span data-ttu-id=\"f452a-145\">让我们从一个新的示例开始，修改该示例，以演示可以与字符串内插配合使用的其他表达式。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-145\">Let's start with a new example and modify it to demonstrate other expressions you can use with string interpolation.</span></span> <span data-ttu-id=\"f452a-146\">将以下代码粘贴到 `Main` 方法中的交互式窗口：</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-146\">Paste the following code into the interactive window in the `Main` method:</span></span>\n\n[!code-csharp[Phrases](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#Phrases)]  \n\n<span data-ttu-id=\"f452a-147\">可以删除局部变量 `average`，并在内插字符串表达式中执行该计算。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-147\">You can remove the local variable `average` and perform that calculation as part of the interpolated string expression.</span></span> <span data-ttu-id=\"f452a-148\">将最后两行替换为以下部分：</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-148\">Replace the last two lines with the following:</span></span>\n\n```csharp\nWriteLine($\"The average word length is: {wordLength.Average()}\");\n```\n\n<span data-ttu-id=\"f452a-149\">运行前面的示例，你可能会发现 `Average` 的输出的小数位数比你需要的多。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-149\">Running the preceding example, you would find that the output for `Average` has more decimal places than you would like.</span></span> <span data-ttu-id=\"f452a-150\">字符串内插语法支持可使用前面的格式设置方法的所有格式字符串。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-150\">The string interpolation syntax supports all the format strings available using earlier formatting methods.</span></span> <span data-ttu-id=\"f452a-151\">在大括号内指定格式字符串。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-151\">You specify the format string inside the braces.</span></span> <span data-ttu-id=\"f452a-152\">在要设置格式的表达式后面添加 `:`：</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-152\">Add a `:` following the expression to format:</span></span>\n\n```csharp\nWriteLine($\"The average word length is: {wordLength.Average():F2}\");\n```\n"
- title: <span data-ttu-id="f452a-153">快速且简单的 null 检查</span><span class="sxs-lookup"><span data-stu-id="f452a-153">Quick and easy null checks</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"f452a-154\">借助 `?.`（null 条件）运算符，可轻松编写包含 `null` 值的逻辑，无需额外的 `if` 检查。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-154\">The `?.` (null conditional) operator makes it easier to write logic that takes `null` values into account seamlessly, without extra `if` checks.</span></span> <span data-ttu-id=\"f452a-155\">若要探索此功能，请先将以下代码复制到交互式窗口，然后进行尝试：</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-155\">To explore the feature, start by copying the following code into the interactive window to try it:</span></span>\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n      string s = null;\n      Console.WriteLine(s.Length);\n    }\n}\n```\n\n<span data-ttu-id=\"f452a-156\">运行该示例时，它会引发 <xref:System.NullReferenceException>。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-156\">It throws a <xref:System.NullReferenceException> when you run the sample.</span></span> <span data-ttu-id=\"f452a-157\">将 `.` 成员访问运算符更改为 null 条件运算符：</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-157\">Change the `.` member access operator to the **null conditional operator**:</span></span>\n\n```csharp\nConsole.WriteLine(s?.Length);\n``` \n\n<span data-ttu-id=\"f452a-158\">做此更改后，不会有任何输出。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-158\">After this change, there's no output.</span></span> <span data-ttu-id=\"f452a-159\">这是因为 `s.Length` 的结果为 `int` 时，`s?.Length` 的结果为 `int?`。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-159\">That's because the result of `s?.Length` is an `int?` when the result of `s.Length` is an `int`.</span></span> <span data-ttu-id=\"f452a-160\">在此示例中，`s?.Length` 为 `null`。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-160\">In this example, `s?.Length` is `null`.</span></span> <span data-ttu-id=\"f452a-161\">如果 `?.` 的左操作数为 `null`，则它返回 `null`。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-161\">The `?.` returns `null` if its left operand is `null`.</span></span> <span data-ttu-id=\"f452a-162\">如果右操作数的类型为值类型，则 `?.` 运算符为该类型返回可以为 null 的类型。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-162\">If the type of the right operand is a value type, the `?.` operator returns a nullable type for that type.</span></span> <span data-ttu-id=\"f452a-163\">除了 `?.` 之外，还可以使用 `?[]` 进行数组或索引访问。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-163\">In addition to `?.` you can use `?[]` for array or indexer access.</span></span> <span data-ttu-id=\"f452a-164\">在交互式窗口中，试运行以下代码：</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-164\">Try the following code in the interactive window:</span></span>\n\n ```csharp\n char? c = s?[0];\n Console.WriteLine(c.HasValue);\n ```\n\n <span data-ttu-id=\"f452a-165\">多个条件运算符可以组合成一个表达式。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-165\">Multiple conditional operators can be combined into a single expression.</span></span> <span data-ttu-id=\"f452a-166\">`null` 左操作数生成 `null` 结果，这样就可以很容易地避免嵌套 if 子句以访问成员的成员。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-166\">A `null` left operand produces a `null` result, making it easy to avoid nested if clauses to access members of members.</span></span> <span data-ttu-id=\"f452a-167\">例如，在交互式窗口中，试运行以下代码：</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-167\">For example, try the following code in the interactive window:</span></span>\n\n ```csharp\n string s = null;\n bool? hasMore = s?.ToCharArray()?.GetEnumerator()?.MoveNext();\n Console.WriteLine(hasMore.HasValue);\n ```\n\n <span data-ttu-id=\"f452a-168\">通过使用 null 合并运算符提供默认值，可以简化前面的示例：</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-168\">The preceding example can be simplified by using the **null coalescing operator** to provide a default value:</span></span>\n\n ```csharp\n bool hasMore = s?.ToCharArray()?.GetEnumerator()?.MoveNext() ?? false;\n Console.WriteLine(hasMore);\n ```\n\n <span data-ttu-id=\"f452a-169\">null 条件运算符可以帮助你编写使核心逻辑清晰，同时无缝测试 `null` 值的代码。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-169\">The **null conditional operator** helps you write code that makes your core logic clear while seamlessly testing for `null` values.</span></span>\n"
- title: <span data-ttu-id="f452a-170">异常筛选器</span><span class="sxs-lookup"><span data-stu-id="f452a-170">Exception filters</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"f452a-171\">使用异常筛选器可以捕获基于某些条件的异常。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-171\">Exception filters enable you to catch an exception based on some condition.</span></span> <span data-ttu-id=\"f452a-172\">典型用法是创建筛选器方法，该方法记录异常，但从不处理这些异常。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-172\">A typical use is to create a filter method that logs exceptions, but never handles those exceptions.</span></span> <span data-ttu-id=\"f452a-173\">异常筛选器为布尔表达式，应执行 `catch` 子句时该表达式为 `true`，不应由 `catch` 子句捕获异常时，该表达式为 `false`。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-173\">An exception filter is a boolean expression that is `true` when the `catch` clause should be executed, and `false` when the exception should not be caught by the `catch` clause.</span></span> <span data-ttu-id=\"f452a-174\">在交互式窗口中，试运行以下代码：它将异常类型和消息记录到控制台。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-174\">Try the following code in the interactive window: It logs the exception type and message to the console.</span></span> <span data-ttu-id=\"f452a-175\">返回 `false`，表示无法处理异常。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-175\">It returns `false` which indicates that the exception can't be handled.</span></span> <span data-ttu-id=\"f452a-176\">在交互式窗口中，尝试运行该程序。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-176\">Try the program in the interactive window.</span></span>\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        try \n        {\n            string s = null;\n            Console.WriteLine(s.Length);\n\n        } catch (Exception e) when (LogException(e))\n        {\n        }\n        Console.WriteLine(\"Exception must have been handled\");\n    }\n\n    private static bool LogException(Exception e)\n    {\n        Console.WriteLine($\"\\tIn the log routine. Caught {e.GetType()}\");\n        Console.WriteLine($\"\\tMessage: {e.Message}\");\n        return false;\n    }\n}\n```\n\n<span data-ttu-id=\"f452a-177\">应会显示来自 `LogException` 方法的消息，然后显示默认异常消息。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-177\">You should see the message from the `LogException` method, followed by the default exception message.</span></span> <span data-ttu-id=\"f452a-178\">尝试将 `return false` 语句更改为 `return true`，然后再运行一次。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-178\">Just to experiment, change the `return false` statement to `return true` and run this again.</span></span> <span data-ttu-id=\"f452a-179\">现在，捕获到异常，并且程序运行直到完成。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-179\">Now, the exception is caught and the program runs to completion.</span></span>\n\n<span data-ttu-id=\"f452a-180\">除日志记录场景外，异常筛选器在异常的属性确定采取何种操作时可能最有用。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-180\">Beyond logging scenarios, exception filters can be most useful when a property of the exception determines what action to take.</span></span> <span data-ttu-id=\"f452a-181\">例如，可以查看 <xref:System.AggregateException> 中包含的异常，并根据特定的异常采取适当的操作。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-181\">For example, you can look inside an <xref:System.AggregateException> to see what the contained exceptions are and take some appropriate action depending on the specific exception.</span></span>\n"
- title: <span data-ttu-id="f452a-182">使用 nameof</span><span class="sxs-lookup"><span data-stu-id="f452a-182">Using nameof</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"f452a-183\">`nameof` 运算符返回任何变量、类型或类型成员的名称。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-183\">The `nameof` operator returns the name of any variable, a type, or a type's member.</span></span> <span data-ttu-id=\"f452a-184\">在交互式窗口中，尝试运行以下代码，了解工作原理：</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-184\">Try the following code in the interactive window to see how it works:</span></span>\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Console.WriteLine(nameof(System.String));\n        int j = 5;\n        Console.WriteLine(nameof(j));\n        List<string> names = new List<string>();\n        Console.WriteLine(nameof(names));\n    }\n}\n```\n\n<span data-ttu-id=\"f452a-185\">输出与变量或类型的名称相匹配。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-185\">The output matches the name of the variable or type.</span></span> <span data-ttu-id=\"f452a-186\">即使提供了完全限定的类型名称（如 `System.String`），`nameof` 运算符也会返回不限定的名称。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-186\">Even when you provided the fully qualified type name (such as `System.String`) the `nameof` operator returns the unqualified name.</span></span> <span data-ttu-id=\"f452a-187\">如果需要将参数或属性名称转换为字符串，此功能非常有用。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-187\">This feature is most useful when you need to convert a parameter or property name to a string.</span></span> <span data-ttu-id=\"f452a-188\">示例包括捕获用于引发 <xref:System.ArgumentNullException> 或 <xref:System.ArgumentException> 的参数的名称，或者捕获实现 <xref:System.ComponentModel.INotifyPropertyChanged> 时更改的属性的名称。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-188\">Examples include capturing the name of an argument for throwing a <xref:System.ArgumentNullException> or <xref:System.ArgumentException>, or capturing the name of a changed property when implementing <xref:System.ComponentModel.INotifyPropertyChanged>.</span></span> \n"
- title: <span data-ttu-id="f452a-189">新的对象初始化语法</span><span class="sxs-lookup"><span data-stu-id="f452a-189">New object initialization syntax</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"f452a-190\">对象初始值设定项语法现在支持初始化索引器以及属性和字段。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-190\">Object initializer syntax now supports initializing *indexers* as well as properties and fields.</span></span> <span data-ttu-id=\"f452a-191\">此添加使初始化字典和其他类型更容易。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-191\">This addition makes it easier to initialize dictionaries and other types.</span></span> <span data-ttu-id=\"f452a-192\">开始使用字典。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-192\">Start with a dictionary.</span></span> <span data-ttu-id=\"f452a-193\">在交互式窗口中运行以下代码：</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-193\">Run the following code in the interactive window:</span></span>\n\n```csharp\nvar messages = new Dictionary<int, string>\n{\n    [404] = \"Page not Found\",\n    [302] = \"Page moved, but left a forwarding address.\",\n    [500] = \"The web server can't come out to play today.\"\n};\n\nConsole.WriteLine(messages[302]);\n```\n\n<span data-ttu-id=\"f452a-194\">此语法在索引器中设置值，可用于在索引器上具有可访问的 set 访问器的任何类型。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-194\">This syntax, which sets a value in an indexer, can be used for any type that has an accessible set accessor on an indexer.</span></span>\n\n<span data-ttu-id=\"f452a-195\">通过第二个更改，可以更轻松地为表示序列的类型启用初始化表达式语法。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-195\">A second change makes it easier to enable initializer syntax for types that represent sequences.</span></span> <span data-ttu-id=\"f452a-196\">集合初始值设定项可用于任何实现 <xref:System.Collections.IEnumerable> 且具有可公开访问 `Add` 方法的类。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-196\">Collection initializers can be used on any class that implements <xref:System.Collections.IEnumerable> and has a publicly accessible `Add` method.</span></span> <span data-ttu-id=\"f452a-197\">`Add` 现在为扩展方法。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-197\">That `Add` method can now be an extension method.</span></span> \n\n<span data-ttu-id=\"f452a-198\">以下示例显示了此语法的一种场景。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-198\">The following example shows one scenario for this syntax.</span></span> <span data-ttu-id=\"f452a-199\">它创建 `Path` 类，该类实现 `IEnumerable<Point3D>` 并具有用于添加点（包含三个参数）的方法。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-199\">It creates a `Path` class that implements `IEnumerable<Point3D>` and has a method to add points that take three arguments.</span></span> <span data-ttu-id=\"f452a-200\">`Extensions` 类创建其他 `Add` 方法，用于从其三个组件添加新点。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-200\">The `Extensions` class creates an additional `Add` method to add a new point from its three components.</span></span> <span data-ttu-id=\"f452a-201\">由于环境限制，此示例当前不以交互方式运行。</span><span class=\"sxs-lookup\"><span data-stu-id=\"f452a-201\">This sample does not currently run interactively due to restrictions in the environment.</span></span>\n\n```csharp\npublic class Path : IEnumerable<Point3D>\n{\n    private List<Point3D> points = new List<Point3D>();\n    public IEnumerator<Point3D> GetEnumerator() => points.GetEnumerator();\n    IEnumerator IEnumerable.GetEnumerator() => points.GetEnumerator();\n\n    public void Add(Point3D pt) => points.Add(pt);\n}\n\npublic static class Extensions\n{\n    public static void Add(this Path path, double x, double y, double z) => path.Add(new Point3D(x, y, z));\n}\n```\n"
- content: <span data-ttu-id="f452a-202">你已完成对 C# 6 中新功能的探索。</span><span class="sxs-lookup"><span data-stu-id="f452a-202">You've completed an exploration of the new features in C# 6.</span></span> <span data-ttu-id="f452a-203">请立即在应用程序中亲自尝试新功能。</span><span class="sxs-lookup"><span data-stu-id="f452a-203">Now try them yourself in your applications.</span></span>
