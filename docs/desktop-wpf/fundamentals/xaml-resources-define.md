---
title: 定义 XAML 资源
description: 了解适用于 .NET Core 的 WPF 中的 XAML 资源。 了解 XAML 资源的类型，并学习如何定义 XAML 资源。
author: thraka
ms.author: adegeo
ms.date: 08/21/2019
ms.openlocfilehash: b278bb92afc308578d60e347871e0150b26a95db
ms.sourcegitcommit: f8c36054eab877de4d40a705aacafa2552ce70e9
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/31/2019
ms.locfileid: "81432568"
---
# <a name="overview-of-xaml-resources"></a><span data-ttu-id="2c4e0-104">XAML 资源概述</span><span class="sxs-lookup"><span data-stu-id="2c4e0-104">Overview of XAML resources</span></span>

<span data-ttu-id="2c4e0-105">资源是可以在应用中的不同位置重复使用的对象。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-105">A resource is an object that can be reused in different places in your app.</span></span> <span data-ttu-id="2c4e0-106">资源的示例包括画笔和样式。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-106">Examples of resources include brushes and styles.</span></span> <span data-ttu-id="2c4e0-107">本概述介绍如何使用 Extensible Application Markup Language (XAML) 中的资源。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-107">This overview describes how to use resources in Extensible Application Markup Language (XAML).</span></span> <span data-ttu-id="2c4e0-108">你还可以使用代码创建和访问资源。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-108">You can also create and access resources by using code.</span></span>

> [!NOTE]
> <span data-ttu-id="2c4e0-109">本文所述的 XAML 资源与*应用资源*不同，后者通常指添加到应用中的文件，例如内容、数据或嵌入式文件。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-109">XAML resources described in this article are different from *app resources* which are generally files added to an app, such as content, data, or embedded files.</span></span>

<!-- TODO: File redirect from docs\framework\wpf\advanced\xaml-resources.md -->

[!INCLUDE [desktop guide under construction](../../../includes/desktop-guide-preview-note.md)]

## <a name="using-resources-in-xaml"></a><span data-ttu-id="2c4e0-110">使用 XAML 中的资源</span><span class="sxs-lookup"><span data-stu-id="2c4e0-110">Using resources in XAML</span></span>

<span data-ttu-id="2c4e0-111">下面的示例将 <xref:System.Windows.Media.SolidColorBrush> 定义为页面根元素上的资源。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-111">The following example defines a <xref:System.Windows.Media.SolidColorBrush> as a resource on the root element of a page.</span></span> <span data-ttu-id="2c4e0-112">该示例随后引用资源，并使用它来设置多个子元素的属性，其中包括 <xref:System.Windows.Shapes.Ellipse>、<xref:System.Windows.Controls.TextBlock> 和 <xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-112">The example then references the resource and uses it to set properties of several child elements, including an <xref:System.Windows.Shapes.Ellipse>, a <xref:System.Windows.Controls.TextBlock>, and a <xref:System.Windows.Controls.Button>.</span></span>

[!code-xaml[FEResourceSH_snip#XAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResourceSH_snip/CS/page1.xaml#xaml)]

<span data-ttu-id="2c4e0-113">每个框架级元素（<xref:System.Windows.FrameworkElement> 或 <xref:System.Windows.FrameworkContentElement>）都具有 <xref:System.Windows.FrameworkElement.Resources%2A> 属性，该属性是包含已定义资源的 <xref:System.Windows.ResourceDictionary> 类型。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-113">Every framework-level element (<xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>) has a <xref:System.Windows.FrameworkElement.Resources%2A> property, which is a <xref:System.Windows.ResourceDictionary> type that contains defined resources.</span></span> <span data-ttu-id="2c4e0-114">你可以在任何元素上定义资源，例如 <xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-114">You can define resources on any element, such as a <xref:System.Windows.Controls.Button>.</span></span> <span data-ttu-id="2c4e0-115">但是，最常在根元素上定义资源，本示例中的根元素为 <xref:System.Windows.Controls.Page>。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-115">However, resources are most often defined on the root element, which is <xref:System.Windows.Controls.Page> in the example.</span></span>

<span data-ttu-id="2c4e0-116">资源字典中的每个资源都必须具有唯一键。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-116">Each resource in a resource dictionary must have a unique key.</span></span> <span data-ttu-id="2c4e0-117">在标记中定义资源时，可通过 [x:Key 指令](../xaml-services/xkey-directive.md)来分配唯一键。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-117">When you define resources in markup, you assign the unique key through the [x:Key Directive](../xaml-services/xkey-directive.md).</span></span> <span data-ttu-id="2c4e0-118">通常情况下，这个键是一个字符串；但是，也可使用相应的标记扩展将其设置为其他对象类型。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-118">Typically, the key is a string; however, you can also set it to other object types by using the appropriate markup extensions.</span></span> <span data-ttu-id="2c4e0-119">资源的非字符串键用于 WPF 中的某些功能区，尤其是样式、组件资源和数据样式。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-119">Non-string keys for resources are used by certain feature areas in WPF, notably for styles, component resources, and data styling.</span></span>

<span data-ttu-id="2c4e0-120">你可以使用具有资源标记扩展语法（指定资源的键名）的已定义资源。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-120">You can use a defined resource with the resource markup extension syntax that specifies the key name of the resource.</span></span> <span data-ttu-id="2c4e0-121">例如，将资源用作另一个元素上的属性的值。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-121">For example, use the resource as the value of a property on another element.</span></span>

[!code-xaml[FEResourceSH_snip#KeyNameUsage](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResourceSH_snip/CS/page2.xaml#keynameusage)]

<span data-ttu-id="2c4e0-122">在前面的示例中，如果 XAML 加载程序处理 <xref:System.Windows.Controls.Button> 上 <xref:System.Windows.Controls.Control.Background%2A> 属性的值 `{StaticResource MyBrush}`，则资源查找逻辑会首先检查 <xref:System.Windows.Controls.Button> 元素的资源字典。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-122">In the preceding example, when the XAML loader processes the value `{StaticResource MyBrush}` for the <xref:System.Windows.Controls.Control.Background%2A> property on <xref:System.Windows.Controls.Button>, the resource lookup logic first checks the resource dictionary for the <xref:System.Windows.Controls.Button> element.</span></span> <span data-ttu-id="2c4e0-123">如果 <xref:System.Windows.Controls.Button> 没有资源键 `MyBrush` 的定义（在该示例中没有；其资源集合为空），则查找逻辑接下来会检查 <xref:System.Windows.Controls.Button> 的父元素，即 <xref:System.Windows.Controls.Page>。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-123">If <xref:System.Windows.Controls.Button> doesn't have a definition of the resource key `MyBrush` (in that example it doesn't; its resource collection is empty), the lookup next checks the parent element of <xref:System.Windows.Controls.Button>, which is <xref:System.Windows.Controls.Page>.</span></span> <span data-ttu-id="2c4e0-124">如果在 <xref:System.Windows.Controls.Page> 根元素上定义资源，则 <xref:System.Windows.Controls.Page> 的逻辑树中的所有元素都可以访问它。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-124">If you define a resource on the <xref:System.Windows.Controls.Page> root element, all the elements in the logical tree of the <xref:System.Windows.Controls.Page> can access it.</span></span> <span data-ttu-id="2c4e0-125">而且，你可以重复使用相同的资源来设置接受与该资源所表示类型相同的类型的所有属性的值。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-125">And you can reuse the same resource for setting the value of any property that accepts the same type that the resource represents.</span></span> <span data-ttu-id="2c4e0-126">在前面的示例中，同一 `MyBrush` 资源设置两个不同的属性：<xref:System.Windows.Controls.Button> 的 <xref:System.Windows.Controls.Control.Background%2A> 和 <xref:System.Windows.Shapes.Rectangle> 的 <xref:System.Windows.Shapes.Shape.Fill%2A>。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-126">In the previous example, the same `MyBrush` resource sets two different properties: the <xref:System.Windows.Controls.Control.Background%2A> of a <xref:System.Windows.Controls.Button>, and the <xref:System.Windows.Shapes.Shape.Fill%2A> of a <xref:System.Windows.Shapes.Rectangle>.</span></span>

## <a name="static-and-dynamic-resources"></a><span data-ttu-id="2c4e0-127">静态和动态资源</span><span class="sxs-lookup"><span data-stu-id="2c4e0-127">Static and dynamic resources</span></span>

<span data-ttu-id="2c4e0-128">资源可引用为静态资源或动态资源。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-128">A resource can be referenced as either static or dynamic.</span></span> <span data-ttu-id="2c4e0-129">可通过使用 [StaticResource 标记扩展](../../framework/wpf/advanced/staticresource-markup-extension.md)或 [DynamicResource 标记扩展](../../framework/wpf/advanced/dynamicresource-markup-extension.md)创建引用。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-129">References are created by using either the [StaticResource Markup Extension](../../framework/wpf/advanced/staticresource-markup-extension.md) or the [DynamicResource Markup Extension](../../framework/wpf/advanced/dynamicresource-markup-extension.md).</span></span> <span data-ttu-id="2c4e0-130">标记扩展是 XAML 的一项功能，可以通过使用标记扩展来处理属性字符串并将对象返回到 XAML 加载程序，从而指定对象引用。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-130">A markup extension is a XAML feature that lets you specify an object reference by having the markup extension process the attribute string and return the object to a XAML loader.</span></span> <span data-ttu-id="2c4e0-131">有关标记扩展行为的详细信息，请参阅 [标记扩展和 WPF XAML](../../framework/wpf/advanced/markup-extensions-and-wpf-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-131">For more information about markup extension behavior, see [Markup Extensions and WPF XAML](../../framework/wpf/advanced/markup-extensions-and-wpf-xaml.md).</span></span>

<span data-ttu-id="2c4e0-132">使用标记扩展时，通常会以字符串的形式提供一个或多个由该特定标记扩展处理的参数。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-132">When you use a markup extension, you typically provide one or more parameters in string form that are processed by that particular markup extension.</span></span> <span data-ttu-id="2c4e0-133">[StaticResource 标记扩展](../../framework/wpf/advanced/staticresource-markup-extension.md)通过在所有可用的资源字典中查找键值来处理键。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-133">The [StaticResource Markup Extension](../../framework/wpf/advanced/staticresource-markup-extension.md) processes a key by looking up the value for that key in all available resource dictionaries.</span></span> <span data-ttu-id="2c4e0-134">处理在加载期间进行，即加载过程需要分配属性值时。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-134">Processing happens during load, which is when the loading process needs to assign the property value.</span></span> <span data-ttu-id="2c4e0-135">[DynamicResource 标记扩展](../../framework/wpf/advanced/dynamicresource-markup-extension.md)则通过创建表达式来处理键，而且表达式会保持未计算状态，直至应用运行为止。当应用实际运行时，表达式会进行计算并提供一个值。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-135">The [DynamicResource Markup Extension](../../framework/wpf/advanced/dynamicresource-markup-extension.md) instead processes a key by creating an expression, and that expression remains unevaluated until the app runs, at which time the expression is evaluated and provides a value.</span></span>

<span data-ttu-id="2c4e0-136">在引用某个资源时，下列注意事项可能会对于使用静态资源引用还是使用动态资源引用产生影响：</span><span class="sxs-lookup"><span data-stu-id="2c4e0-136">When you reference a resource, the following considerations can influence whether you use a static resource reference or a dynamic resource reference:</span></span>

- <span data-ttu-id="2c4e0-137">确定如何为应用创建资源的整体设计（在每页上、在应用程序中、在宽松的 XAML 中或在仅包含资源的程序集中）时，请考虑以下事项：</span><span class="sxs-lookup"><span data-stu-id="2c4e0-137">When determining the overall design of how you create the resources for your app (per page, in the app, in loose XAML, or in a resource-only assembly), consider the following:</span></span>

- <span data-ttu-id="2c4e0-138">应用的功能。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-138">The app's functionality.</span></span> <span data-ttu-id="2c4e0-139">实时更新资源是否为应用要求的一部分？</span><span class="sxs-lookup"><span data-stu-id="2c4e0-139">Are updating resources in real-time part of your app requirements?</span></span>
- <span data-ttu-id="2c4e0-140">该资源引用类型的相应查找行为。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-140">The respective lookup behavior of that resource reference type.</span></span>
- <span data-ttu-id="2c4e0-141">特定的属性或资源类型，以及这些类型的本机行为。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-141">The particular property or resource type, and the native behavior of those types.</span></span>

## <a name="static-resources"></a><span data-ttu-id="2c4e0-142">静态资源</span><span class="sxs-lookup"><span data-stu-id="2c4e0-142">Static resources</span></span>

<span data-ttu-id="2c4e0-143">在以下情况下，最适合使用静态资源引用：</span><span class="sxs-lookup"><span data-stu-id="2c4e0-143">Static resource references work best for the following circumstances:</span></span>

- <span data-ttu-id="2c4e0-144">应用设计将其大多数资源集中到页面或应用程序级资源字典中。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-144">Your app design concentrates most of its resources into page or application-level resource dictionaries.</span></span> <span data-ttu-id="2c4e0-145">静态资源引用不基于运行时行为（例如重载页面）重新计算。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-145">Static resource references aren't reevaluated based on runtime behaviors, such as reloading a page.</span></span> <span data-ttu-id="2c4e0-146">因此，根据资源和应用设计，如果避免不必要地使用大量动态资源引用，可能会一定程度地提高性能。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-146">So there can be some performance benefit to avoiding large numbers of dynamic resource references when they aren't necessary based on your resource and app design.</span></span>

- <span data-ttu-id="2c4e0-147">要设置不在 <xref:System.Windows.DependencyObject> 或 <xref:System.Windows.Freezable> 上的属性的值。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-147">You're setting the value of a property that isn't on a <xref:System.Windows.DependencyObject> or a <xref:System.Windows.Freezable>.</span></span>

- <span data-ttu-id="2c4e0-148">要创建的资源字典将编译成 DLL，并将打包为应用的一部分或在应用间共享。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-148">You're creating a resource dictionary that will be compiled into a DLL and packaged as part of the app or shared between apps.</span></span>

- <span data-ttu-id="2c4e0-149">要为自定义控件创建主题，并要定义在主题中使用的资源。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-149">You're creating a theme for a custom control and are defining resources that are used within the themes.</span></span> <span data-ttu-id="2c4e0-150">在这种情况下，通常不希望执行动态资源引用查找行为，而是希望执行静态资源引用行为，以确保查找可预测并自包含到主题中。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-150">For this case, you typically do not want the dynamic resource reference lookup behavior; you instead want the static resource reference behavior so that the lookup is predictable and self-contained to the theme.</span></span> <span data-ttu-id="2c4e0-151">使用动态资源引用时，即使主题中的引用也会在运行时前保持未计算状态。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-151">With a dynamic resource reference, even a reference within a theme is left unevaluated until run-time.</span></span> <span data-ttu-id="2c4e0-152">而且，主题可能会得到应用，但某个本地元素仍会重新定义主题正尝试引用的键，并且该本地元素在查找期间会排在主题之前。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-152">and there is a chance that when the theme is applied, some local element will redefine a key that your theme is trying to reference, and the local element will fall prior to the theme itself in the lookup.</span></span> <span data-ttu-id="2c4e0-153">如果发生这种情况，主题的行为将偏离预期方式。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-153">If that happens, your theme will not behave as expected.</span></span>

- <span data-ttu-id="2c4e0-154">要使用资源设置大量依赖属性。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-154">You're using resources to set large numbers of dependency properties.</span></span> <span data-ttu-id="2c4e0-155">依赖属性会通过属性系统启用有效值缓存功能；因此，如果为可在加载时进行计算的依赖属性提供了值，则该依赖属性不必检查是否存在重新计算的表达式并可返回最后一个有效值。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-155">Dependency properties have effective value caching as enabled by the property system, so if you provide a value for a dependency property that can be evaluated at load time, the dependency property doesn't have to check for a reevaluated expression and can return the last effective value.</span></span> <span data-ttu-id="2c4e0-156">此项技术可以提高性能。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-156">This technique can be a performance benefit.</span></span>

- <span data-ttu-id="2c4e0-157">想为所有使用者更改基础资源，或想通过使用 [x:Shared 属性](../xaml-services/xshared-attribute.md)为每个使用者维护单独的可写实例。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-157">You want to change the underlying resource for all consumers, or you want to maintain separate writable instances for each consumer by using the [x:Shared Attribute](../xaml-services/xshared-attribute.md).</span></span>

### <a name="static-resource-lookup-behavior"></a><span data-ttu-id="2c4e0-158">静态资源查找行为</span><span class="sxs-lookup"><span data-stu-id="2c4e0-158">Static resource lookup behavior</span></span>

<span data-ttu-id="2c4e0-159">下面介绍属性或元素引用静态资源时自动发生的查找过程：</span><span class="sxs-lookup"><span data-stu-id="2c4e0-159">The following describes the lookup process that automatically happens when a static resource is referenced by a property or element:</span></span>

01. <span data-ttu-id="2c4e0-160">查找进程在用于设置属性的元素所定义的资源字典中查找请求的键。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-160">The lookup process checks for the requested key within the resource dictionary defined by the element that sets the property.</span></span>

01. <span data-ttu-id="2c4e0-161">查找过程随后会向上遍历逻辑树，以查找父元素及其资源字典。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-161">The lookup process then traverses the logical tree upward to the parent element and its resource dictionary.</span></span> <span data-ttu-id="2c4e0-162">此过程到达根元素后才会停止。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-162">This process continues until the root element is reached.</span></span>

01. <span data-ttu-id="2c4e0-163">检查应用资源。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-163">App resources are checked.</span></span> <span data-ttu-id="2c4e0-164">应用资源就是 <xref:System.Windows.Application> 对象为 WPF 应用定义的资源字典中的资源。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-164">App resources are those resources within the resource dictionary that is defined by the <xref:System.Windows.Application> object for your WPF app.</span></span>

<span data-ttu-id="2c4e0-165">从资源字典中进行的静态资源引用必须引用已在资源引用前进行过词法定义的资源。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-165">Static resource references from within a resource dictionary must reference a resource that has already been defined lexically before the resource reference.</span></span> <span data-ttu-id="2c4e0-166">静态资源引用无法解析前向引用。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-166">Forward references cannot be resolved by a static resource reference.</span></span> <span data-ttu-id="2c4e0-167">因此，请设计资源字典的结构，以便在每个相应资源字典的开头或邻近开头的位置定义资源。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-167">For this reason, design your resource dictionary structure such that resources are defined at or near the beginning of each respective resource dictionary.</span></span>

<span data-ttu-id="2c4e0-168">静态资源查找可以扩展到主题或系统资源中，但此查找受支持只是因为 XAML 加载程序推迟了请求。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-168">Static resource lookup can extend into themes or into system resources, but this lookup is supported only because the XAML loader defers the request.</span></span> <span data-ttu-id="2c4e0-169">为了让页面加载时的运行时主题正确地应用到应用，这种延迟是必需的。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-169">The deferral is necessary so that the runtime theme at the time the page loads applies properly to the app.</span></span> <span data-ttu-id="2c4e0-170">但是，不建议使用对已知仅在主题中存在或作为系统资源存在的键的静态资源引用，因为如果用户实时更改主题，不会重新计算此类引用。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-170">However, static resource references to keys that are known to only exist in themes or as system resources aren't recommended, because such references aren't reevaluated if the theme is changed by the user in real time.</span></span> <span data-ttu-id="2c4e0-171">请求主题或系统资源时，动态资源引用更为可靠。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-171">A dynamic resource reference is more reliable when you request theme or system resources.</span></span> <span data-ttu-id="2c4e0-172">例外情况是当主题元素自身请求另一个资源。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-172">The exception is when a theme element itself requests another resource.</span></span> <span data-ttu-id="2c4e0-173">出于上述原因，这些引用应该是静态资源引用。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-173">These references should be static resource references, for the reasons mentioned earlier.</span></span>

<span data-ttu-id="2c4e0-174">因找不到静态资源引用而引发的异常行为各不相同。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-174">The exception behavior if a static resource reference isn't found varies.</span></span> <span data-ttu-id="2c4e0-175">如果资源被延迟，则异常会在运行时发生。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-175">If the resource was deferred, then the exception occurs at runtime.</span></span> <span data-ttu-id="2c4e0-176">如果资源未延迟，则异常会在加载时发生。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-176">If the resource was not deferred, the exception occurs at load time.</span></span>

## <a name="dynamic-resources"></a><span data-ttu-id="2c4e0-177">动态资源</span><span class="sxs-lookup"><span data-stu-id="2c4e0-177">Dynamic resources</span></span>

<span data-ttu-id="2c4e0-178">在以下情况下，最适合使用动态资源：</span><span class="sxs-lookup"><span data-stu-id="2c4e0-178">Dynamic resources work best when:</span></span>

- <span data-ttu-id="2c4e0-179">资源（包括系统资源或用户可设置的资源）的值取决于直到运行时才知道的条件。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-179">The value of the resource, including system resources, or resources that are otherwise user settable, depends on conditions that aren't known until runtime.</span></span> <span data-ttu-id="2c4e0-180">例如，你可以创建 setter 值（引用由 <xref:System.Windows.SystemColors>、<xref:System.Windows.SystemFonts> 或 <xref:System.Windows.SystemParameters> 公开的系统属性）。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-180">For example, you can create setter values that refer to system properties as exposed by <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, or <xref:System.Windows.SystemParameters>.</span></span> <span data-ttu-id="2c4e0-181">这些值是真正的动态值，因为它们最终来自用户和操作系统的运行时环境。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-181">These values are truly dynamic because they ultimately come from the runtime environment of the user and operating system.</span></span> <span data-ttu-id="2c4e0-182">或许还拥有可能会发生变化的应用程序级主题，而页面级资源访问也必须捕获其中的变化。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-182">You might also have application-level themes that can change, where page-level resource access must also capture the change.</span></span>

- <span data-ttu-id="2c4e0-183">要为自定义控件创建或引用主题样式。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-183">You're creating or referencing theme styles for a custom control.</span></span>

- <span data-ttu-id="2c4e0-184">打算在应用生存期内调整 <xref:System.Windows.ResourceDictionary> 的内容。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-184">You intend to adjust the contents of a <xref:System.Windows.ResourceDictionary> during an app lifetime.</span></span>

- <span data-ttu-id="2c4e0-185">拥有存在相互依赖关系且可能需要进行前向引用的复杂资源结构。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-185">You have a complicated resource structure that has interdependencies, where a forward reference may be required.</span></span> <span data-ttu-id="2c4e0-186">静态资源引用不支持前向引用，但动态资源引用支持，因为资源在运行时之前不需要计算，所以前向引用是一个不相关的概念。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-186">Static resource references do not support forward references, but dynamic resource references do support them because the resource doesn't need to be evaluated until runtime, and forward references are therefore not a relevant concept.</span></span>

- <span data-ttu-id="2c4e0-187">要引用从编译或工作集的角度来看很大的资源，而且该资源在页面加载时可能不会立即使用。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-187">You're referencing a resource that is large from the perspective of a compile or working set, and the resource might not be used immediately when the page loads.</span></span> <span data-ttu-id="2c4e0-188">页面加载时，始终会从 XAML 加载静态资源引用。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-188">Static resource references always load from XAML when the page loads.</span></span> <span data-ttu-id="2c4e0-189">但是，动态资源引用在使用前不会加载。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-189">However, a dynamic resource reference doesn't load until it's used.</span></span>

- <span data-ttu-id="2c4e0-190">要创建的样式的 setter 值可能来自受主题或其他用户设置影响的其他值。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-190">You're creating a style where setter values might come from other values that are influenced by themes or other user settings.</span></span>

- <span data-ttu-id="2c4e0-191">要将资源应用于可能会在应用生存期内在逻辑树中重定父级的元素。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-191">You're applying resources to elements that might be reparented in the logical tree during app lifetime.</span></span> <span data-ttu-id="2c4e0-192">父级更改后，资源查找范围也可能会随之更改；因此，如果希望重定父级的元素的资源基于新范围重新进行计算，请始终使用动态资源引用。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-192">Changing the parent also potentially changes the resource lookup scope, so if you want the resource for a reparented element to be reevaluated based on the new scope, always use a dynamic resource reference.</span></span>

### <a name="dynamic-resource-lookup-behavior"></a><span data-ttu-id="2c4e0-193">动态资源查找行为</span><span class="sxs-lookup"><span data-stu-id="2c4e0-193">Dynamic resource lookup behavior</span></span>

<span data-ttu-id="2c4e0-194">如果调用 <xref:System.Windows.FrameworkElement.FindResource%2A> 或 <xref:System.Windows.FrameworkElement.SetResourceReference%2A>，则动态资源引用的资源查找行为会与代码中的查找行为并行执行：</span><span class="sxs-lookup"><span data-stu-id="2c4e0-194">Resource lookup behavior for a dynamic resource reference parallels the lookup behavior in your code if you call <xref:System.Windows.FrameworkElement.FindResource%2A> or <xref:System.Windows.FrameworkElement.SetResourceReference%2A>:</span></span>

01. <span data-ttu-id="2c4e0-195">查找在用于设置属性的元素所定义的资源字典中查找请求的键：</span><span class="sxs-lookup"><span data-stu-id="2c4e0-195">The lookup checks for the requested key within the resource dictionary defined by the element that sets the property:</span></span>

    - <span data-ttu-id="2c4e0-196">如果元素定义 <xref:System.Windows.FrameworkElement.Style%2A> 属性，则该元素的 <xref:System.Windows.FrameworkElement.Style?displayProperty=fullName> 将检查其 <xref:System.Windows.Style.Resources> 字典。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-196">If the element defines a <xref:System.Windows.FrameworkElement.Style%2A> property, the <xref:System.Windows.FrameworkElement.Style?displayProperty=fullName> of the element has its <xref:System.Windows.Style.Resources> dictionary checked.</span></span>

    - <span data-ttu-id="2c4e0-197">如果元素定义 <xref:System.Windows.Controls.Control.Template%2A> 属性，则检查该元素的 <xref:System.Windows.FrameworkTemplate.Resources?displayProperty=fullName> 字典。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-197">If the element defines a <xref:System.Windows.Controls.Control.Template%2A> property, the <xref:System.Windows.FrameworkTemplate.Resources?displayProperty=fullName> dictionary of the element is checked.</span></span>

01. <span data-ttu-id="2c4e0-198">查找会向上遍历逻辑树，以查找父元素及其资源字典。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-198">The lookup traverses the logical tree upward to the parent element and its resource dictionary.</span></span> <span data-ttu-id="2c4e0-199">此过程到达根元素后才会停止。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-199">This process continues until the root element is reached.</span></span>

01. <span data-ttu-id="2c4e0-200">检查应用资源。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-200">App resources are checked.</span></span> <span data-ttu-id="2c4e0-201">应用资源就是 <xref:System.Windows.Application> 对象为 WPF 应用定义的资源字典中的资源。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-201">App resources are those resources within the resource dictionary that are defined by the <xref:System.Windows.Application> object for your WPF app.</span></span>

01. <span data-ttu-id="2c4e0-202">检查主题资源字典中当前处于活动状态的主题。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-202">The theme resource dictionary is checked for the currently active theme.</span></span> <span data-ttu-id="2c4e0-203">如果主题在运行时发生更改，则会重新计算值。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-203">If the theme changes at runtime, the value is reevaluated.</span></span>

01. <span data-ttu-id="2c4e0-204">检查系统资源。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-204">System resources are checked.</span></span>

<span data-ttu-id="2c4e0-205">异常行为（如果有）各不相同：</span><span class="sxs-lookup"><span data-stu-id="2c4e0-205">Exception behavior (if any) varies:</span></span>

- <span data-ttu-id="2c4e0-206">如果 <xref:System.Windows.FrameworkElement.FindResource%2A> 调用请求了某个资源但未找到该资源，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-206">If a resource was requested by a <xref:System.Windows.FrameworkElement.FindResource%2A> call and was not found, an exception is thrown.</span></span>

- <span data-ttu-id="2c4e0-207">如果 <xref:System.Windows.FrameworkElement.TryFindResource%2A> 调用请求了某个资源但未找到该资源，不会引发任何异常，并且返回的值为 `null`。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-207">If a resource was requested by a <xref:System.Windows.FrameworkElement.TryFindResource%2A> call and was not found, no exception is thrown, and the returned value is `null`.</span></span> <span data-ttu-id="2c4e0-208">如果要设置的属性不接受 `null`，则仍有可能引发更深的异常（取决于要设置的单独属性）。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-208">If the property being set doesn't accept `null`, then it's still possible that a deeper exception will be thrown, depending on the individual property being set.</span></span>

- <span data-ttu-id="2c4e0-209">如果 XAML 中的动态资源引用请求了某个资源但未找到该资源，则行为取决于常规属性系统。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-209">If a resource was requested by a dynamic resource reference in XAML and was not found, then the behavior depends on the general property system.</span></span> <span data-ttu-id="2c4e0-210">常规行为即存在资源的级别上没有发生属性设置操作时执行的行为。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-210">The general behavior is as if no property setting operation occurred at the level where the resource exists.</span></span> <span data-ttu-id="2c4e0-211">例如，如果尝试使用无法计算的资源来设置个别按钮元素上的背景，则值设置操作不会产生任何结果，但有效值可能仍来自属性系统和值优先级中的其他参与者。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-211">For instance, if you attempt to set the background on an individual button element using a resource that could not be evaluated, then no value set results, but the effective value can still come from other participants in the property system and value precedence.</span></span> <span data-ttu-id="2c4e0-212">例如，背景值可能仍来自在本地定义的某个按钮样式，或来自主题样式。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-212">For instance, the background value might still come from a locally defined button style or from the theme style.</span></span> <span data-ttu-id="2c4e0-213">对于并非由主题样式定义的属性，资源计算失败后的有效值可能来自属性元数据中的默认值。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-213">For properties that aren't defined by theme styles, the effective value after a failed resource evaluation might come from the default value in the property metadata.</span></span>

### <a name="restrictions"></a><span data-ttu-id="2c4e0-214">限制</span><span class="sxs-lookup"><span data-stu-id="2c4e0-214">Restrictions</span></span>

<span data-ttu-id="2c4e0-215">动态资源引用存在一些重要限制。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-215">Dynamic resource references have some notable restrictions.</span></span> <span data-ttu-id="2c4e0-216">必须至少满足以下条件之一：</span><span class="sxs-lookup"><span data-stu-id="2c4e0-216">At least one of the following conditions must be true:</span></span>

- <span data-ttu-id="2c4e0-217">要设置的属性必须是 <xref:System.Windows.FrameworkElement> 或 <xref:System.Windows.FrameworkContentElement> 上的属性。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-217">The property being set must be a property on a <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>.</span></span> <span data-ttu-id="2c4e0-218">该属性必须由 <xref:System.Windows.DependencyProperty> 支持。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-218">That property must be backed by a <xref:System.Windows.DependencyProperty>.</span></span>

- <span data-ttu-id="2c4e0-219">该引用用于 `StyleSetter` 内的值。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-219">The reference is for a value within a `StyleSetter`.</span></span>

- <span data-ttu-id="2c4e0-220">要设置的属性必须是 <xref:System.Windows.Freezable>（以 <xref:System.Windows.FrameworkElement> 或 <xref:System.Windows.FrameworkContentElement> 属性的值或 <xref:System.Windows.Setter> 值的形式提供）上的属性。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-220">The property being set must be a property on a <xref:System.Windows.Freezable> that is provided as a value of either a <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> property, or a <xref:System.Windows.Setter> value.</span></span>

<span data-ttu-id="2c4e0-221">由于要设置的属性必须是 <xref:System.Windows.DependencyProperty> 或 <xref:System.Windows.Freezable> 属性，大多数属性更改都可以传播到 UI，这是因为属性更改（更改的动态资源值）会经由属性系统确认。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-221">Because the property being set must be a <xref:System.Windows.DependencyProperty> or <xref:System.Windows.Freezable> property, most property changes can propagate to the UI because a property change (the changed dynamic resource value) is acknowledged by the property system.</span></span> <span data-ttu-id="2c4e0-222">大多数控件都包含相应的逻辑；当 <xref:System.Windows.DependencyProperty> 有所更改且该属性可能会影响布局时，该逻辑将强制使用控件的其他布局。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-222">Most controls include logic that will force another layout of a control if a <xref:System.Windows.DependencyProperty> changes and that property might affect layout.</span></span> <span data-ttu-id="2c4e0-223">但是，并不保证所有使用 [DynamicResource 标记扩展](../../framework/wpf/advanced/dynamicresource-markup-extension.md)作为其值的属性都能在 UI 中提供实时更新。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-223">However, not all properties that have a [DynamicResource Markup Extension](../../framework/wpf/advanced/dynamicresource-markup-extension.md) as their value are guaranteed to provide real time updates in the UI.</span></span> <span data-ttu-id="2c4e0-224">此功能可能仍会因属性、属性所属的类型，甚至应用的逻辑结构而异。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-224">That functionality still might vary depending on the property, as well as depending on the type that owns the property, or even the logical structure of your app.</span></span>

## <a name="styles-datatemplates-and-implicit-keys"></a><span data-ttu-id="2c4e0-225">样式、DataTemplate 和隐式键</span><span class="sxs-lookup"><span data-stu-id="2c4e0-225">Styles, DataTemplates, and implicit keys</span></span>

<span data-ttu-id="2c4e0-226">尽管 <xref:System.Windows.ResourceDictionary> 中的所有项都必须具有键，但这并不意味着所有资源都必须具有显式 `x:Key`。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-226">Although all items in a <xref:System.Windows.ResourceDictionary> must have a key, that doesn't mean that all resources must have an explicit `x:Key`.</span></span> <span data-ttu-id="2c4e0-227">多种对象类型在定义为资源时都支持隐式键，其键值会与另一属性的值绑定。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-227">Several object types support an implicit key when defined as a resource, where the key value is tied to the value of another property.</span></span> <span data-ttu-id="2c4e0-228">这类键被称为隐式键，而 `x:Key` 属性为显式键。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-228">This type of key is known as an implicit key, whereas an `x:Key` attribute is an explicit key.</span></span> <span data-ttu-id="2c4e0-229">任何隐式键都可通过指定显式键来覆盖。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-229">You can overwrite any implicit key by specifying an explicit key.</span></span>

<span data-ttu-id="2c4e0-230">关于资源，一个重要的方案就是用于定义 <xref:System.Windows.Style>。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-230">One important scenario for resources is when you define a <xref:System.Windows.Style>.</span></span> <span data-ttu-id="2c4e0-231">事实上，<xref:System.Windows.Style> 几乎总会作为资源字典中的条目进行定义，因为样式在本质上可供重复使用。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-231">In fact, a <xref:System.Windows.Style> is almost always defined as an entry in a resource dictionary, because styles are inherently intended for reuse.</span></span> <span data-ttu-id="2c4e0-232">有关样式的详细信息，请参阅[样式设置和模板化](styles-templates-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-232">For more information about styles, see [Styling and Templating](styles-templates-overview.md).</span></span>

<span data-ttu-id="2c4e0-233">控件样式可通过隐式键来创建和引用。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-233">Styles for controls can be both created with and referenced with an implicit key.</span></span> <span data-ttu-id="2c4e0-234">用于定义控件默认外观的主题样式依赖于该隐式键。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-234">The theme styles that define the default appearance of a control rely on this implicit key.</span></span> <span data-ttu-id="2c4e0-235">从请求的角度来看，隐式键是控件本身的 <xref:System.Type>。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-235">From the standpoint of requesting it, the implicit key is the <xref:System.Type> of the control itself.</span></span> <span data-ttu-id="2c4e0-236">从定义资源的角度来看，隐式键是样式的 <xref:System.Windows.Style.TargetType%2A>。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-236">From the standpoint of defining the resources, the implicit key is the <xref:System.Windows.Style.TargetType%2A> of the style.</span></span> <span data-ttu-id="2c4e0-237">因此，如果要创建自定义控件的主题或要创建会与现有主题样式交互的样式，则无需为该 <xref:System.Windows.Style> 指定 [x:Key 指令](../xaml-services/xkey-directive.md)。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-237">Therefore, if you're creating themes for custom controls or creating styles that interact with existing theme styles, you do not need to specify an [x:Key Directive](../xaml-services/xkey-directive.md) for that <xref:System.Windows.Style>.</span></span> <span data-ttu-id="2c4e0-238">另外，如果想要使用主题样式，则根本无需指定任何样式。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-238">And if you want to use the themed styles, you do not need to specify any style at all.</span></span> <span data-ttu-id="2c4e0-239">例如，即使 <xref:System.Windows.Style> 资源似乎没有键，以下样式定义仍起作用：</span><span class="sxs-lookup"><span data-stu-id="2c4e0-239">For instance, the following style definition works, even though the <xref:System.Windows.Style> resource doesn't appear to have a key:</span></span>

[!code-xaml[FEResourceSH_snip#ImplicitStyle](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResourceSH_snip/CS/page2.xaml#implicitstyle)]

<span data-ttu-id="2c4e0-240">该样式确实具有一个键：隐式键 `typeof(System.Windows.Controls.Button)`。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-240">That style really does have a key: the implicit key `typeof(System.Windows.Controls.Button)`.</span></span> <span data-ttu-id="2c4e0-241">在标记中，可以直接将 <xref:System.Windows.Style.TargetType%2A> 指定为类型名称（或者，可以选择使用 [{x:Type...}](../xaml-services/xtype-markup-extension.md)</span><span class="sxs-lookup"><span data-stu-id="2c4e0-241">In markup, you can specify a <xref:System.Windows.Style.TargetType%2A> directly as the type name (or you can optionally use [{x:Type...}](../xaml-services/xtype-markup-extension.md)</span></span> <span data-ttu-id="2c4e0-242">返回 <xref:System.Type>）。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-242">to return a <xref:System.Type>.</span></span>

<span data-ttu-id="2c4e0-243">通过 WPF 使用的默认主题样式机制，即使 <xref:System.Windows.Controls.Button> 本身不尝试指定其 <xref:System.Windows.FrameworkElement.Style%2A> 属性或对样式的特定资源引用，该样式也将作为页面上 <xref:System.Windows.Controls.Button> 的运行时样式应用。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-243">Through the default theme style mechanisms used by WPF, that style is applied as the runtime style of a <xref:System.Windows.Controls.Button> on the page, even though the <xref:System.Windows.Controls.Button> itself doesn't attempt to specify its <xref:System.Windows.FrameworkElement.Style%2A> property or a specific resource reference to the style.</span></span> <span data-ttu-id="2c4e0-244">在页面中定义的样式位于查找序列中的靠前位置（在主题字典样式之前），其所用的键与主题字典样式的键相同。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-244">Your style defined in the page is found earlier in the lookup sequence than the theme dictionary style, using the same key that the theme dictionary style has.</span></span> <span data-ttu-id="2c4e0-245">可以在页面上的任意位置指定 `<Button>Hello</Button>`，使用 `Button` 的 <xref:System.Windows.Style.TargetType%2A> 定义的样式将应用于该按钮。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-245">You could just specify `<Button>Hello</Button>` anywhere in the page, and the style you defined with <xref:System.Windows.Style.TargetType%2A> of `Button` would apply to that button.</span></span> <span data-ttu-id="2c4e0-246">如果需要，仍可为此样式显式指定与 <xref:System.Windows.Style.TargetType%2A> 的类型值相同的键，以求在标记中清楚明示，但这是可选的。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-246">If you want, you can still explicitly key the style with the same type value as <xref:System.Windows.Style.TargetType%2A> for clarity in your markup, but that is optional.</span></span>

<span data-ttu-id="2c4e0-247">如果 <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> 为 `true`，则样式的隐式键不会应用于控件。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-247">Implicit keys for styles do not apply on a control if <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> is `true`.</span></span> <span data-ttu-id="2c4e0-248">（另请注意，<xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> 可能被设置为控件类的本机行为的一部分，而不是在控件的实例上显式设置。）此外，为了支持在派生类方案中使用隐式键，控件必须替代 <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A>（作为 WPF 的一部分提供的所有现有控件都包括此替代）。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-248">(Also note that <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> might be set as part of native behavior for the control class, rather than explicitly on an instance of the control.) Also, in order to support implicit keys for derived class scenarios, the control must override <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> (all existing controls provided as part of WPF include this override).</span></span> <span data-ttu-id="2c4e0-249">有关样式、主题和控件设计的详细信息，请参阅[可样式化控件的设计指南](../../framework/wpf/controls/guidelines-for-designing-stylable-controls.md)。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-249">For more information about styles, themes, and control design, see [Guidelines for Designing Stylable Controls](../../framework/wpf/controls/guidelines-for-designing-stylable-controls.md).</span></span>

<span data-ttu-id="2c4e0-250"><xref:System.Windows.DataTemplate> 也有一个隐式键。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-250"><xref:System.Windows.DataTemplate> also has an implicit key.</span></span> <span data-ttu-id="2c4e0-251"><xref:System.Windows.DataTemplate> 的隐式键是 <xref:System.Windows.DataTemplate.DataType%2A> 属性值。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-251">The implicit key for a <xref:System.Windows.DataTemplate> is the <xref:System.Windows.DataTemplate.DataType%2A> property value.</span></span> <span data-ttu-id="2c4e0-252"><xref:System.Windows.DataTemplate.DataType%2A> 也可以作为类型的名称来指定，而不是使用 [{x:Type...}](../xaml-services/xtype-markup-extension.md) 来显式指定。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-252"><xref:System.Windows.DataTemplate.DataType%2A> can also be specified as the name of the type rather than explicitly using [{x:Type...}](../xaml-services/xtype-markup-extension.md).</span></span> <span data-ttu-id="2c4e0-253">有关详细信息，请参阅[数据模板化概述](../../framework/wpf/data/data-templating-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="2c4e0-253">For details, see [Data Templating Overview](../../framework/wpf/data/data-templating-overview.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="2c4e0-254">请参阅</span><span class="sxs-lookup"><span data-stu-id="2c4e0-254">See also</span></span>

- <xref:System.Windows.ResourceDictionary>
- [<span data-ttu-id="2c4e0-255">应用程序资源</span><span class="sxs-lookup"><span data-stu-id="2c4e0-255">Application resources</span></span>](../../framework/wpf/advanced/optimizing-performance-application-resources.md)
- [<span data-ttu-id="2c4e0-256">资源和代码</span><span class="sxs-lookup"><span data-stu-id="2c4e0-256">Resources and code</span></span>](../../framework/wpf/advanced/resources-and-code.md)
- [<span data-ttu-id="2c4e0-257">定义和引用资源</span><span class="sxs-lookup"><span data-stu-id="2c4e0-257">Define and reference a resource</span></span>](../../framework/wpf/advanced/how-to-define-and-reference-a-resource.md)
- [<span data-ttu-id="2c4e0-258">应用程序管理概述</span><span class="sxs-lookup"><span data-stu-id="2c4e0-258">Application management overview</span></span>](../../framework/wpf/app-development/application-management-overview.md)
- [<span data-ttu-id="2c4e0-259">x:Type 标记扩展</span><span class="sxs-lookup"><span data-stu-id="2c4e0-259">x:Type markup extension</span></span>](../xaml-services/xtype-markup-extension.md)
- [<span data-ttu-id="2c4e0-260">StaticResource 标记扩展</span><span class="sxs-lookup"><span data-stu-id="2c4e0-260">StaticResource markup extension</span></span>](../../framework/wpf/advanced/staticresource-markup-extension.md)
- [<span data-ttu-id="2c4e0-261">DynamicResource 标记扩展</span><span class="sxs-lookup"><span data-stu-id="2c4e0-261">DynamicResource markup extension</span></span>](../../framework/wpf/advanced/dynamicresource-markup-extension.md)
