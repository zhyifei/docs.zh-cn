---
title: XAML 的类型转换器概述
ms.date: 03/30/2017
helpviewer_keywords:
- XAML [XAML Services], type converters
- XAML [XAML Services], TypeConverter
- type conversion for XAML [XAML Services]
ms.assetid: 51a65860-efcb-4fe0-95a0-1c679cde66b7
ms.openlocfilehash: c3c69aebacd140a14e74545d601c0207cb8de681
ms.sourcegitcommit: c2d9718996402993cf31541f11e95531bc68bad0
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/27/2020
ms.locfileid: "81432868"
---
# <a name="overview-of-type-converters-for-xaml"></a><span data-ttu-id="b4409-102">XAML 类型转换器概述</span><span class="sxs-lookup"><span data-stu-id="b4409-102">Overview of type converters for XAML</span></span>

<span data-ttu-id="b4409-103">类型转换器为对象编写器提供逻辑，用于从 XAML 标记中的字符串转换为对象图中的特定对象。</span><span class="sxs-lookup"><span data-stu-id="b4409-103">Type converters supply logic for an object writer that converts from a string in XAML markup into particular objects in an object graph.</span></span> <span data-ttu-id="b4409-104">在 .NET XAML 服务中，类型转换器必须是派生自<xref:System.ComponentModel.TypeConverter>的类。</span><span class="sxs-lookup"><span data-stu-id="b4409-104">In .NET XAML Services, the type converter must be a class that derives from <xref:System.ComponentModel.TypeConverter>.</span></span> <span data-ttu-id="b4409-105">某些转换器还支持 XAML 保存路径，可以用于将对象从序列化标记序列化为字符串形式。</span><span class="sxs-lookup"><span data-stu-id="b4409-105">Some converters also support the XAML save path and can be used to serialize an object into a string form in serialization markup.</span></span> <span data-ttu-id="b4409-106">本主题介绍如何以及何时调用 XAML 中的类型转换器，以及为 <xref:System.ComponentModel.TypeConverter>的方法重写提供实现建议。</span><span class="sxs-lookup"><span data-stu-id="b4409-106">This topic describes how and when type converters in XAML are invoked, and provides implementation advice for the method overrides of <xref:System.ComponentModel.TypeConverter>.</span></span>

## <a name="type-conversion-concepts"></a><span data-ttu-id="b4409-107">类型转换概念</span><span class="sxs-lookup"><span data-stu-id="b4409-107">Type Conversion Concepts</span></span>

<span data-ttu-id="b4409-108">以下各节介绍有关 XAML 如何使用字符串的基本概念，以及 .NET XAML 服务中的对象编写器如何使用类型转换器来处理 XAML 源中遇到的一些字符串值。</span><span class="sxs-lookup"><span data-stu-id="b4409-108">The following sections explain basic concepts about how XAML uses strings, and how object writers in .NET XAML Services use type converters to process some of the string values that are encountered in a XAML source.</span></span>

### <a name="xaml-and-string-values"></a><span data-ttu-id="b4409-109">XAML 和字符串值</span><span class="sxs-lookup"><span data-stu-id="b4409-109">XAML and String Values</span></span>

<span data-ttu-id="b4409-110">在 XAML 文件中设置特性值时，该值的初始类型在一般意义上是字符串，在 XML 意义上是字符串特性值。</span><span class="sxs-lookup"><span data-stu-id="b4409-110">When you set an attribute value in a XAML file, the initial type of that value is a string in a general sense, and a string attribute value in an XML sense.</span></span> <span data-ttu-id="b4409-111">甚至其他基元（如 <xref:System.Double> ）最初对于 XAML 处理器都是字符串。</span><span class="sxs-lookup"><span data-stu-id="b4409-111">Even other primitives such as <xref:System.Double> are initially strings to a XAML processor.</span></span>

<span data-ttu-id="b4409-112">在大多数情况下，XAML 处理器需要两条信息来处理特性值。</span><span class="sxs-lookup"><span data-stu-id="b4409-112">In most cases, a XAML processor needs two pieces of information to process an attribute value.</span></span> <span data-ttu-id="b4409-113">第一条信息是所设置的属性的值类型。</span><span class="sxs-lookup"><span data-stu-id="b4409-113">The first piece of information is the value type of the property that is being set.</span></span> <span data-ttu-id="b4409-114">定义特性值以及在 XAML 中进行处理的任何字符串都必须最终转换或解析为该类型的值。</span><span class="sxs-lookup"><span data-stu-id="b4409-114">Any string that defines an attribute value and that is processed in XAML must ultimately be converted or resolved to a value of that type.</span></span> <span data-ttu-id="b4409-115">如果值是 XAML 分析器可理解的基元（如数值），则会尝试直接转换字符串。</span><span class="sxs-lookup"><span data-stu-id="b4409-115">If the value is a primitive that is understood by the XAML parser (such as a numeric value), a direct conversion of the string is attempted.</span></span> <span data-ttu-id="b4409-116">如果特性的值引用枚举，则会检查提供的字符串中是否存在与该枚举中的命名常量匹配的名称。</span><span class="sxs-lookup"><span data-stu-id="b4409-116">If the value for the attribute references an enumeration, the supplied string is checked for a name match to a named constant in that enumeration.</span></span> <span data-ttu-id="b4409-117">如果值不是分析器理解的原始元或枚举中的常量名称，则适用的类型必须能够提供基于转换字符串的值或引用。</span><span class="sxs-lookup"><span data-stu-id="b4409-117">If the value is not a parser-understood primitive or a constant name from an enumeration, the applicable type must be able to provide a value or reference that is based on a converted string.</span></span>

> [!NOTE]
> <span data-ttu-id="b4409-118">XAML 语言指令不使用类型转换器。</span><span class="sxs-lookup"><span data-stu-id="b4409-118">XAML language directives do not use type converters.</span></span>

### <a name="type-converters-and-markup-extensions"></a><span data-ttu-id="b4409-119">类型转换器和标记扩展</span><span class="sxs-lookup"><span data-stu-id="b4409-119">Type Converters and Markup Extensions</span></span>

<span data-ttu-id="b4409-120">标记扩展用法必须先由 XAML 处理器进行处理，然后才能检查属性类型和其他注意事项。</span><span class="sxs-lookup"><span data-stu-id="b4409-120">Markup extension usages must be handled by a XAML processor before it checks for property type and other considerations.</span></span> <span data-ttu-id="b4409-121">例如，如果设置为特性的属性通常具有类型转换，但在特定情况下通过标记扩展用法进行设置，则标记扩展行为会首先进行处理。</span><span class="sxs-lookup"><span data-stu-id="b4409-121">For example, if a property being set as an attribute normally has a type conversion, but in a particular case is set by a markup extension usage, then the markup extension behavior processes first.</span></span> <span data-ttu-id="b4409-122">需要标记扩展的一种常见情况是使对已存在的对象进行引用。</span><span class="sxs-lookup"><span data-stu-id="b4409-122">One common situation where a markup extension is necessary is to make a reference to an object that already exists.</span></span> <span data-ttu-id="b4409-123">对于这种情况，无状态类型转换器只能生成新实例，这可能并不理想。</span><span class="sxs-lookup"><span data-stu-id="b4409-123">For this scenario, a stateless type converter can only generate a new instance, which might not be desirable.</span></span> <span data-ttu-id="b4409-124">有关标记扩展的详细信息，请参阅 [Markup Extensions for XAML Overview](markup-extensions-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="b4409-124">For more information about markup extensions, see [Markup Extensions for XAML Overview](markup-extensions-overview.md).</span></span>

### <a name="native-type-converters"></a><span data-ttu-id="b4409-125">本机类型转换器</span><span class="sxs-lookup"><span data-stu-id="b4409-125">Native Type Converters</span></span>

<span data-ttu-id="b4409-126">在 Windows 演示基础 （WPF） 和 .NET XAML 服务实现中，某些 CLR 类型具有本机类型转换处理。</span><span class="sxs-lookup"><span data-stu-id="b4409-126">In the Windows Presentation Foundation (WPF) and .NET XAML services implementations, there are certain CLR types that have native type conversion handling.</span></span> <span data-ttu-id="b4409-127">但是，这些 CLR 类型通常不被视为基元。</span><span class="sxs-lookup"><span data-stu-id="b4409-127">However, those CLR types are not conventionally thought of as primitives.</span></span> <span data-ttu-id="b4409-128">这种类型的一个示例是 <xref:System.DateTime>。</span><span class="sxs-lookup"><span data-stu-id="b4409-128">An example of such a type is <xref:System.DateTime>.</span></span> <span data-ttu-id="b4409-129">造成这种情况的原因之一是 .NET Framework 体系结构的工作原理：类型 <xref:System.DateTime> 在 mscorlib（.NET 中最基本的库中）中定义。</span><span class="sxs-lookup"><span data-stu-id="b4409-129">One reason for this is how the .NET Framework architecture works: the type <xref:System.DateTime> is defined in mscorlib, the most basic library in .NET.</span></span> <span data-ttu-id="b4409-130"><xref:System.DateTime>不允许将来自引入依赖项的另一个程序集的属性属性归用（<xref:System.ComponentModel.TypeConverterAttribute>来自 System）。</span><span class="sxs-lookup"><span data-stu-id="b4409-130"><xref:System.DateTime> is not permitted to be attributed with an attribute that comes from another assembly that introduces a dependency (<xref:System.ComponentModel.TypeConverterAttribute> is from System).</span></span> <span data-ttu-id="b4409-131">因此，不支持通过归因进行通常的类型转换器发现机制。</span><span class="sxs-lookup"><span data-stu-id="b4409-131">Therefore, the usual type converter discovery mechanism by attributing cannot be supported.</span></span> <span data-ttu-id="b4409-132">相反，XAML 分析器具有需要本机处理的类型的列表，它可通过与真正基元的处理方式类似的方式来处理这些类型。</span><span class="sxs-lookup"><span data-stu-id="b4409-132">Instead, the XAML parser has a list of types that need native processing, and it processes these types similar to how the true primitives are processed.</span></span> <span data-ttu-id="b4409-133">对于 <xref:System.DateTime>，这种处理涉及调用 <xref:System.DateTime.Parse%2A>。</span><span class="sxs-lookup"><span data-stu-id="b4409-133">In the case of <xref:System.DateTime>, this processing involves a call to <xref:System.DateTime.Parse%2A>.</span></span>

## <a name="implementing-a-type-converter"></a><span data-ttu-id="b4409-134">实现类型转换器</span><span class="sxs-lookup"><span data-stu-id="b4409-134">Implementing a Type Converter</span></span>

<span data-ttu-id="b4409-135">以下各节讨论 <xref:System.ComponentModel.TypeConverter> 类的 API。</span><span class="sxs-lookup"><span data-stu-id="b4409-135">The following sections discuss the API of the <xref:System.ComponentModel.TypeConverter> class.</span></span>

### <a name="typeconverter"></a><span data-ttu-id="b4409-136">TypeConverter</span><span class="sxs-lookup"><span data-stu-id="b4409-136">TypeConverter</span></span>

<span data-ttu-id="b4409-137">在 .NET XAML 服务下，用于 XAML 用途的所有类型转换器都是派生自基类<xref:System.ComponentModel.TypeConverter>的类。</span><span class="sxs-lookup"><span data-stu-id="b4409-137">Under .NET XAML Services, all type converters that are used for XAML purposes are classes that derive from the base class <xref:System.ComponentModel.TypeConverter>.</span></span> <span data-ttu-id="b4409-138"><xref:System.ComponentModel.TypeConverter> 类在 XAML 出现之前便存在于 .NET Framework 各版本中；原始 <xref:System.ComponentModel.TypeConverter> 方案之一是在可视化设计器中为属性编辑器提供字符串转换。</span><span class="sxs-lookup"><span data-stu-id="b4409-138">The <xref:System.ComponentModel.TypeConverter> class existed in versions of the .NET Framework before XAML existed; one of the original <xref:System.ComponentModel.TypeConverter> scenarios was to provide string conversion for property editors in visual designers.</span></span>

<span data-ttu-id="b4409-139">对于 XAML， <xref:System.ComponentModel.TypeConverter> 的角色已进行了扩展。</span><span class="sxs-lookup"><span data-stu-id="b4409-139">For XAML, the role of <xref:System.ComponentModel.TypeConverter> is expanded.</span></span> <span data-ttu-id="b4409-140">对于 XAML 用途， <xref:System.ComponentModel.TypeConverter> 是用于为某些变为字符串和源自字符串转换提供支持的基类。</span><span class="sxs-lookup"><span data-stu-id="b4409-140">For XAML purposes, <xref:System.ComponentModel.TypeConverter> is the base class for providing support for certain to-string and from-string conversions.</span></span> <span data-ttu-id="b4409-141">通过源自字符串转换可从 XAML 分析字符串特性值。</span><span class="sxs-lookup"><span data-stu-id="b4409-141">From-string enables parsing a string attribute value from XAML.</span></span> <span data-ttu-id="b4409-142">通过变为字符串转换可处理特定对象属性的运行时值以恢复为 XAML 中的特性，从而实现序列化。</span><span class="sxs-lookup"><span data-stu-id="b4409-142">To-string might enable processing a run-time value of a particular object property back into an attribute in XAML for serialization.</span></span>

<span data-ttu-id="b4409-143"><xref:System.ComponentModel.TypeConverter> 定义了四个成员，它们对于针对 XAML 处理用途的转换为字符串和从字符串转换是相关的：</span><span class="sxs-lookup"><span data-stu-id="b4409-143"><xref:System.ComponentModel.TypeConverter> defines four members that are relevant for converting to-string and from-string for XAML processing purposes:</span></span>

- <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>

- <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>

- <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>

- <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>

<span data-ttu-id="b4409-144">在这些成员中，最重要的方法是 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>，它将输入字符串转换为所需的对象类型。</span><span class="sxs-lookup"><span data-stu-id="b4409-144">Of these members, the most important method is <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>, which converts the input string to the required object type.</span></span> <span data-ttu-id="b4409-145">可以实现 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 方法以将更广泛的类型转换为转换器的预期目标类型。</span><span class="sxs-lookup"><span data-stu-id="b4409-145">The <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method can be implemented to convert a wider range of types into the intended destination type of the converter.</span></span> <span data-ttu-id="b4409-146">因此，它可以实现扩展到 XAML 外部的用途，如支持运行时转换。</span><span class="sxs-lookup"><span data-stu-id="b4409-146">Therefore, it can serve purposes that extend beyond XAML, such as supporting run-time conversions.</span></span> <span data-ttu-id="b4409-147">但是，对于 XAML 使用，只有可以处理 <xref:System.String> 输入的代码路径才十分重要。</span><span class="sxs-lookup"><span data-stu-id="b4409-147">However, for XAML use, only the code path that can process a <xref:System.String> input is important.</span></span>

<span data-ttu-id="b4409-148">第二个最重要的方法是<xref:System.ComponentModel.TypeConverter.ConvertTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="b4409-148">The second-most important method is <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span> <span data-ttu-id="b4409-149">如果将应用程序转换为标记表示形式（例如，如果应用程序作为文件保存到 XAML），<xref:System.ComponentModel.TypeConverter.ConvertTo%2A>则涉及 XAML 文本编写器的较大方案以生成标记表示形式。</span><span class="sxs-lookup"><span data-stu-id="b4409-149">If an application is converted to a markup representation (for example, if it is saved to XAML as a file), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is involved in the larger scenario of a XAML text writer to produce a markup representation.</span></span> <span data-ttu-id="b4409-150">在这种情况下，XAML 的重要代码路径是调用方何时传递 `destinationType` 的 <xref:System.String>。</span><span class="sxs-lookup"><span data-stu-id="b4409-150">In this case, the important code path for XAML is when the caller passes a `destinationType` of <xref:System.String>.</span></span>

<span data-ttu-id="b4409-151"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> 和 <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> 是在服务查询 <xref:System.ComponentModel.TypeConverter> 实现的功能时使用的支持方法。</span><span class="sxs-lookup"><span data-stu-id="b4409-151"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> and <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> are support methods that are used when a service queries the capabilities of the <xref:System.ComponentModel.TypeConverter> implementation.</span></span> <span data-ttu-id="b4409-152">必须实现这些方法以便为转换器的等效转换方法支持的特定于类型的情况返回 `true` 。</span><span class="sxs-lookup"><span data-stu-id="b4409-152">You must implement these methods to return `true` for type-specific cases that the equivalent conversion methods of your converter support.</span></span> <span data-ttu-id="b4409-153">对于 XAML 用途，这通常意味着 <xref:System.String> 类型。</span><span class="sxs-lookup"><span data-stu-id="b4409-153">For XAML purposes, this generally means the <xref:System.String> type.</span></span>

### <a name="culture-information-and-type-converters-for-xaml"></a><span data-ttu-id="b4409-154">XAML 的区域性信息和类型转换器</span><span class="sxs-lookup"><span data-stu-id="b4409-154">Culture Information and Type Converters for XAML</span></span>

<span data-ttu-id="b4409-155">每个 <xref:System.ComponentModel.TypeConverter> 实现都可以唯一地解释对于转换是有效字符串的内容，它还可以使用或忽略作为参数传递的类型说明。</span><span class="sxs-lookup"><span data-stu-id="b4409-155">Each <xref:System.ComponentModel.TypeConverter> implementation can uniquely interpret what is a valid string for a conversion, and it can also use or ignore the type description that is passed as parameters.</span></span> <span data-ttu-id="b4409-156">区域性和 XAML 类型转换的一个重要注意事项如下所示：尽管 XAML 支持使用可本地化的字符串作为特性值，但是不能使用这些可本地化的字符串作为具有特定区域性要求的类型转换器输入。</span><span class="sxs-lookup"><span data-stu-id="b4409-156">An important consideration for culture and XAML type conversion is the following: although using localizable strings as attribute values is supported by XAML, you cannot use these localizable strings as type converter input with specific culture requirements.</span></span> <span data-ttu-id="b4409-157">存在此限制是因为 XAML 特性值的类型转换器涉及使用 `en-US` 区域性的必定固定的语言 XAML 处理行为。</span><span class="sxs-lookup"><span data-stu-id="b4409-157">This limitation is because type converters for XAML attribute values involve a necessarily fixed-language XAML-processing behavior that uses `en-US` culture.</span></span> <span data-ttu-id="b4409-158">有关此限制的设计原因的详细信息，请参阅 XAML 语言规范[\[（MS-XAML）\]](https://docs.microsoft.com/previous-versions/msp-n-p/ff650760(v=pandp.10))或[WPF 全球化和本地化概述](../../framework/wpf/advanced/wpf-globalization-and-localization-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="b4409-158">For more information about the design reasons for this restriction, see the XAML language specification ([\[MS-XAML\]](https://docs.microsoft.com/previous-versions/msp-n-p/ff650760(v=pandp.10))) or [WPF Globalization and Localization Overview](../../framework/wpf/advanced/wpf-globalization-and-localization-overview.md).</span></span>

<span data-ttu-id="b4409-159">区域性可能会产生问题的一个示例是，某些区域性使用逗号而不是句点作为字符串形式的数字的小数点分隔符。</span><span class="sxs-lookup"><span data-stu-id="b4409-159">As an example where culture can be an issue, some cultures use a comma instead of a period as the decimal point delimiter for numbers in string form.</span></span> <span data-ttu-id="b4409-160">这种用法与许多现有类型转换器所具有的行为（即使用逗号作为分隔符）冲突。</span><span class="sxs-lookup"><span data-stu-id="b4409-160">This use collides with the behavior that many existing type converters have, which is to use a comma as a delimiter.</span></span> <span data-ttu-id="b4409-161">在周围的 XAML 中通过 `xml:lang` 传递区域性无法解决此问题。</span><span class="sxs-lookup"><span data-stu-id="b4409-161">Passing a culture through `xml:lang` in the surrounding XAML does not solve the issue.</span></span>

### <a name="implementing-convertfrom"></a><span data-ttu-id="b4409-162">实现 ConvertFrom</span><span class="sxs-lookup"><span data-stu-id="b4409-162">Implementing ConvertFrom</span></span>

<span data-ttu-id="b4409-163">若要能够用作支持 XAML 的 <xref:System.ComponentModel.TypeConverter> 实现，该转换器的 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 方法必须接受字符串作为 `value` 参数。</span><span class="sxs-lookup"><span data-stu-id="b4409-163">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method for that converter must accept a string as the `value` parameter.</span></span> <span data-ttu-id="b4409-164">如果字符串采用有效格式，并且可以由 <xref:System.ComponentModel.TypeConverter> 实现进行转换，则返回对象必须支持强制转换为属性预期的类型。</span><span class="sxs-lookup"><span data-stu-id="b4409-164">If the string is in a valid format and can be converted by the <xref:System.ComponentModel.TypeConverter> implementation, the returned object must support a cast to the type that is expected by the property.</span></span> <span data-ttu-id="b4409-165">否则， <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 实现必须返回 `null`。</span><span class="sxs-lookup"><span data-stu-id="b4409-165">Otherwise, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation must return `null`.</span></span>

<span data-ttu-id="b4409-166">每个 <xref:System.ComponentModel.TypeConverter> 实现都可以唯一地解释对于转换构成效字符串的内容，它还可以使用或忽略作为参数传递的类型说明或区域性上下文。</span><span class="sxs-lookup"><span data-stu-id="b4409-166">Each <xref:System.ComponentModel.TypeConverter> implementation can uniquely interpret what constitutes a valid string for a conversion, and it can also use or ignore the type description or culture contexts that are passed as parameters.</span></span> <span data-ttu-id="b4409-167">但是，WPF XAML 处理可能不会在所有情况下都将值传递给类型说明上下文，还可能不会基于 `xml:lang`传递区域性。</span><span class="sxs-lookup"><span data-stu-id="b4409-167">However, the WPF XAML processing might not pass values to the type description context in all cases and also might not pass culture based on `xml:lang`.</span></span>

> [!NOTE]
> <span data-ttu-id="b4409-168">请勿使用大括号 （），{}特别是左大括号 （\*） 作为字符串格式的元素。</span><span class="sxs-lookup"><span data-stu-id="b4409-168">Do not use the braces ({}), specifically the opening brace ({), as an element of your string format.</span></span> <span data-ttu-id="b4409-169">这些字符保留作为标记扩展序列的入口和出口。</span><span class="sxs-lookup"><span data-stu-id="b4409-169">These characters are reserved as the entry and exit for a markup extension sequence.</span></span>

<span data-ttu-id="b4409-170">当类型转换器必须从 .NET XAML 服务对象编写器访问 XAML 服务，但针对上下文进行的<xref:System.IServiceProvider.GetService%2A>调用不会返回该服务时，则引发异常是适当的。</span><span class="sxs-lookup"><span data-stu-id="b4409-170">It is appropriate to throw an exception when your type converter must have access to a XAML service from .NET XAML Services object writer, but the <xref:System.IServiceProvider.GetService%2A> call that is made against the context does not return that service.</span></span>

### <a name="implementing-convertto"></a><span data-ttu-id="b4409-171">实现 ConvertTo</span><span class="sxs-lookup"><span data-stu-id="b4409-171">Implementing ConvertTo</span></span>

<span data-ttu-id="b4409-172"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 可能用于序列化支持。</span><span class="sxs-lookup"><span data-stu-id="b4409-172"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is potentially used for serialization support.</span></span> <span data-ttu-id="b4409-173">通过 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 为自定义类型及其类型转换器实现的序列化支持不是绝对要求。</span><span class="sxs-lookup"><span data-stu-id="b4409-173">Serialization support through <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> for your custom type and its type converter is not an absolute requirement.</span></span> <span data-ttu-id="b4409-174">但是，如果要实现控件，或使用序列化作为类的功能或设计的一部分，则应实现 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="b4409-174">However, if you are implementing a control, or using serialization of as part of the features or design of your class, you should implement <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span>

<span data-ttu-id="b4409-175">若要能够用作支持 XAML 的 <xref:System.ComponentModel.TypeConverter> 实现，该转换器的 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 方法必须接受支持的类型（或值）的实例作为 `value` 参数。</span><span class="sxs-lookup"><span data-stu-id="b4409-175">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> method for that converter must accept an instance of the type (or a value) that is supported as the `value` parameter.</span></span> <span data-ttu-id="b4409-176">当 `destinationType` 参数属于 <xref:System.String>类型时，返回对象必须能够强制转换为 <xref:System.String>。</span><span class="sxs-lookup"><span data-stu-id="b4409-176">When the `destinationType` parameter is of type <xref:System.String>, the returned object must be able to be cast as <xref:System.String>.</span></span> <span data-ttu-id="b4409-177">返回字符串必须表示 `value` 的序列化值。</span><span class="sxs-lookup"><span data-stu-id="b4409-177">The returned string must represent a serialized value of `value`.</span></span> <span data-ttu-id="b4409-178">理想情况下，选择的序列化格式应能够生成相同的值，就像该字符串传递给相同转换器的 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 实现一样，不会丢失大量信息。</span><span class="sxs-lookup"><span data-stu-id="b4409-178">Ideally, the serialization format that you choose should be able to generate the same value as if that string were passed to the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation of the same converter, without significant loss of information.</span></span>

<span data-ttu-id="b4409-179">如果值无法进行序列化，或转换器不支持序列化，则 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 实现必须返回 `null` ，可能会引发异常。</span><span class="sxs-lookup"><span data-stu-id="b4409-179">If the value cannot be serialized or the converter does not support serialization, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> implementation must return `null` and can throw an exception.</span></span> <span data-ttu-id="b4409-180">但是，如果确实引发了异常，则应报告无法使用该转换作为 <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> 实现的一部分，以便支持首先使用 <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> 进行检查以避免异常这一最佳做法。</span><span class="sxs-lookup"><span data-stu-id="b4409-180">However, if you do throw exceptions, you should report the inability to use that conversion as part of your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation so that the best practice of checking with <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> first to avoid exceptions is supported.</span></span>

<span data-ttu-id="b4409-181">如果 `destinationType` 参数不属于 <xref:System.String>类型，则你可以选择自己的转换器处理。</span><span class="sxs-lookup"><span data-stu-id="b4409-181">If the `destinationType` parameter is not of type <xref:System.String>, you can choose your own converter handling.</span></span> <span data-ttu-id="b4409-182">通常你会恢复为基实现处理，这会在基 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 中引发特定异常。</span><span class="sxs-lookup"><span data-stu-id="b4409-182">Typically, you revert to base implementation handling, which in the base <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> raises a specific exception.</span></span>

<span data-ttu-id="b4409-183">当类型转换器必须从 .NET XAML 服务对象编写器访问 XAML 服务，但针对上下文进行的<xref:System.IServiceProvider.GetService%2A>调用不会返回该服务时，则引发异常是适当的。</span><span class="sxs-lookup"><span data-stu-id="b4409-183">It is appropriate to throw an exception when your type converter must have access to a XAML service from .NET XAML Services object writer, but the <xref:System.IServiceProvider.GetService%2A> call that is made against the context does not return that service.</span></span>

### <a name="implementing-canconvertfrom"></a><span data-ttu-id="b4409-184">实现 CanConvertFrom</span><span class="sxs-lookup"><span data-stu-id="b4409-184">Implementing CanConvertFrom</span></span>

<span data-ttu-id="b4409-185">对于 <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> 类型的 `true` ， `sourceType` 实现应返回 <xref:System.String> ，否则遵从基实现。</span><span class="sxs-lookup"><span data-stu-id="b4409-185">Your <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> implementation should return `true` for `sourceType` of type <xref:System.String> and otherwise, defer to the base implementation.</span></span> <span data-ttu-id="b4409-186">不会从 <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> 引发异常。</span><span class="sxs-lookup"><span data-stu-id="b4409-186">Do not throw exceptions from <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>.</span></span>

### <a name="implementing-canconvertto"></a><span data-ttu-id="b4409-187">实现 CanConvertTo</span><span class="sxs-lookup"><span data-stu-id="b4409-187">Implementing CanConvertTo</span></span>

<span data-ttu-id="b4409-188">对于 <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> 类型的 `true` ， `destinationType` 实现应返回 <xref:System.String>，否则遵从基实现。</span><span class="sxs-lookup"><span data-stu-id="b4409-188">Your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation should return `true` for `destinationType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span> <span data-ttu-id="b4409-189">不会从 <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> 引发异常。</span><span class="sxs-lookup"><span data-stu-id="b4409-189">Do not throw exceptions from <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>.</span></span>

## <a name="applying-the-typeconverterattribute"></a><span data-ttu-id="b4409-190">应用 TypeConverterAttribute</span><span class="sxs-lookup"><span data-stu-id="b4409-190">Applying the TypeConverterAttribute</span></span>

<span data-ttu-id="b4409-191">要将自定义类型转换器用作 .NET XAML 服务自定义类的代理类型转换器，必须将 应用<xref:System.ComponentModel.TypeConverterAttribute>到类定义。</span><span class="sxs-lookup"><span data-stu-id="b4409-191">For your custom type converter to be used as the acting type converter for a custom class by .NET XAML Services, you must apply the <xref:System.ComponentModel.TypeConverterAttribute> to your class definition.</span></span> <span data-ttu-id="b4409-192">通过特性指定的 <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> 必须是自定义类型转换器的类型名。</span><span class="sxs-lookup"><span data-stu-id="b4409-192">The <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> that you specify through the attribute must be the type name of your custom type converter.</span></span> <span data-ttu-id="b4409-193">如果应用此特性，则当 XAML 处理器处理属性类型使用自定义类类型的值时，它可以输入字符串并返回对象实例。</span><span class="sxs-lookup"><span data-stu-id="b4409-193">If you apply this attribute, when a XAML processor handles values where the property type uses your custom class type, it can input strings and return object instances.</span></span>

<span data-ttu-id="b4409-194">还可以基于每个属性提供类型转换器。</span><span class="sxs-lookup"><span data-stu-id="b4409-194">You can also provide a type converter on a per-property basis.</span></span> <span data-ttu-id="b4409-195">而不是将 应用于<xref:System.ComponentModel.TypeConverterAttribute>类定义，而是将其应用于属性定义（主定义，而不是其中的`get`/`set`实现）。</span><span class="sxs-lookup"><span data-stu-id="b4409-195">Instead of applying a <xref:System.ComponentModel.TypeConverterAttribute> to the class definition, apply it to a property definition (the main definition, not the `get`/`set` implementations within it).</span></span> <span data-ttu-id="b4409-196">属性的类型必须与自定义类型转换器处理的类型匹配。</span><span class="sxs-lookup"><span data-stu-id="b4409-196">The type of the property must match the type that is processed by your custom type converter.</span></span> <span data-ttu-id="b4409-197">应用此特性时，当 XAML 处理器处理该属性的值时，它可以处理输入字符串并返回对象实例。</span><span class="sxs-lookup"><span data-stu-id="b4409-197">With this attribute applied, when a XAML processor handles values of that property, it can process input strings and return object instances.</span></span> <span data-ttu-id="b4409-198">如果选择使用 Microsoft .NET Framework 或其他库中的属性类型（其中不能控制类定义且无法应用<xref:System.ComponentModel.TypeConverterAttribute>）。因此，每个属性类型转换器技术非常有用。</span><span class="sxs-lookup"><span data-stu-id="b4409-198">The per-property type converter technique is useful if you choose to use a property type from Microsoft .NET Framework or from some other library where you cannot control the class definition and cannot apply a <xref:System.ComponentModel.TypeConverterAttribute> there.</span></span>

<span data-ttu-id="b4409-199">若要为自定义附加成员提供类型转换行为，请将 <xref:System.ComponentModel.TypeConverterAttribute> 应用于附加成员的实现模式的 `Get` 访问器方法。</span><span class="sxs-lookup"><span data-stu-id="b4409-199">To supply a type conversion behavior for a custom attached member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get` accessor method of the implementation pattern for the attached member.</span></span>

## <a name="accessing-service-provider-context-from-a-markup-extension-implementation"></a><span data-ttu-id="b4409-200">从标记扩展实现访问服务提供程序上下文</span><span class="sxs-lookup"><span data-stu-id="b4409-200">Accessing Service Provider Context from a Markup Extension Implementation</span></span>

<span data-ttu-id="b4409-201">可用服务对于任何值转换器都是相同的。</span><span class="sxs-lookup"><span data-stu-id="b4409-201">The available services are the same for any value converter.</span></span> <span data-ttu-id="b4409-202">不同之处在于每个值转换器接收服务上下文的方式。</span><span class="sxs-lookup"><span data-stu-id="b4409-202">The difference is in how each value converter receives the service context.</span></span> <span data-ttu-id="b4409-203">访问服务以及可用服务在主题 [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md)中进行了说明。</span><span class="sxs-lookup"><span data-stu-id="b4409-203">Accessing services and the services available are documented in the topic [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

## <a name="type-converters-in-the-xaml-node-stream"></a><span data-ttu-id="b4409-204">XAML 节点流中的类型转换器</span><span class="sxs-lookup"><span data-stu-id="b4409-204">Type Converters in the XAML Node Stream</span></span>

<span data-ttu-id="b4409-205">如果使用 XAML 节点流，则尚未执行类型转换器的操作或最终结果。</span><span class="sxs-lookup"><span data-stu-id="b4409-205">If you are working with a XAML node stream, the action or end result of a type converter is not yet executed.</span></span> <span data-ttu-id="b4409-206">在加载路径中，最终需要进行类型转换以便加载的特性字符串会在起始成员和结束成员中保留为文本值。</span><span class="sxs-lookup"><span data-stu-id="b4409-206">In a load path, the attribute string that eventually needs to be type-converted in order to load remains as a text value within a start member and end member.</span></span> <span data-ttu-id="b4409-207">此操作最终需要的类型转换器可以使用 <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> 属性来确定。</span><span class="sxs-lookup"><span data-stu-id="b4409-207">The type converter that is eventually needed for this operation can be determined by using the <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="b4409-208">但是，从 <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> 获取有效值依赖于具有 XAML 架构上下文，这可以通过基础成员（或成员使用的对象值的类型）访问此类信息。</span><span class="sxs-lookup"><span data-stu-id="b4409-208">However, obtaining a valid value from <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> relies on having a XAML schema context, which can access such information through the underlying member, or the type of the object value that the member uses.</span></span> <span data-ttu-id="b4409-209">调用类型转换行为也需要 XAML 架构上下文，因为这需要类型映射和创建转换器实例。</span><span class="sxs-lookup"><span data-stu-id="b4409-209">Invoking the type conversion behavior also requires the XAML schema context because that requires type-mapping and creating a converter instance.</span></span>

## <a name="see-also"></a><span data-ttu-id="b4409-210">请参阅</span><span class="sxs-lookup"><span data-stu-id="b4409-210">See also</span></span>

- <xref:System.ComponentModel.TypeConverterAttribute>
- [<span data-ttu-id="b4409-211">XAML 的类型转换器和标记扩展</span><span class="sxs-lookup"><span data-stu-id="b4409-211">Type Converters and Markup Extensions for XAML</span></span>](type-converters-and-markup-extensions.md)
- [<span data-ttu-id="b4409-212">XAML 概述 (WPF)</span><span class="sxs-lookup"><span data-stu-id="b4409-212">XAML Overview (WPF)</span></span>](../fundamentals/xaml.md)
