---
title: 容器化整体式应用程序
description: 容器化整体式应用程序虽然无法从微服务体系结构中获得所有好处，但却具有可立即提供的重要部署优势。
ms.date: 01/30/2020
ms.openlocfilehash: 0e6f7504a91d2b1a89193471746168fc34f50956
ms.sourcegitcommit: f38e527623883b92010cf4760246203073e12898
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/20/2020
ms.locfileid: "77503284"
---
# <a name="containerizing-monolithic-applications"></a><span data-ttu-id="baf9b-103">容器化整体式应用程序</span><span class="sxs-lookup"><span data-stu-id="baf9b-103">Containerizing monolithic applications</span></span>

<span data-ttu-id="baf9b-104">你可能想构建单个整体部署的 Web 应用程序或服务，并将其部署为容器。</span><span class="sxs-lookup"><span data-stu-id="baf9b-104">You might want to build a single, monolithically deployed web application or service and deploy it as a container.</span></span> <span data-ttu-id="baf9b-105">应用程序本身在内部可能并非整体式，只是结构化为多个库、组件甚至层（应用程序层、域层、数据访问层等等）。</span><span class="sxs-lookup"><span data-stu-id="baf9b-105">The application itself might not be internally monolithic, but structured as several libraries, components, or even layers (application layer, domain layer, data-access layer, etc.).</span></span> <span data-ttu-id="baf9b-106">但在外部，应用程序则是单个容器 - 单个进程、单个 Web 应用程序或单个服务。</span><span class="sxs-lookup"><span data-stu-id="baf9b-106">Externally, however, it's a single container—a single process, a single web application, or a single service.</span></span>

<span data-ttu-id="baf9b-107">若要管理此模型，可部署单个容器来表示应用程序。</span><span class="sxs-lookup"><span data-stu-id="baf9b-107">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="baf9b-108">若要增加容量，可进行横向扩展，即，只需添加更多副本并将负载均衡器置于前面。</span><span class="sxs-lookup"><span data-stu-id="baf9b-108">To increase capacity, you scale out, that is, just add more copies with a load balancer in front.</span></span> <span data-ttu-id="baf9b-109">为了简单起见，在单个容器或 VM 中管理单个部署。</span><span class="sxs-lookup"><span data-stu-id="baf9b-109">The simplicity comes from managing a single deployment in a single container or VM.</span></span>

![显示整体式容器化应用程序组件的关系图。](./media/containerize-monolithic-applications/monolithic-containerized-application.png)

<span data-ttu-id="baf9b-111">**图 4-1**。</span><span class="sxs-lookup"><span data-stu-id="baf9b-111">**Figure 4-1**.</span></span> <span data-ttu-id="baf9b-112">容器化整体式应用程序的体系结构示例</span><span class="sxs-lookup"><span data-stu-id="baf9b-112">Example of the architecture of a containerized monolithic application</span></span>

<span data-ttu-id="baf9b-113">如图 4-1 中所示，可以在每个容器添加多个组件、库或内部层。</span><span class="sxs-lookup"><span data-stu-id="baf9b-113">You can include multiple components, libraries, or internal layers in each container, as illustrated in Figure 4-1.</span></span> <span data-ttu-id="baf9b-114">整体式容器化应用程序将其大部分功能集中在一个具有内部层或库的容器中，并通过在多个服务器/VM 上克隆容器来进行横向扩展。</span><span class="sxs-lookup"><span data-stu-id="baf9b-114">A monolithic containerized application has most of its functionality within a single container, with internal layers or libraries, and scales out by cloning the container on multiple servers/VMs.</span></span> <span data-ttu-id="baf9b-115">然而，这种整体式模式可能违背了容器原则（“一个容器在一个进程中做一件事”），但在某些情况下没有关系。</span><span class="sxs-lookup"><span data-stu-id="baf9b-115">However, this monolithic pattern might conflict with the container principle "a container does one thing, and does it in one process", but might be ok for some cases.</span></span>

<span data-ttu-id="baf9b-116">如果应用程序在增长，需要它进行缩放，这种方法的缺点就会变得显而易见。</span><span class="sxs-lookup"><span data-stu-id="baf9b-116">The downside of this approach becomes evident if the application grows, requiring it to scale.</span></span> <span data-ttu-id="baf9b-117">如果整个应用程序都可缩放，这就不是问题了。</span><span class="sxs-lookup"><span data-stu-id="baf9b-117">If the entire application can scale, it isn't really a problem.</span></span> <span data-ttu-id="baf9b-118">但在大多数情况下，应用程序中只有一小部分是瓶颈，需要进行缩放，而其他组件使用较少。</span><span class="sxs-lookup"><span data-stu-id="baf9b-118">However, in most cases, just a few parts of the application are the choke points that requiring scaling, while other components are used less.</span></span>

<span data-ttu-id="baf9b-119">例如，在典型的电子商务应用程序中，很可能需要缩放产品信息子系统，因为更多的顾客仅浏览产品而非购买产品。</span><span class="sxs-lookup"><span data-stu-id="baf9b-119">For example, in a typical e-commerce application, you likely need to scale the product information subsystem, because many more customers browse products than purchase them.</span></span> <span data-ttu-id="baf9b-120">使用购物车的顾客比使用付款管道的多。</span><span class="sxs-lookup"><span data-stu-id="baf9b-120">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="baf9b-121">较少的顾客会评论或查看购买记录。</span><span class="sxs-lookup"><span data-stu-id="baf9b-121">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="baf9b-122">而且你可能只需要少量的员工管理货物和营销活动。</span><span class="sxs-lookup"><span data-stu-id="baf9b-122">And you might have only a handful of employees that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="baf9b-123">如果缩放整体式设计，则会多次部署并按相同等级缩放这些不同任务的所有代码。</span><span class="sxs-lookup"><span data-stu-id="baf9b-123">If you scale the monolithic design, all the code for these different tasks is deployed multiple times and scaled at the same grade.</span></span>

<span data-ttu-id="baf9b-124">缩放应用程序的方法有多种，如：水平复制、拆分应用程序的不同区域，以及分割类似的经营理念或数据。</span><span class="sxs-lookup"><span data-stu-id="baf9b-124">There are multiple ways to scale an application-horizontal duplication, splitting different areas of the application, and partitioning similar business concepts or data.</span></span> <span data-ttu-id="baf9b-125">但除了缩放所有组件的问题外，更改单个组件还需要完全重新测试整个应用程序，以及完全重新部署所有实例。</span><span class="sxs-lookup"><span data-stu-id="baf9b-125">But, in addition to the problem of scaling all components, changes to a single component require complete retesting of the entire application, and a complete redeployment of all the instances.</span></span>

<span data-ttu-id="baf9b-126">然而，整体式方法非常常见，因为应用程序的开发最初比微服务方法更容易。</span><span class="sxs-lookup"><span data-stu-id="baf9b-126">However, the monolithic approach is common, because the development of the application is initially easier than for microservices approaches.</span></span> <span data-ttu-id="baf9b-127">因此，许多组织都使用此体系结构方法进行开发。</span><span class="sxs-lookup"><span data-stu-id="baf9b-127">Thus, many organizations develop using this architectural approach.</span></span> <span data-ttu-id="baf9b-128">一些组织获得了不错的成效，而其他组织却快要达到极限。</span><span class="sxs-lookup"><span data-stu-id="baf9b-128">While some organizations have had good enough results, others are hitting limits.</span></span> <span data-ttu-id="baf9b-129">许多组织使用这种模型设计应用程序，因为几年前的工具和基础结构难以构建面向服务的体系结构 (SOA)，而且在应用程序增长之前他们也没有发现这种需要。</span><span class="sxs-lookup"><span data-stu-id="baf9b-129">Many organizations designed their applications using this model because tools and infrastructure made it too difficult to build service-oriented architectures (SOA) years ago, and they did not see the need-until the application grew.</span></span>

<span data-ttu-id="baf9b-130">从基础结构的角度来看，每台服务器可以在同一台主机上运行多个应用程序，在资源使用率中具有可接受的效率比率，如图 4-2 所示。</span><span class="sxs-lookup"><span data-stu-id="baf9b-130">From an infrastructure perspective, each server can run many applications within the same host and have an acceptable ratio of efficiency in resources usage, as shown in Figure 4-2.</span></span>

![显示一个主机在容器中运行许多应用的关系图。](./media/containerize-monolithic-applications/host-multiple-apps-containers.png)

<span data-ttu-id="baf9b-132">**图 4-2**。</span><span class="sxs-lookup"><span data-stu-id="baf9b-132">**Figure 4-2**.</span></span> <span data-ttu-id="baf9b-133">整体式方法：主机运行多个应用，每个应用作为一个容器运行</span><span class="sxs-lookup"><span data-stu-id="baf9b-133">Monolithic approach: Host running multiple apps, each app running as a container</span></span>

<span data-ttu-id="baf9b-134">Microsoft Azure 中的整体式应用程序可以使用每个实例的专用 VM 进行部署。</span><span class="sxs-lookup"><span data-stu-id="baf9b-134">Monolithic applications in Microsoft Azure can be deployed using dedicated VMs for each instance.</span></span> <span data-ttu-id="baf9b-135">此外，使用 [Azure 虚拟机规模集](https://azure.microsoft.com/documentation/services/virtual-machine-scale-sets/)可轻松缩放 VM。</span><span class="sxs-lookup"><span data-stu-id="baf9b-135">Additionally, using [Azure virtual machine scale sets](https://azure.microsoft.com/documentation/services/virtual-machine-scale-sets/), you can easily scale the VMs.</span></span> <span data-ttu-id="baf9b-136">[Azure 应用服务](https://azure.microsoft.com/services/app-service/)还可运行整体式应用程序和轻松缩放实例，无需管理 VM。</span><span class="sxs-lookup"><span data-stu-id="baf9b-136">[Azure App Service](https://azure.microsoft.com/services/app-service/) can also run monolithic applications and easily scale instances without requiring you to manage the VMs.</span></span> <span data-ttu-id="baf9b-137">自 2016 年起，Azure 应用服务也可以运行 Docker 容器的单个实例，从而简化部署。</span><span class="sxs-lookup"><span data-stu-id="baf9b-137">Since 2016, Azure App Services can run single instances of Docker containers as well, simplifying deployment.</span></span>

<span data-ttu-id="baf9b-138">像 QA 环境或有限的生产环境一样，可以部署多个 Docker 主机 VM 并使用 Azure 平衡器平衡这些 VM，如图 4-3 所示。</span><span class="sxs-lookup"><span data-stu-id="baf9b-138">As a QA environment or a limited production environment, you can deploy multiple Docker host VMs and balance them using the Azure balancer, as shown in Figure 4-3.</span></span> <span data-ttu-id="baf9b-139">这样，你可以使用粗粒度方法管理缩放，因为整个应用程序都在单个容器中。</span><span class="sxs-lookup"><span data-stu-id="baf9b-139">This lets you manage scaling with a coarse-grain approach, because the whole application lives within a single container.</span></span>

![显示几个主机运行整体式应用容器的关系图。](./media/containerize-monolithic-applications/docker-infrastructure-monolithic-application.png)

<span data-ttu-id="baf9b-141">**图 4-3**。</span><span class="sxs-lookup"><span data-stu-id="baf9b-141">**Figure 4-3**.</span></span> <span data-ttu-id="baf9b-142">多个主机纵向扩展单容器应用程序的示例</span><span class="sxs-lookup"><span data-stu-id="baf9b-142">Example of multiple hosts scaling up a single container application</span></span>

<span data-ttu-id="baf9b-143">使用传统的部署技术可以管理各种主机的部署。</span><span class="sxs-lookup"><span data-stu-id="baf9b-143">Deployment to the various hosts can be managed with traditional deployment techniques.</span></span> <span data-ttu-id="baf9b-144">通过 `docker run` 或 `docker-compose` 等命令可以手动管理 Docker 主机，也可以通过持续交付 (CD) 管道等来自动化管理。</span><span class="sxs-lookup"><span data-stu-id="baf9b-144">Docker hosts can be managed with commands like `docker run` or `docker-compose` performed manually, or through automation such as continuous delivery (CD) pipelines.</span></span>

## <a name="deploying-a-monolithic-application-as-a-container"></a><span data-ttu-id="baf9b-145">将整体式应用程序部署为容器</span><span class="sxs-lookup"><span data-stu-id="baf9b-145">Deploying a monolithic application as a container</span></span>

<span data-ttu-id="baf9b-146">使用容器管理整体式应用程序部署具有一些益处。</span><span class="sxs-lookup"><span data-stu-id="baf9b-146">There are benefits to using containers to manage monolithic application deployments.</span></span> <span data-ttu-id="baf9b-147">缩放容器实例比再部署另外的 VM 要快得多，也容易地多。</span><span class="sxs-lookup"><span data-stu-id="baf9b-147">Scaling container instances is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="baf9b-148">即使是使用虚拟机规模集，启动 VM 也需要时间。</span><span class="sxs-lookup"><span data-stu-id="baf9b-148">Even if you use virtual machine scale sets, VMs take time to start.</span></span> <span data-ttu-id="baf9b-149">部署为传统应用程序实例而非容器时，管理应用程序的配置就属于 VM 的一部分，这并不是理想的方式。</span><span class="sxs-lookup"><span data-stu-id="baf9b-149">When deployed as traditional application instances instead of containers, the configuration of the application is managed as part of the VM, which isn't ideal.</span></span>

<span data-ttu-id="baf9b-150">将更新部署为 Docker 映像会快得多，并且网络效率更高。</span><span class="sxs-lookup"><span data-stu-id="baf9b-150">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="baf9b-151">Docker 映像通常会在几秒内启动，加快了推出速度。</span><span class="sxs-lookup"><span data-stu-id="baf9b-151">Docker images typically start in seconds, which speeds rollouts.</span></span> <span data-ttu-id="baf9b-152">拆除 Docker 映像实例与发出 `docker stop` 命令一样简单，通常在一秒钟以内便可完成。</span><span class="sxs-lookup"><span data-stu-id="baf9b-152">Tearing down a Docker image instance is as easy as issuing a `docker stop` command, and typically completes in less than a second.</span></span>

<span data-ttu-id="baf9b-153">因为容器设计为不可更改，所以不必担心损坏的 VM。</span><span class="sxs-lookup"><span data-stu-id="baf9b-153">Because containers are immutable by design, you never need to worry about corrupted VMs.</span></span> <span data-ttu-id="baf9b-154">与此相反，VM 的更新脚本可能会忘记某些特定配置的帐户或磁盘上的剩余文件。</span><span class="sxs-lookup"><span data-stu-id="baf9b-154">In contrast, update scripts for a VM might forget to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="baf9b-155">虽然整体式应用程序可以从 Docker 中获益，但我们仅涉及到这些益处。</span><span class="sxs-lookup"><span data-stu-id="baf9b-155">While monolithic applications can benefit from Docker, we're touching only on the benefits.</span></span> <span data-ttu-id="baf9b-156">管理容器的其他益处来自于使用容器业务流程协调程序进行部署，此协调程序负责管理每个容器实例的各种实例和生命周期。</span><span class="sxs-lookup"><span data-stu-id="baf9b-156">Additional benefits of managing containers come from deploying with container orchestrators, which manage the various instances and lifecycle of each container instance.</span></span> <span data-ttu-id="baf9b-157">将整体式应用程序分解为可以单独缩放、开发和部署的子系统是进入微服务领域的切入点。</span><span class="sxs-lookup"><span data-stu-id="baf9b-157">Breaking up the monolithic application into subsystems that can be scaled, developed, and deployed individually is your entry point into the realm of microservices.</span></span>

## <a name="publishing-a-single-container-based-application-to-azure-app-service"></a><span data-ttu-id="baf9b-158">将基于单个容器的应用程序发布到 Azure 应用服务</span><span class="sxs-lookup"><span data-stu-id="baf9b-158">Publishing a single-container-based application to Azure App Service</span></span>

<span data-ttu-id="baf9b-159">无论是想验证部署到 Azure 的容器，还是想应用程序只作为单容器应用程序，Azure 应用服务都能够用一种适合的方式可缩放的基于单个容器的服务。</span><span class="sxs-lookup"><span data-stu-id="baf9b-159">Whether you want to get validation of a container deployed to Azure or when an application is simply a single-container application, Azure App Service provides a great way to provide scalable single-container-based services.</span></span> <span data-ttu-id="baf9b-160">Azure 应用服务使用简单。</span><span class="sxs-lookup"><span data-stu-id="baf9b-160">Using Azure App Service is simple.</span></span> <span data-ttu-id="baf9b-161">此服务与 Git 完美集成，可方便获取代码、在 Visual Studio 中构建此服务并将其直接部署到 Azure。</span><span class="sxs-lookup"><span data-stu-id="baf9b-161">It provides great integration with Git to make it easy to take your code, build it in Visual Studio, and deploy it directly to Azure.</span></span>

![显示容器注册表的“创建应用服务”对话框的屏幕截图。](./media/containerize-monolithic-applications/publish-azure-app-service-container.png)

<span data-ttu-id="baf9b-163">**图 4-4**。</span><span class="sxs-lookup"><span data-stu-id="baf9b-163">**Figure 4-4**.</span></span> <span data-ttu-id="baf9b-164">将单容器应用程序从 Visual Studio 2019 发布到 Azure 应用服务</span><span class="sxs-lookup"><span data-stu-id="baf9b-164">Publishing a single-container application to Azure App Service from Visual Studio 2019</span></span>

<span data-ttu-id="baf9b-165">如果没有 Docker，需要 Azure 应用服务中不支持的其他功能、框架或依赖项时，则必须等到 Azure 团队更新应用服务中的这些依赖项。</span><span class="sxs-lookup"><span data-stu-id="baf9b-165">Without Docker, if you needed other capabilities, frameworks, or dependencies that aren't supported in Azure App Service, you had to wait until the Azure team updated those dependencies in App Service.</span></span> <span data-ttu-id="baf9b-166">或者必须切换到 Azure 云服务或 VM 等其他服务，你可以在其中获得更进一步的控制权，且可以为应用程序安装所需的组件或框架。</span><span class="sxs-lookup"><span data-stu-id="baf9b-166">Or you had to switch to other services like Azure Cloud Services or VMs, where you had further control and you could install a required component or framework for your application.</span></span>

<span data-ttu-id="baf9b-167">借助 Visual Studio 2017 及更高版本中的容器支持，你能够在应用程序环境中包括任何想要的内容，如图 4-4 所示。</span><span class="sxs-lookup"><span data-stu-id="baf9b-167">Container support in Visual Studio 2017 and later gives you the ability to include whatever you want in your application environment, as shown in Figure 4-4.</span></span> <span data-ttu-id="baf9b-168">由于容器中正在运行此支持，因此如果向应用程序添加依赖项，则可以将依赖项包含在 Dockerfile 或 Docker 映像中。</span><span class="sxs-lookup"><span data-stu-id="baf9b-168">Since you're running it in a container, if you add a dependency to your application, you can include the dependency in your Dockerfile or Docker image.</span></span>

<span data-ttu-id="baf9b-169">仍然如图 4-4 所示，发布流通过容器注册表发布映像。</span><span class="sxs-lookup"><span data-stu-id="baf9b-169">As also shown in Figure 4-4, the publish flow pushes an image through a container registry.</span></span> <span data-ttu-id="baf9b-170">这可以是 Azure 容器注册表（一个与 Azure 中的部署密切相关并由 Azure Active Directory 组和帐户保护的注册表），也可以是任何其他 Docker 注册表（如 Docker 中心或本地注册表）。</span><span class="sxs-lookup"><span data-stu-id="baf9b-170">This can be the Azure Container Registry (a registry close to your deployments in Azure and secured by Azure Active Directory groups and accounts), or any other Docker registry, like Docker Hub or an on-premises registry.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="baf9b-171">[上一页](index.md)
>[下一页](docker-application-state-data.md)</span><span class="sxs-lookup"><span data-stu-id="baf9b-171">[Previous](index.md)
[Next](docker-application-state-data.md)</span></span>
