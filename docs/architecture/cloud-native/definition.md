---
title: 定义云本机
description: 了解提供适用于云原生系统成为的基础支柱
author: robvet
ms.date: 08/20/2019
ms.openlocfilehash: 27191a67b2964ac2e1636a4d7dc55d5314b78439
ms.sourcegitcommit: 515469828d0f040e01bde01df6b8e4eb43630b06
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/06/2020
ms.locfileid: "78675126"
---
# <a name="defining-cloud-native"></a>定义云本机

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

停止您正在执行的操作和您的同事的文本10。 要求他们定义术语 "云本机"。 好机会，你会获得八个不同的答案。 有趣的是，从现在起六个月，因为云本机技术和实践的发展，所以它们的定义。

云本机就是对构造关键业务系统所要做的更改。

云本机系统旨在实现快速变化、大规模和复原能力。

云本机计算基础提供了[官方定义](https://github.com/cncf/foundation/blob/master/charter.md)：

> *云本机技术使组织能够在新式和混合云等新式动态环境中构建和运行可缩放的应用程序。容器、service 网格、微服务、不可变的基础结构和声明性 Api 求知欲这种方法。*

> *这些技术可以实现具有复原能力、可管理性和可观察性的松耦合系统。它们结合了强大的自动化，使工程师能够以最小的 toil 频繁、可预测地做出影响。*

随着用户的日益增长，应用程序也变得越来越复杂。 用户需要快速响应、创新的功能和零停机时间。 性能问题、反复发生的错误以及无法快速移动的无法再接受。 他们将轻松地转到你的竞争对手。

云本机非常涉及*速度*和*灵活性*。 业务系统不断发展，使业务功能成为战略转换的武器，加速业务速度和增长。 立即将创意推广到市场是必不可少的。

下面是一些已实现这些技术的公司。 请考虑其实现速度、灵活性和可伸缩性。

| Company | 体验 |
| :-------- | :-------- |
| [Netflix](https://www.infoq.com/news/2013/06/netflix/) | 在生产环境中有600多项服务。 每天部署数百次。 |
| [Uber](https://eng.uber.com/micro-deploy/) | 生产中存储了1000多个服务。 每周部署几千个版本。 |
| [微信](https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf) | 生产中包含300多个服务。 每天进行约1000个更改。 |

如您所见，Netflix、Uber 和 WeChat 公开了由数百个独立微服务组成的系统。 这种体系结构样式使其能够快速响应市场状况。 它们可即时更新实时、复杂应用程序的小区域，并根据需要单独缩放这些区域。

云本机的速度和灵活性来自许多因素。 最重要的是云基础结构。 图1-3 中所示的其他五个基础要点还提供了适用于云原生系统的成为。

![云-本机基础支柱](./media/cloud-native-foundational-pillars.png)

**图 1-3**。 云-本机基础支柱

让我们花一些时间来更好地了解每个支柱的重要性。

## <a name="the-cloud"></a>云 。

云本机系统充分利用了云服务模型。

这些系统旨在发展动态的虚拟化云环境，广泛使用[平台即服务（PaaS）](https://azure.microsoft.com/overview/what-is-paas/)计算基础结构和托管服务。 它们将底层基础*结构视为可*在几分钟内预配、按需调整大小、缩放、移动或销毁-通过自动化。

请考虑被广泛接受的[宠物与毕竟现在](https://medium.com/@Joachim8675309/devops-concepts-pets-vs-cattle-2380b5aab313)的 DevOps 概念。 在传统的数据中心，将服务器视为*宠物*：物理计算机，为其指定有意义的名称，为关心。 可以通过将更多资源添加到同一个计算机来进行缩放（向上缩放）。 如果服务器变成病假，你会将它改回运行状况。 如果服务器不可用，则会通知所有人。

*毕竟现在*服务模型不同。 将每个实例设置为虚拟机或容器。 它们是相同的，并分配有服务-01、Service-02 等的系统标识符。 可以通过创建多个扩展来进行缩放（向外缩放）。 当一个不可用时，无人通知。

毕竟现在模型涵盖*不可变的基础结构*。 不修复或修改服务器。 如果一个失败或需要更新，则会将其销毁并预配一个新的-所有操作都通过自动化完成。

云本机系统采用毕竟现在服务模型。 它们将继续运行，因为基础结构可根据其运行的计算机进行扩展或缩小。

Azure 云平台支持这种类型的高度弹性基础结构，具有自动缩放、自我修复和监视功能。

## <a name="modern-design"></a>新式设计

如何设计云本机应用？ 您的体系结构是什么样子？ 你将遵守哪些原则、模式和最佳实践？ 什么是重要的基础结构和操作问题？

### <a name="the-twelve-factor-application"></a>十二因素应用程序

构建基于云的应用程序的广泛接受的方法是使用[十二个应用程序](https://12factor.net/)。 它介绍了开发人员构建针对新式云环境优化的应用程序的一系列原则和实践。 特别注意跨环境和声明性自动化的可移植性。

在适用于任何基于 web 的应用程序的情况下，很多专业人员认为它是构建云本机应用程序的坚实基础。 基于这些原则构建的系统可以快速部署和缩放，并添加功能以快速应对市场变化。

下表突出显示了十二因素方法：

|    |  因素 | 说明  |
| :-------- | :-------- | :-------- |
| 1 | 基本代码 | 每个微服务的一个基本代码，存储在其自己的存储库中。 通过版本控制进行跟踪，可部署到多个环境（QA、过渡、生产）。 |
| 2 | 依赖项 | 每个微服务都隔离并打包其自己的依赖项，以在不影响整个系统的情况下进行更改。 |
| 3 | 配置  | 配置信息通过代码之外的配置管理工具移出微服务和外部化。 相同的部署可以在应用了正确配置的环境中进行传播。  |
| 4 | 支持服务 | 辅助资源（数据存储、缓存、消息代理）应通过可寻址 URL 公开。 这样做会使资源与应用程序分离，使其能够互相替换。  |
| 5 | 生成、发布、运行 | 每个版本都必须强制实施跨生成、发布和运行阶段的严格分离。 每个都应使用唯一 ID 标记，并支持回滚功能。 新式 CI/CD 系统有助于满足此原则。 |
| 6 | 进程 | 每个微服务应在其自己的进程中执行，与其他正在运行的服务隔离。 外部化要求状态到后备服务，如分布式缓存或数据存储。 |
| 7 | 端口绑定 | 每个微服务都应自包含在其自己的端口上公开的接口和功能。 这样做会提供与其他微服务的隔离。 |
| 8 | 并发 | 服务跨大量的小型相同进程（副本）进行扩展，而不是在功能最强大的计算机上扩展单个大型实例。 |
| 9 | Disposability | 服务实例应该是可释放的，favoring 快速启动以提高可伸缩性机会，并使系统保持正常状态。 Docker 容器以及 orchestrator 本身就满足了这一要求。 |
| 10 | 开发/生产奇偶校验 | 使环境在应用程序生命周期中保持尽可能相似，避免成本高昂的快捷方式。 在这里，使用容器可以通过提升相同的执行环境来做出极大的贡献。 |
| 11 | 日志记录 | 将微服务生成的日志视为事件流。 使用事件聚合器处理这些数据，并将数据传播到 Azure Monitor 或 Splunk 等数据挖掘/日志管理工具，最终长期存档。 |
| 12 | 管理进程 | 以一次性进程的形式运行管理/管理任务。 任务可以包含报表的数据清理和拉取分析。 执行这些任务的工具应从生产环境中调用，而不是与应用程序一起调用。 |

在本指南中，在 [十二个因素的应用程序之外](https://content.pivotal.io/blog/beyond-the-twelve-factor-app)，将 Hoffman 的每一个原始12个因素（以2011编写）为依据。 此外，该书还提供了三个其他因素来反映当今的新式云应用程序设计。

|    |  新因素 | 说明  |
| :-------- | :-------- | :-------- |
| 13 | API 优先 | 使所有内容成为服务。 假设你的代码将由前端客户端、网关或其他服务使用。 |
| 14 | 遥测 | 在工作站上，你可以深入了解应用程序及其行为。 在云中，你不能。 请确保您的设计包括监视、特定于域的和健康/系统数据的收集。 |
| 15 | 身份验证/授权  | 开始实现标识。 考虑在公有云中提供[RBAC （基于角色的访问控制）](https://docs.microsoft.com/azure/role-based-access-control/overview)功能。  |

我们将参考本章和整个书籍中的众多12个因素。

### <a name="critical-design-considerations"></a>关键设计注意事项

除了12系数方法中提供的指导外，在构造分布式系统时，还必须做出几个关键的设计决策。

*通讯*

前端客户端应用程序如何与已备份端核心服务通信？ 是否允许直接通信？ 或者，是否可以使用提供灵活性、控制和安全性的网关外观来抽象后端服务？

如何将后端核心服务相互通信？ 是否允许直接 HTTP 调用导致耦合和影响性能与灵活性？ 或者是否可以考虑将消息与队列和主题技术分离？

有关详细信息，请阅读*云本机通信模式*。

*复原能力*

微服务体系结构将系统从进程内传输到网络通信。 在分布式环境中，当服务 B 未响应服务 A 的调用时，会执行什么操作？ 当服务 C 暂时不可用，且其他服务调用堆栈并降低系统性能时，会发生什么情况？

复原的详细信息，请阅读*云-原生复原*。

*分布式数据*

按照设计，每个微服务都封装自己的数据，通过其公共接口公开操作。 如果是这样，如何查询数据或跨多个服务实现事务？

有关分布式数据的详细信息，请阅读*云本机数据模式*。

*标识*

你的服务将如何识别谁正在访问它以及他们具有哪些权限？

标识详见第8章 "*标识*"。

## <a name="microservices"></a>微服务

云本机系统采用微服务，这是一种用于构建新式应用程序的常用体系结构样式。

作为通过共享结构进行交互的一组分布式小型独立服务构建的，微服务共享以下特征：

- 每个在更大的域上下文内实现特定的业务功能。

- 每个都是自主开发的，可以独立部署。

- 每个都是独立的，它封装其自己的数据存储技术（SQL、NoSQL）和编程平台。

- 每个运行在其自己的进程中，并使用标准通信协议（例如 HTTP/HTTPS、Websocket 或[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)）与其他用户通信。

- 它们共同构成应用程序。

图1-4 使用微服务方法来对比单一应用程序方法。 请注意，单体架构是由分层体系结构组成的，它在单个进程中执行。 它通常使用关系数据库。 不过，微服务方法将分隔开来功能转换为包含逻辑和数据的独立服务。 每个微服务托管其自己的数据存储。

![单一部署与微服务](./media/monolithic-vs-microservices.png)

**图1-4。** 单一部署与微服务

请注意，微服务如何从[十二个因素的应用程序](https://12factor.net/)中提升 "一个代码库，一个应用程序" 原则，详见前面的章节。

> *系数 \#1 为每个微服务指定单个基本代码，存储在其自己的存储库中。已通过版本控制进行跟踪，可部署到多个环境。 "*

### <a name="why-microservices"></a>为何使用微服务？

微服务提供灵活性。

在本章前面的部分中，我们将使用微服务生成的电子商务应用程序与单体架构进行比较。 在此示例中，我们看到了一些明显的优点：

- 每个微服务都有自治生命周期，并且可以独立地进行发展并经常部署。 无需等待季度发布即可部署新功能或更新。 您可以更新复杂应用程序的较小区域，同时降低中断整个系统的风险。

- 每个微服务可以独立缩放。 只需横向扩展需要更多处理能力或网络带宽的服务，而不是将整个应用程序作为单个单元进行缩放。 这一细化方法可用于更好地控制系统，并可帮助你在扩展系统的部分而不是所有内容时降低总体成本。

了解微服务的优秀参考指南是[.Net 微服务：容器化 .Net 应用程序的体系结构](https://docs.microsoft.com/dotnet/standard/microservices-architecture/)。 本书深层深入到微服务设计和体系结构。 这是一种适用于 Microsoft 免费下载的[完整堆栈微服务参考体系结构](https://github.com/dotnet-architecture/eShopOnContainers)。

### <a name="developing-microservices"></a>开发微服务

可在任何新式开发平台上创建微服务。

Microsoft .NET 核心平台是一种很好的选择。 免费和开源，它具有许多内置功能，可简化微服务开发。 .NET Core 是跨平台的。 应用程序可以在 Windows、macOS 和 Linux 的大多数风格上生成和运行。

.NET Core 具有高性能，与 node.js 和其他竞争性平台相比，其评分非常好。 有趣的是， [TechEmpower](https://www.techempower.com/)对许多 web 应用程序平台和框架执行了一组全面的[性能基准](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext)。 .NET Core 在顶级的十大平台和其他竞争性平台上评分。

.NET Core 由 Microsoft 和 GitHub 上的 .NET 社区维护。

## <a name="containers"></a>容器

如今，听一下与*云本机*有关的任何讨论中提到的术语*容器*是一种很自然的。 在本指南中， [Cloud 本机模式](https://www.manning.com/books/cloud-native-patterns)、作者 Cornelia Davis 观察到，"容器是云本机软件的极佳启用程序。" 云本机计算基础将微服务容器化作为其[云本机线索映射](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png)的第一步，即企业开始其云原生旅程的指南。

容器化微服务简单明了。 代码、其依赖项和运行时打包到称为[容器映像](https://docs.docker.com/glossary/?term=image)的二进制文件中。 映像存储在[容器注册表](https://caylent.com/container-registries/)中，该注册表用作映像的存储库或库。 注册表可以位于开发计算机上、数据中心或公有云中。 Docker 本身通过[Docker 中心](https://hub.docker.com/)维护公共注册表。 Azure 云使用[容器注册表](https://azure.microsoft.com/services/container-registry/)来存储与将运行它们的云应用程序接近的容器映像。

需要时，将图像转换为正在运行的容器实例。 实例在安装了[容器运行时](https://kubernetes.io/docs/setup/production-environment/container-runtimes/)引擎的任何计算机上运行。 您可以根据需要创建容器化服务的任意多个实例。

图1-5 显示了三个不同的微服务，每个都在单独的主机上运行的容器中。

![在一个容器主机上运行多个容器](./media/hosting-mulitple-containers.png)

**图 1-5**。 在一个容器主机上运行多个容器

请注意，每个容器如何维护其自己的依赖项和运行时，它们可能不同。 在这里，我们看到在同一主机上运行的产品微服务的版本不同。 每个容器共享底层主机操作系统、内存和处理器的一个切片，但彼此隔离。

请注意，容器模型将 "依赖关系" 原则[纳入十二个因素应用程序](https://12factor.net/)。

> *系数 \#2 指定 "每个微服务将隔离并打包其自己的依赖项，从而在不影响整个系统的情况下进行更改。"*

容器支持 Linux 和 Windows 工作负荷。 Azure 云公开了这两者。 有趣的是，它是 Linux，而不是 Windows Server，已成为 Azure 中最流行的操作系统。

虽然存在多个容器供应商，但 Docker 却捕获了 lion 的市场份额。 公司已在推动软件容器的移动。 它已成为打包、部署和运行云本机应用程序的事实上的标准。

### <a name="why-containers"></a>为什么选择容器？

容器可提供可移植性，并确保环境之间的一致性。 将所有内容封装到一个包中，即可将微服务及其依赖项从底层基础结构中*隔离开来*。

可以在具有 Docker 运行时引擎的任何环境中部署相同的容器。 容器化工作负荷还消除了通过框架、软件库和运行时引擎预配置每个环境的费用。

通过共享基础操作系统和主机资源，容器的占用空间比完整虚拟机少很多。 较小的大小增加了给定主机一次可以运行的*密度*或微服务数。

### <a name="container-orchestration"></a>容器业务流程

虽然 Docker 等工具创建映像和运行容器，但你还需要工具来管理它们。 容器管理是使用称为容器 orchestrator 的特殊软件程序来完成的。 在大规模操作时，容器业务流程至关重要。

图1-6 显示了容器协调器提供的管理任务。

![什么是容器协调器](./media/what-container-orchestrators-do.png)

**图 1-6**。 什么是容器协调器

下表描述了常见的业务流程任务。

|  任务 | 说明  |
| :-------- | :-------- |
| 计划 | 自动预配容器实例。|
| 相关性/反相关性 | 每个附近或附近预配容器，有助于实现可用性和性能。 |
| 运行状况监视 | 自动检测并更正失败。|
| 故障转移 | 自动重新设置失败的实例恢复到正常运行的计算机。|
| 扩展 | 自动添加或删除容器实例以满足需求。|
| 网络 | 管理用于容器通信的网络覆盖区。|
| 服务发现 | 使容器相互定位。|
| 滚动升级 | 协调增量升级，并部署零停机时间。 自动回滚有问题的更改。|

请注意，协调器如何接受来自十二个因素的[应用程序](https://12factor.net/)的 disposability 和并发原则，这一章前面讨论过。

> *因素 \#9 指定 "服务实例应该是可释放的、favoring 快速启动的，以提高可伸缩性机会，并使系统保持正常状态。Docker 容器以及 orchestrator 本身就满足了这一要求。 "*

> *系数 \#8 指定 "服务跨大量的小型相同进程（副本）进行扩展，而不是在功能最强大的计算机上向上扩展单个大型实例。"*

尽管存在多个容器协调器，但[Kubernetes](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/)已成为云原生世界的事实上标准。 它是一个可移植的可扩展开源平台，用于管理容器化工作负荷。

您可以托管自己的 Kubernetes 实例，但随后需要负责预配和管理其资源，这可能很复杂。 Azure 云功能 Kubernetes 作为托管服务， [Azure Kubernetes 服务（AKS）](https://azure.microsoft.com/services/kubernetes-service/)。 托管服务使你可以充分利用其功能，而无需安装和维护它。

Azure Kubernetes Services 在第2章中详细介绍了如何*扩展云本机应用程序*。

## <a name="backing-services"></a>支持服务

云本机系统依赖于许多不同的辅助资源，如数据存储、消息代理、监视和标识服务。 这些服务称为 "[后备服务](https://12factor.net/backing-services)"。

 图1-7 显示了云本机系统使用的许多常见后备服务。

![常见的支持服务](./media/common-backing-services.png)

**图 1-7**。 常见的支持服务

后备服务从[十二个因素的应用程序](https://12factor.net/)中提升 "情形" 原则，这一章在前面讨论过。

>*系数 \#6*指定 "每个微服务应在其自己的进程中执行，与其他正在运行的服务隔离开。 外部化要求状态到后备服务，如分布式缓存或数据存储。 "

你可以托管自己的支持服务，但随后你将负责授权、预配和管理这些资源。

云提供商提供丰富的*托管支持服务。* 只需使用服务即可。 提供程序对资源进行大规模的操作，并为性能、安全性和维护提供责任。 服务中内置了监视、冗余和可用性。 提供商完全支持其托管服务-打开一个票据，并解决问题。

云本机系统支持云供应商提供的托管支持服务。 节省时间和劳动非常好。 托管您自己和遇到问题的运营风险会迅速降低。

最佳做法是将后备服务视为*附加资源*，动态绑定到微服务，其中包含存储在外部配置中的信息（URL 和凭据）。 本指南在这一章前面讨论过的[十二因素应用程序](https://12factor.net/)中进行了介绍。

>*系数 \#4*指定应通过可寻址 URL 公开后备服务。 这样做会使资源与应用程序分离，使其能够互相替换。 "

>*因素 \#3*指定 "通过代码之外的配置管理工具将配置信息移出微服务和外部化。"

使用此模式，可附加和分离后备服务，无需更改代码。 可以将微服务从问答升级到过渡环境。 将微服务配置更新为指向暂存中的后备服务，并通过环境变量将设置注入到容器中。

云供应商提供了 Api，使你能够与其专有支持服务进行通信。 这些库封装了管道和复杂性。 直接与这些 Api 进行通信会将你的代码紧密地耦合到支持服务。 更好的做法是，隔离供应商 API 的实现细节。 引入 intermediation 层或中间 API，将一般操作公开给你的服务代码。 这种松散耦合使你可以将另一个后备服务换出，或将代码移到不同的公有云，而无需更改主线服务代码。

支持服务的详细信息，请参见第5章、*云本机数据模式*和第4章 *-本机通信模式*。

## <a name="automation"></a>自动化

如您所见，云本机系统采用微服务、容器和新式系统设计来实现速度和灵活性。 但这只是其中的一部分。 如何预配这些系统运行时所用的云环境？ 如何快速部署应用功能和更新？ 如何整整图片？

输入[基础结构为代码](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)或 IaC 的广泛接受的做法。

借助 IaC，你可以自动执行平台预配和应用程序部署。 实质上是将软件工程实践（例如测试和版本控制）应用于 DevOps 做法。 你的基础结构和部署是自动、一致且可重复的。

### <a name="automating-infrastructure"></a>自动化基础结构

[Azure 资源管理器](https://azure.microsoft.com/documentation/articles/resource-group-overview/)、Terraform 和[Azure CLI](https://docs.microsoft.com/cli/azure/)等工具使你能够以声明方式为你所需的云基础结构编写脚本。 资源名称、位置、容量和密码都是参数化和动态的。 脚本被版本控制，并签入到源控件中作为项目的项目。 调用脚本可以在系统环境（如 QA、过渡和生产）中预配一致且可重复的基础结构。

在这种情况下，IaC 是幂等的，这意味着您可以反复运行相同的脚本，而不会产生负面影响。 如果团队需要进行更改，则会编辑并重新运行该脚本。 只有更新的资源才会受到影响。

在本文中，[什么是基础结构即代码](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)，Author Sam Guckenheimer 介绍了 "实现 IaC 的团队如何快速、大规模地交付稳定环境。 团队避免手动配置环境，并通过代码来表示环境所需的状态，从而强制实现一致性。 使用 IaC 的基础结构部署是可重复的，并防止配置偏移或缺少依赖项导致的运行时问题。 DevOps 团队可以结合使用一组统一的做法和工具，迅速、可靠、大规模地提供应用程序及其支持基础结构。

### <a name="automating-deployments"></a>自动部署

前面所述的[十二因素应用程序](https://12factor.net/)会在将完成的代码转换为正在运行的应用程序时调用单独的步骤。

> *系数 \#5*指定 "每个版本都必须在生成、发布和运行阶段强制实现严格分离。 每个都应使用唯一的 ID 标记，并支持回滚的能力。 "

新式 CI/CD 系统有助于满足此原则。 它们提供了单独的部署步骤，有助于确保可供用户随时使用的一致和质量代码。

图1-8 显示了在整个部署过程中的分离。

![CI/CD 管道中的部署步骤](./media/build-release-run-pipeline.png)

**图 1-8**。 CI/CD 管道中的部署步骤

在上图中，请特别注意任务的分离。

开发人员在其开发环境中构造一项功能，该功能将循环访问所谓的代码 "内部循环"、"运行" 和 "调试"。 完成后，该代码会被*推送*到代码存储库中，例如 GitHub、Azure DevOps 或 BitBucket。

推送会触发一个将代码转换为二进制项目的生成阶段。 该工作是使用[持续集成（CI）](https://martinfowler.com/articles/continuousIntegration.html)管道实现的。 它自动生成、测试并打包应用程序。

发布阶段选取二进制项目，应用外部应用程序和环境配置信息，并生成不可变版本。 发布将部署到指定的环境中。 该工作是通过[持续交付（CD）](https://martinfowler.com/bliki/ContinuousDelivery.html)管道实现的。 每个版本都应可识别。 你可以说 "此部署正在运行应用程序的发布版本。"

最后，已发布的功能在目标执行环境中运行。 版本是不可变的，这意味着任何更改都必须创建新版本。

应用这些方案后，组织会对其交付软件的方式进行了彻底的发展。 许多人都从季度版本转移到按需更新。 其目标是在开发周期的早期发现问题，因为这些问题的修复开销较低。 集成之间的持续时间越长，要解决的问题越昂贵。  随着集成过程的一致性，团队可以更频繁地提交代码更改，从而提高协作和软件质量。

### <a name="azure-pipelines"></a>Azure Pipelines

Azure 云包括一项名为[Azure Pipelines](https://azure.microsoft.com/services/devops/pipelines/)的新 CI/CD 服务，该服务是如图1-9 所示的[Azure DevOps](https://azure.microsoft.com/services/devops/)产品的一部分。

![DevOps 中的 Azure Pipelines](./media/devops-components.png)

**图 1-9**。 Azure DevOps 产品/服务

Azure Pipelines 是一种云服务，它将持续集成（CI）和持续交付（CD）结合在一起。 你可以自动测试、生成代码并将其交付到任意目标。

在 YAML 文件的代码中，将管道定义为应用的其余代码。

- 该管道通过您的代码进行版本控制，并遵循相同的分支结构。
- 可以通过拉取请求和分支生成策略中的代码评审来验证所做的更改。
- 你使用的每个分支都可以通过修改 azure-pipelines. docker-compose.override.yml 文件来自定义生成策略。
- 管道文件签入到版本控制中，如果出现问题，则可以进行调查。

Azure Pipelines 服务支持大多数 Git 提供程序，并且可以为在 Linux、macOS 或 Windows 平台上编写的应用程序生成部署管道。 它包括对 Java、.NET、JavaScript、Python、PHP、中转、XCode 和C++的支持。

>[!div class="step-by-step"]
>[上一页](introduction.md)
>[下一页](candidate-apps.md)
