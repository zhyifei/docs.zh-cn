---
title: 定义云本机
description: 了解提供适用于云原生系统成为的基础支柱
author: robvet
ms.date: 05/13/2020
ms.openlocfilehash: e8b07fe7758d90f6ba97b81d0efa9d2fb5058d49
ms.sourcegitcommit: 27db07ffb26f76912feefba7b884313547410db5
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/19/2020
ms.locfileid: "83614159"
---
# <a name="defining-cloud-native"></a><span data-ttu-id="10b56-103">定义云本机</span><span class="sxs-lookup"><span data-stu-id="10b56-103">Defining cloud native</span></span>

<span data-ttu-id="10b56-104">停止正在执行的操作和文本10的同事。</span><span class="sxs-lookup"><span data-stu-id="10b56-104">Stop what you're doing and text ten of your colleagues.</span></span> <span data-ttu-id="10b56-105">要求他们定义术语 "云本机"。</span><span class="sxs-lookup"><span data-stu-id="10b56-105">Ask them to define the term "Cloud Native".</span></span> <span data-ttu-id="10b56-106">很有可能得到十个不同的答案。</span><span class="sxs-lookup"><span data-stu-id="10b56-106">Good chance you'll get ten different answers.</span></span>

<span data-ttu-id="10b56-107">云本机是指改变你对构建关键业务系统的方式。</span><span class="sxs-lookup"><span data-stu-id="10b56-107">Cloud native is all about changing the way you think about constructing critical business systems.</span></span>

<span data-ttu-id="10b56-108">云本机系统旨在实现快速变化、大规模和复原能力。</span><span class="sxs-lookup"><span data-stu-id="10b56-108">Cloud-native systems are designed to embrace rapid change, large scale, and resilience.</span></span>

<span data-ttu-id="10b56-109">云本机计算基础提供了[官方定义](https://github.com/cncf/foundation/blob/master/charter.md)：</span><span class="sxs-lookup"><span data-stu-id="10b56-109">The Cloud Native Computing Foundation provides an [official definition](https://github.com/cncf/foundation/blob/master/charter.md):</span></span>

> <span data-ttu-id="10b56-110">*云本机技术使组织能够在新式和混合云等新式动态环境中构建和运行可缩放的应用程序。容器、service 网格、微服务、不可变的基础结构和声明性 Api 求知欲这种方法。*</span><span class="sxs-lookup"><span data-stu-id="10b56-110">*Cloud-native technologies empower organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds. Containers, service meshes, microservices, immutable infrastructure, and declarative APIs exemplify this approach.*</span></span>

> <span data-ttu-id="10b56-111">*这些技术可以实现具有复原能力、可管理性和可观察性的松耦合系统。它们结合了强大的自动化，使工程师能够以最小的 toil 频繁、可预测地做出影响。*</span><span class="sxs-lookup"><span data-stu-id="10b56-111">*These techniques enable loosely coupled systems that are resilient, manageable, and observable. Combined with robust automation, they allow engineers to make high-impact changes frequently and predictably with minimal toil.*</span></span>

<span data-ttu-id="10b56-112">随着用户的日益增长，应用程序也变得越来越复杂。</span><span class="sxs-lookup"><span data-stu-id="10b56-112">Applications have become increasingly complex with users demanding more and more.</span></span> <span data-ttu-id="10b56-113">用户需要快速响应、创新的功能和零停机时间。</span><span class="sxs-lookup"><span data-stu-id="10b56-113">Users expect rapid responsiveness, innovative features, and zero downtime.</span></span> <span data-ttu-id="10b56-114">性能问题、反复发生的错误以及无法快速移动的无法再接受。</span><span class="sxs-lookup"><span data-stu-id="10b56-114">Performance problems, recurring errors, and the inability to move fast are no longer acceptable.</span></span> <span data-ttu-id="10b56-115">他们将轻松地转到你的竞争对手。</span><span class="sxs-lookup"><span data-stu-id="10b56-115">They'll easily move to your competitor.</span></span>

<span data-ttu-id="10b56-116">云本机非常涉及*速度*和*灵活性*。</span><span class="sxs-lookup"><span data-stu-id="10b56-116">Cloud native is much about *speed* and *agility*.</span></span> <span data-ttu-id="10b56-117">业务系统不断发展，使业务功能成为战略转换的武器，加速业务速度和增长。</span><span class="sxs-lookup"><span data-stu-id="10b56-117">Business systems are evolving from enabling business capabilities to weapons of strategic transformation, accelerating business velocity and growth.</span></span> <span data-ttu-id="10b56-118">立即将创意推广到市场是必不可少的。</span><span class="sxs-lookup"><span data-stu-id="10b56-118">It's imperative to get ideas to market immediately.</span></span>

<span data-ttu-id="10b56-119">下面是一些已实现这些技术的公司。</span><span class="sxs-lookup"><span data-stu-id="10b56-119">Here are some companies who have implemented these techniques.</span></span> <span data-ttu-id="10b56-120">请考虑其实现速度、灵活性和可伸缩性。</span><span class="sxs-lookup"><span data-stu-id="10b56-120">Think about the speed, agility, and scalability they've achieved.</span></span>

| <span data-ttu-id="10b56-121">Company</span><span class="sxs-lookup"><span data-stu-id="10b56-121">Company</span></span> | <span data-ttu-id="10b56-122">体验</span><span class="sxs-lookup"><span data-stu-id="10b56-122">Experience</span></span> |
| :-------- | :-------- |
| [<span data-ttu-id="10b56-123">Netflix</span><span class="sxs-lookup"><span data-stu-id="10b56-123">Netflix</span></span>](https://www.infoq.com/news/2013/06/netflix/) | <span data-ttu-id="10b56-124">在生产环境中有600多项服务。</span><span class="sxs-lookup"><span data-stu-id="10b56-124">Has 600+ services in production.</span></span> <span data-ttu-id="10b56-125">每天部署数百次。</span><span class="sxs-lookup"><span data-stu-id="10b56-125">Deploys hundred times per day.</span></span> |
| [<span data-ttu-id="10b56-126">Uber</span><span class="sxs-lookup"><span data-stu-id="10b56-126">Uber</span></span>](https://eng.uber.com/micro-deploy/) | <span data-ttu-id="10b56-127">在生产环境中具有1000个以上的服务。</span><span class="sxs-lookup"><span data-stu-id="10b56-127">Has 1,000+ services in production.</span></span> <span data-ttu-id="10b56-128">每周部署几千次。</span><span class="sxs-lookup"><span data-stu-id="10b56-128">Deploys several thousand times each week.</span></span> |
| [<span data-ttu-id="10b56-129">微信</span><span class="sxs-lookup"><span data-stu-id="10b56-129">WeChat</span></span>](https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf) | <span data-ttu-id="10b56-130">生产中包含300多个服务。</span><span class="sxs-lookup"><span data-stu-id="10b56-130">Has 300+ services in production.</span></span> <span data-ttu-id="10b56-131">一天部署1000次。</span><span class="sxs-lookup"><span data-stu-id="10b56-131">Deploys 1,000 times a day.</span></span> |

<span data-ttu-id="10b56-132">如您所见，Netflix、Uber 和 WeChat 公开了由数百个独立微服务组成的系统。</span><span class="sxs-lookup"><span data-stu-id="10b56-132">As you can see, Netflix, Uber, and WeChat expose systems that consist of hundreds of independent microservices.</span></span> <span data-ttu-id="10b56-133">这种体系结构样式使其能够快速响应市场状况。</span><span class="sxs-lookup"><span data-stu-id="10b56-133">This architectural style enables them to rapidly respond to market conditions.</span></span> <span data-ttu-id="10b56-134">它们可即时更新实时、复杂应用程序的小区域，并根据需要单独缩放这些区域。</span><span class="sxs-lookup"><span data-stu-id="10b56-134">They can instantaneously update small areas of a live, complex application, and individually scale those areas as needed.</span></span>

<span data-ttu-id="10b56-135">云本机的速度和灵活性来自许多因素。</span><span class="sxs-lookup"><span data-stu-id="10b56-135">The speed and agility of cloud native come about from a number of factors.</span></span> <span data-ttu-id="10b56-136">最重要的是云基础结构。</span><span class="sxs-lookup"><span data-stu-id="10b56-136">Foremost is cloud infrastructure.</span></span> <span data-ttu-id="10b56-137">图1-3 中所示的其他五个基础要点还提供了适用于云原生系统的成为。</span><span class="sxs-lookup"><span data-stu-id="10b56-137">Five additional foundational pillars shown in Figure 1-3 also provide the bedrock for cloud-native systems.</span></span>

![云-本机基础支柱](./media/cloud-native-foundational-pillars.png)

<span data-ttu-id="10b56-139">**图 1-3**。</span><span class="sxs-lookup"><span data-stu-id="10b56-139">**Figure 1-3**.</span></span> <span data-ttu-id="10b56-140">云-本机基础支柱</span><span class="sxs-lookup"><span data-stu-id="10b56-140">Cloud-native foundational pillars</span></span>

<span data-ttu-id="10b56-141">让我们花一些时间来更好地了解每个支柱的重要性。</span><span class="sxs-lookup"><span data-stu-id="10b56-141">Let's take some time to better understand the significance of each pillar.</span></span>

## <a name="the-cloud"></a><span data-ttu-id="10b56-142">云 .。。</span><span class="sxs-lookup"><span data-stu-id="10b56-142">The cloud…</span></span>

<span data-ttu-id="10b56-143">云本机系统充分利用了云服务模型。</span><span class="sxs-lookup"><span data-stu-id="10b56-143">Cloud-native systems take full advantage of the cloud service model.</span></span>

<span data-ttu-id="10b56-144">这些系统旨在发展动态的虚拟化云环境，广泛使用[平台即服务（PaaS）](https://azure.microsoft.com/overview/what-is-paas/)计算基础结构和托管服务。</span><span class="sxs-lookup"><span data-stu-id="10b56-144">Designed to thrive in a dynamic, virtualized cloud environment, these systems make extensive use of [Platform as a Service (PaaS)](https://azure.microsoft.com/overview/what-is-paas/) compute infrastructure and managed services.</span></span> <span data-ttu-id="10b56-145">它们将底层基础*结构视为可*在几分钟内预配、按需调整大小、缩放、移动或销毁-通过自动化。</span><span class="sxs-lookup"><span data-stu-id="10b56-145">They treat the underlying infrastructure as *disposable* - provisioned in minutes and resized, scaled, moved, or destroyed on demand – via automation.</span></span>

<span data-ttu-id="10b56-146">请考虑被广泛接受的[宠物与毕竟现在](https://medium.com/@Joachim8675309/devops-concepts-pets-vs-cattle-2380b5aab313)的 DevOps 概念。</span><span class="sxs-lookup"><span data-stu-id="10b56-146">Consider the widely accepted DevOps concept of [Pets vs. Cattle](https://medium.com/@Joachim8675309/devops-concepts-pets-vs-cattle-2380b5aab313).</span></span> <span data-ttu-id="10b56-147">在传统的数据中心，将服务器视为*宠物*：物理计算机，为其指定有意义的名称，为关心。</span><span class="sxs-lookup"><span data-stu-id="10b56-147">In a traditional data center, servers are treated as *Pets*: a physical machine, given a meaningful name, and cared for.</span></span> <span data-ttu-id="10b56-148">可以通过将更多资源添加到同一个计算机来进行缩放（向上缩放）。</span><span class="sxs-lookup"><span data-stu-id="10b56-148">You scale by adding more resources to the same machine (scaling up).</span></span> <span data-ttu-id="10b56-149">如果服务器变成病假，你会将它改回运行状况。</span><span class="sxs-lookup"><span data-stu-id="10b56-149">If the server becomes sick, you nurse it back to health.</span></span> <span data-ttu-id="10b56-150">如果服务器不可用，则会通知所有人。</span><span class="sxs-lookup"><span data-stu-id="10b56-150">Should the server become unavailable, everyone notices.</span></span>

<span data-ttu-id="10b56-151">*毕竟现在*服务模型不同。</span><span class="sxs-lookup"><span data-stu-id="10b56-151">The *Cattle* service model is different.</span></span> <span data-ttu-id="10b56-152">将每个实例设置为虚拟机或容器。</span><span class="sxs-lookup"><span data-stu-id="10b56-152">You provision each instance as a virtual machine or container.</span></span> <span data-ttu-id="10b56-153">它们是相同的，并分配有服务-01、Service-02 等的系统标识符。</span><span class="sxs-lookup"><span data-stu-id="10b56-153">They're identical and assigned a system identifier such as Service-01, Service-02, and so on.</span></span> <span data-ttu-id="10b56-154">可以通过创建多个扩展来进行缩放（向外缩放）。</span><span class="sxs-lookup"><span data-stu-id="10b56-154">You scale by creating more of them (scaling out).</span></span> <span data-ttu-id="10b56-155">当一个不可用时，无人通知。</span><span class="sxs-lookup"><span data-stu-id="10b56-155">When one becomes unavailable, nobody notices.</span></span>

<span data-ttu-id="10b56-156">毕竟现在模型涵盖*不可变的基础结构*。</span><span class="sxs-lookup"><span data-stu-id="10b56-156">The cattle model embraces *immutable infrastructure*.</span></span> <span data-ttu-id="10b56-157">不修复或修改服务器。</span><span class="sxs-lookup"><span data-stu-id="10b56-157">Servers aren't repaired or modified.</span></span> <span data-ttu-id="10b56-158">如果一个失败或需要更新，则会将其销毁并预配一个新的-所有操作都通过自动化完成。</span><span class="sxs-lookup"><span data-stu-id="10b56-158">If one fails or requires updating, it's destroyed and a new one is provisioned – all done via automation.</span></span>

<span data-ttu-id="10b56-159">云本机系统采用毕竟现在服务模型。</span><span class="sxs-lookup"><span data-stu-id="10b56-159">Cloud-native systems embrace the Cattle service model.</span></span> <span data-ttu-id="10b56-160">它们将继续运行，因为基础结构可根据其运行的计算机进行扩展或缩小。</span><span class="sxs-lookup"><span data-stu-id="10b56-160">They continue to run as the infrastructure scales in or out with no regard to the machines upon which they're running.</span></span>

<span data-ttu-id="10b56-161">Azure 云平台支持这种类型的高度弹性基础结构，具有自动缩放、自我修复和监视功能。</span><span class="sxs-lookup"><span data-stu-id="10b56-161">The Azure cloud platform supports this type of highly elastic infrastructure with automatic scaling, self-healing, and monitoring capabilities.</span></span>

## <a name="modern-design"></a><span data-ttu-id="10b56-162">新式设计</span><span class="sxs-lookup"><span data-stu-id="10b56-162">Modern design</span></span>

<span data-ttu-id="10b56-163">如何设计云本机应用？</span><span class="sxs-lookup"><span data-stu-id="10b56-163">How would you design a cloud-native app?</span></span> <span data-ttu-id="10b56-164">您的体系结构是什么样子？</span><span class="sxs-lookup"><span data-stu-id="10b56-164">What would your architecture look like?</span></span> <span data-ttu-id="10b56-165">你将遵守哪些原则、模式和最佳实践？</span><span class="sxs-lookup"><span data-stu-id="10b56-165">To what principles, patterns, and best practices would you adhere?</span></span> <span data-ttu-id="10b56-166">什么是重要的基础结构和操作问题？</span><span class="sxs-lookup"><span data-stu-id="10b56-166">What infrastructure and operational concerns would be important?</span></span>

### <a name="the-twelve-factor-application"></a><span data-ttu-id="10b56-167">十二因素应用程序</span><span class="sxs-lookup"><span data-stu-id="10b56-167">The Twelve-Factor Application</span></span>

<span data-ttu-id="10b56-168">构建基于云的应用程序的广泛接受的方法是使用[十二个应用程序](https://12factor.net/)。</span><span class="sxs-lookup"><span data-stu-id="10b56-168">A widely accepted methodology for constructing cloud-based applications is the [Twelve-Factor Application](https://12factor.net/).</span></span> <span data-ttu-id="10b56-169">它介绍了开发人员构建针对新式云环境优化的应用程序的一系列原则和实践。</span><span class="sxs-lookup"><span data-stu-id="10b56-169">It describes a set of principles and practices that developers follow to construct applications optimized for modern cloud environments.</span></span> <span data-ttu-id="10b56-170">特别注意跨环境和声明性自动化的可移植性。</span><span class="sxs-lookup"><span data-stu-id="10b56-170">Special attention is given to portability across environments and declarative automation.</span></span>

<span data-ttu-id="10b56-171">尽管适用于任何基于 web 的应用程序，但许多专业人员都将十二个因素视为构建云本机应用程序的坚实基础。</span><span class="sxs-lookup"><span data-stu-id="10b56-171">While applicable to any web-based application, many practitioners consider Twelve-Factor as a solid foundation for building cloud-native apps.</span></span> <span data-ttu-id="10b56-172">基于这些原则构建的系统可以快速部署和缩放，并添加功能以快速应对市场变化。</span><span class="sxs-lookup"><span data-stu-id="10b56-172">Systems built upon these principles can deploy and scale rapidly and add features to react quickly to market changes.</span></span>

<span data-ttu-id="10b56-173">下表突出显示了十二因素方法：</span><span class="sxs-lookup"><span data-stu-id="10b56-173">The following table highlights the Twelve-Factor methodology:</span></span>

|    |  <span data-ttu-id="10b56-174">因素</span><span class="sxs-lookup"><span data-stu-id="10b56-174">Factor</span></span> | <span data-ttu-id="10b56-175">说明</span><span class="sxs-lookup"><span data-stu-id="10b56-175">Explanation</span></span>  |
| :-------- | :-------- | :-------- |
| <span data-ttu-id="10b56-176">1</span><span class="sxs-lookup"><span data-stu-id="10b56-176">1</span></span> | <span data-ttu-id="10b56-177">基本代码</span><span class="sxs-lookup"><span data-stu-id="10b56-177">Code Base</span></span> | <span data-ttu-id="10b56-178">每个微服务的一个基本代码，存储在其自己的存储库中。</span><span class="sxs-lookup"><span data-stu-id="10b56-178">A single code base for each microservice, stored in its own repository.</span></span> <span data-ttu-id="10b56-179">通过版本控制进行跟踪，可部署到多个环境（QA、过渡、生产）。</span><span class="sxs-lookup"><span data-stu-id="10b56-179">Tracked with version control, it can deploy to multiple environments (QA, Staging, Production).</span></span> |
| <span data-ttu-id="10b56-180">2</span><span class="sxs-lookup"><span data-stu-id="10b56-180">2</span></span> | <span data-ttu-id="10b56-181">依赖项</span><span class="sxs-lookup"><span data-stu-id="10b56-181">Dependencies</span></span> | <span data-ttu-id="10b56-182">每个微服务都隔离并打包其自己的依赖项，以在不影响整个系统的情况下进行更改。</span><span class="sxs-lookup"><span data-stu-id="10b56-182">Each microservice isolates and packages its own dependencies, embracing changes without impacting the entire system.</span></span> |
| <span data-ttu-id="10b56-183">3</span><span class="sxs-lookup"><span data-stu-id="10b56-183">3</span></span> | <span data-ttu-id="10b56-184">配置</span><span class="sxs-lookup"><span data-stu-id="10b56-184">Configurations</span></span>  | <span data-ttu-id="10b56-185">配置信息通过代码之外的配置管理工具移出微服务和外部化。</span><span class="sxs-lookup"><span data-stu-id="10b56-185">Configuration information is moved out of the microservice and externalized through a configuration management tool outside of the code.</span></span> <span data-ttu-id="10b56-186">相同的部署可以在应用了正确配置的环境中进行传播。</span><span class="sxs-lookup"><span data-stu-id="10b56-186">The same deployment can propagate across environments with the correct configuration applied.</span></span>  |
| <span data-ttu-id="10b56-187">4</span><span class="sxs-lookup"><span data-stu-id="10b56-187">4</span></span> | <span data-ttu-id="10b56-188">支持服务</span><span class="sxs-lookup"><span data-stu-id="10b56-188">Backing Services</span></span> | <span data-ttu-id="10b56-189">辅助资源（数据存储、缓存、消息代理）应通过可寻址 URL 公开。</span><span class="sxs-lookup"><span data-stu-id="10b56-189">Ancillary resources (data stores, caches, message brokers) should be exposed via an addressable URL.</span></span> <span data-ttu-id="10b56-190">这样做会使资源与应用程序分离，使其能够互相替换。</span><span class="sxs-lookup"><span data-stu-id="10b56-190">Doing so decouples the resource from the application, enabling it to be interchangeable.</span></span>  |
| <span data-ttu-id="10b56-191">5</span><span class="sxs-lookup"><span data-stu-id="10b56-191">5</span></span> | <span data-ttu-id="10b56-192">生成、发布、运行</span><span class="sxs-lookup"><span data-stu-id="10b56-192">Build, Release, Run</span></span> | <span data-ttu-id="10b56-193">每个版本都必须强制实施跨生成、发布和运行阶段的严格分离。</span><span class="sxs-lookup"><span data-stu-id="10b56-193">Each release must enforce a strict separation across the build, release, and run stages.</span></span> <span data-ttu-id="10b56-194">每个都应使用唯一 ID 标记，并支持回滚功能。</span><span class="sxs-lookup"><span data-stu-id="10b56-194">Each should be tagged with a unique ID and support the ability to roll back.</span></span> <span data-ttu-id="10b56-195">新式 CI/CD 系统有助于满足此原则。</span><span class="sxs-lookup"><span data-stu-id="10b56-195">Modern CI/CD systems help fulfill this principle.</span></span> |
| <span data-ttu-id="10b56-196">6</span><span class="sxs-lookup"><span data-stu-id="10b56-196">6</span></span> | <span data-ttu-id="10b56-197">进程</span><span class="sxs-lookup"><span data-stu-id="10b56-197">Processes</span></span> | <span data-ttu-id="10b56-198">每个微服务应在其自己的进程中执行，与其他正在运行的服务隔离。</span><span class="sxs-lookup"><span data-stu-id="10b56-198">Each microservice should execute in its own process,  isolated from other running services.</span></span> <span data-ttu-id="10b56-199">外部化要求状态到后备服务，如分布式缓存或数据存储。</span><span class="sxs-lookup"><span data-stu-id="10b56-199">Externalize required state to a backing service such as a distributed cache or data store.</span></span> |
| <span data-ttu-id="10b56-200">7</span><span class="sxs-lookup"><span data-stu-id="10b56-200">7</span></span> | <span data-ttu-id="10b56-201">端口绑定</span><span class="sxs-lookup"><span data-stu-id="10b56-201">Port Binding</span></span> | <span data-ttu-id="10b56-202">每个微服务都应自包含在其自己的端口上公开的接口和功能。</span><span class="sxs-lookup"><span data-stu-id="10b56-202">Each microservice should be self-contained with its interfaces and functionality exposed on its own port.</span></span> <span data-ttu-id="10b56-203">这样做会提供与其他微服务的隔离。</span><span class="sxs-lookup"><span data-stu-id="10b56-203">Doing so provides isolation from other microservices.</span></span> |
| <span data-ttu-id="10b56-204">8</span><span class="sxs-lookup"><span data-stu-id="10b56-204">8</span></span> | <span data-ttu-id="10b56-205">并发</span><span class="sxs-lookup"><span data-stu-id="10b56-205">Concurrency</span></span> | <span data-ttu-id="10b56-206">服务跨大量的小型相同进程（副本）进行扩展，而不是在功能最强大的计算机上扩展单个大型实例。</span><span class="sxs-lookup"><span data-stu-id="10b56-206">Services scale out across a large number of small identical processes (copies) as opposed to scaling-up a single large instance on the most powerful machine available.</span></span> |
| <span data-ttu-id="10b56-207">9</span><span class="sxs-lookup"><span data-stu-id="10b56-207">9</span></span> | <span data-ttu-id="10b56-208">Disposability</span><span class="sxs-lookup"><span data-stu-id="10b56-208">Disposability</span></span> | <span data-ttu-id="10b56-209">服务实例应该是可释放的，favoring 快速启动以提高可伸缩性机会，并使系统保持正常状态。</span><span class="sxs-lookup"><span data-stu-id="10b56-209">Service instances should be disposable, favoring fast startups to increase scalability opportunities and graceful shutdowns to leave the system in a correct state.</span></span> <span data-ttu-id="10b56-210">Docker 容器以及 orchestrator 本身就满足了这一要求。</span><span class="sxs-lookup"><span data-stu-id="10b56-210">Docker containers along with an orchestrator inherently satisfy this requirement.</span></span> |
| <span data-ttu-id="10b56-211">10</span><span class="sxs-lookup"><span data-stu-id="10b56-211">10</span></span> | <span data-ttu-id="10b56-212">开发/生产奇偶校验</span><span class="sxs-lookup"><span data-stu-id="10b56-212">Dev/Prod Parity</span></span> | <span data-ttu-id="10b56-213">使环境在应用程序生命周期中保持尽可能相似，避免成本高昂的快捷方式。</span><span class="sxs-lookup"><span data-stu-id="10b56-213">Keep environments across the application lifecycle as similar as possible, avoiding costly shortcuts.</span></span> <span data-ttu-id="10b56-214">在这里，使用容器可以通过提升相同的执行环境来做出极大的贡献。</span><span class="sxs-lookup"><span data-stu-id="10b56-214">Here, the adoption of containers can greatly contribute by promoting the same execution environment.</span></span> |
| <span data-ttu-id="10b56-215">11</span><span class="sxs-lookup"><span data-stu-id="10b56-215">11</span></span> | <span data-ttu-id="10b56-216">日志记录</span><span class="sxs-lookup"><span data-stu-id="10b56-216">Logging</span></span> | <span data-ttu-id="10b56-217">将微服务生成的日志视为事件流。</span><span class="sxs-lookup"><span data-stu-id="10b56-217">Treat logs generated by microservices as event streams.</span></span> <span data-ttu-id="10b56-218">使用事件聚合器处理这些数据，并将数据传播到 Azure Monitor 或 Splunk 等数据挖掘/日志管理工具，最终长期存档。</span><span class="sxs-lookup"><span data-stu-id="10b56-218">Process them with an event aggregator and propagate the data to data-mining/log management tools like Azure Monitor or Splunk and eventually long-term archival.</span></span> |
| <span data-ttu-id="10b56-219">12</span><span class="sxs-lookup"><span data-stu-id="10b56-219">12</span></span> | <span data-ttu-id="10b56-220">管理进程</span><span class="sxs-lookup"><span data-stu-id="10b56-220">Admin Processes</span></span> | <span data-ttu-id="10b56-221">以一次性进程的形式运行管理/管理任务。</span><span class="sxs-lookup"><span data-stu-id="10b56-221">Run administrative/management tasks as one-off processes.</span></span> <span data-ttu-id="10b56-222">任务可以包含报表的数据清理和拉取分析。</span><span class="sxs-lookup"><span data-stu-id="10b56-222">Tasks can include data cleanup and pulling analytics for a report.</span></span> <span data-ttu-id="10b56-223">执行这些任务的工具应从生产环境中调用，而不是与应用程序一起调用。</span><span class="sxs-lookup"><span data-stu-id="10b56-223">Tools executing these tasks should be  invoked from the production environment, but separately from the application.</span></span> |

<span data-ttu-id="10b56-224">在本指南中，在 [十二个因素的应用程序之外](https://content.pivotal.io/blog/beyond-the-twelve-factor-app)，将 Hoffman 的每一个原始12个因素（以2011编写）为依据。</span><span class="sxs-lookup"><span data-stu-id="10b56-224">In the book, [Beyond the Twelve-Factor App](https://content.pivotal.io/blog/beyond-the-twelve-factor-app), author Kevin Hoffman details each of the original 12 factors (written in 2011).</span></span> <span data-ttu-id="10b56-225">此外，他还讨论了三个反映当今新式云应用程序设计的其他因素。</span><span class="sxs-lookup"><span data-stu-id="10b56-225">Additionally, he discusses three additional factors that reflect today's modern cloud application design.</span></span>

|    |  <span data-ttu-id="10b56-226">新因素</span><span class="sxs-lookup"><span data-stu-id="10b56-226">New Factor</span></span> | <span data-ttu-id="10b56-227">说明</span><span class="sxs-lookup"><span data-stu-id="10b56-227">Explanation</span></span>  |
| :-------- | :-------- | :-------- |
| <span data-ttu-id="10b56-228">13</span><span class="sxs-lookup"><span data-stu-id="10b56-228">13</span></span> | <span data-ttu-id="10b56-229">API 优先</span><span class="sxs-lookup"><span data-stu-id="10b56-229">API First</span></span> | <span data-ttu-id="10b56-230">使所有内容成为服务。</span><span class="sxs-lookup"><span data-stu-id="10b56-230">Make everything a service.</span></span> <span data-ttu-id="10b56-231">假设你的代码将由前端客户端、网关或其他服务使用。</span><span class="sxs-lookup"><span data-stu-id="10b56-231">Assume your code will be consumed by a front-end client, gateway, or another service.</span></span> |
| <span data-ttu-id="10b56-232">14</span><span class="sxs-lookup"><span data-stu-id="10b56-232">14</span></span> | <span data-ttu-id="10b56-233">遥测</span><span class="sxs-lookup"><span data-stu-id="10b56-233">Telemetry</span></span> | <span data-ttu-id="10b56-234">在工作站上，你可以深入了解应用程序及其行为。</span><span class="sxs-lookup"><span data-stu-id="10b56-234">On a workstation, you have deep visibility into your application and its behavior.</span></span> <span data-ttu-id="10b56-235">在云中，你不能。</span><span class="sxs-lookup"><span data-stu-id="10b56-235">In the cloud, you don't.</span></span> <span data-ttu-id="10b56-236">请确保您的设计包括监视、特定于域的和健康/系统数据的收集。</span><span class="sxs-lookup"><span data-stu-id="10b56-236">Make sure your design includes the collection of monitoring, domain-specific, and health/system data.</span></span> |
| <span data-ttu-id="10b56-237">15</span><span class="sxs-lookup"><span data-stu-id="10b56-237">15</span></span> | <span data-ttu-id="10b56-238">身份验证/授权</span><span class="sxs-lookup"><span data-stu-id="10b56-238">Authentication/ Authorization</span></span>  | <span data-ttu-id="10b56-239">开始实现标识。</span><span class="sxs-lookup"><span data-stu-id="10b56-239">Implement identity from the start.</span></span> <span data-ttu-id="10b56-240">考虑在公有云中提供[RBAC （基于角色的访问控制）](https://docs.microsoft.com/azure/role-based-access-control/overview)功能。</span><span class="sxs-lookup"><span data-stu-id="10b56-240">Consider [RBAC (role-based access control)](https://docs.microsoft.com/azure/role-based-access-control/overview) features available in public clouds.</span></span>  |

<span data-ttu-id="10b56-241">我们将参考本章和整个书籍中的众多12个因素。</span><span class="sxs-lookup"><span data-stu-id="10b56-241">We'll refer to many of the 12+ factors in this chapter and throughout the book.</span></span>

### <a name="critical-design-considerations"></a><span data-ttu-id="10b56-242">关键设计注意事项</span><span class="sxs-lookup"><span data-stu-id="10b56-242">Critical Design Considerations</span></span>

<span data-ttu-id="10b56-243">除了12系数方法中提供的指导外，在构造分布式系统时，还必须做出几个关键的设计决策。</span><span class="sxs-lookup"><span data-stu-id="10b56-243">Beyond the guidance provided from the twelve-factor methodology, there are several critical design decisions you must make when constructing distributed systems.</span></span>

<span data-ttu-id="10b56-244">*通信*</span><span class="sxs-lookup"><span data-stu-id="10b56-244">*Communication*</span></span>

<span data-ttu-id="10b56-245">前端客户端应用程序如何与已备份端核心服务通信？</span><span class="sxs-lookup"><span data-stu-id="10b56-245">How will front-end client applications communicate with backed-end core services?</span></span> <span data-ttu-id="10b56-246">是否允许直接通信？</span><span class="sxs-lookup"><span data-stu-id="10b56-246">Will you allow direct communication?</span></span> <span data-ttu-id="10b56-247">或者，是否可以使用提供灵活性、控制和安全性的网关外观来抽象后端服务？</span><span class="sxs-lookup"><span data-stu-id="10b56-247">Or, might you abstract the back-end services with a gateway façade that provides  flexibility, control, and security?</span></span>

<span data-ttu-id="10b56-248">如何将后端核心服务相互通信？</span><span class="sxs-lookup"><span data-stu-id="10b56-248">How will back-end core services communicate with each other?</span></span> <span data-ttu-id="10b56-249">是否允许直接 HTTP 调用导致耦合和影响性能与灵活性？</span><span class="sxs-lookup"><span data-stu-id="10b56-249">Will you allow direct HTTP calls that lead to coupling and impact performance and agility?</span></span> <span data-ttu-id="10b56-250">或者是否可以考虑将消息与队列和主题技术分离？</span><span class="sxs-lookup"><span data-stu-id="10b56-250">Or might you consider decoupled messaging with queue and topic technologies?</span></span>

<span data-ttu-id="10b56-251">有关详细信息，请阅读*云本机通信模式*。</span><span class="sxs-lookup"><span data-stu-id="10b56-251">Communication is covered in detail Chapter 4, *Cloud-Native Communication Patterns*.</span></span>

<span data-ttu-id="10b56-252">*复原能力*</span><span class="sxs-lookup"><span data-stu-id="10b56-252">*Resiliency*</span></span>

<span data-ttu-id="10b56-253">微服务体系结构将系统从进程内迁移到进程外网络通信。</span><span class="sxs-lookup"><span data-stu-id="10b56-253">A microservices architecture moves your system from in-process to out-of-process network communication.</span></span> <span data-ttu-id="10b56-254">在分布式体系结构中，如果服务 B 未响应来自服务 A 的网络呼叫，会发生什么情况？</span><span class="sxs-lookup"><span data-stu-id="10b56-254">In a distributed architecture, what happens when Service B isn't responding to a network call from Service A?</span></span> <span data-ttu-id="10b56-255">或者，当服务 C 暂时不可用时，会发生什么情况，其他调用它的服务会被阻止？</span><span class="sxs-lookup"><span data-stu-id="10b56-255">Or, what happens when Service C becomes temporarily unavailable and other services calling it are blocked?</span></span>

<span data-ttu-id="10b56-256">复原的详细信息，请阅读*云-原生复原*。</span><span class="sxs-lookup"><span data-stu-id="10b56-256">Resiliency is covered in detail Chapter 6, *Cloud-Native Resiliency*.</span></span>

<span data-ttu-id="10b56-257">*分布式数据*</span><span class="sxs-lookup"><span data-stu-id="10b56-257">*Distributed Data*</span></span>

<span data-ttu-id="10b56-258">按照设计，每个微服务都封装自己的数据，通过其公共接口公开操作。</span><span class="sxs-lookup"><span data-stu-id="10b56-258">By design, each microservice encapsulates its own data, exposing operations via its public interface.</span></span> <span data-ttu-id="10b56-259">如果是这样，如何查询数据或跨多个服务实现事务？</span><span class="sxs-lookup"><span data-stu-id="10b56-259">If so, how do you query data or implement a transaction across multiple services?</span></span>

<span data-ttu-id="10b56-260">有关分布式数据的详细信息，请阅读*云本机数据模式*。</span><span class="sxs-lookup"><span data-stu-id="10b56-260">Distributed data is covered in detail Chapter 5, *Cloud-Native Data Patterns*.</span></span>

<span data-ttu-id="10b56-261">*标识*</span><span class="sxs-lookup"><span data-stu-id="10b56-261">*Identity*</span></span>

<span data-ttu-id="10b56-262">你的服务将如何识别谁正在访问它以及他们具有哪些权限？</span><span class="sxs-lookup"><span data-stu-id="10b56-262">How will your service identify who is accessing it and what permissions they have?</span></span>

<span data-ttu-id="10b56-263">标识详见第8章 "*标识*"。</span><span class="sxs-lookup"><span data-stu-id="10b56-263">Identity is covered in detail Chapter 8, *Identity*.</span></span>

## <a name="microservices"></a><span data-ttu-id="10b56-264">微服务</span><span class="sxs-lookup"><span data-stu-id="10b56-264">Microservices</span></span>

<span data-ttu-id="10b56-265">云本机系统采用微服务，这是一种用于构建新式应用程序的常用体系结构样式。</span><span class="sxs-lookup"><span data-stu-id="10b56-265">Cloud-native systems embrace microservices, a popular architectural style for constructing modern applications.</span></span>

<span data-ttu-id="10b56-266">作为通过共享结构进行交互的一组分布式小型独立服务构建的，微服务共享以下特征：</span><span class="sxs-lookup"><span data-stu-id="10b56-266">Built as a distributed set of small, independent services that interact through a shared fabric, microservices share the following characteristics:</span></span>

- <span data-ttu-id="10b56-267">每个在更大的域上下文内实现特定的业务功能。</span><span class="sxs-lookup"><span data-stu-id="10b56-267">Each implements a specific business capability within a larger domain context.</span></span>

- <span data-ttu-id="10b56-268">每个都是自主开发的，可以独立部署。</span><span class="sxs-lookup"><span data-stu-id="10b56-268">Each is developed autonomously and can be deployed independently.</span></span>

- <span data-ttu-id="10b56-269">每个都是独立的，它封装其自己的数据存储技术（SQL、NoSQL）和编程平台。</span><span class="sxs-lookup"><span data-stu-id="10b56-269">Each is self-contained encapsulating its own data storage technology (SQL, NoSQL) and programming platform.</span></span>

- <span data-ttu-id="10b56-270">每个运行在其自己的进程中，并使用标准通信协议（例如 HTTP/HTTPS、Websocket 或[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)）与其他用户通信。</span><span class="sxs-lookup"><span data-stu-id="10b56-270">Each runs in its own process and communicates with others using standard communication protocols such as HTTP/HTTPS, WebSockets, or [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).</span></span>

- <span data-ttu-id="10b56-271">它们共同构成应用程序。</span><span class="sxs-lookup"><span data-stu-id="10b56-271">They compose together to form an application.</span></span>

<span data-ttu-id="10b56-272">图1-4 使用微服务方法来对比单一应用程序方法。</span><span class="sxs-lookup"><span data-stu-id="10b56-272">Figure 1-4 contrasts a monolithic application approach with a microservices approach.</span></span> <span data-ttu-id="10b56-273">请注意，单体架构是由分层体系结构组成的，它在单个进程中执行。</span><span class="sxs-lookup"><span data-stu-id="10b56-273">Note how the monolith is composed of a layered architecture, which executes in a single process.</span></span> <span data-ttu-id="10b56-274">它通常使用关系数据库。</span><span class="sxs-lookup"><span data-stu-id="10b56-274">It typically consumes a relational database.</span></span> <span data-ttu-id="10b56-275">不过，微服务方法将分隔开来功能转换为包含逻辑和数据的独立服务。</span><span class="sxs-lookup"><span data-stu-id="10b56-275">The microservice approach, however, segregates functionality into independent services that include logic and data.</span></span> <span data-ttu-id="10b56-276">每个微服务托管其自己的数据存储。</span><span class="sxs-lookup"><span data-stu-id="10b56-276">Each microservice hosts its own datastore.</span></span>

![单一部署与微服务](./media/monolithic-vs-microservices.png)

<span data-ttu-id="10b56-278">**图1-4。**</span><span class="sxs-lookup"><span data-stu-id="10b56-278">**Figure 1-4.**</span></span> <span data-ttu-id="10b56-279">单一部署与微服务</span><span class="sxs-lookup"><span data-stu-id="10b56-279">Monolithic deployment versus microservices</span></span>

<span data-ttu-id="10b56-280">请注意，微服务如何从[十二个因素的应用程序](https://12factor.net/)中提升 "一个代码库，一个应用程序" 原则，详见前面的章节。</span><span class="sxs-lookup"><span data-stu-id="10b56-280">Note how microservices promote the "One Codebase, One Application" principle from the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

> <span data-ttu-id="10b56-281">*系数 \# 1 为每个微服务指定了单个基本代码，存储在其自己的存储库中。已通过版本控制进行跟踪，可部署到多个环境。 "*</span><span class="sxs-lookup"><span data-stu-id="10b56-281">*Factor \#1  specifies "A single codebase for each microservice, stored in its own repository. Tracked with version control, it can deploy to multiple environments."*</span></span>

### <a name="why-microservices"></a><span data-ttu-id="10b56-282">为何使用微服务？</span><span class="sxs-lookup"><span data-stu-id="10b56-282">Why microservices?</span></span>

<span data-ttu-id="10b56-283">微服务提供灵活性。</span><span class="sxs-lookup"><span data-stu-id="10b56-283">Microservices provide agility.</span></span>

<span data-ttu-id="10b56-284">在本章前面的部分中，我们将使用微服务生成的电子商务应用程序与单体架构进行比较。</span><span class="sxs-lookup"><span data-stu-id="10b56-284">Earlier in the chapter, we compared an eCommerce application built as a monolith to that with microservices.</span></span> <span data-ttu-id="10b56-285">在此示例中，我们看到了一些明显的优点：</span><span class="sxs-lookup"><span data-stu-id="10b56-285">In the example, we saw some clear benefits:</span></span>

- <span data-ttu-id="10b56-286">每个微服务都有自治生命周期，并且可以独立地进行发展并经常部署。</span><span class="sxs-lookup"><span data-stu-id="10b56-286">Each microservice has an autonomous lifecycle and can evolve independently and deploy frequently.</span></span> <span data-ttu-id="10b56-287">无需等待季度发布即可部署新功能或更新。</span><span class="sxs-lookup"><span data-stu-id="10b56-287">You don't have to wait for a quarterly release to deploy a new features or update.</span></span> <span data-ttu-id="10b56-288">您可以更新复杂应用程序的较小区域，同时降低中断整个系统的风险。</span><span class="sxs-lookup"><span data-stu-id="10b56-288">You can update a small area of a complex application with less risk of disrupting the entire system.</span></span>

- <span data-ttu-id="10b56-289">每个微服务可以独立缩放。</span><span class="sxs-lookup"><span data-stu-id="10b56-289">Each microservice can scale independently.</span></span> <span data-ttu-id="10b56-290">只需横向扩展需要更多处理能力或网络带宽的服务，而不是将整个应用程序作为单个单元进行缩放。</span><span class="sxs-lookup"><span data-stu-id="10b56-290">Instead of scaling the entire application as a single unit, you scale out only those services that require more processing power or network bandwidth.</span></span> <span data-ttu-id="10b56-291">这一细化方法可用于更好地控制系统，并可帮助你在扩展系统的部分而不是所有内容时降低总体成本。</span><span class="sxs-lookup"><span data-stu-id="10b56-291">This  fine-grained approach to scaling provides for greater control of your system and helps to reduce overall costs as you scale portions of your system, not everything.</span></span>

<span data-ttu-id="10b56-292">了解微服务的优秀参考指南是[.Net 微服务：容器化 .Net 应用程序的体系结构](https://dotnet.microsoft.com/download/thank-you/microservices-architecture-ebook)。</span><span class="sxs-lookup"><span data-stu-id="10b56-292">An excellent reference guide for understanding microservices is [.NET Microservices: Architecture for Containerized .NET Applications](https://dotnet.microsoft.com/download/thank-you/microservices-architecture-ebook).</span></span> <span data-ttu-id="10b56-293">本书深层深入到微服务设计和体系结构。</span><span class="sxs-lookup"><span data-stu-id="10b56-293">The book deep dives into microservices design and architecture.</span></span> <span data-ttu-id="10b56-294">这是一种适用于 Microsoft 免费下载的[完整堆栈微服务参考体系结构](https://github.com/dotnet-architecture/eShopOnContainers)。</span><span class="sxs-lookup"><span data-stu-id="10b56-294">It's a companion for a [full-stack microservice reference architecture](https://github.com/dotnet-architecture/eShopOnContainers) available as a free download from Microsoft.</span></span>

### <a name="developing-microservices"></a><span data-ttu-id="10b56-295">开发微服务</span><span class="sxs-lookup"><span data-stu-id="10b56-295">Developing microservices</span></span>

<span data-ttu-id="10b56-296">可在任何新式开发平台上创建微服务。</span><span class="sxs-lookup"><span data-stu-id="10b56-296">Microservices can be created with any modern development platform.</span></span>

<span data-ttu-id="10b56-297">Microsoft .NET 核心平台是一种很好的选择。</span><span class="sxs-lookup"><span data-stu-id="10b56-297">The Microsoft .NET Core platform is an excellent choice.</span></span> <span data-ttu-id="10b56-298">免费和开源，它具有许多内置功能，可简化微服务开发。</span><span class="sxs-lookup"><span data-stu-id="10b56-298">Free and open source, it has many built-in features to simplify microservice development.</span></span> <span data-ttu-id="10b56-299">.NET Core 是跨平台的。</span><span class="sxs-lookup"><span data-stu-id="10b56-299">.NET Core is cross-platform.</span></span> <span data-ttu-id="10b56-300">应用程序可以在 Windows、macOS 和 Linux 的大多数风格上生成和运行。</span><span class="sxs-lookup"><span data-stu-id="10b56-300">Applications can be built and run on Windows, macOS, and most flavors of Linux.</span></span>

<span data-ttu-id="10b56-301">.NET Core 具有高性能，与 node.js 和其他竞争性平台相比，其评分非常好。</span><span class="sxs-lookup"><span data-stu-id="10b56-301">.NET Core is highly performant and has scored well in comparison to Node.js and other competing platforms.</span></span> <span data-ttu-id="10b56-302">有趣的是， [TechEmpower](https://www.techempower.com/)对许多 web 应用程序平台和框架执行了一组全面的[性能基准](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext)。</span><span class="sxs-lookup"><span data-stu-id="10b56-302">Interestingly, [TechEmpower](https://www.techempower.com/) conducted an extensive set of [performance benchmarks](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext) across many web application platforms and frameworks.</span></span> <span data-ttu-id="10b56-303">.NET Core 在顶级的十大平台和其他竞争性平台上评分。</span><span class="sxs-lookup"><span data-stu-id="10b56-303">.NET Core scored in the top 10 - well above Node.js and other competing platforms.</span></span>

<span data-ttu-id="10b56-304">.NET Core 由 Microsoft 和 GitHub 上的 .NET 社区维护。</span><span class="sxs-lookup"><span data-stu-id="10b56-304">.NET Core is maintained by Microsoft and the .NET community on GitHub.</span></span>

## <a name="containers"></a><span data-ttu-id="10b56-305">容器</span><span class="sxs-lookup"><span data-stu-id="10b56-305">Containers</span></span>

<span data-ttu-id="10b56-306">如今，听一下与*云本机*有关的任何讨论中提到的术语*容器*是一种很自然的。</span><span class="sxs-lookup"><span data-stu-id="10b56-306">Nowadays, it's natural to hear the term *container* mentioned in any conversation concerning *cloud native*.</span></span> <span data-ttu-id="10b56-307">在本指南中， [Cloud 本机模式](https://www.manning.com/books/cloud-native-patterns)、作者 Cornelia Davis 观察到，"容器是云本机软件的极佳启用程序。"</span><span class="sxs-lookup"><span data-stu-id="10b56-307">In the book, [Cloud Native Patterns](https://www.manning.com/books/cloud-native-patterns), author Cornelia Davis observes that, "Containers are a great enabler of cloud-native software."</span></span> <span data-ttu-id="10b56-308">云本机计算基础将微服务容器化作为其[云本机线索映射](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png)的第一步，即企业开始其云原生旅程的指南。</span><span class="sxs-lookup"><span data-stu-id="10b56-308">The Cloud Native Computing Foundation places microservice containerization as the first step in their [Cloud-Native Trail Map](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png) - guidance for enterprises beginning their cloud-native journey.</span></span>

<span data-ttu-id="10b56-309">容器化微服务简单明了。</span><span class="sxs-lookup"><span data-stu-id="10b56-309">Containerizing a microservice is simple and straightforward.</span></span> <span data-ttu-id="10b56-310">代码、其依赖项和运行时打包到称为[容器映像](https://docs.docker.com/glossary/?term=image)的二进制文件中。</span><span class="sxs-lookup"><span data-stu-id="10b56-310">The code, its dependencies, and runtime are packaged into a binary called a [container image](https://docs.docker.com/glossary/?term=image).</span></span> <span data-ttu-id="10b56-311">映像存储在[容器注册表](https://caylent.com/container-registries/)中，该注册表用作映像的存储库或库。</span><span class="sxs-lookup"><span data-stu-id="10b56-311">Images are stored in a [container registry](https://caylent.com/container-registries/), which acts as a repository or library for images.</span></span> <span data-ttu-id="10b56-312">注册表可以位于开发计算机上、数据中心或公有云中。</span><span class="sxs-lookup"><span data-stu-id="10b56-312">A registry can be located on your development computer, in your data center, or in a public cloud.</span></span> <span data-ttu-id="10b56-313">Docker 本身通过[Docker 中心](https://hub.docker.com/)维护公共注册表。</span><span class="sxs-lookup"><span data-stu-id="10b56-313">Docker itself maintains a public registry via [Docker Hub](https://hub.docker.com/).</span></span> <span data-ttu-id="10b56-314">Azure 云使用[容器注册表](https://azure.microsoft.com/services/container-registry/)来存储与将运行它们的云应用程序接近的容器映像。</span><span class="sxs-lookup"><span data-stu-id="10b56-314">The Azure cloud features a [container registry](https://azure.microsoft.com/services/container-registry/) to store container images close to the cloud applications that will run them.</span></span>

<span data-ttu-id="10b56-315">需要时，将图像转换为正在运行的容器实例。</span><span class="sxs-lookup"><span data-stu-id="10b56-315">When needed, you transform the image into a running container instance.</span></span> <span data-ttu-id="10b56-316">实例在安装了[容器运行时](https://kubernetes.io/docs/setup/production-environment/container-runtimes/)引擎的任何计算机上运行。</span><span class="sxs-lookup"><span data-stu-id="10b56-316">The instance runs on any computer that has a [container runtime](https://kubernetes.io/docs/setup/production-environment/container-runtimes/) engine installed.</span></span> <span data-ttu-id="10b56-317">您可以根据需要创建容器化服务的任意多个实例。</span><span class="sxs-lookup"><span data-stu-id="10b56-317">You can have as many instances of the containerized service as needed.</span></span>

<span data-ttu-id="10b56-318">图1-5 显示了三个不同的微服务，每个都在单独的主机上运行的容器中。</span><span class="sxs-lookup"><span data-stu-id="10b56-318">Figure 1-5 shows three different microservices, each in its own container, running on a single host.</span></span>

![在一个容器主机上运行多个容器](./media/hosting-mulitple-containers.png)

<span data-ttu-id="10b56-320">**图 1-5**。</span><span class="sxs-lookup"><span data-stu-id="10b56-320">**Figure 1-5**.</span></span> <span data-ttu-id="10b56-321">在一个容器主机上运行多个容器</span><span class="sxs-lookup"><span data-stu-id="10b56-321">Multiple containers running on a container host</span></span>

<span data-ttu-id="10b56-322">请注意，每个容器如何维护其自己的依赖项和运行时，它们可能不同。</span><span class="sxs-lookup"><span data-stu-id="10b56-322">Note how each container maintains its own set of dependencies and runtime, which can be different.</span></span> <span data-ttu-id="10b56-323">在这里，我们看到在同一主机上运行的产品微服务的版本不同。</span><span class="sxs-lookup"><span data-stu-id="10b56-323">Here, we see different versions of the Product microservice running on the same host.</span></span> <span data-ttu-id="10b56-324">每个容器共享底层主机操作系统、内存和处理器的一个切片，但彼此隔离。</span><span class="sxs-lookup"><span data-stu-id="10b56-324">Each container shares a slice of the underlying host operating system, memory, and processor, but is isolated from one another.</span></span>

<span data-ttu-id="10b56-325">请注意，容器模型将 "依赖关系" 原则[纳入十二个因素应用程序](https://12factor.net/)。</span><span class="sxs-lookup"><span data-stu-id="10b56-325">Note how well the container model embraces the "Dependencies" principle from the [Twelve-Factor Application](https://12factor.net/).</span></span>

> <span data-ttu-id="10b56-326">*系数 \# 2 指定 "每个微服务将其自己的依赖项隔离并打包在一起，以在不影响整个系统的情况下进行更改。"*</span><span class="sxs-lookup"><span data-stu-id="10b56-326">*Factor \#2  specifies that "Each microservice isolates and packages its own dependencies, embracing changes without impacting the entire system."*</span></span>

<span data-ttu-id="10b56-327">容器支持 Linux 和 Windows 工作负荷。</span><span class="sxs-lookup"><span data-stu-id="10b56-327">Containers support both Linux and Windows workloads.</span></span> <span data-ttu-id="10b56-328">Azure 云公开了这两者。</span><span class="sxs-lookup"><span data-stu-id="10b56-328">The Azure cloud openly embraces both.</span></span> <span data-ttu-id="10b56-329">有趣的是，它是 Linux，而不是 Windows Server，已成为 Azure 中最流行的操作系统。</span><span class="sxs-lookup"><span data-stu-id="10b56-329">Interestingly, it's Linux, not Windows Server, that has become the most popular operating system in Azure.</span></span>

<span data-ttu-id="10b56-330">虽然存在多个容器供应商，但 Docker 却捕获了 lion 的市场份额。</span><span class="sxs-lookup"><span data-stu-id="10b56-330">While several container vendors exist, Docker has captured the lion's share of the market.</span></span> <span data-ttu-id="10b56-331">公司已在推动软件容器的移动。</span><span class="sxs-lookup"><span data-stu-id="10b56-331">The company has been driving the software container movement.</span></span> <span data-ttu-id="10b56-332">它已成为打包、部署和运行云本机应用程序的事实上的标准。</span><span class="sxs-lookup"><span data-stu-id="10b56-332">It has become the de facto standard for packaging, deploying, and running cloud-native applications.</span></span>

### <a name="why-containers"></a><span data-ttu-id="10b56-333">为什么选择容器？</span><span class="sxs-lookup"><span data-stu-id="10b56-333">Why containers?</span></span>

<span data-ttu-id="10b56-334">容器可提供可移植性，并确保环境之间的一致性。</span><span class="sxs-lookup"><span data-stu-id="10b56-334">Containers provide portability and guarantee consistency across environments.</span></span> <span data-ttu-id="10b56-335">将所有内容封装到一个包中，即可将微服务及其依赖项从底层基础结构中*隔离开来*。</span><span class="sxs-lookup"><span data-stu-id="10b56-335">By encapsulating everything into a single package, you *isolate* the microservice and its dependencies from the underlying infrastructure.</span></span>

<span data-ttu-id="10b56-336">可以在具有 Docker 运行时引擎的任何环境中部署相同的容器。</span><span class="sxs-lookup"><span data-stu-id="10b56-336">You can deploy that same container in any environment that has the Docker runtime engine.</span></span> <span data-ttu-id="10b56-337">容器化工作负荷还消除了通过框架、软件库和运行时引擎预配置每个环境的费用。</span><span class="sxs-lookup"><span data-stu-id="10b56-337">Containerized workloads also eliminate the expense of pre-configuring each environment with frameworks, software libraries, and runtime engines.</span></span>

<span data-ttu-id="10b56-338">通过共享基础操作系统和主机资源，容器的占用空间比完整虚拟机少很多。</span><span class="sxs-lookup"><span data-stu-id="10b56-338">By sharing the underlying operating system and host resources, containers have a much smaller footprint than a full virtual machine.</span></span> <span data-ttu-id="10b56-339">较小的大小增加了给定主机一次可以运行的*密度*或微服务数。</span><span class="sxs-lookup"><span data-stu-id="10b56-339">The smaller size increases the *density*, or number of microservices, that a given host can run at one time.</span></span>

### <a name="container-orchestration"></a><span data-ttu-id="10b56-340">容器业务流程</span><span class="sxs-lookup"><span data-stu-id="10b56-340">Container orchestration</span></span>

<span data-ttu-id="10b56-341">虽然 Docker 等工具创建映像和运行容器，但你还需要工具来管理它们。</span><span class="sxs-lookup"><span data-stu-id="10b56-341">While tools such as Docker create images and run containers, you also need tools to manage them.</span></span> <span data-ttu-id="10b56-342">容器管理是使用称为容器 orchestrator 的特殊软件程序来完成的。</span><span class="sxs-lookup"><span data-stu-id="10b56-342">Container management is done with a special software program called a container orchestrator.</span></span> <span data-ttu-id="10b56-343">在大规模操作时，容器业务流程至关重要。</span><span class="sxs-lookup"><span data-stu-id="10b56-343">When operating at scale, container orchestration is essential.</span></span>

<span data-ttu-id="10b56-344">图1-6 显示了容器协调器提供的管理任务。</span><span class="sxs-lookup"><span data-stu-id="10b56-344">Figure 1-6 shows management tasks that container orchestrators provide.</span></span>

![什么是容器协调器](./media/what-container-orchestrators-do.png)

<span data-ttu-id="10b56-346">**图 1-6**。</span><span class="sxs-lookup"><span data-stu-id="10b56-346">**Figure 1-6**.</span></span> <span data-ttu-id="10b56-347">什么是容器协调器</span><span class="sxs-lookup"><span data-stu-id="10b56-347">What container orchestrators do</span></span>

<span data-ttu-id="10b56-348">下表描述了常见的业务流程任务。</span><span class="sxs-lookup"><span data-stu-id="10b56-348">The following table describes common orchestration tasks.</span></span>

|  <span data-ttu-id="10b56-349">任务</span><span class="sxs-lookup"><span data-stu-id="10b56-349">Tasks</span></span> | <span data-ttu-id="10b56-350">说明</span><span class="sxs-lookup"><span data-stu-id="10b56-350">Explanation</span></span>  |
| :-------- | :-------- |
| <span data-ttu-id="10b56-351">计划</span><span class="sxs-lookup"><span data-stu-id="10b56-351">Scheduling</span></span> | <span data-ttu-id="10b56-352">自动预配容器实例。</span><span class="sxs-lookup"><span data-stu-id="10b56-352">Automatically provision container instances.</span></span>|
| <span data-ttu-id="10b56-353">相关性/反相关性</span><span class="sxs-lookup"><span data-stu-id="10b56-353">Affinity/anti-affinity</span></span> | <span data-ttu-id="10b56-354">每个附近或附近预配容器，有助于实现可用性和性能。</span><span class="sxs-lookup"><span data-stu-id="10b56-354">Provision containers nearby or far apart from each other, helping  availability and performance.</span></span> |
| <span data-ttu-id="10b56-355">运行状况监视</span><span class="sxs-lookup"><span data-stu-id="10b56-355">Health monitoring</span></span> | <span data-ttu-id="10b56-356">自动检测并更正失败。</span><span class="sxs-lookup"><span data-stu-id="10b56-356">Automatically detect and correct failures.</span></span>|
| <span data-ttu-id="10b56-357">故障转移</span><span class="sxs-lookup"><span data-stu-id="10b56-357">Failover</span></span> | <span data-ttu-id="10b56-358">自动重新设置失败的实例恢复到正常运行的计算机。</span><span class="sxs-lookup"><span data-stu-id="10b56-358">Automatically reprovision failed instance to healthy machines.</span></span>|
| <span data-ttu-id="10b56-359">扩展</span><span class="sxs-lookup"><span data-stu-id="10b56-359">Scaling</span></span> | <span data-ttu-id="10b56-360">自动添加或删除容器实例以满足需求。</span><span class="sxs-lookup"><span data-stu-id="10b56-360">Automatically add or remove container instance to meet demand.</span></span>|
| <span data-ttu-id="10b56-361">网络</span><span class="sxs-lookup"><span data-stu-id="10b56-361">Networking</span></span> | <span data-ttu-id="10b56-362">管理用于容器通信的网络覆盖区。</span><span class="sxs-lookup"><span data-stu-id="10b56-362">Manage a networking overlay for container communication.</span></span>|
| <span data-ttu-id="10b56-363">服务发现</span><span class="sxs-lookup"><span data-stu-id="10b56-363">Service Discovery</span></span> | <span data-ttu-id="10b56-364">使容器相互定位。</span><span class="sxs-lookup"><span data-stu-id="10b56-364">Enable containers to locate each other.</span></span>|
| <span data-ttu-id="10b56-365">滚动升级</span><span class="sxs-lookup"><span data-stu-id="10b56-365">Rolling Upgrades</span></span> | <span data-ttu-id="10b56-366">协调增量升级，并部署零停机时间。</span><span class="sxs-lookup"><span data-stu-id="10b56-366">Coordinate incremental upgrades with zero downtime deployment.</span></span> <span data-ttu-id="10b56-367">自动回滚有问题的更改。</span><span class="sxs-lookup"><span data-stu-id="10b56-367">Automatically roll back problematic changes.</span></span>|

<span data-ttu-id="10b56-368">请注意，协调器如何接受来自十二个因素的[应用程序](https://12factor.net/)的 disposability 和并发原则，这一章前面讨论过。</span><span class="sxs-lookup"><span data-stu-id="10b56-368">Note how orchestrators embrace the disposability and concurrency principles from the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

> <span data-ttu-id="10b56-369">*第 \# 9 个因素9指定 "服务实例应该是可释放的、favoring 快速启动的，以增加可伸缩性机会，并使系统保持正常状态。Docker 容器以及 orchestrator 本身就满足了这一要求。 "*</span><span class="sxs-lookup"><span data-stu-id="10b56-369">*Factor \#9  specifies that "Service instances should be disposable, favoring fast startups to increase scalability opportunities and graceful shutdowns to leave the system in a correct state. Docker containers along with an orchestrator inherently satisfy this requirement."*</span></span>

> <span data-ttu-id="10b56-370">*\#第8个因素8指定 "服务跨大量的小型相同进程（副本）进行扩展，而不是在功能最强大的计算机上扩展单个大型实例。"*</span><span class="sxs-lookup"><span data-stu-id="10b56-370">*Factor \#8  specifies that "Services scale out across a large number of small identical processes (copies) as opposed to scaling-up a single large instance on the most powerful machine available."*</span></span>

<span data-ttu-id="10b56-371">尽管存在多个容器协调器，但[Kubernetes](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/)已成为云原生世界的事实上标准。</span><span class="sxs-lookup"><span data-stu-id="10b56-371">While several container orchestrators exist, [Kubernetes](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/) has become the de facto standard for the cloud-native world.</span></span> <span data-ttu-id="10b56-372">它是一个可移植的可扩展开源平台，用于管理容器化工作负荷。</span><span class="sxs-lookup"><span data-stu-id="10b56-372">It's a portable, extensible, open-source platform for managing containerized workloads.</span></span>

<span data-ttu-id="10b56-373">您可以托管自己的 Kubernetes 实例，但随后需要负责预配和管理其资源，这可能很复杂。</span><span class="sxs-lookup"><span data-stu-id="10b56-373">You could host your own instance of Kubernetes, but then you'd be responsible for provisioning and managing its resources - which can be complex.</span></span> <span data-ttu-id="10b56-374">Azure 云功能 Kubernetes 作为托管服务， [Azure Kubernetes 服务（AKS）](https://azure.microsoft.com/services/kubernetes-service/)。</span><span class="sxs-lookup"><span data-stu-id="10b56-374">The Azure cloud features Kubernetes as a managed service, [Azure Kubernetes Service (AKS)](https://azure.microsoft.com/services/kubernetes-service/).</span></span> <span data-ttu-id="10b56-375">托管服务使你可以充分利用其功能，而无需安装和维护它。</span><span class="sxs-lookup"><span data-stu-id="10b56-375">A managed service allows you to fully leverage its features, without having to install and maintain it.</span></span>

<span data-ttu-id="10b56-376">Azure Kubernetes Services 在第2章中详细介绍了如何*扩展云本机应用程序*。</span><span class="sxs-lookup"><span data-stu-id="10b56-376">Azure Kubernetes Services is covered in detail Chapter 2, *Scaling Cloud-Native Applications*.</span></span>

## <a name="backing-services"></a><span data-ttu-id="10b56-377">支持服务</span><span class="sxs-lookup"><span data-stu-id="10b56-377">Backing services</span></span>

<span data-ttu-id="10b56-378">云本机系统依赖于许多不同的辅助资源，如数据存储、消息代理、监视和标识服务。</span><span class="sxs-lookup"><span data-stu-id="10b56-378">Cloud-native systems depend upon many different ancillary resources, such as data stores, message brokers, monitoring, and identity services.</span></span> <span data-ttu-id="10b56-379">这些服务称为 "[后备服务](https://12factor.net/backing-services)"。</span><span class="sxs-lookup"><span data-stu-id="10b56-379">These services are known as [backing services](https://12factor.net/backing-services).</span></span>

 <span data-ttu-id="10b56-380">图1-7 显示了云本机系统使用的许多常见后备服务。</span><span class="sxs-lookup"><span data-stu-id="10b56-380">Figure 1-7 shows many common backing services that cloud-native systems consume.</span></span>

![常见的支持服务](./media/common-backing-services.png)

<span data-ttu-id="10b56-382">**图 1-7**。</span><span class="sxs-lookup"><span data-stu-id="10b56-382">**Figure 1-7**.</span></span> <span data-ttu-id="10b56-383">常见的支持服务</span><span class="sxs-lookup"><span data-stu-id="10b56-383">Common backing services</span></span>

<span data-ttu-id="10b56-384">后备服务从[十二个因素的应用程序](https://12factor.net/)中提升 "情形" 原则，这一章在前面讨论过。</span><span class="sxs-lookup"><span data-stu-id="10b56-384">Backing services promote the "Statelessness" principle from the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

><span data-ttu-id="10b56-385">*系数 \# 6*指定 "每个微服务应在其自己的进程中运行，与其他正在运行的服务隔离。</span><span class="sxs-lookup"><span data-stu-id="10b56-385">*Factor \#6* specifies that, "Each microservice should execute in its own process, isolated from other running services.</span></span> <span data-ttu-id="10b56-386">外部化要求状态到后备服务，如分布式缓存或数据存储。 "</span><span class="sxs-lookup"><span data-stu-id="10b56-386">Externalize required state to a backing service such as a distributed cache or data store."</span></span>

<span data-ttu-id="10b56-387">你可以托管自己的支持服务，但随后你将负责授权、预配和管理这些资源。</span><span class="sxs-lookup"><span data-stu-id="10b56-387">You could host your own backing services, but then you'd be responsible for licensing, provisioning, and managing those resources.</span></span>

<span data-ttu-id="10b56-388">云提供商提供丰富的*托管支持服务。*</span><span class="sxs-lookup"><span data-stu-id="10b56-388">Cloud providers offer a rich assortment of *managed backing services.*</span></span> <span data-ttu-id="10b56-389">只需使用服务即可。</span><span class="sxs-lookup"><span data-stu-id="10b56-389">Instead of owning the service, you simply consume it.</span></span> <span data-ttu-id="10b56-390">提供程序对资源进行大规模的操作，并为性能、安全性和维护提供责任。</span><span class="sxs-lookup"><span data-stu-id="10b56-390">The provider operates the resource at scale and bears the responsibility for performance, security, and maintenance.</span></span> <span data-ttu-id="10b56-391">服务中内置了监视、冗余和可用性。</span><span class="sxs-lookup"><span data-stu-id="10b56-391">Monitoring, redundancy, and availability are built into the service.</span></span> <span data-ttu-id="10b56-392">提供商完全支持其托管服务-打开一个票据，并解决问题。</span><span class="sxs-lookup"><span data-stu-id="10b56-392">Providers fully support their managed services - open a ticket and they fix your issue.</span></span>

<span data-ttu-id="10b56-393">云本机系统支持云供应商提供的托管支持服务。</span><span class="sxs-lookup"><span data-stu-id="10b56-393">Cloud-native systems favor managed backing services from cloud vendors.</span></span> <span data-ttu-id="10b56-394">节省时间和劳动非常好。</span><span class="sxs-lookup"><span data-stu-id="10b56-394">The savings in time and labor are great.</span></span> <span data-ttu-id="10b56-395">托管您自己和遇到问题的运营风险会迅速降低。</span><span class="sxs-lookup"><span data-stu-id="10b56-395">The operational risk of hosting your own and experiencing trouble can get expensive fast.</span></span>

<span data-ttu-id="10b56-396">最佳做法是将后备服务视为*附加资源*，动态绑定到微服务，其中包含存储在外部配置中的信息（URL 和凭据）。</span><span class="sxs-lookup"><span data-stu-id="10b56-396">A best practice is to treat a backing service as an *attached resource*, dynamically bound to a microservice with information (a URL and credentials) stored in an external configuration.</span></span> <span data-ttu-id="10b56-397">本指南在这一章前面讨论过的[十二因素应用程序](https://12factor.net/)中进行了介绍。</span><span class="sxs-lookup"><span data-stu-id="10b56-397">This guidance is spelled out in the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

><span data-ttu-id="10b56-398">\* \# 4 系数 4\*指定应通过可寻址 URL 公开后备服务。</span><span class="sxs-lookup"><span data-stu-id="10b56-398">*Factor \#4* specifies that backing services "should be exposed via an addressable URL.</span></span> <span data-ttu-id="10b56-399">这样做会使资源与应用程序分离，使其能够互相替换。 "</span><span class="sxs-lookup"><span data-stu-id="10b56-399">Doing so decouples the resource from the application, enabling it to be interchangeable."</span></span>

><span data-ttu-id="10b56-400">\* \# 第3个因素\*：指定 "通过代码外的配置管理工具将配置信息移出微服务和外部化。"</span><span class="sxs-lookup"><span data-stu-id="10b56-400">*Factor \#3* specifies that "Configuration information is moved out of the microservice and externalized through a configuration management tool outside of the code."</span></span>

<span data-ttu-id="10b56-401">使用此模式，可附加和分离后备服务，无需更改代码。</span><span class="sxs-lookup"><span data-stu-id="10b56-401">With this pattern, a backing service can be attached and detached without code changes.</span></span> <span data-ttu-id="10b56-402">可以将微服务从问答升级到过渡环境。</span><span class="sxs-lookup"><span data-stu-id="10b56-402">You might promote a microservice from QA to a staging environment.</span></span> <span data-ttu-id="10b56-403">将微服务配置更新为指向暂存中的后备服务，并通过环境变量将设置注入到容器中。</span><span class="sxs-lookup"><span data-stu-id="10b56-403">You update the microservice configuration to point to the backing services in staging and inject the settings into your container through an environment variable.</span></span>

<span data-ttu-id="10b56-404">云供应商提供了 Api，使你能够与其专有支持服务进行通信。</span><span class="sxs-lookup"><span data-stu-id="10b56-404">Cloud vendors provide APIs for you to communicate with their proprietary backing services.</span></span> <span data-ttu-id="10b56-405">这些库封装了管道和复杂性。</span><span class="sxs-lookup"><span data-stu-id="10b56-405">These libraries encapsulate the plumbing and complexity.</span></span> <span data-ttu-id="10b56-406">直接与这些 Api 进行通信会将你的代码紧密地耦合到支持服务。</span><span class="sxs-lookup"><span data-stu-id="10b56-406">Communicating directly with these APIs will tightly couple your code to the backing service.</span></span> <span data-ttu-id="10b56-407">更好的做法是，隔离供应商 API 的实现细节。</span><span class="sxs-lookup"><span data-stu-id="10b56-407">It's a better practice to insulate the implementation details of the vendor API.</span></span> <span data-ttu-id="10b56-408">引入 intermediation 层或中间 API，将一般操作公开给你的服务代码。</span><span class="sxs-lookup"><span data-stu-id="10b56-408">Introduce an intermediation layer, or intermediate API, exposing generic operations to your service code.</span></span> <span data-ttu-id="10b56-409">这种松散耦合使你可以将另一个后备服务换出，或将代码移到不同的公有云，而无需更改主线服务代码。</span><span class="sxs-lookup"><span data-stu-id="10b56-409">This loose coupling enables you to swap out one backing service for another or move your code to a different public cloud without having to make changes to the mainline service code.</span></span>

<span data-ttu-id="10b56-410">支持服务的详细信息，请参见第5章、*云本机数据模式*和第4章 *-本机通信模式*。</span><span class="sxs-lookup"><span data-stu-id="10b56-410">Backing services are discussed in detail Chapter 5, *Cloud-Native Data Patterns*, and Chapter 4, *Cloud-Native Communication Patterns*.</span></span>

## <a name="automation"></a><span data-ttu-id="10b56-411">自动化</span><span class="sxs-lookup"><span data-stu-id="10b56-411">Automation</span></span>

<span data-ttu-id="10b56-412">如您所见，云本机系统采用微服务、容器和新式系统设计来实现速度和灵活性。</span><span class="sxs-lookup"><span data-stu-id="10b56-412">As you've seen, cloud-native systems embrace microservices, containers, and modern system design to achieve speed and agility.</span></span> <span data-ttu-id="10b56-413">但这只是其中的一部分。</span><span class="sxs-lookup"><span data-stu-id="10b56-413">But, that's only part of the story.</span></span> <span data-ttu-id="10b56-414">如何预配这些系统运行时所用的云环境？</span><span class="sxs-lookup"><span data-stu-id="10b56-414">How do you provision the cloud environments upon which these systems run?</span></span> <span data-ttu-id="10b56-415">如何快速部署应用功能和更新？</span><span class="sxs-lookup"><span data-stu-id="10b56-415">How do you rapidly deploy app features and updates?</span></span> <span data-ttu-id="10b56-416">如何整整图片？</span><span class="sxs-lookup"><span data-stu-id="10b56-416">How do you round out the full picture?</span></span>

<span data-ttu-id="10b56-417">输入[基础结构为代码](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)或 IaC 的广泛接受的做法。</span><span class="sxs-lookup"><span data-stu-id="10b56-417">Enter the widely accepted practice of [Infrastructure as Code](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code), or IaC.</span></span>

<span data-ttu-id="10b56-418">借助 IaC，你可以自动执行平台预配和应用程序部署。</span><span class="sxs-lookup"><span data-stu-id="10b56-418">With IaC, you automate platform provisioning and application deployment.</span></span> <span data-ttu-id="10b56-419">实质上是将软件工程实践（例如测试和版本控制）应用于 DevOps 做法。</span><span class="sxs-lookup"><span data-stu-id="10b56-419">You essentially apply software engineering practices such as testing and versioning to your DevOps practices.</span></span> <span data-ttu-id="10b56-420">你的基础结构和部署是自动、一致且可重复的。</span><span class="sxs-lookup"><span data-stu-id="10b56-420">Your infrastructure and deployments are automated, consistent, and repeatable.</span></span>

### <a name="automating-infrastructure"></a><span data-ttu-id="10b56-421">自动化基础结构</span><span class="sxs-lookup"><span data-stu-id="10b56-421">Automating infrastructure</span></span>

<span data-ttu-id="10b56-422">[Azure 资源管理器](https://azure.microsoft.com/documentation/articles/resource-group-overview/)、Terraform 和[Azure CLI](https://docs.microsoft.com/cli/azure/)等工具使你能够以声明方式为你所需的云基础结构编写脚本。</span><span class="sxs-lookup"><span data-stu-id="10b56-422">Tools like [Azure Resource Manager](https://azure.microsoft.com/documentation/articles/resource-group-overview/), Terraform, and the [Azure CLI](https://docs.microsoft.com/cli/azure/), enable you to declaratively script the cloud infrastructure you require.</span></span> <span data-ttu-id="10b56-423">资源名称、位置、容量和密码都是参数化和动态的。</span><span class="sxs-lookup"><span data-stu-id="10b56-423">Resource names, locations, capacities, and secrets are parameterized and dynamic.</span></span> <span data-ttu-id="10b56-424">脚本被版本控制，并签入到源控件中作为项目的项目。</span><span class="sxs-lookup"><span data-stu-id="10b56-424">The script is versioned and checked into source control as an artifact of your project.</span></span> <span data-ttu-id="10b56-425">调用脚本可以在系统环境（如 QA、过渡和生产）中预配一致且可重复的基础结构。</span><span class="sxs-lookup"><span data-stu-id="10b56-425">You invoke the script to provision a consistent and repeatable infrastructure across system environments, such as QA, staging, and production.</span></span>

<span data-ttu-id="10b56-426">在这种情况下，IaC 是幂等的，这意味着您可以反复运行相同的脚本，而不会产生负面影响。</span><span class="sxs-lookup"><span data-stu-id="10b56-426">Under the hood, IaC is idempotent, meaning that you can run the same script over and over without side effects.</span></span> <span data-ttu-id="10b56-427">如果团队需要进行更改，则会编辑并重新运行该脚本。</span><span class="sxs-lookup"><span data-stu-id="10b56-427">If the team needs to make a change, they edit and rerun the script.</span></span> <span data-ttu-id="10b56-428">只有更新的资源才会受到影响。</span><span class="sxs-lookup"><span data-stu-id="10b56-428">Only the updated resources are affected.</span></span>

<span data-ttu-id="10b56-429">在本文中，[什么是基础结构即代码](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)，Author Sam Guckenheimer 介绍了 "实现 IaC 的团队如何快速、大规模地交付稳定环境。</span><span class="sxs-lookup"><span data-stu-id="10b56-429">In the article, [What is Infrastructure as Code](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code), Author Sam Guckenheimer describes how, "Teams who implement IaC can deliver stable environments rapidly and at scale.</span></span> <span data-ttu-id="10b56-430">团队避免手动配置环境，并通过代码来表示环境所需的状态，从而强制实现一致性。</span><span class="sxs-lookup"><span data-stu-id="10b56-430">Teams avoid manual configuration of environments and enforce consistency by representing the desired state of their environments via code.</span></span> <span data-ttu-id="10b56-431">使用 IaC 的基础结构部署是可重复的，并防止配置偏移或缺少依赖项导致的运行时问题。</span><span class="sxs-lookup"><span data-stu-id="10b56-431">Infrastructure deployments with IaC are repeatable and prevent runtime issues caused by configuration drift or missing dependencies.</span></span> <span data-ttu-id="10b56-432">DevOps 团队可以结合使用一组统一的做法和工具，迅速、可靠、大规模地提供应用程序及其支持基础结构。</span><span class="sxs-lookup"><span data-stu-id="10b56-432">DevOps teams can work together with a unified set of practices and tools to deliver applications and their supporting infrastructure rapidly, reliably, and at scale."</span></span>

### <a name="automating-deployments"></a><span data-ttu-id="10b56-433">自动部署</span><span class="sxs-lookup"><span data-stu-id="10b56-433">Automating deployments</span></span>

<span data-ttu-id="10b56-434">前面所述的[十二因素应用程序](https://12factor.net/)会在将完成的代码转换为正在运行的应用程序时调用单独的步骤。</span><span class="sxs-lookup"><span data-stu-id="10b56-434">The [Twelve-Factor Application](https://12factor.net/), discussed earlier, calls for separate steps when transforming completed code into a running application.</span></span>

> <span data-ttu-id="10b56-435">*系数 \# 5*指定 "每个版本都必须在生成、发布和运行阶段强制实现严格分离。</span><span class="sxs-lookup"><span data-stu-id="10b56-435">*Factor \#5* specifies that "Each release must enforce a strict separation across the build, release and run stages.</span></span> <span data-ttu-id="10b56-436">每个都应使用唯一的 ID 标记，并支持回滚的能力。 "</span><span class="sxs-lookup"><span data-stu-id="10b56-436">Each should be tagged with a unique ID and support the ability to roll back."</span></span>

<span data-ttu-id="10b56-437">新式 CI/CD 系统有助于满足此原则。</span><span class="sxs-lookup"><span data-stu-id="10b56-437">Modern CI/CD systems help fulfill this principle.</span></span> <span data-ttu-id="10b56-438">它们提供了单独的部署步骤，有助于确保可供用户随时使用的一致和质量代码。</span><span class="sxs-lookup"><span data-stu-id="10b56-438">They provide separate deployment steps and help ensure consistent and quality code that's readily available to users.</span></span>

<span data-ttu-id="10b56-439">图1-8 显示了在整个部署过程中的分离。</span><span class="sxs-lookup"><span data-stu-id="10b56-439">Figure 1-8 shows the separation across the deployment process.</span></span>

![CI/CD 管道中的部署步骤](./media/build-release-run-pipeline.png)

<span data-ttu-id="10b56-441">**图 1-8**。</span><span class="sxs-lookup"><span data-stu-id="10b56-441">**Figure 1-8**.</span></span> <span data-ttu-id="10b56-442">CI/CD 管道中的部署步骤</span><span class="sxs-lookup"><span data-stu-id="10b56-442">Deployment steps in a CI/CD Pipeline</span></span>

<span data-ttu-id="10b56-443">在上图中，请特别注意任务的分离。</span><span class="sxs-lookup"><span data-stu-id="10b56-443">In the previous figure, pay special attention to separation of tasks.</span></span>

<span data-ttu-id="10b56-444">开发人员在其开发环境中构造一项功能，该功能将循环访问所谓的代码 "内部循环"、"运行" 和 "调试"。</span><span class="sxs-lookup"><span data-stu-id="10b56-444">The developer constructs a feature in their development environment, iterating through what is called the "inner loop" of code, run, and debug.</span></span> <span data-ttu-id="10b56-445">完成后，该代码会被*推送*到代码存储库中，例如 GitHub、Azure DevOps 或 BitBucket。</span><span class="sxs-lookup"><span data-stu-id="10b56-445">When complete, that code is *pushed* into a code repository, such as GitHub, Azure DevOps, or BitBucket.</span></span>

<span data-ttu-id="10b56-446">推送会触发一个将代码转换为二进制项目的生成阶段。</span><span class="sxs-lookup"><span data-stu-id="10b56-446">The push triggers a build stage that transforms the code into a binary artifact.</span></span> <span data-ttu-id="10b56-447">该工作是使用[持续集成（CI）](https://martinfowler.com/articles/continuousIntegration.html)管道实现的。</span><span class="sxs-lookup"><span data-stu-id="10b56-447">The work is implemented with a [Continuous Integration (CI)](https://martinfowler.com/articles/continuousIntegration.html) pipeline.</span></span> <span data-ttu-id="10b56-448">它自动生成、测试并打包应用程序。</span><span class="sxs-lookup"><span data-stu-id="10b56-448">It automatically builds, tests, and packages the application.</span></span>

<span data-ttu-id="10b56-449">发布阶段选取二进制项目，应用外部应用程序和环境配置信息，并生成不可变版本。</span><span class="sxs-lookup"><span data-stu-id="10b56-449">The release stage picks up the binary artifact, applies external application and environment configuration information, and produces an immutable release.</span></span> <span data-ttu-id="10b56-450">发布将部署到指定的环境中。</span><span class="sxs-lookup"><span data-stu-id="10b56-450">The release is deployed to a specified environment.</span></span> <span data-ttu-id="10b56-451">该工作是通过[持续交付（CD）](https://martinfowler.com/bliki/ContinuousDelivery.html)管道实现的。</span><span class="sxs-lookup"><span data-stu-id="10b56-451">The work is implemented with a [Continuous Delivery(CD)](https://martinfowler.com/bliki/ContinuousDelivery.html) pipeline.</span></span> <span data-ttu-id="10b56-452">每个版本都应可识别。</span><span class="sxs-lookup"><span data-stu-id="10b56-452">Each release should be identifiable.</span></span> <span data-ttu-id="10b56-453">你可以说 "此部署正在运行应用程序的发布版本。"</span><span class="sxs-lookup"><span data-stu-id="10b56-453">You can say, "This deployment is running Release 2.1.1 of the application."</span></span>

<span data-ttu-id="10b56-454">最后，已发布的功能在目标执行环境中运行。</span><span class="sxs-lookup"><span data-stu-id="10b56-454">Finally, the released feature is run in the target execution environment.</span></span> <span data-ttu-id="10b56-455">版本是不可变的，这意味着任何更改都必须创建新版本。</span><span class="sxs-lookup"><span data-stu-id="10b56-455">Releases are immutable meaning that any change must create a new release.</span></span>

<span data-ttu-id="10b56-456">应用这些方案后，组织会对其交付软件的方式进行了彻底的发展。</span><span class="sxs-lookup"><span data-stu-id="10b56-456">Applying these practices, organizations have radically evolved how they ship software.</span></span> <span data-ttu-id="10b56-457">许多人都从季度版本转移到按需更新。</span><span class="sxs-lookup"><span data-stu-id="10b56-457">Many have moved from quarterly releases to on-demand updates.</span></span> <span data-ttu-id="10b56-458">其目标是在开发周期的早期发现问题，因为这些问题的修复开销较低。</span><span class="sxs-lookup"><span data-stu-id="10b56-458">The goal is to catch problems early in the development cycle when they're less expensive to fix.</span></span> <span data-ttu-id="10b56-459">集成之间的持续时间越长，要解决的问题越昂贵。</span><span class="sxs-lookup"><span data-stu-id="10b56-459">The longer the duration between integrations, the more expensive problems become to resolve.</span></span>  <span data-ttu-id="10b56-460">随着集成过程的一致性，团队可以更频繁地提交代码更改，从而提高协作和软件质量。</span><span class="sxs-lookup"><span data-stu-id="10b56-460">With consistency in the integration process, teams can commit code changes more frequently, leading to better collaboration and software quality.</span></span>

### <a name="azure-pipelines"></a><span data-ttu-id="10b56-461">Azure Pipelines</span><span class="sxs-lookup"><span data-stu-id="10b56-461">Azure Pipelines</span></span>

<span data-ttu-id="10b56-462">Azure 云包括一项名为[Azure Pipelines](https://azure.microsoft.com/services/devops/pipelines/)的新 CI/CD 服务，该服务是如图1-9 所示的[Azure DevOps](https://azure.microsoft.com/services/devops/)产品的一部分。</span><span class="sxs-lookup"><span data-stu-id="10b56-462">The Azure cloud includes a new CI/CD service entitled [Azure Pipelines](https://azure.microsoft.com/services/devops/pipelines/), which is part of the [Azure DevOps](https://azure.microsoft.com/services/devops/) offering shown in Figure 1-9.</span></span>

![DevOps 中的 Azure Pipelines](./media/devops-components.png)

<span data-ttu-id="10b56-464">**图 1-9**。</span><span class="sxs-lookup"><span data-stu-id="10b56-464">**Figure 1-9**.</span></span> <span data-ttu-id="10b56-465">Azure DevOps 产品/服务</span><span class="sxs-lookup"><span data-stu-id="10b56-465">Azure DevOps offerings</span></span>

<span data-ttu-id="10b56-466">Azure Pipelines 是一种云服务，它将持续集成（CI）和持续交付（CD）结合在一起。</span><span class="sxs-lookup"><span data-stu-id="10b56-466">Azure Pipelines is a cloud service that combines continuous integration (CI) and continuous delivery (CD).</span></span> <span data-ttu-id="10b56-467">你可以自动测试、生成代码并将其交付到任意目标。</span><span class="sxs-lookup"><span data-stu-id="10b56-467">You can automatically test, build, and ship your code to any target.</span></span>

<span data-ttu-id="10b56-468">在 YAML 文件的代码中，将管道定义为应用的其余代码。</span><span class="sxs-lookup"><span data-stu-id="10b56-468">You define your pipeline in code in a YAML file alongside the rest of the code for your app.</span></span>

- <span data-ttu-id="10b56-469">该管道通过您的代码进行版本控制，并遵循相同的分支结构。</span><span class="sxs-lookup"><span data-stu-id="10b56-469">The pipeline is versioned with your code and follows the same branching structure.</span></span>
- <span data-ttu-id="10b56-470">可以通过拉取请求和分支生成策略中的代码评审来验证所做的更改。</span><span class="sxs-lookup"><span data-stu-id="10b56-470">You get validation of your changes through code reviews in pull requests and branch build policies.</span></span>
- <span data-ttu-id="10b56-471">你使用的每个分支都可以通过修改 azure-pipelines. docker-compose.override.yml 文件来自定义生成策略。</span><span class="sxs-lookup"><span data-stu-id="10b56-471">Every branch you use can customize the build policy by modifying the azure-pipelines.yml file.</span></span>
- <span data-ttu-id="10b56-472">管道文件签入到版本控制中，如果出现问题，则可以进行调查。</span><span class="sxs-lookup"><span data-stu-id="10b56-472">The pipeline file is checked into version control and can be investigated if there's a problem.</span></span>

<span data-ttu-id="10b56-473">Azure Pipelines 服务支持大多数 Git 提供程序，并且可以为在 Linux、macOS 或 Windows 平台上编写的应用程序生成部署管道。</span><span class="sxs-lookup"><span data-stu-id="10b56-473">The Azure Pipelines service supports most Git providers and can generate deployment pipelines for applications written on the Linux, macOS, or Windows platforms.</span></span> <span data-ttu-id="10b56-474">它包括对 Java、.NET、JavaScript、Python、PHP、中转、XCode 和 c + + 的支持。</span><span class="sxs-lookup"><span data-stu-id="10b56-474">It includes support for Java, .NET, JavaScript, Python, PHP, Go, XCode, and C++.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="10b56-475">[上一页](introduction.md)
>[下一页](candidate-apps.md)</span><span class="sxs-lookup"><span data-stu-id="10b56-475">[Previous](introduction.md)
[Next](candidate-apps.md)</span></span>
