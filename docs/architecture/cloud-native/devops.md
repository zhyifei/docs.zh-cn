---
title: DevOps
description: 云本机应用程序的 DevOps 注意事项
ms.date: 05/13/2020
ms.openlocfilehash: ce814595245d49e409e780cb0f63c436299c2e4e
ms.sourcegitcommit: 27db07ffb26f76912feefba7b884313547410db5
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/19/2020
ms.locfileid: "83614107"
---
# <a name="devops"></a><span data-ttu-id="3d892-103">DevOps</span><span class="sxs-lookup"><span data-stu-id="3d892-103">DevOps</span></span>

<span data-ttu-id="3d892-104">软件顾问最喜爱的口头禅是解答 "这一问题，它取决于所提出的任何问题。</span><span class="sxs-lookup"><span data-stu-id="3d892-104">The favorite mantra of software consultants is to answer "It depends" to any question posed.</span></span> <span data-ttu-id="3d892-105">这并不是因为软件顾问喜欢不是一个位置。</span><span class="sxs-lookup"><span data-stu-id="3d892-105">It isn't because software consultants are fond of not taking a position.</span></span> <span data-ttu-id="3d892-106">这是因为软件中的任何问题都没有真正的答案。</span><span class="sxs-lookup"><span data-stu-id="3d892-106">It's because there's no one true answer to any questions in software.</span></span> <span data-ttu-id="3d892-107">没有绝对权限和错误，而是相对之间的平衡。</span><span class="sxs-lookup"><span data-stu-id="3d892-107">There's no absolute right and wrong, but rather a balance between opposites.</span></span>

<span data-ttu-id="3d892-108">例如，开发 web 应用程序的两个主要方面：单页面应用程序（Spa）与服务器端应用程序。</span><span class="sxs-lookup"><span data-stu-id="3d892-108">Take, for instance, the two major schools of developing web applications: Single Page Applications (SPAs) versus server-side applications.</span></span> <span data-ttu-id="3d892-109">一方面，用户体验会更好地用于 Spa，可以最大程度地减少到 web 服务器的流量，使其能够在与静态宿主简单的操作上托管。</span><span class="sxs-lookup"><span data-stu-id="3d892-109">On the one hand, the user experience tends to be better with SPAs and the amount of traffic to the web server can be minimized making it possible to host them on something as simple as static hosting.</span></span> <span data-ttu-id="3d892-110">另一方面，Spa 往往会变慢，并且更难测试。</span><span class="sxs-lookup"><span data-stu-id="3d892-110">On the other hand, SPAs tend to be slower to develop and more difficult to test.</span></span> <span data-ttu-id="3d892-111">哪一个是正确的选择？</span><span class="sxs-lookup"><span data-stu-id="3d892-111">Which one is the right choice?</span></span> <span data-ttu-id="3d892-112">这取决于你的情况。</span><span class="sxs-lookup"><span data-stu-id="3d892-112">Well, it depends on your situation.</span></span>

<span data-ttu-id="3d892-113">云本机应用程序不会受到相同分裂的不受限于。</span><span class="sxs-lookup"><span data-stu-id="3d892-113">Cloud-native applications aren't immune to that same dichotomy.</span></span> <span data-ttu-id="3d892-114">它们在开发、稳定性和可伸缩性方面具有明显的优势，但对它们进行管理可能有点困难。</span><span class="sxs-lookup"><span data-stu-id="3d892-114">They have clear advantages in terms of speed of development, stability, and scalability, but managing them can be quite a bit more difficult.</span></span>

<span data-ttu-id="3d892-115">几年前，将应用程序从开发环境转移到生产环境的过程要花一个月，甚至更多。</span><span class="sxs-lookup"><span data-stu-id="3d892-115">Years ago, it wasn't uncommon for the process of moving an application from development to production to take a month, or even more.</span></span> <span data-ttu-id="3d892-116">公司在6个月甚至每年的步调上发布软件。</span><span class="sxs-lookup"><span data-stu-id="3d892-116">Companies released software on a 6-month or even every year cadence.</span></span> <span data-ttu-id="3d892-117">在 Windows 10 之前的那一天之前，只需要查看 Microsoft Windows，才能获得可接受的发布节奏。</span><span class="sxs-lookup"><span data-stu-id="3d892-117">One needs to look no further than Microsoft Windows to get an idea for the cadence of releases that were acceptable before the ever-green days of Windows 10.</span></span> <span data-ttu-id="3d892-118">五年在 Windows XP 和 Vista 之间传递，在 Vista 和 Windows 7 之间还有3个。</span><span class="sxs-lookup"><span data-stu-id="3d892-118">Five years passed between Windows XP and Vista, a further 3 between Vista and Windows 7.</span></span>

<span data-ttu-id="3d892-119">它现在相当明确，能够发布软件，使快速发展的公司在 sloth 的竞争对手更具优势。</span><span class="sxs-lookup"><span data-stu-id="3d892-119">It's now fairly well established that being able to release software rapidly gives fast-moving companies a huge market advantage over their more sloth-like competitors.</span></span> <span data-ttu-id="3d892-120">这是因为，Windows 10 的主要更新现在大约每六个月执行一次。</span><span class="sxs-lookup"><span data-stu-id="3d892-120">It's for that reason that major updates to Windows 10 are now approximately every six months.</span></span>

<span data-ttu-id="3d892-121">支持更快速、更可靠的版本实现业务价值的模式和实践统称为 "DevOps"。</span><span class="sxs-lookup"><span data-stu-id="3d892-121">The patterns and practices that enable faster, more reliable releases to deliver value to the business are collectively known as DevOps.</span></span> <span data-ttu-id="3d892-122">它们包括从整个软件开发生命周期到整个软件开发生命周期的各种创意，从指定应用程序一直到提供和操作该应用程序。</span><span class="sxs-lookup"><span data-stu-id="3d892-122">They consist of a wide range of ideas spanning the entire software development life cycle from specifying an application all the way up to delivering and operating that application.</span></span>

<span data-ttu-id="3d892-123">DevOps 在微服务之前发生，并且很可能会更小，更适合使用目的服务，无需进行发布和操作，而只是在生产中运行的应用程序更简单。</span><span class="sxs-lookup"><span data-stu-id="3d892-123">DevOps emerged before microservices and it's likely that the movement towards smaller, more fit to purpose services wouldn't have been possible without DevOps to make releasing and operating not just one but many applications in production easier.</span></span>

![图10-1 搜索趋势表明，微服务的增长不会开始，DevOps 是一种非常合理的理念。](./media/microservices-vs-devops.png)

<span data-ttu-id="3d892-125">**图 10-1** -DevOps 和微服务。</span><span class="sxs-lookup"><span data-stu-id="3d892-125">**Figure 10-1** - DevOps and microservices.</span></span>

<span data-ttu-id="3d892-126">通过良好的 DevOps 实践，可以实现云本机应用程序的优势，而无需 suffocating 的工作实际运行应用程序。</span><span class="sxs-lookup"><span data-stu-id="3d892-126">Through good DevOps practices, it's possible to realize the advantages of cloud-native applications without suffocating under a mountain of work actually operating the applications.</span></span>

<span data-ttu-id="3d892-127">DevOps 时，不会有任何黄金 hammer。</span><span class="sxs-lookup"><span data-stu-id="3d892-127">There's no golden hammer when it comes to DevOps.</span></span> <span data-ttu-id="3d892-128">任何人都不能销售完整且全面的解决方案，用于发布和运行高质量的应用程序。</span><span class="sxs-lookup"><span data-stu-id="3d892-128">Nobody can sell a complete and all-encompassing solution for releasing and operating high-quality applications.</span></span> <span data-ttu-id="3d892-129">这是因为每个应用程序与其他应用程序完全不同。</span><span class="sxs-lookup"><span data-stu-id="3d892-129">This is because each application is wildly different from all others.</span></span> <span data-ttu-id="3d892-130">不过，有一些工具可以使 DevOps 的意义更少。</span><span class="sxs-lookup"><span data-stu-id="3d892-130">However, there are tools that can make DevOps a far less daunting proposition.</span></span> <span data-ttu-id="3d892-131">其中一种工具称为 Azure DevOps。</span><span class="sxs-lookup"><span data-stu-id="3d892-131">One of these tools is known as Azure DevOps.</span></span>

## <a name="azure-devops"></a><span data-ttu-id="3d892-132">Azure DevOps</span><span class="sxs-lookup"><span data-stu-id="3d892-132">Azure DevOps</span></span>

<span data-ttu-id="3d892-133">Azure DevOps 的 pedigree 较长。</span><span class="sxs-lookup"><span data-stu-id="3d892-133">Azure DevOps has a long pedigree.</span></span> <span data-ttu-id="3d892-134">当 Team Foundation Server 首次移动并通过各种名称更改： Visual Studio Online 和 Visual Studio Team Services 时，它可以将其根追溯回。</span><span class="sxs-lookup"><span data-stu-id="3d892-134">It can trace its roots back to when Team Foundation Server first moved online and through the various name changes: Visual Studio Online and Visual Studio Team Services.</span></span> <span data-ttu-id="3d892-135">不过，多年来，它远远超出了其前置任务。</span><span class="sxs-lookup"><span data-stu-id="3d892-135">Through the years, however, it has become far more than its predecessors.</span></span>

<span data-ttu-id="3d892-136">Azure DevOps 分为五个主要组件：</span><span class="sxs-lookup"><span data-stu-id="3d892-136">Azure DevOps is divided into five major components:</span></span>

![图 10-2 Azure DevOps 的五个主要区域](./media/devops-components.png)

<span data-ttu-id="3d892-138">**图 10-2** -Azure DevOps。</span><span class="sxs-lookup"><span data-stu-id="3d892-138">**Figure 10-2** - Azure DevOps.</span></span>

<span data-ttu-id="3d892-139">**Azure Repos**源代码管理，支持古老 TEAM FOUNDATION 版本控制（TFVC）和业界喜爱的[Git](https://en.wikipedia.org/wiki/Git)。</span><span class="sxs-lookup"><span data-stu-id="3d892-139">**Azure Repos** - Source code management that supports the venerable Team Foundation Version Control (TFVC) and the industry favorite [Git](https://en.wikipedia.org/wiki/Git).</span></span> <span data-ttu-id="3d892-140">拉取请求提供了一种方法来实现社交编码，方法是在进行更改时对其进行讨论。</span><span class="sxs-lookup"><span data-stu-id="3d892-140">Pull requests provide a way to enable social coding by fostering discussion of changes as they're made.</span></span>

<span data-ttu-id="3d892-141">**Azure Boards** -提供一个问题和工作项跟踪工具，旨在允许用户选择最适合自己的工作流。</span><span class="sxs-lookup"><span data-stu-id="3d892-141">**Azure Boards** - Provides an issue and work item tracking tool that strives to allow users to pick the workflows that work best for them.</span></span> <span data-ttu-id="3d892-142">它附带多个预先配置的模板，其中包括用于支持 SCRUM 和看板开发样式的模板。</span><span class="sxs-lookup"><span data-stu-id="3d892-142">It comes with a number of pre-configured templates including ones to support SCRUM and Kanban styles of development.</span></span>

<span data-ttu-id="3d892-143">**Azure Pipelines** -支持与 Azure 紧密集成的生成和发布管理系统。</span><span class="sxs-lookup"><span data-stu-id="3d892-143">**Azure Pipelines** - A build and release management system that supports tight integration with Azure.</span></span> <span data-ttu-id="3d892-144">可从 Windows 到 Linux 的各种平台上运行生成到 MacOS。</span><span class="sxs-lookup"><span data-stu-id="3d892-144">Builds can be run on a variety of platforms from Windows to Linux to MacOS.</span></span> <span data-ttu-id="3d892-145">可以在云中或本地预配生成代理。</span><span class="sxs-lookup"><span data-stu-id="3d892-145">Build agents may be provisioned in the cloud or on-premises.</span></span>

<span data-ttu-id="3d892-146">**Azure Test Plans** -通过 Test Plans 功能提供的测试管理和探索性测试支持，不会留下 QA 人员。</span><span class="sxs-lookup"><span data-stu-id="3d892-146">**Azure Test Plans** - No QA person will be left behind with the test management and exploratory testing support offered by the Test Plans feature.</span></span>

<span data-ttu-id="3d892-147">**Azure Artifacts** -一个项目源，允许公司创建其自己的、内部、版本的 NuGet、npm 和其他版本。</span><span class="sxs-lookup"><span data-stu-id="3d892-147">**Azure Artifacts** - An artifact feed that allows companies to create their own, internal, versions of NuGet, npm, and others.</span></span> <span data-ttu-id="3d892-148">如果集中式存储库出现故障，则该服务可充当上游包的缓存。</span><span class="sxs-lookup"><span data-stu-id="3d892-148">It serves a double purpose of acting as a cache of upstream packages if there's a failure of a centralized repository.</span></span>

<span data-ttu-id="3d892-149">Azure DevOps 中的顶层组织单位称为 "项目"。</span><span class="sxs-lookup"><span data-stu-id="3d892-149">The top-level organizational unit in Azure DevOps is known as a Project.</span></span> <span data-ttu-id="3d892-150">在每个项目中，可以打开和关闭各种组件，如 Azure Artifacts。</span><span class="sxs-lookup"><span data-stu-id="3d892-150">Within each project the various components, such as Azure Artifacts, can be turned on and off.</span></span> <span data-ttu-id="3d892-151">其中每个组件都为云本机应用程序提供不同的优点。</span><span class="sxs-lookup"><span data-stu-id="3d892-151">Each of these components provides different advantages for cloud-native applications.</span></span> <span data-ttu-id="3d892-152">最有用的三个是存储库、板和管道。</span><span class="sxs-lookup"><span data-stu-id="3d892-152">The three most useful are repositories, boards, and pipelines.</span></span> <span data-ttu-id="3d892-153">如果用户想要在其他存储库堆栈（例如 GitHub）中管理其源代码，但仍要充分利用 Azure Pipelines 和其他组件，这是完全可能的。</span><span class="sxs-lookup"><span data-stu-id="3d892-153">If users want to manage their source code in another repository stack, such as GitHub, but still take advantage of Azure Pipelines and other components, that's perfectly possible.</span></span>

<span data-ttu-id="3d892-154">幸运的是，开发团队在选择存储库时有很多选项。</span><span class="sxs-lookup"><span data-stu-id="3d892-154">Fortunately, development teams have many options when selecting a repository.</span></span> <span data-ttu-id="3d892-155">其中一个是 GitHub。</span><span class="sxs-lookup"><span data-stu-id="3d892-155">One of them is GitHub.</span></span>

## <a name="github-actions"></a><span data-ttu-id="3d892-156">GitHub 操作</span><span class="sxs-lookup"><span data-stu-id="3d892-156">GitHub Actions</span></span>

<span data-ttu-id="3d892-157">GitHub 采用2009，是一种广泛流行的基于 web 的存储库，用于承载项目、文档和代码。</span><span class="sxs-lookup"><span data-stu-id="3d892-157">Founded in 2009, GitHub is a widely popular web-based repository for hosting projects, documentation, and code.</span></span> <span data-ttu-id="3d892-158">许多大型技术公司（如 Apple、Amazon、Google 和主流公司）都使用 GitHub。</span><span class="sxs-lookup"><span data-stu-id="3d892-158">Many large tech companies, such as Apple, Amazon, Google, and mainstream corporations use GitHub.</span></span> <span data-ttu-id="3d892-159">GitHub 使用名为 Git 的开源分布式版本控制系统作为其基础。</span><span class="sxs-lookup"><span data-stu-id="3d892-159">GitHub uses the open-source, distributed version control system named Git as its foundation.</span></span> <span data-ttu-id="3d892-160">然后，它将添加自己的一组功能，包括缺陷跟踪、功能和拉取请求、任务管理和每个基本代码的 wiki。</span><span class="sxs-lookup"><span data-stu-id="3d892-160">On top, it then adds its own set of features, including defect tracking, feature and pull requests, tasks management, and wikis for each code base.</span></span>

<span data-ttu-id="3d892-161">当 GitHub 发展时，还会添加 DevOps 功能。</span><span class="sxs-lookup"><span data-stu-id="3d892-161">As GitHub evolves, it too is adding DevOps features.</span></span> <span data-ttu-id="3d892-162">例如，GitHub 有自己的持续集成/持续交付（CI/CD）管道，称为 `GitHub Actions` 。</span><span class="sxs-lookup"><span data-stu-id="3d892-162">For example, GitHub has its own continuous integration/continuous delivery (CI/CD) pipeline, called `GitHub Actions`.</span></span> <span data-ttu-id="3d892-163">GitHub 操作是一个社区支持的工作流自动化工具。</span><span class="sxs-lookup"><span data-stu-id="3d892-163">GitHub Actions is a community-powered workflow automation tool.</span></span> <span data-ttu-id="3d892-164">它可让 DevOps 团队与现有工具集成、混合和匹配新产品，以及挂钩到其软件生命周期，包括现有的 CI/CD 合作伙伴。 "</span><span class="sxs-lookup"><span data-stu-id="3d892-164">It lets DevOps teams integrate with their existing tooling, mix and match new products, and hook into their software lifecycle, including existing CI/CD partners."</span></span>

<span data-ttu-id="3d892-165">GitHub 包含40000000多个用户，使其成为世界上最大的源代码宿主。</span><span class="sxs-lookup"><span data-stu-id="3d892-165">GitHub has over 40 million users, making it the largest host of source code in the world.</span></span> <span data-ttu-id="3d892-166">2018年10月，Microsoft 购买的 GitHub。</span><span class="sxs-lookup"><span data-stu-id="3d892-166">In October of 2018, Microsoft purchased GitHub.</span></span> <span data-ttu-id="3d892-167">Microsoft pledged，GitHub 仍将成为任何开发人员可以插入和扩展的[开放平台](https://techcrunch.com/2018/06/04/microsoft-promises-to-keep-github-independent-and-open/)。</span><span class="sxs-lookup"><span data-stu-id="3d892-167">Microsoft has pledged that GitHub will remain an [open platform](https://techcrunch.com/2018/06/04/microsoft-promises-to-keep-github-independent-and-open/) that any developer can plug into and extend.</span></span> <span data-ttu-id="3d892-168">它继续作为独立的公司运行。</span><span class="sxs-lookup"><span data-stu-id="3d892-168">It continues to operate as an independent company.</span></span> <span data-ttu-id="3d892-169">GitHub 提供适用于企业、团队、专业和免费帐户的计划。</span><span class="sxs-lookup"><span data-stu-id="3d892-169">GitHub offers plans for enterprise, team, professional, and free accounts.</span></span>

## <a name="source-control"></a><span data-ttu-id="3d892-170">源代码管理</span><span class="sxs-lookup"><span data-stu-id="3d892-170">Source control</span></span>

<span data-ttu-id="3d892-171">组织云本机应用程序的代码可能会很困难。</span><span class="sxs-lookup"><span data-stu-id="3d892-171">Organizing the code for a cloud-native application can be challenging.</span></span> <span data-ttu-id="3d892-172">云本机应用程序不是单个非常大的应用程序，而是由相互之间相互通信的小型应用程序构成。</span><span class="sxs-lookup"><span data-stu-id="3d892-172">Instead of a single giant application, the cloud-native applications tend to be made up of a web of smaller applications that talk with one another.</span></span> <span data-ttu-id="3d892-173">与计算中的所有情况一样，代码的最佳排列仍是一个开放式问题。</span><span class="sxs-lookup"><span data-stu-id="3d892-173">As with all things in computing, the best arrangement of code remains an open question.</span></span> <span data-ttu-id="3d892-174">使用不同种类的布局时，有成功的应用程序示例，但两个变体看起来最受欢迎。</span><span class="sxs-lookup"><span data-stu-id="3d892-174">There are examples of successful applications using different kinds of layouts, but two variants seem to have the most popularity.</span></span>

<span data-ttu-id="3d892-175">在开始实际源控件之前，可能需要决定适当的项目数量。</span><span class="sxs-lookup"><span data-stu-id="3d892-175">Before getting down into the actual source control itself, it's probably worth deciding on how many projects are appropriate.</span></span> <span data-ttu-id="3d892-176">在单个项目中，支持多个存储库，并生成管道。</span><span class="sxs-lookup"><span data-stu-id="3d892-176">Within a single project, there's support for multiple repositories, and build pipelines.</span></span> <span data-ttu-id="3d892-177">板有点复杂，但在同一项目中，可以轻松地将任务分配给多个团队。</span><span class="sxs-lookup"><span data-stu-id="3d892-177">Boards are a little more complicated, but there too, the tasks can easily be assigned to multiple teams within a single project.</span></span> <span data-ttu-id="3d892-178">可以支持数百个甚至数千个开发人员，而不是单个 Azure DevOps 项目。</span><span class="sxs-lookup"><span data-stu-id="3d892-178">It's possible to support hundreds, even thousands of developers, out of a single Azure DevOps project.</span></span> <span data-ttu-id="3d892-179">这样做可能是最佳方法，因为它为所有开发人员提供了一个单一位置，并减少了开发人员不确定应用程序所驻留的项目时发现该应用程序的混乱程度。</span><span class="sxs-lookup"><span data-stu-id="3d892-179">Doing so is likely the best approach as it provides a single place for all developer to work out of and reduces the confusion of finding that one application when developers are unsure in which project in which it resides.</span></span>

<span data-ttu-id="3d892-180">将微服务的代码拆分到 Azure DevOps 项目中可能会稍微提高难度。</span><span class="sxs-lookup"><span data-stu-id="3d892-180">Splitting up code for microservices within the Azure DevOps project can be slightly more challenging.</span></span>

![图10-3 单个和多个存储库](./media/single-repository-vs-multiple.png)

<span data-ttu-id="3d892-182">**图 10-3** -一个和多个存储库。</span><span class="sxs-lookup"><span data-stu-id="3d892-182">**Figure 10-3** - One vs. many repositories.</span></span>

### <a name="repository-per-microservice"></a><span data-ttu-id="3d892-183">每微服务的存储库</span><span class="sxs-lookup"><span data-stu-id="3d892-183">Repository per microservice</span></span>

<span data-ttu-id="3d892-184">乍一看，这似乎是拆分微服务的源代码的最逻辑方法。</span><span class="sxs-lookup"><span data-stu-id="3d892-184">At first glance, this seems like the most logical approach to splitting up the source code for microservices.</span></span> <span data-ttu-id="3d892-185">每个存储库可以包含生成一个微服务所需的代码。</span><span class="sxs-lookup"><span data-stu-id="3d892-185">Each repository can contain the code needed to build the one microservice.</span></span> <span data-ttu-id="3d892-186">此方法的优点非常明显：</span><span class="sxs-lookup"><span data-stu-id="3d892-186">The advantages to this approach are readily visible:</span></span>

1. <span data-ttu-id="3d892-187">有关生成和维护应用程序的说明可以添加到每个存储库根目录中的自述文件。</span><span class="sxs-lookup"><span data-stu-id="3d892-187">Instructions for building and maintaining the application can be added to a README file at the root of each repository.</span></span> <span data-ttu-id="3d892-188">在浏览存储库时，可以轻松地找到这些说明，缩短开发人员的加速时间。</span><span class="sxs-lookup"><span data-stu-id="3d892-188">When flipping through the repositories, it's easy to find these instructions, reducing spin-up time for developers.</span></span>
2. <span data-ttu-id="3d892-189">每个服务都位于一个逻辑位置，可通过了解服务的名称轻松找到。</span><span class="sxs-lookup"><span data-stu-id="3d892-189">Every service is located in a logical place, easily found by knowing the name of the service.</span></span>
3. <span data-ttu-id="3d892-190">可以轻松地设置生成，以便仅当对所属存储库进行更改时才触发生成。</span><span class="sxs-lookup"><span data-stu-id="3d892-190">Builds can easily be set up such that they're only triggered when a change is made to the owning repository.</span></span>
4. <span data-ttu-id="3d892-191">进入存储库中的更改数量仅限于处理此项目的少数开发人员。</span><span class="sxs-lookup"><span data-stu-id="3d892-191">The number of changes coming into a repository is limited to the small number of developers working on the project.</span></span>
5. <span data-ttu-id="3d892-192">通过限制开发人员拥有读取和写入权限的存储库，可以轻松地设置安全性。</span><span class="sxs-lookup"><span data-stu-id="3d892-192">Security is easy to set up by restricting the repositories to which developers have read and write permissions.</span></span>
6. <span data-ttu-id="3d892-193">所有者组可以更改存储库级别设置，最少与其他人进行讨论。</span><span class="sxs-lookup"><span data-stu-id="3d892-193">Repository level settings can be changed by the owning team with a minimum of discussion with others.</span></span>

<span data-ttu-id="3d892-194">微服务背后的一项重要想法是，服务应该是孤立的，彼此之间是分离的。</span><span class="sxs-lookup"><span data-stu-id="3d892-194">One of the key ideas behind microservices is that services should be siloed and separated from each other.</span></span> <span data-ttu-id="3d892-195">当使用域驱动设计来决定服务的边界时，服务将充当事务边界。</span><span class="sxs-lookup"><span data-stu-id="3d892-195">When using Domain Driven Design to decide on the boundaries for services the services act as transactional boundaries.</span></span> <span data-ttu-id="3d892-196">数据库更新不应跨多个服务。</span><span class="sxs-lookup"><span data-stu-id="3d892-196">Database updates shouldn't span multiple services.</span></span> <span data-ttu-id="3d892-197">此相关数据的集合称为 "边界上下文"。</span><span class="sxs-lookup"><span data-stu-id="3d892-197">This collection of related data is referred to as a bounded context.</span></span>  <span data-ttu-id="3d892-198">这一想法通过将微服务数据隔离到独立的数据库，与服务的其余部分分开。</span><span class="sxs-lookup"><span data-stu-id="3d892-198">This idea is reflected by the isolation of microservice data to a database separate and autonomous from the rest of the services.</span></span> <span data-ttu-id="3d892-199">通过这种方式，您可以很好地将此理念传递到源代码。</span><span class="sxs-lookup"><span data-stu-id="3d892-199">It makes a great deal of sense to carry this idea all the way through to the source code.</span></span>

<span data-ttu-id="3d892-200">但是，这种方法没有什么问题。</span><span class="sxs-lookup"><span data-stu-id="3d892-200">However, this approach isn't without its issues.</span></span> <span data-ttu-id="3d892-201">我们的时间 gnarly 的开发问题之一就是管理依赖项。</span><span class="sxs-lookup"><span data-stu-id="3d892-201">One of the more gnarly development problems of our time is managing dependencies.</span></span> <span data-ttu-id="3d892-202">考虑构成平均目录的文件数 `node_modules` 。</span><span class="sxs-lookup"><span data-stu-id="3d892-202">Consider the number of files that make up the average `node_modules` directory.</span></span> <span data-ttu-id="3d892-203">类似于的全新安装 `create-react-app` 可能会引入上千个包。</span><span class="sxs-lookup"><span data-stu-id="3d892-203">A fresh install of something like `create-react-app` is likely to bring with it thousands of packages.</span></span> <span data-ttu-id="3d892-204">如何管理这些依赖项的问题是一项困难的问题。</span><span class="sxs-lookup"><span data-stu-id="3d892-204">The question of how to manage these dependencies is a difficult one.</span></span>

<span data-ttu-id="3d892-205">如果更新了依赖项，则下游包还必须更新此依赖项。</span><span class="sxs-lookup"><span data-stu-id="3d892-205">If a dependency is updated, then downstream packages must also update this dependency.</span></span> <span data-ttu-id="3d892-206">遗憾的是，这种情况下，使用开发工作会使 `node_modules` 目录的多个版本最终出现在单个包的多个版本中，每个版本都是以略微不同的步调版本化的其他某个包的依赖项。</span><span class="sxs-lookup"><span data-stu-id="3d892-206">Unfortunately, that takes development work so, invariably, the `node_modules` directory ends up with multiple versions of a single package, each one a dependency of some other package that is versioned at a slightly different cadence.</span></span> <span data-ttu-id="3d892-207">部署应用程序时，应使用哪种版本的依赖项？</span><span class="sxs-lookup"><span data-stu-id="3d892-207">When deploying an application, which version of a dependency should be used?</span></span> <span data-ttu-id="3d892-208">当前在生产中的版本？</span><span class="sxs-lookup"><span data-stu-id="3d892-208">The version that is currently in production?</span></span> <span data-ttu-id="3d892-209">当前为 Beta 版本，但在使用者将其投入生产时，它可能处于生产环境中的版本？</span><span class="sxs-lookup"><span data-stu-id="3d892-209">The version that is currently in Beta but is likely to be in production by the time the consumer makes it to production?</span></span> <span data-ttu-id="3d892-210">不只是使用微服务解决的困难问题。</span><span class="sxs-lookup"><span data-stu-id="3d892-210">Difficult problems that aren't resolved by just using microservices.</span></span>

<span data-ttu-id="3d892-211">许多项目都依赖于这些库。</span><span class="sxs-lookup"><span data-stu-id="3d892-211">There are libraries that are depended upon by a wide variety of projects.</span></span> <span data-ttu-id="3d892-212">通过将微服务划分为每个存储库中的一个，可以通过使用内部存储库 Azure Artifacts 来最大程度地解决内部依赖关系。</span><span class="sxs-lookup"><span data-stu-id="3d892-212">By dividing the microservices up with one in each repository the internal dependencies can best be resolved by using the internal repository, Azure Artifacts.</span></span> <span data-ttu-id="3d892-213">库的生成会将其最新版本推送到 Azure Artifacts 以供内部使用。</span><span class="sxs-lookup"><span data-stu-id="3d892-213">Builds for libraries will push their latest versions into Azure Artifacts for internal consumption.</span></span> <span data-ttu-id="3d892-214">还必须手动更新下游项目，才能依赖于新更新的包。</span><span class="sxs-lookup"><span data-stu-id="3d892-214">The downstream project must still be manually updated to take a dependency on the newly updated packages.</span></span>

<span data-ttu-id="3d892-215">当在服务之间移动代码时，另一个缺点会自我呈现。</span><span class="sxs-lookup"><span data-stu-id="3d892-215">Another disadvantage presents itself when moving code between services.</span></span> <span data-ttu-id="3d892-216">尽管将应用程序的第一个部分划分为100% 是微服务的，但实际上很少如此 prescient，因为这样做不会产生任何服务划分错误。</span><span class="sxs-lookup"><span data-stu-id="3d892-216">Although it would be nice to believe that the first division of an application into microservices is 100% correct, the reality is that rarely we're so prescient as to make no service division mistakes.</span></span> <span data-ttu-id="3d892-217">因此，功能和用于驱动它的代码将需要从服务迁移到服务：存储库。</span><span class="sxs-lookup"><span data-stu-id="3d892-217">Thus, functionality and the code that drives it will need to move from service to service: repository to repository.</span></span> <span data-ttu-id="3d892-218">当 leaping 从一个存储库到另一个存储库时，代码就会丢失其历史记录。</span><span class="sxs-lookup"><span data-stu-id="3d892-218">When leaping from one repository to another, the code loses its history.</span></span> <span data-ttu-id="3d892-219">在许多情况下，尤其是在出现审核事件的情况下，对一段代码具有完整历史记录是非常有用的。</span><span class="sxs-lookup"><span data-stu-id="3d892-219">There are many cases, especially in the event of an audit, where having full history on a piece of code is invaluable.</span></span>

<span data-ttu-id="3d892-220">最终和最重要的缺点是协调更改。</span><span class="sxs-lookup"><span data-stu-id="3d892-220">The final and most important disadvantage is coordinating changes.</span></span> <span data-ttu-id="3d892-221">在真正的微服务应用程序中，服务之间不应有部署依赖关系。</span><span class="sxs-lookup"><span data-stu-id="3d892-221">In a true microservices application, there should be no deployment dependencies between services.</span></span> <span data-ttu-id="3d892-222">可以按任何顺序部署服务 A、B 和 C，因为这些服务具有松耦合。</span><span class="sxs-lookup"><span data-stu-id="3d892-222">It should be possible to deploy services A, B, and C in any order as they have loose coupling.</span></span> <span data-ttu-id="3d892-223">但实际上，在某些情况下，需要同时进行跨多个存储库的更改。</span><span class="sxs-lookup"><span data-stu-id="3d892-223">In reality, however, there are times when it's desirable to make a change that crosses multiple repositories at the same time.</span></span> <span data-ttu-id="3d892-224">一些示例包括更新库以关闭安全漏洞或更改所有服务使用的通信协议。</span><span class="sxs-lookup"><span data-stu-id="3d892-224">Some examples include updating a library to close a security hole or changing a communication protocol used by all services.</span></span>

<span data-ttu-id="3d892-225">若要进行跨存储库更改，需要对每个存储库进行提交。</span><span class="sxs-lookup"><span data-stu-id="3d892-225">To do a cross-repository change requires a commit to each repository be made in succession.</span></span> <span data-ttu-id="3d892-226">每个存储库中的每个更改都需要请求并单独查看。</span><span class="sxs-lookup"><span data-stu-id="3d892-226">Each change in each repository will need to be pull-requested and reviewed separately.</span></span> <span data-ttu-id="3d892-227">这可能很难协调。</span><span class="sxs-lookup"><span data-stu-id="3d892-227">This can be difficult to coordinate.</span></span>

<span data-ttu-id="3d892-228">使用多个存储库的另一种方法是将所有源代码放在一个非常简单的、所有已知的单个存储库中。</span><span class="sxs-lookup"><span data-stu-id="3d892-228">An alternative to using many repositories is to put all the source code together in a giant, all knowing, single repository.</span></span>

### <a name="single-repository"></a><span data-ttu-id="3d892-229">单个存储库</span><span class="sxs-lookup"><span data-stu-id="3d892-229">Single repository</span></span>

<span data-ttu-id="3d892-230">在此方法中，有时称为[monorepository](https://danluu.com/monorepo/)，每个服务的所有源代码都置于相同的存储库中。</span><span class="sxs-lookup"><span data-stu-id="3d892-230">In this approach, sometimes referred to as a [monorepository](https://danluu.com/monorepo/), all the source code for every service is put into the same repository.</span></span> <span data-ttu-id="3d892-231">最初，这看起来很可能会使源代码处理变得难以处理。</span><span class="sxs-lookup"><span data-stu-id="3d892-231">At first, this seems like a terrible idea likely to make dealing with source code unwieldy.</span></span> <span data-ttu-id="3d892-232">但有些标记的优点是以这种方式工作。</span><span class="sxs-lookup"><span data-stu-id="3d892-232">There are, however, some marked advantages to working this way.</span></span>

<span data-ttu-id="3d892-233">第一个优点是更易于管理项目之间的依赖关系。</span><span class="sxs-lookup"><span data-stu-id="3d892-233">The first advantage is that it's easier to manage dependencies between projects.</span></span> <span data-ttu-id="3d892-234">项目可以直接导入另一个项目源，而不是依赖于某个外部的项目源。</span><span class="sxs-lookup"><span data-stu-id="3d892-234">Instead of relying on some external artifact feed, projects can directly import one another.</span></span> <span data-ttu-id="3d892-235">这意味着在开发人员工作站上的编译时，可能会发现更新是即时的，并且可能会发现冲突的版本。</span><span class="sxs-lookup"><span data-stu-id="3d892-235">This means that updates are instant, and conflicting versions are likely to be found at compile time on the developer's workstation.</span></span> <span data-ttu-id="3d892-236">实际上，改变了一些集成测试的左侧部分。</span><span class="sxs-lookup"><span data-stu-id="3d892-236">In effect, shifting some of the integration testing left.</span></span>

<span data-ttu-id="3d892-237">在项目间移动代码时，现在可以更轻松地保留历史记录，因为文件将被检测为已移动而不是重新编写。</span><span class="sxs-lookup"><span data-stu-id="3d892-237">When moving code between projects, it's now easier to preserve the history as the files will be detected as having been moved rather than being rewritten.</span></span>

<span data-ttu-id="3d892-238">另一个优点是，跨越服务边界的各种更改都可以在单个提交中进行。</span><span class="sxs-lookup"><span data-stu-id="3d892-238">Another advantage is that wide ranging changes that cross service boundaries can be made in a single commit.</span></span> <span data-ttu-id="3d892-239">这可以减少可能会对多个更改进行单独检查的开销。</span><span class="sxs-lookup"><span data-stu-id="3d892-239">This reduces the overhead of having potentially dozens of changes to review individually.</span></span>

<span data-ttu-id="3d892-240">许多工具都可以对代码执行静态分析，以检测不安全的编程做法或 Api 的问题使用。</span><span class="sxs-lookup"><span data-stu-id="3d892-240">There are many tools that can perform static analysis of code to detect insecure programming practices or problematic use of APIs.</span></span> <span data-ttu-id="3d892-241">在多存储库世界中，需要循环访问每个存储库，以找出其中的问题。</span><span class="sxs-lookup"><span data-stu-id="3d892-241">In a multi-repository world, each repository will need to be iterated over to find the problems in them.</span></span> <span data-ttu-id="3d892-242">单个存储库允许在一个位置运行分析。</span><span class="sxs-lookup"><span data-stu-id="3d892-242">The single repository allows running the analysis all in one place.</span></span>

<span data-ttu-id="3d892-243">单个存储库方法也有很多缺点。</span><span class="sxs-lookup"><span data-stu-id="3d892-243">There are also many disadvantages to the single repository approach.</span></span> <span data-ttu-id="3d892-244">最担心的一点是，只有单个存储库引发了安全问题。</span><span class="sxs-lookup"><span data-stu-id="3d892-244">One of the most worrying ones is that having a single repository raises security concerns.</span></span> <span data-ttu-id="3d892-245">如果存储库中每个服务模型的内容泄漏，则丢失的代码量最小。</span><span class="sxs-lookup"><span data-stu-id="3d892-245">If the contents of a repository are leaked in a repository per service model, the amount of code lost is minimal.</span></span> <span data-ttu-id="3d892-246">使用单个存储库，公司拥有的一切都可能会丢失。</span><span class="sxs-lookup"><span data-stu-id="3d892-246">With a single repository, everything the company owns could be lost.</span></span> <span data-ttu-id="3d892-247">在过去的这种情况下，有很多示例，将整个游戏开发工作。</span><span class="sxs-lookup"><span data-stu-id="3d892-247">There have been many examples in the past of this happening and derailing entire game development efforts.</span></span> <span data-ttu-id="3d892-248">如果有多个存储库公开了较少的外围应用，则这是大多数安全做法中所需的特征。</span><span class="sxs-lookup"><span data-stu-id="3d892-248">Having multiple repositories exposes less surface area, which is a desirable trait in most security practices.</span></span>

<span data-ttu-id="3d892-249">单个存储库的大小可能无法快速进行管理。</span><span class="sxs-lookup"><span data-stu-id="3d892-249">The size of the single repository is likely to become unmanageable rapidly.</span></span> <span data-ttu-id="3d892-250">这会带来一些有趣的性能影响。</span><span class="sxs-lookup"><span data-stu-id="3d892-250">This presents some interesting performance implications.</span></span> <span data-ttu-id="3d892-251">可能需要使用专用的工具（例如[用于 Git 的虚拟文件系统](https://vfsforgit.org/)），这种方法最初旨在改进 Windows 团队开发人员的体验。</span><span class="sxs-lookup"><span data-stu-id="3d892-251">It may become necessary to use specialized tools such as [Virtual File System for Git](https://vfsforgit.org/), which was originally designed to improve the experience for developers on the Windows team.</span></span>

<span data-ttu-id="3d892-252">通常，使用单个存储库的参数会归结为 Facebook 或 Google 使用此方法进行源代码排列的参数。</span><span class="sxs-lookup"><span data-stu-id="3d892-252">Frequently the argument for using a single repository boils down to an argument that Facebook or Google use this method for source code arrangement.</span></span> <span data-ttu-id="3d892-253">如果这种方法对于这些公司来说是足够的，当然，这是适用于所有公司的正确方法。</span><span class="sxs-lookup"><span data-stu-id="3d892-253">If the approach is good enough for these companies, then, surely, it's the correct approach for all companies.</span></span> <span data-ttu-id="3d892-254">这种情况的一个事实是，很少有公司对 Facebook 或 Google 的规模等内容进行操作。</span><span class="sxs-lookup"><span data-stu-id="3d892-254">The truth of the matter is that few companies operate on anything like the scale of Facebook or Google.</span></span> <span data-ttu-id="3d892-255">在这些规模上出现的问题与大多数开发人员将面临的问题不同。</span><span class="sxs-lookup"><span data-stu-id="3d892-255">The problems that occur at those scales are different from those most developers will face.</span></span> <span data-ttu-id="3d892-256">对于看，goose 的好处可能并不好。</span><span class="sxs-lookup"><span data-stu-id="3d892-256">What is good for the goose may not be good for the gander.</span></span>

<span data-ttu-id="3d892-257">最终，可以使用解决方案来托管微服务的源代码。</span><span class="sxs-lookup"><span data-stu-id="3d892-257">In the end, either solution can be used to host the source code for microservices.</span></span> <span data-ttu-id="3d892-258">但在大多数情况下，在单个存储库中运行的管理和工程开销不值得 meager。</span><span class="sxs-lookup"><span data-stu-id="3d892-258">However, in most cases, the management, and engineering overhead of operating in a single repository isn't worth the meager advantages.</span></span> <span data-ttu-id="3d892-259">将代码拆分在多个存储库上有助于更好地分离关注点并鼓励开发团队之间自治。</span><span class="sxs-lookup"><span data-stu-id="3d892-259">Splitting code up over multiple repositories encourages better separation of concerns and encourages autonomy among development teams.</span></span>  

### <a name="standard-directory-structure"></a><span data-ttu-id="3d892-260">标准目录结构</span><span class="sxs-lookup"><span data-stu-id="3d892-260">Standard directory structure</span></span>

<span data-ttu-id="3d892-261">不管是单个还是多个存储库，每个服务都将有自己的目录。</span><span class="sxs-lookup"><span data-stu-id="3d892-261">Regardless of the single versus multiple repositories debate each service will have its own directory.</span></span> <span data-ttu-id="3d892-262">若要使开发人员可以快速地在项目之间进行交互，最佳优化之一就是维护一种标准目录结构。</span><span class="sxs-lookup"><span data-stu-id="3d892-262">One of the best optimizations to allow developers to cross between projects quickly is to maintain a standard directory structure.</span></span>

![图10-4 电子邮件和登录服务的标准目录结构](./media/dir-struct.png)

<span data-ttu-id="3d892-264">**图 10-4** -标准目录结构。</span><span class="sxs-lookup"><span data-stu-id="3d892-264">**Figure 10-4** - Standard directory structure.</span></span>

<span data-ttu-id="3d892-265">每当创建新项目时，都应使用放置正确结构的模板。</span><span class="sxs-lookup"><span data-stu-id="3d892-265">Whenever a new project is created, a template that puts in place the correct structure should be used.</span></span> <span data-ttu-id="3d892-266">此模板还可以将此类有用项包含为框架 README 文件和 `azure-pipelines.yml` 。</span><span class="sxs-lookup"><span data-stu-id="3d892-266">This template can also include such useful items as a skeleton README file and an `azure-pipelines.yml`.</span></span> <span data-ttu-id="3d892-267">在任何微服务的体系结构中，项目之间的差异很高，使得服务的大容量操作更困难。</span><span class="sxs-lookup"><span data-stu-id="3d892-267">In any microservice architecture, a high degree of variance between projects makes bulk operations against the services more difficult.</span></span>

<span data-ttu-id="3d892-268">有许多工具可为整个目录提供模板化，其中包含多个源代码目录。</span><span class="sxs-lookup"><span data-stu-id="3d892-268">There are many tools that can provide templating for an entire directory, containing several source code directories.</span></span> <span data-ttu-id="3d892-269">[Yeoman](https://yeoman.io/)在 JavaScript 领域中很受欢迎，GitHub 最近发布了[存储库模板](https://github.blog/2019-06-06-generate-new-repositories-with-repository-templates/)，它们提供了很多相同的功能。</span><span class="sxs-lookup"><span data-stu-id="3d892-269">[Yeoman](https://yeoman.io/) is popular in the JavaScript world and GitHub have recently released [Repository Templates](https://github.blog/2019-06-06-generate-new-repositories-with-repository-templates/), which provide much of the same functionality.</span></span>

## <a name="task-management"></a><span data-ttu-id="3d892-270">任务管理</span><span class="sxs-lookup"><span data-stu-id="3d892-270">Task management</span></span>

<span data-ttu-id="3d892-271">在任何项目中管理任务都很困难。</span><span class="sxs-lookup"><span data-stu-id="3d892-271">Managing tasks in any project can be difficult.</span></span> <span data-ttu-id="3d892-272">最前面的问题是为了确保开发人员的工作效率，要解决的有关工作流的排序问题。</span><span class="sxs-lookup"><span data-stu-id="3d892-272">Up front there are countless questions to be answered about the sort of workflows to set up to ensure optimal developer productivity.</span></span>

<span data-ttu-id="3d892-273">云本机应用程序通常比传统软件产品更小，或至少将其划分为较小的服务。</span><span class="sxs-lookup"><span data-stu-id="3d892-273">Cloud-native applications tend to be smaller than traditional software products or at least they're divided into smaller services.</span></span> <span data-ttu-id="3d892-274">跟踪与这些服务相关的问题或任务与任何其他软件项目一样重要。</span><span class="sxs-lookup"><span data-stu-id="3d892-274">Tracking of issues or tasks related to these services remains as important as with any other software project.</span></span> <span data-ttu-id="3d892-275">无人希望失去对某些工作项的跟踪，或者向客户说明未正确记录其问题。</span><span class="sxs-lookup"><span data-stu-id="3d892-275">Nobody wants to lose track of some work item or explain to a customer that their issue wasn't properly logged.</span></span> <span data-ttu-id="3d892-276">板在项目级别配置，但在每个项目中都可以定义区域。</span><span class="sxs-lookup"><span data-stu-id="3d892-276">Boards are configured at the project level but within each project, areas can be defined.</span></span> <span data-ttu-id="3d892-277">它们允许跨多个组件打破问题。</span><span class="sxs-lookup"><span data-stu-id="3d892-277">These allow breaking down issues across several components.</span></span> <span data-ttu-id="3d892-278">将整个应用程序的所有工作保存在一个位置的优点是，在更好地理解工作项时，可以轻松地将工作项从一个团队移动到另一个团队。</span><span class="sxs-lookup"><span data-stu-id="3d892-278">The advantage to keeping all the work for the entire application in one place is that it's easy to move work items from one team to another as they're understood better.</span></span>

<span data-ttu-id="3d892-279">Azure DevOps 附带了一些预配置的热门模板。</span><span class="sxs-lookup"><span data-stu-id="3d892-279">Azure DevOps comes with a number of popular templates pre-configured.</span></span> <span data-ttu-id="3d892-280">在最基本的配置中，需要知道的是积压工作（backlog）、用户正在处理的内容以及执行的操作。</span><span class="sxs-lookup"><span data-stu-id="3d892-280">In the most basic configuration, all that is needed to know is what's in the backlog, what people are working on, and what's done.</span></span> <span data-ttu-id="3d892-281">请务必了解构建软件的过程，以便将工作转换为客户的优先级并完成任务。</span><span class="sxs-lookup"><span data-stu-id="3d892-281">It's important to have this visibility into the process of building software, so that work can be prioritized and completed tasks reported to the customer.</span></span> <span data-ttu-id="3d892-282">当然，一些软件项目会坚持使用、和这一过程 `to do` `doing` `done` 。</span><span class="sxs-lookup"><span data-stu-id="3d892-282">Of course, few software projects stick to a process as simple as `to do`, `doing`, and `done`.</span></span> <span data-ttu-id="3d892-283">人们开始向过程中添加步骤并不需要花费很长时间 `QA` `Detailed Specification` 。</span><span class="sxs-lookup"><span data-stu-id="3d892-283">It doesn't take long for people to start adding steps like `QA` or `Detailed Specification` to the process.</span></span>

<span data-ttu-id="3d892-284">敏捷方法的一个更重要的部分是按固定的时间间隔自我自检。</span><span class="sxs-lookup"><span data-stu-id="3d892-284">One of the more important parts of Agile methodologies is self-introspection at regular intervals.</span></span> <span data-ttu-id="3d892-285">这些检查旨在帮助用户了解团队面临的问题以及如何改进。</span><span class="sxs-lookup"><span data-stu-id="3d892-285">These reviews are meant to provide insight into what problems the team is facing and how they can be improved.</span></span> <span data-ttu-id="3d892-286">通常，这意味着通过开发过程更改问题和功能的流动。</span><span class="sxs-lookup"><span data-stu-id="3d892-286">Frequently, this means changing the flow of issues and features through the development process.</span></span> <span data-ttu-id="3d892-287">因此，最好是通过其他阶段展开板的布局。</span><span class="sxs-lookup"><span data-stu-id="3d892-287">So, it's perfectly healthy to expand the layouts of the boards with additional stages.</span></span>

<span data-ttu-id="3d892-288">板中的阶段并不是唯一的组织工具。</span><span class="sxs-lookup"><span data-stu-id="3d892-288">The stages in the boards aren't the only organizational tool.</span></span> <span data-ttu-id="3d892-289">根据板的配置，存在工作项的层次结构。</span><span class="sxs-lookup"><span data-stu-id="3d892-289">Depending on the configuration of the board, there's a hierarchy of work items.</span></span> <span data-ttu-id="3d892-290">看板上可以显示的最精细的项是一项任务。</span><span class="sxs-lookup"><span data-stu-id="3d892-290">The most granular item that can appear on a board is a task.</span></span> <span data-ttu-id="3d892-291">现在，任务包含标题的字段、说明、优先级、剩余工作量的估计值以及链接到其他工作项或开发项（分支、提交、拉取请求、生成等）的功能。</span><span class="sxs-lookup"><span data-stu-id="3d892-291">Out of the box a task contains fields for a title, description, a priority, an estimate of the amount of work remaining and the ability to link to other work items or development items (branches, commits, pull requests, builds, and so forth).</span></span> <span data-ttu-id="3d892-292">工作项可归入应用程序的不同区域和不同迭代（冲刺（sprint）），使其更易于查找。</span><span class="sxs-lookup"><span data-stu-id="3d892-292">Work items can be classified into different areas of the application and different iterations (sprints) to make finding them easier.</span></span>

![图 10-5 Azure DevOps 中的示例任务](./media/task-details.png)

<span data-ttu-id="3d892-294">**图 10-5** -Azure DevOps 中的任务。</span><span class="sxs-lookup"><span data-stu-id="3d892-294">**Figure 10-5** - Task in Azure DevOps.</span></span>

<span data-ttu-id="3d892-295">"说明" 字段支持所需的常规样式（粗体、斜体下划线和删除线）以及插入图像的功能。</span><span class="sxs-lookup"><span data-stu-id="3d892-295">The description field supports the normal styles you'd expect (bold, italic underscore and strike through) and the ability to insert images.</span></span> <span data-ttu-id="3d892-296">这使它成为在指定工作或 bug 时使用的强大工具。</span><span class="sxs-lookup"><span data-stu-id="3d892-296">This makes it a powerful tool for use when specifying work or bugs.</span></span>

<span data-ttu-id="3d892-297">任务可以汇总到功能中，这些功能定义了更大的工作单元。</span><span class="sxs-lookup"><span data-stu-id="3d892-297">Tasks can be rolled up into features, which define a larger unit of work.</span></span> <span data-ttu-id="3d892-298">功能又可以[汇总到长篇故事](https://docs.microsoft.com/azure/devops/boards/backlogs/define-features-epics?view=azure-devops)中。</span><span class="sxs-lookup"><span data-stu-id="3d892-298">Features, in turn, can be [rolled up into epics](https://docs.microsoft.com/azure/devops/boards/backlogs/define-features-epics?view=azure-devops).</span></span> <span data-ttu-id="3d892-299">利用此层次结构中的任务，可以更轻松地了解如何关闭大型功能。</span><span class="sxs-lookup"><span data-stu-id="3d892-299">Classifying tasks in this hierarchy makes it much easier to understand how close a large feature is to rolling out.</span></span>

![图10-6 基本过程模板中默认配置的工作项类型](./media/board-issue-types.png)

<span data-ttu-id="3d892-301">**图 10-6** -Azure DevOps 中的工作项。</span><span class="sxs-lookup"><span data-stu-id="3d892-301">**Figure 10-6** - Work item in Azure DevOps.</span></span>

<span data-ttu-id="3d892-302">Azure Boards 中的问题有不同种类的视图。</span><span class="sxs-lookup"><span data-stu-id="3d892-302">There are different kinds of views into the issues in Azure Boards.</span></span> <span data-ttu-id="3d892-303">尚未计划的项会出现在积压工作（backlog）中。</span><span class="sxs-lookup"><span data-stu-id="3d892-303">Items that aren't yet scheduled appear in the backlog.</span></span> <span data-ttu-id="3d892-304">可以从此处将其分配给冲刺（sprint）。</span><span class="sxs-lookup"><span data-stu-id="3d892-304">From there, they can be assigned to a sprint.</span></span> <span data-ttu-id="3d892-305">冲刺（sprint）是一个时间段，在该时间段内，需要完成一些工作。</span><span class="sxs-lookup"><span data-stu-id="3d892-305">A sprint is a time box during which it's expected some quantity of work will be completed.</span></span> <span data-ttu-id="3d892-306">此工作可以包括任务，还可以包括票证的解析。</span><span class="sxs-lookup"><span data-stu-id="3d892-306">This work can include tasks but also the resolution of tickets.</span></span> <span data-ttu-id="3d892-307">在此之后，可以从冲刺（Sprint）板部分管理整个冲刺（sprint）。</span><span class="sxs-lookup"><span data-stu-id="3d892-307">Once there, the entire sprint can be managed from the Sprint board section.</span></span> <span data-ttu-id="3d892-308">此视图显示了工作的进展情况，并提供了一个刻录图，以在冲刺（sprint）将成功时提供更新的估计值。</span><span class="sxs-lookup"><span data-stu-id="3d892-308">This view shows how work is progressing and includes a burn down chart to give an ever-updating estimate of if the sprint will be successful.</span></span>

![图10-7 定义了冲刺（sprint）的板](./media/sprint-board.png)

<span data-ttu-id="3d892-310">**图 10-7** -Azure DevOps 中的板。</span><span class="sxs-lookup"><span data-stu-id="3d892-310">**Figure 10-7** - Board in Azure DevOps.</span></span>

<span data-ttu-id="3d892-311">到现在为止，Azure DevOps 中的主板有很大的强大功能。</span><span class="sxs-lookup"><span data-stu-id="3d892-311">By now, it should be apparent that there's a great deal of power in the Boards in Azure DevOps.</span></span> <span data-ttu-id="3d892-312">对于开发人员来说，有很简单的视图可用于处理。</span><span class="sxs-lookup"><span data-stu-id="3d892-312">For developers, there are easy views of what is being worked on.</span></span> <span data-ttu-id="3d892-313">供项目经理查看即将到来的工作以及现有工作的概述。</span><span class="sxs-lookup"><span data-stu-id="3d892-313">For project managers views into upcoming work as well as an overview of existing work.</span></span> <span data-ttu-id="3d892-314">对于管理人员，有许多关于管理和容量的报告。</span><span class="sxs-lookup"><span data-stu-id="3d892-314">For managers, there are plenty of reports about resourcing and capacity.</span></span> <span data-ttu-id="3d892-315">遗憾的是，没有神奇的无需跟踪工作的云本机应用程序。</span><span class="sxs-lookup"><span data-stu-id="3d892-315">Unfortunately, there's nothing magical about cloud-native applications that eliminate the need to track work.</span></span> <span data-ttu-id="3d892-316">但如果您必须跟踪工作，则在某些情况下，体验比 Azure DevOps 更好。</span><span class="sxs-lookup"><span data-stu-id="3d892-316">But if you must track work, there are a few places where the experience is better than in Azure DevOps.</span></span>

## <a name="cicd-pipelines"></a><span data-ttu-id="3d892-317">CI/CD 管道</span><span class="sxs-lookup"><span data-stu-id="3d892-317">CI/CD pipelines</span></span>

<span data-ttu-id="3d892-318">除了持续集成（CI）和持续交付（CD）出现，软件开发生命周期中几乎没有任何变化。</span><span class="sxs-lookup"><span data-stu-id="3d892-318">Almost no change in the software development life cycle has been so revolutionary as the advent of continuous integration (CI) and continuous delivery (CD).</span></span> <span data-ttu-id="3d892-319">更改后，将立即针对项目的源代码生成并运行自动测试，并提前捕获错误。</span><span class="sxs-lookup"><span data-stu-id="3d892-319">Building and running automated tests against the source code of a project as soon as a change is checked in catches mistakes early.</span></span> <span data-ttu-id="3d892-320">在持续集成生成的出现之前，从存储库中拉取代码并发现它未通过测试或甚至无法生成。</span><span class="sxs-lookup"><span data-stu-id="3d892-320">Prior to the advent of continuous integration builds, it wouldn't be uncommon to pull code from the repository and find that it didn't pass tests or couldn't even be built.</span></span> <span data-ttu-id="3d892-321">这会导致跟踪破损的源。</span><span class="sxs-lookup"><span data-stu-id="3d892-321">This resulted in tracking down the source of the breakage.</span></span>

<span data-ttu-id="3d892-322">传统上，在生产环境中交付软件需要大量文档和步骤列表。</span><span class="sxs-lookup"><span data-stu-id="3d892-322">Traditionally shipping software to the production environment required extensive documentation and a list of steps.</span></span> <span data-ttu-id="3d892-323">需要手动完成的每个步骤都需要在一个非常容易出错的过程中完成。</span><span class="sxs-lookup"><span data-stu-id="3d892-323">Each one of these steps needed to be manually completed in a very error prone process.</span></span>

![图10-8 清单](./media/checklist.png)

<span data-ttu-id="3d892-325">**图 10-8** -清单。</span><span class="sxs-lookup"><span data-stu-id="3d892-325">**Figure 10-8** - Checklist.</span></span>

<span data-ttu-id="3d892-326">持续集成的备用是持续交付，其中，将在环境中部署全新的生成包。</span><span class="sxs-lookup"><span data-stu-id="3d892-326">The sister of continuous integration is continuous delivery in which the freshly built packages are deployed to an environment.</span></span> <span data-ttu-id="3d892-327">手动过程无法进行缩放以匹配开发速度，因此自动化变得更加重要。</span><span class="sxs-lookup"><span data-stu-id="3d892-327">The manual process can't scale to match the speed of development so automation becomes more important.</span></span> <span data-ttu-id="3d892-328">清单由可以更快、更准确地执行相同任务的脚本替换。</span><span class="sxs-lookup"><span data-stu-id="3d892-328">Checklists are replaced by scripts that can execute the same tasks faster and more accurately than any human.</span></span>

<span data-ttu-id="3d892-329">持续交付交付的环境可能是一个测试环境，也可能是由许多主要技术公司来完成的，它可能是生产环境。</span><span class="sxs-lookup"><span data-stu-id="3d892-329">The environment to which continuous delivery delivers might be a test environment or, as is being done by many major technology companies, it could be the production environment.</span></span> <span data-ttu-id="3d892-330">后者要求对高质量的测试投资，这会使更改不会对用户产生中断。</span><span class="sxs-lookup"><span data-stu-id="3d892-330">The latter requires an investment in high-quality tests that can give confidence that a change isn't going to break production for users.</span></span> <span data-ttu-id="3d892-331">与持续集成在代码早期持续交付中发现问题的方式相同，这是及早捕获部署过程中的问题。</span><span class="sxs-lookup"><span data-stu-id="3d892-331">In the same way that continuous integration caught issues in the code early continuous delivery catches issues in the deployment process early.</span></span>

<span data-ttu-id="3d892-332">自动执行生成和传递过程的重要性由云本机应用程序突出。</span><span class="sxs-lookup"><span data-stu-id="3d892-332">The importance of automating the build and delivery process is accentuated by cloud-native applications.</span></span> <span data-ttu-id="3d892-333">部署发生的频率更高，更多，因此无法在不可能的情况上手动部署边框。</span><span class="sxs-lookup"><span data-stu-id="3d892-333">Deployments happen more frequently and to more environments so manually deploying borders on impossible.</span></span>

### <a name="azure-builds"></a><span data-ttu-id="3d892-334">Azure 版本</span><span class="sxs-lookup"><span data-stu-id="3d892-334">Azure Builds</span></span>

<span data-ttu-id="3d892-335">Azure DevOps 提供了一套工具，使持续集成和部署比以往更容易。</span><span class="sxs-lookup"><span data-stu-id="3d892-335">Azure DevOps provides a set of tools to make continuous integration and deployment easier than ever.</span></span> <span data-ttu-id="3d892-336">这些工具位于 Azure Pipelines 下。</span><span class="sxs-lookup"><span data-stu-id="3d892-336">These tools are located under Azure Pipelines.</span></span> <span data-ttu-id="3d892-337">第一个是 Azure 版本，它是一种用于在规模上运行基于 YAML 的生成定义的工具。</span><span class="sxs-lookup"><span data-stu-id="3d892-337">The first of them is Azure Builds, which is a tool for running YAML-based build definitions at scale.</span></span> <span data-ttu-id="3d892-338">用户可以使用自己的生成计算机（在生成需要精心设置环境时非常有用），也可以从不断刷新的 Azure 托管虚拟机池使用计算机。</span><span class="sxs-lookup"><span data-stu-id="3d892-338">Users can either bring their own build machines (great for if the build requires a meticulously set up environment) or use a machine from a constantly refreshed pool of Azure hosted virtual machines.</span></span> <span data-ttu-id="3d892-339">这些托管生成代理随各种开发工具预安装，不仅适用于 .NET 开发，而且还适用于从 Java 到 Python 到 iPhone 开发的所有内容。</span><span class="sxs-lookup"><span data-stu-id="3d892-339">These hosted build agents come pre-installed with a wide range of development tools for not just .NET development but for everything from Java to Python to iPhone development.</span></span>

<span data-ttu-id="3d892-340">DevOps 包括范围广泛的现成生成定义，可针对任何生成进行自定义。</span><span class="sxs-lookup"><span data-stu-id="3d892-340">DevOps includes a wide range of out of the box build definitions that can be customized for any build.</span></span> <span data-ttu-id="3d892-341">生成定义在名为的文件中定义 `azure-pipelines.yml` ，并签入到存储库中，以便它们可以与源代码一起进行版本控制。</span><span class="sxs-lookup"><span data-stu-id="3d892-341">The build definitions are defined in a file called `azure-pipelines.yml` and checked into the repository so they can be versioned along with the source code.</span></span> <span data-ttu-id="3d892-342">这样就可以更轻松地在分支中对生成管道进行更改，因为可以将更改签入到该分支。</span><span class="sxs-lookup"><span data-stu-id="3d892-342">This makes it much easier to make changes to the build pipeline in a branch as the changes can be checked into just that branch.</span></span> <span data-ttu-id="3d892-343">`azure-pipelines.yml`图10-9 显示了在完整 framework 上构建 ASP.NET web 应用程序的示例。</span><span class="sxs-lookup"><span data-stu-id="3d892-343">An example `azure-pipelines.yml` for building an ASP.NET web application on full framework is show in Figure 10-9.</span></span>

```yml
name: $(rev:r)

variables:
  version: 9.2.0.$(Build.BuildNumber)
  solution: Portals.sln
  artifactName: drop
  buildPlatform: any cpu
  buildConfiguration: release
  
pool:
  name: Hosted VS2017
  demands:
  - msbuild
  - visualstudio
  - vstest

steps:
- task: NuGetToolInstaller@0
  displayName: 'Use NuGet 4.4.1'
  inputs:
    versionSpec: 4.4.1

- task: NuGetCommand@2
  displayName: 'NuGet restore'
  inputs:
    restoreSolution: '$(solution)'

- task: VSBuild@1
  displayName: 'Build solution'
  inputs:
    solution: '$(solution)'
    msbuildArgs: '-p:DeployOnBuild=true -p:WebPublishMethod=Package -p:PackageAsSingleFile=true -p:SkipInvalidConfigurations=true -p:PackageLocation="$(build.artifactstagingdirectory)\\"'
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'

- task: VSTest@2
  displayName: 'Test Assemblies'
  inputs:
    testAssemblyVer2: |
     **\$(buildConfiguration)\**\*test*.dll
     !**\obj\**
     !**\*testadapter.dll
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'

- task: CopyFiles@2
  displayName: 'Copy UI Test Files to: $(build.artifactstagingdirectory)'
  inputs:
    SourceFolder: UITests
    TargetFolder: '$(build.artifactstagingdirectory)/uitests'

- task: PublishBuildArtifacts@1
  displayName: 'Publish Artifact'
  inputs:
    PathtoPublish: '$(build.artifactstagingdirectory)'
    ArtifactName: '$(artifactName)'
  condition: succeededOrFailed()
```

<span data-ttu-id="3d892-344">**图 10-9** -示例 azure-pipelines. docker-compose.override.yml</span><span class="sxs-lookup"><span data-stu-id="3d892-344">**Figure 10-9** - A sample azure-pipelines.yml</span></span>

<span data-ttu-id="3d892-345">此生成定义使用许多内置任务，使创建生成的操作与构建设置（比巨大的 Millennium Falcon 简单）简单。</span><span class="sxs-lookup"><span data-stu-id="3d892-345">This build definition uses a number of built-in tasks that make creating builds as simple as building a Lego set (simpler than the giant Millennium Falcon).</span></span> <span data-ttu-id="3d892-346">例如，NuGet 任务还原 NuGet 包，而 VSBuild 任务调用 Visual Studio 生成工具来执行实际编译。</span><span class="sxs-lookup"><span data-stu-id="3d892-346">For instance, the NuGet task restores NuGet packages, while the VSBuild task calls the Visual Studio build tools to perform the actual compilation.</span></span> <span data-ttu-id="3d892-347">Azure DevOps 中有数百个不同的任务，社区维护了数千个不同的任务。</span><span class="sxs-lookup"><span data-stu-id="3d892-347">There are hundreds of different tasks available in Azure DevOps, with thousands more that are maintained by the community.</span></span> <span data-ttu-id="3d892-348">您可能不知道您想要运行哪些生成任务，而有人已经生成了一个任务。</span><span class="sxs-lookup"><span data-stu-id="3d892-348">It's likely that no matter what build tasks you're looking to run, somebody has built one already.</span></span>

<span data-ttu-id="3d892-349">可以通过签入、计划或完成其他生成来手动触发生成。</span><span class="sxs-lookup"><span data-stu-id="3d892-349">Builds can be triggered manually, by a check-in, on a schedule, or by the completion of another build.</span></span> <span data-ttu-id="3d892-350">在大多数情况下，需要对每个签入进行构建。</span><span class="sxs-lookup"><span data-stu-id="3d892-350">In most cases, building on every check-in is desirable.</span></span> <span data-ttu-id="3d892-351">可以对生成进行筛选，以使不同的生成针对存储库的不同部分或不同的分支运行。</span><span class="sxs-lookup"><span data-stu-id="3d892-351">Builds can be filtered so that different builds run against different parts of the repository or against different branches.</span></span> <span data-ttu-id="3d892-352">这可以实现这样的方案：运行快速生成，减少对拉取请求的测试，并在夜间针对中继运行完整的回归分析套件。</span><span class="sxs-lookup"><span data-stu-id="3d892-352">This allows for scenarios like running fast builds with reduced testing on pull requests and running a full regression suite against the trunk on a nightly basis.</span></span>

<span data-ttu-id="3d892-353">生成的最终结果是一组称为 "生成项目" 的文件。</span><span class="sxs-lookup"><span data-stu-id="3d892-353">The end result of a build is a collection of files known as build artifacts.</span></span> <span data-ttu-id="3d892-354">这些项目可传递到生成过程中的下一步或添加到 Azure 项目源，以便其他生成使用。</span><span class="sxs-lookup"><span data-stu-id="3d892-354">These artifacts can be passed along to the next step in the build process or added to an Azure Artifact feed, so they can be consumed by other builds.</span></span>

### <a name="azure-devops-releases"></a><span data-ttu-id="3d892-355">Azure DevOps 版本</span><span class="sxs-lookup"><span data-stu-id="3d892-355">Azure DevOps releases</span></span>

<span data-ttu-id="3d892-356">构建负责将软件编译到可交付的包中，但仍需要将项目推送到测试环境以完成持续交付。</span><span class="sxs-lookup"><span data-stu-id="3d892-356">Builds take care of compiling the software into a shippable package, but the artifacts still need to be pushed out to a testing environment to complete continuous delivery.</span></span> <span data-ttu-id="3d892-357">为此，Azure DevOps 使用名为 release 的单独工具。</span><span class="sxs-lookup"><span data-stu-id="3d892-357">For this, Azure DevOps uses a separate tool called Releases.</span></span> <span data-ttu-id="3d892-358">版本工具使用的是可用于生成的相同任务库，但引入了 "阶段" 的概念。</span><span class="sxs-lookup"><span data-stu-id="3d892-358">The Releases tool makes use of the same tasks' library that were available to the Build but introduce a concept of "stages".</span></span> <span data-ttu-id="3d892-359">阶段是安装包的隔离环境。</span><span class="sxs-lookup"><span data-stu-id="3d892-359">A stage is an isolated environment into which the package is installed.</span></span> <span data-ttu-id="3d892-360">例如，产品可能使用开发、QA 和生产环境。</span><span class="sxs-lookup"><span data-stu-id="3d892-360">For instance, a product might make use of a development, a QA, and a production environment.</span></span> <span data-ttu-id="3d892-361">代码持续交付到可在其中运行自动测试的开发环境。</span><span class="sxs-lookup"><span data-stu-id="3d892-361">Code is continuously delivered into the development environment where automated tests can be run against it.</span></span> <span data-ttu-id="3d892-362">一旦这些测试通过，版本就会移到 QA 环境进行手动测试。</span><span class="sxs-lookup"><span data-stu-id="3d892-362">Once those tests pass the release moves onto the QA environment for manual testing.</span></span> <span data-ttu-id="3d892-363">最后，将代码推送到生产环境中，其中的每个人都可以看到该代码。</span><span class="sxs-lookup"><span data-stu-id="3d892-363">Finally, the code is pushed to production where it's visible to everybody.</span></span>

![图10-10 使用开发、QA 和生产阶段的示例发布管道](./media/release-pipeline.png)

<span data-ttu-id="3d892-365">**图 10-10** -发布管道</span><span class="sxs-lookup"><span data-stu-id="3d892-365">**Figure 10-10** - Release pipeline</span></span>

<span data-ttu-id="3d892-366">生成中的每个阶段都可以在上一阶段完成后自动触发。</span><span class="sxs-lookup"><span data-stu-id="3d892-366">Each stage in the build can be automatically triggered by the completion of the previous phase.</span></span> <span data-ttu-id="3d892-367">但在许多情况下，这并不是理想的做法。</span><span class="sxs-lookup"><span data-stu-id="3d892-367">In many cases, however, this isn't desirable.</span></span> <span data-ttu-id="3d892-368">将代码移动到生产中可能需要对他人的批准。</span><span class="sxs-lookup"><span data-stu-id="3d892-368">Moving code into production might require approval from somebody.</span></span> <span data-ttu-id="3d892-369">版本工具通过在发布管道的每个步骤允许审批者来支持此操作。</span><span class="sxs-lookup"><span data-stu-id="3d892-369">The Releases tool supports this by allowing approvers at each step of the release pipeline.</span></span> <span data-ttu-id="3d892-370">可以设置规则，以便特定人员或人员组在发布到生产环境之前，必须在发布上注销。</span><span class="sxs-lookup"><span data-stu-id="3d892-370">Rules can be set up such that a specific person or group of people must sign off on a release before it makes into production.</span></span> <span data-ttu-id="3d892-371">这些入口允许进行手动质量检查，还可满足任何与控制生产环境相关的法规要求。</span><span class="sxs-lookup"><span data-stu-id="3d892-371">These gates allow for manual quality checks and also for compliance with any regulatory requirements related to control what goes into production.</span></span>

### <a name="everybody-gets-a-build-pipeline"></a><span data-ttu-id="3d892-372">每个人获取生成管道</span><span class="sxs-lookup"><span data-stu-id="3d892-372">Everybody gets a build pipeline</span></span>

<span data-ttu-id="3d892-373">配置多个生成管道并无开销，因此，每个微服务至少有一个生成管道。</span><span class="sxs-lookup"><span data-stu-id="3d892-373">There's no cost to configuring many build pipelines, so it's advantageous to have at least one build pipeline per microservice.</span></span> <span data-ttu-id="3d892-374">理想情况下，微服务可独立部署到任何环境，因此，每个环境都可以通过自己的管道释放，而不会产生大量无关的代码。</span><span class="sxs-lookup"><span data-stu-id="3d892-374">Ideally, microservices are independently deployable to any environment so having each one able to be released via its own pipeline without releasing a mass of unrelated code is perfect.</span></span> <span data-ttu-id="3d892-375">每个管道都可以有自己的一组审批，使每个服务的生成过程变体变体。</span><span class="sxs-lookup"><span data-stu-id="3d892-375">Each pipeline can have its own set of approvals allowing for variations in build process for each service.</span></span>

### <a name="versioning-releases"></a><span data-ttu-id="3d892-376">版本控制</span><span class="sxs-lookup"><span data-stu-id="3d892-376">Versioning releases</span></span>

<span data-ttu-id="3d892-377">使用发布功能的一个缺点是它无法在签入的文件中定义 `azure-pipelines.yml` 。</span><span class="sxs-lookup"><span data-stu-id="3d892-377">One drawback to using the Releases functionality is that it can't be defined in a checked-in `azure-pipelines.yml` file.</span></span> <span data-ttu-id="3d892-378">出于许多原因，你可能想要执行此操作，因为有多个分支版本定义可将发布主干添加到项目模板中。</span><span class="sxs-lookup"><span data-stu-id="3d892-378">There are many reasons you might want to do that from having per-branch release definitions to including a release skeleton in your project template.</span></span> <span data-ttu-id="3d892-379">幸运的是，工作正在努力将部分支持转移到生成组件。</span><span class="sxs-lookup"><span data-stu-id="3d892-379">Fortunately, work is ongoing to shift some of the stages support into the Build component.</span></span> <span data-ttu-id="3d892-380">这会被称为多阶段生成，而[第一版现在可用](https://devblogs.microsoft.com/devops/whats-new-with-azure-pipelines/)！</span><span class="sxs-lookup"><span data-stu-id="3d892-380">This will be known as multi-stage build and the [first version is available now](https://devblogs.microsoft.com/devops/whats-new-with-azure-pipelines/)!</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="3d892-381">[上一页](azure-security.md)
>[下一页](feature-flags.md)</span><span class="sxs-lookup"><span data-stu-id="3d892-381">[Previous](azure-security.md)
[Next](feature-flags.md)</span></span>
