---
title: 每微服务一个数据库
description: 整体和云本机应用程序中的数据存储对比。
author: robvet
ms.date: 01/22/2020
ms.openlocfilehash: e472309d3dc815070fc2d2c220bf4fe00b8c29ae
ms.sourcegitcommit: 13e79efdbd589cad6b1de634f5d6b1262b12ab01
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/28/2020
ms.locfileid: "76795061"
---
# <a name="database-per-microservice"></a><span data-ttu-id="806c8-103">每微服务一个数据库</span><span class="sxs-lookup"><span data-stu-id="806c8-103">Database-per-microservice</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="806c8-104">正如我们在本书中看到的那样，云本机方法会改变设计、部署和管理应用程序的方式。</span><span class="sxs-lookup"><span data-stu-id="806c8-104">As we've seen throughout this book, a cloud-native approach changes the way you design, deploy, and manage applications.</span></span> <span data-ttu-id="806c8-105">它还更改了管理和存储数据的方式。</span><span class="sxs-lookup"><span data-stu-id="806c8-105">It also changes the way you manage and store data.</span></span>

<span data-ttu-id="806c8-106">图5-1 对比不同之处。</span><span class="sxs-lookup"><span data-stu-id="806c8-106">Figure 5-1 contrasts the differences.</span></span>

![云本机应用程序中的数据存储](./media/distributed-data.png)

<span data-ttu-id="806c8-108">**图 5-1**。</span><span class="sxs-lookup"><span data-stu-id="806c8-108">**Figure 5-1**.</span></span> <span data-ttu-id="806c8-109">云中的数据管理-本机应用程序</span><span class="sxs-lookup"><span data-stu-id="806c8-109">Data management in cloud-native applications</span></span>

<span data-ttu-id="806c8-110">经验丰富的开发人员可以轻松地识别出图5-1 左侧的体系结构。</span><span class="sxs-lookup"><span data-stu-id="806c8-110">Experienced developers will easily recognize the architecture on the left-side of figure 5-1.</span></span> <span data-ttu-id="806c8-111">在此*单一应用程序*中，业务服务组件归置在一个共享服务层中，共享单个关系数据库中的数据。</span><span class="sxs-lookup"><span data-stu-id="806c8-111">In this *monolithic application*, business service components collocate together in a shared services tier, sharing data from a single relational database.</span></span>

<span data-ttu-id="806c8-112">在许多方面，单一数据库将数据管理保持简单。</span><span class="sxs-lookup"><span data-stu-id="806c8-112">In many ways, a single database keeps data management simple.</span></span> <span data-ttu-id="806c8-113">跨多个表查询数据非常简单。</span><span class="sxs-lookup"><span data-stu-id="806c8-113">Querying data across multiple tables is straightforward.</span></span> <span data-ttu-id="806c8-114">对数据更新一起或全部回滚。</span><span class="sxs-lookup"><span data-stu-id="806c8-114">Changes to data update together or they all rollback.</span></span> <span data-ttu-id="806c8-115">[ACID 事务](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties)保证了强和即时一致性。</span><span class="sxs-lookup"><span data-stu-id="806c8-115">[ACID transactions](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties) guarantee strong and immediate consistency.</span></span>

<span data-ttu-id="806c8-116">为云本机设计，我们采用不同的方法。</span><span class="sxs-lookup"><span data-stu-id="806c8-116">Designing for cloud-native, we take a different approach.</span></span> <span data-ttu-id="806c8-117">在图5-1 的右侧，请注意企业功能如何分隔开来到小型、独立的微服务中。</span><span class="sxs-lookup"><span data-stu-id="806c8-117">On the right-side of Figure 5-1, note how business functionality segregates into small, independent microservices.</span></span> <span data-ttu-id="806c8-118">每个微服务都封装了特定的业务功能及其自身的数据。</span><span class="sxs-lookup"><span data-stu-id="806c8-118">Each microservice encapsulates a specific business capability and its own data.</span></span> <span data-ttu-id="806c8-119">单一数据库分解到分布式数据模型中，其中包含许多较小的数据库，每个数据库都与微服务对齐。</span><span class="sxs-lookup"><span data-stu-id="806c8-119">The monolithic database decomposes into a distributed data model with many smaller databases, each aligning with a microservice.</span></span> <span data-ttu-id="806c8-120">冒烟清除时，会出现一个*按微服务公开数据库*的设计。</span><span class="sxs-lookup"><span data-stu-id="806c8-120">When the smoke clears, we emerge with a design that exposes a *database per microservice*.</span></span>

## <a name="why"></a><span data-ttu-id="806c8-121">为什么?</span><span class="sxs-lookup"><span data-stu-id="806c8-121">Why?</span></span>

<span data-ttu-id="806c8-122">此数据库的每个微服务都有很多好处，特别是对于必须迅速发展并支持大规模扩展的系统。</span><span class="sxs-lookup"><span data-stu-id="806c8-122">This database per microservice provides many benefits, especially for systems that must evolve rapidly and support massive scale.</span></span> <span data-ttu-id="806c8-123">具有此模型 。</span><span class="sxs-lookup"><span data-stu-id="806c8-123">With this model...</span></span>

- <span data-ttu-id="806c8-124">域数据封装在服务中</span><span class="sxs-lookup"><span data-stu-id="806c8-124">Domain data is encapsulated within the service</span></span>
- <span data-ttu-id="806c8-125">数据架构可在不直接影响其他服务的情况下进行发展</span><span class="sxs-lookup"><span data-stu-id="806c8-125">Data schema can evolve without directly impacting other services</span></span>
- <span data-ttu-id="806c8-126">每个数据存储可以独立缩放</span><span class="sxs-lookup"><span data-stu-id="806c8-126">Each data store can independently scale</span></span>
- <span data-ttu-id="806c8-127">一项服务中的数据存储故障不会直接影响其他服务</span><span class="sxs-lookup"><span data-stu-id="806c8-127">A data store failure in one service won't directly impact other services</span></span>

<span data-ttu-id="806c8-128">分离数据还允许每个微服务实现最适合其工作负荷、存储需求和读/写模式的数据存储类型。</span><span class="sxs-lookup"><span data-stu-id="806c8-128">Segregating data also enables each microservice to implement the data store type that is best optimized for its workload, storage needs, and read/write patterns.</span></span> <span data-ttu-id="806c8-129">选项包括关系、文档、键-值甚至基于图形的数据存储区。</span><span class="sxs-lookup"><span data-stu-id="806c8-129">Choices include relational, document, key-value, and even graph-based data stores.</span></span>

<span data-ttu-id="806c8-130">图5-2 显示了云本机系统中 polyglot 持久性的原则。</span><span class="sxs-lookup"><span data-stu-id="806c8-130">Figure 5-2 presents the principle of polyglot persistence in a cloud-native system.</span></span>

![Polyglot 数据暂留](./media/polyglot-data-persistence.png)

<span data-ttu-id="806c8-132">**图 5-2**。</span><span class="sxs-lookup"><span data-stu-id="806c8-132">**Figure 5-2**.</span></span> <span data-ttu-id="806c8-133">Polyglot 数据暂留</span><span class="sxs-lookup"><span data-stu-id="806c8-133">Polyglot data persistence</span></span>

<span data-ttu-id="806c8-134">请注意，上图中的每个微服务如何支持不同类型的数据存储。</span><span class="sxs-lookup"><span data-stu-id="806c8-134">Note in the previous figure how each microservice supports a different type of data store.</span></span>

- <span data-ttu-id="806c8-135">产品目录微服务使用关系数据库来容纳其基础数据的丰富关系结构。</span><span class="sxs-lookup"><span data-stu-id="806c8-135">The product catalog microservice consumes a relational database to accommodate the rich relational structure of its underlying data.</span></span>
- <span data-ttu-id="806c8-136">购物车微服务使用一种分布式缓存，该缓存支持其简单的键-值数据存储。</span><span class="sxs-lookup"><span data-stu-id="806c8-136">The shopping cart microservice consumes a distributed cache that supports its simple, key-value data store.</span></span>
- <span data-ttu-id="806c8-137">排序微服务同时使用 NoSql 文档数据库来执行写入操作，同时使用高度非规范化的键/值存储来容纳大量读取操作。</span><span class="sxs-lookup"><span data-stu-id="806c8-137">The ordering microservice consumes both a NoSql document database for write operations along with a highly denormalized key/value store to accommodate high-volumes of read operations.</span></span>
  
<span data-ttu-id="806c8-138">尽管关系数据库仍适用于使用复杂数据的微服务，但 NoSQL 数据库已经获得了相当多的普及。</span><span class="sxs-lookup"><span data-stu-id="806c8-138">While relational databases remain relevant for microservices with complex data, NoSQL databases have gained considerable popularity.</span></span> <span data-ttu-id="806c8-139">它们提供巨大的规模和高可用性。</span><span class="sxs-lookup"><span data-stu-id="806c8-139">They provide massive scale and high availability.</span></span> <span data-ttu-id="806c8-140">它们的无架构性质使开发人员可以从类型化的数据类和 Orm 的体系结构中消失，这会使更改成本高昂且非常耗时。</span><span class="sxs-lookup"><span data-stu-id="806c8-140">Their schemaless nature allows developers to move away from an architecture of typed data classes and ORMs that make change expensive and time-consuming.</span></span> <span data-ttu-id="806c8-141">本章稍后将介绍 NoSQL 数据库。</span><span class="sxs-lookup"><span data-stu-id="806c8-141">We cover NoSQL databases later in this chapter.</span></span>

 <span data-ttu-id="806c8-142">虽然将数据封装到单独的微服务可以提高灵活性、性能和可伸缩性，但也会带来许多挑战。</span><span class="sxs-lookup"><span data-stu-id="806c8-142">While encapsulating  data into separate microservices can increase agility, performance, and scalability, it also presents many challenges.</span></span> <span data-ttu-id="806c8-143">在下一部分中，我们将讨论这些挑战以及模式和实践，以帮助解决这些问题。</span><span class="sxs-lookup"><span data-stu-id="806c8-143">In the next section, we discuss these challenges along with patterns and practices to help overcome them.</span></span>  

## <a name="cross-service-queries"></a><span data-ttu-id="806c8-144">跨服务查询</span><span class="sxs-lookup"><span data-stu-id="806c8-144">Cross-service queries</span></span>

<span data-ttu-id="806c8-145">尽管微服务是独立的，并且侧重于特定功能功能（如库存、发货或排序），但它们常常需要与其他微服务集成。</span><span class="sxs-lookup"><span data-stu-id="806c8-145">While microservices are independent and focus on specific functional capabilities, like inventory, shipping, or ordering, they frequently require integration with other microservices.</span></span> <span data-ttu-id="806c8-146">通常，集成涉及到一个*查询*数据的微服务。</span><span class="sxs-lookup"><span data-stu-id="806c8-146">Often the integration involves one microservice *querying* another for data.</span></span> <span data-ttu-id="806c8-147">图5-3 显示了该方案。</span><span class="sxs-lookup"><span data-stu-id="806c8-147">Figure 5-3 shows the scenario.</span></span>

![跨微服务进行查询](./media/cross-service-query.png)

<span data-ttu-id="806c8-149">**图 5-3**。</span><span class="sxs-lookup"><span data-stu-id="806c8-149">**Figure 5-3**.</span></span> <span data-ttu-id="806c8-150">跨微服务进行查询</span><span class="sxs-lookup"><span data-stu-id="806c8-150">Querying across microservices</span></span>

<span data-ttu-id="806c8-151">在上图中，我们看到一个购物篮微服务，它将商品添加到用户的购物篮中。</span><span class="sxs-lookup"><span data-stu-id="806c8-151">In the preceding figure, we see a shopping basket microservice that adds an item to a user's shopping basket.</span></span> <span data-ttu-id="806c8-152">尽管此微服务的数据存储包含购物篮和行项目数据，但它不会保留产品或定价数据。</span><span class="sxs-lookup"><span data-stu-id="806c8-152">While the data store for this microservice contains basket and line item data, it doesn't maintain product or pricing data.</span></span> <span data-ttu-id="806c8-153">而这些数据项由目录和定价微服务拥有。</span><span class="sxs-lookup"><span data-stu-id="806c8-153">Instead, those data items are owned by the catalog and pricing microservices.</span></span> <span data-ttu-id="806c8-154">这会带来问题。</span><span class="sxs-lookup"><span data-stu-id="806c8-154">This presents a problem.</span></span> <span data-ttu-id="806c8-155">购物篮在其数据库中没有产品或定价数据时，如何微服务将产品添加到用户的购物篮？</span><span class="sxs-lookup"><span data-stu-id="806c8-155">How can the shopping basket microservice add a product to the user's shopping basket when it doesn't have product nor pricing data in its database?</span></span>

<span data-ttu-id="806c8-156">第4章中所述的一个选项是从购物篮到目录和定价微服务的[直接 HTTP 调用](service-to-service-communication.md#queries)。</span><span class="sxs-lookup"><span data-stu-id="806c8-156">One option discussed in Chapter 4 is a [direct HTTP call](service-to-service-communication.md#queries) from the shopping basket to the catalog and pricing microservices.</span></span> <span data-ttu-id="806c8-157">但是，在第4章，我们说同步 HTTP*调用微服务*在一起，从而减少了其独立性并降低了其体系结构的优势。</span><span class="sxs-lookup"><span data-stu-id="806c8-157">However, in chapter 4, we said synchronous HTTP calls *couple* microservices together, reducing their autonomy and diminishing their architectural benefits.</span></span>

<span data-ttu-id="806c8-158">还可以实现请求-答复模式，其中每个服务都有单独的入站和出站队列。</span><span class="sxs-lookup"><span data-stu-id="806c8-158">We could also implement a request-reply pattern with separate inbound and outbound queues for each service.</span></span> <span data-ttu-id="806c8-159">但是，这种模式很复杂，需要进行管道来关联请求和响应消息。</span><span class="sxs-lookup"><span data-stu-id="806c8-159">However, this pattern is complicated and requires plumbing to correlate request and response messages.</span></span>
<span data-ttu-id="806c8-160">尽管这会将后端微服务调用分离，但调用服务仍必须同步等待调用完成。</span><span class="sxs-lookup"><span data-stu-id="806c8-160">While it does decouple the backend microservice calls, the calling service must still synchronously wait for the call to complete.</span></span> <span data-ttu-id="806c8-161">网络拥塞、暂时性故障或过载的微服务，并可能导致长时间运行甚至失败的操作。</span><span class="sxs-lookup"><span data-stu-id="806c8-161">Network congestion, transient faults, or an overloaded microservice and can result in long-running and even failed operations.</span></span>

<span data-ttu-id="806c8-162">相反，删除跨服务依赖项的广泛接受模式是[具体化视图模式](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)，如图5-4 所示。</span><span class="sxs-lookup"><span data-stu-id="806c8-162">Instead, a widely accepted pattern for removing cross-service dependencies is the [Materialized View Pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), shown in Figure 5-4.</span></span>

![具体化视图模式](./media/materialized-view-pattern.png)

<span data-ttu-id="806c8-164">**图 5-4**。</span><span class="sxs-lookup"><span data-stu-id="806c8-164">**Figure 5-4**.</span></span> <span data-ttu-id="806c8-165">具体化视图模式</span><span class="sxs-lookup"><span data-stu-id="806c8-165">Materialized View Pattern</span></span>

<span data-ttu-id="806c8-166">使用此模式，您可以在购物篮服务中放置一个本地数据表（称为*读取模型*）。</span><span class="sxs-lookup"><span data-stu-id="806c8-166">With this pattern, you place a local data table (known as a *read model*) in the shopping basket service.</span></span> <span data-ttu-id="806c8-167">此表包含产品和定价微服务所需的数据的非规范化副本。</span><span class="sxs-lookup"><span data-stu-id="806c8-167">This table contains a denormalized copy of the data needed from the product and pricing microservices.</span></span> <span data-ttu-id="806c8-168">直接将数据复制到购物篮微服务，无需昂贵的跨服务呼叫。</span><span class="sxs-lookup"><span data-stu-id="806c8-168">Copying the data directly into the shopping basket microservice eliminates the need for expensive cross-service calls.</span></span> <span data-ttu-id="806c8-169">利用服务的本地数据，可以提高服务的响应时间和可靠性。</span><span class="sxs-lookup"><span data-stu-id="806c8-169">With the data local to the service, you improve the service's response time and reliability.</span></span> <span data-ttu-id="806c8-170">此外，拥有自己的数据副本使购物篮服务更具弹性。</span><span class="sxs-lookup"><span data-stu-id="806c8-170">Additionally, having its own copy of the data makes the shopping basket service more resilient.</span></span> <span data-ttu-id="806c8-171">如果目录服务不可用，则不会直接影响购物篮服务。</span><span class="sxs-lookup"><span data-stu-id="806c8-171">If the catalog service should become unavailable, it wouldn't directly impact the shopping basket service.</span></span> <span data-ttu-id="806c8-172">购物篮可以继续处理自己的存储中的数据。</span><span class="sxs-lookup"><span data-stu-id="806c8-172">The shopping basket can continue operating with the data from its own store.</span></span> 

<span data-ttu-id="806c8-173">使用此方法时，你的系统中现在已有重复的数据。</span><span class="sxs-lookup"><span data-stu-id="806c8-173">The catch with this approach is that you now have duplicate data in your system.</span></span> <span data-ttu-id="806c8-174">但是，在云本机系统中进行*战略*复制的数据是一种已建立的做法，不会被视为反模式或不良做法。</span><span class="sxs-lookup"><span data-stu-id="806c8-174">However, *strategically* duplicating data in cloud-native systems is an established practice and not considered an anti-pattern, or bad practice.</span></span> <span data-ttu-id="806c8-175">请记住，*一个且仅有一个服务*可以拥有一个数据集，并且拥有其权限。</span><span class="sxs-lookup"><span data-stu-id="806c8-175">Keep in mind that *one and only one service* can own a data set and have authority over it.</span></span> <span data-ttu-id="806c8-176">更新记录的系统时，需要同步读取模型。</span><span class="sxs-lookup"><span data-stu-id="806c8-176">You'll need to synchronize the read models when the system of record is updated.</span></span> <span data-ttu-id="806c8-177">通常通过使用[发布/订阅模式](service-to-service-communication.md#events)的异步消息传送来实现同步，如图5.4 所示。</span><span class="sxs-lookup"><span data-stu-id="806c8-177">Synchronization is typically implemented via asynchronous messaging with a [publish/subscribe pattern](service-to-service-communication.md#events), as shown in Figure 5.4.</span></span>

## <a name="distributed-transactions"></a><span data-ttu-id="806c8-178">分布式事务</span><span class="sxs-lookup"><span data-stu-id="806c8-178">Distributed transactions</span></span>

<span data-ttu-id="806c8-179">当跨微服务查询数据很困难时，跨多个微服务实现事务甚至更加复杂。</span><span class="sxs-lookup"><span data-stu-id="806c8-179">While querying data across microservices is difficult, implementing a transaction across several microservices is even more complex.</span></span> <span data-ttu-id="806c8-180">在不同微服务中跨独立数据源维护数据一致性的固有挑战不能 understated。</span><span class="sxs-lookup"><span data-stu-id="806c8-180">The inherent challenge of maintaining data consistency across independent data sources in different microservices can't be understated.</span></span> <span data-ttu-id="806c8-181">云本机应用程序中缺少分布式事务意味着必须以编程方式管理分布式事务。</span><span class="sxs-lookup"><span data-stu-id="806c8-181">The lack of distributed transactions in cloud-native applications means that you must manage distributed transactions programmatically.</span></span> <span data-ttu-id="806c8-182">从一开始就是，从一开始就是*最终的一致性*。</span><span class="sxs-lookup"><span data-stu-id="806c8-182">You move from a world of *immediate consistency* to that of *eventual consistency*.</span></span>

<span data-ttu-id="806c8-183">图5-5 显示了问题。</span><span class="sxs-lookup"><span data-stu-id="806c8-183">Figure 5-5 shows the problem.</span></span>

![Saga 模式中的事务](./media/saga-transaction-operation.png)

<span data-ttu-id="806c8-185">**图 5-5**。</span><span class="sxs-lookup"><span data-stu-id="806c8-185">**Figure 5-5**.</span></span> <span data-ttu-id="806c8-186">跨微服务实现事务</span><span class="sxs-lookup"><span data-stu-id="806c8-186">Implementing a transaction across microservices</span></span>

<span data-ttu-id="806c8-187">在上图中，五个独立的微服务参与了创建订单的分布式事务。</span><span class="sxs-lookup"><span data-stu-id="806c8-187">In the preceding figure, five independent microservices participate in a distributed transaction that creates an order.</span></span> <span data-ttu-id="806c8-188">每个微服务都维护其自己的数据存储，并为其存储区实现本地事务。</span><span class="sxs-lookup"><span data-stu-id="806c8-188">Each microservice maintains its own data store and implements a local transaction for its store.</span></span> <span data-ttu-id="806c8-189">若要创建顺序，*每个*单独微服务的本地*事务必须成功，否则必须*中止并回滚操作。</span><span class="sxs-lookup"><span data-stu-id="806c8-189">To create the order, the local transaction for *each* individual microservice must succeed, or *all* must abort and roll back the operation.</span></span> <span data-ttu-id="806c8-190">虽然内置事务支持在每个微服务中均可用，但不支持跨所有五个服务的分布式事务，使数据保持一致。</span><span class="sxs-lookup"><span data-stu-id="806c8-190">While built-in transactional support is available inside each of the microservices, there's no support for a distributed transaction that would span across all five services to keep data consistent.</span></span>

<span data-ttu-id="806c8-191">相反，你必须*以编程方式*构造此分布式事务。</span><span class="sxs-lookup"><span data-stu-id="806c8-191">Instead, you must construct this distributed transaction *programmatically*.</span></span>

<span data-ttu-id="806c8-192">用于添加分布式事务支持的常见模式是 Saga 模式。</span><span class="sxs-lookup"><span data-stu-id="806c8-192">A popular pattern for adding distributed transactional support is the Saga pattern.</span></span> <span data-ttu-id="806c8-193">这是通过以编程方式将本地事务组合在一起并按顺序调用每个事务来实现的。</span><span class="sxs-lookup"><span data-stu-id="806c8-193">It's implemented by grouping local transactions together programmatically and sequentially invoking each one.</span></span> <span data-ttu-id="806c8-194">如果任何本地事务失败，Saga 将中止该操作并调用一组[补偿事务](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)。</span><span class="sxs-lookup"><span data-stu-id="806c8-194">If any of the local transactions fail, the Saga aborts the operation and invokes a set of [compensating transactions](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction).</span></span> <span data-ttu-id="806c8-195">补偿事务撤消前面的本地事务所做的更改，并还原数据一致性。</span><span class="sxs-lookup"><span data-stu-id="806c8-195">The compensating transactions undo the changes made by the preceding local transactions and restore data consistency.</span></span> <span data-ttu-id="806c8-196">图5-6 显示了具有 Saga 模式的失败的事务。</span><span class="sxs-lookup"><span data-stu-id="806c8-196">Figure 5-6 shows a failed transaction with the Saga pattern.</span></span>

![在 saga 模式中回滚](./media/saga-rollback-operation.png)

<span data-ttu-id="806c8-198">**图 5-6**。</span><span class="sxs-lookup"><span data-stu-id="806c8-198">**Figure 5-6**.</span></span> <span data-ttu-id="806c8-199">回滚事务</span><span class="sxs-lookup"><span data-stu-id="806c8-199">Rolling back a transaction</span></span>

<span data-ttu-id="806c8-200">在上图中，清单微服务中的*更新清单*操作失败。</span><span class="sxs-lookup"><span data-stu-id="806c8-200">In the previous figure, the *Update Inventory* operation has failed in the Inventory microservice.</span></span> <span data-ttu-id="806c8-201">Saga 调用一组补偿事务（红色）来调整清单计数、取消付款和订单，并将每个微服务的数据返回到一致的状态。</span><span class="sxs-lookup"><span data-stu-id="806c8-201">The Saga invokes a set of compensating transactions (in red) to adjust the inventory counts, cancel the payment and the order, and return the data for each microservice back to a consistent state.</span></span>

<span data-ttu-id="806c8-202">Saga 模式通常编排为一系列相关事件，或作为一组相关命令进行协调。</span><span class="sxs-lookup"><span data-stu-id="806c8-202">Saga patterns are typically choreographed as a series of related events, or orchestrated as a set of related commands.</span></span> <span data-ttu-id="806c8-203">第4章介绍了服务聚合器模式，这种模式会成为协调 saga 实现的基础。</span><span class="sxs-lookup"><span data-stu-id="806c8-203">In Chapter 4, we discussed the service aggregator pattern that would be the foundation for an orchestrated saga implementation.</span></span> <span data-ttu-id="806c8-204">我们还讨论了如何将事件与 Azure 服务总线和 Azure 事件网格主题结合使用，这是编排 saga 实现的基础。</span><span class="sxs-lookup"><span data-stu-id="806c8-204">We also discussed eventing along with Azure Service Bus and Azure Event Grid topics that would be a foundation for a choreographed saga implementation.</span></span>

## <a name="high-volume-data"></a><span data-ttu-id="806c8-205">大容量数据</span><span class="sxs-lookup"><span data-stu-id="806c8-205">High volume data</span></span>

<span data-ttu-id="806c8-206">大型云本机应用程序通常支持大容量数据需求。</span><span class="sxs-lookup"><span data-stu-id="806c8-206">Large cloud-native applications often support high-volume data requirements.</span></span> <span data-ttu-id="806c8-207">在这些情况下，传统的数据存储技术可能会导致瓶颈。</span><span class="sxs-lookup"><span data-stu-id="806c8-207">In these scenarios, traditional data storage techniques can cause bottlenecks.</span></span> <span data-ttu-id="806c8-208">对于大规模部署的复杂系统，命令和查询责任分离（CQRS）和事件源可能会提高应用程序性能。</span><span class="sxs-lookup"><span data-stu-id="806c8-208">For complex systems that deploy on a large scale, both Command and Query Responsibility Segregation (CQRS) and Event Sourcing may improve application performance.</span></span>  

### <a name="cqrs"></a><span data-ttu-id="806c8-209">CQRS</span><span class="sxs-lookup"><span data-stu-id="806c8-209">CQRS</span></span>

<span data-ttu-id="806c8-210">[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs)是一种体系结构模式，有助于最大程度地提高性能、可伸缩性和安全性。</span><span class="sxs-lookup"><span data-stu-id="806c8-210">[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs), is an architectural pattern that can help maximize performance, scalability, and security.</span></span> <span data-ttu-id="806c8-211">此模式分隔从写入数据的操作读取数据的操作。</span><span class="sxs-lookup"><span data-stu-id="806c8-211">The pattern separates operations that read data from those operations that write data.</span></span> 

<span data-ttu-id="806c8-212">对于普通方案，相同的实体模型和数据存储库对象*同时*用于读取和写入操作。</span><span class="sxs-lookup"><span data-stu-id="806c8-212">For normal scenarios, the same entity model and data repository object are used for *both* read and write operations.</span></span>

<span data-ttu-id="806c8-213">但是，在读取和写入时，大容量数据方案可以从单独的模型和数据表中获益。</span><span class="sxs-lookup"><span data-stu-id="806c8-213">However, a high volume data scenario can benefit from separate models and data tables for reads and writes.</span></span> <span data-ttu-id="806c8-214">为了提高性能，读取操作可以查询数据的高度非规范化表示形式，以避免产生昂贵的重复表联接和表锁。</span><span class="sxs-lookup"><span data-stu-id="806c8-214">To improve performance, the read operation could query against a highly denormalized representation of the data to avoid expensive repetitive table joins and table locks.</span></span> <span data-ttu-id="806c8-215">*写入*操作（称为*命令*）会针对保证一致性的数据的完全标准化表示形式进行更新。</span><span class="sxs-lookup"><span data-stu-id="806c8-215">The *write* operation, known as a *command*, would update against a fully normalized representation of the data that would guarantee consistency.</span></span> <span data-ttu-id="806c8-216">然后，需要实现一种机制来使这两种表示形式保持同步。通常，每当修改写入表时，它都会发布一个将修改复制到读取表的事件。</span><span class="sxs-lookup"><span data-stu-id="806c8-216">You then need to implement a mechanism to keep both representations in sync. Typically, whenever the write table is modified, it publishes an event that replicates the modification to the read table.</span></span>

<span data-ttu-id="806c8-217">图5-7 显示了 CQRS 模式的实现。</span><span class="sxs-lookup"><span data-stu-id="806c8-217">Figure 5-7 shows an implementation of the CQRS pattern.</span></span>

![命令和查询责任分离](./media/cqrs-implementation.png)

<span data-ttu-id="806c8-219">**图 5-7**。</span><span class="sxs-lookup"><span data-stu-id="806c8-219">**Figure 5-7**.</span></span> <span data-ttu-id="806c8-220">CQRS 实现</span><span class="sxs-lookup"><span data-stu-id="806c8-220">CQRS implementation</span></span>

<span data-ttu-id="806c8-221">在上图中，实现了单独的命令和查询模型。</span><span class="sxs-lookup"><span data-stu-id="806c8-221">In the previous figure, separate command and query models are implemented.</span></span> <span data-ttu-id="806c8-222">每个数据写入操作都会保存到写存储，然后传播到读取存储。</span><span class="sxs-lookup"><span data-stu-id="806c8-222">Each data write operation is saved to the write store and then propagated to the read store.</span></span> <span data-ttu-id="806c8-223">请密切注意数据传播过程如何以[最终一致性](http://www.cloudcomputingpatterns.org/eventual_consistency/)原则运行。</span><span class="sxs-lookup"><span data-stu-id="806c8-223">Pay close attention to how the data propagation process operates on the principle of [eventual consistency](http://www.cloudcomputingpatterns.org/eventual_consistency/).</span></span> <span data-ttu-id="806c8-224">读取模型最终与写入模型同步，但在此过程中可能会有一些延迟。</span><span class="sxs-lookup"><span data-stu-id="806c8-224">The read model eventually synchronizes with the write model, but there may be some lag in the process.</span></span> <span data-ttu-id="806c8-225">我们将在下一节中介绍最终的一致性。</span><span class="sxs-lookup"><span data-stu-id="806c8-225">We discuss eventual consistency in the next section.</span></span>

<span data-ttu-id="806c8-226">这种分离使读取和写入可以独立缩放。</span><span class="sxs-lookup"><span data-stu-id="806c8-226">This separation enables reads and writes to scale independently.</span></span> <span data-ttu-id="806c8-227">读取操作使用为查询优化的架构，而写入操作使用针对更新进行优化的架构。</span><span class="sxs-lookup"><span data-stu-id="806c8-227">Read operations use a schema optimized for queries, while the writes use a schema optimized for updates.</span></span> <span data-ttu-id="806c8-228">读取查询针对非规范化数据，而复杂业务逻辑可应用于写入模型。</span><span class="sxs-lookup"><span data-stu-id="806c8-228">Read queries go against denormalized data, while complex business logic can be applied to the write model.</span></span> <span data-ttu-id="806c8-229">同样，对写入操作的安全性可能比公开读取操作的安全性更严格。</span><span class="sxs-lookup"><span data-stu-id="806c8-229">As well, you might impose tighter security on write operations than those exposing reads.</span></span>

<span data-ttu-id="806c8-230">实现 CQRS 可以提高云本机服务的应用程序性能。</span><span class="sxs-lookup"><span data-stu-id="806c8-230">Implementing CQRS can improve application performance for cloud-native services.</span></span> <span data-ttu-id="806c8-231">不过，它确实会导致设计更为复杂。</span><span class="sxs-lookup"><span data-stu-id="806c8-231">However, it does result in a more complex design.</span></span> <span data-ttu-id="806c8-232">仔细并策略性地将此原则应用于云本机应用程序中将会从中受益的部分。</span><span class="sxs-lookup"><span data-stu-id="806c8-232">Apply this principle carefully and strategically to those sections of your cloud-native application that will benefit from it.</span></span> <span data-ttu-id="806c8-233">有关 CQRS 的详细信息，请参阅 Microsoft 书籍[.Net 微服务：适用于容器化 .Net 应用程序的体系结构](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns)。</span><span class="sxs-lookup"><span data-stu-id="806c8-233">For more on CQRS, see the Microsoft book [.NET Microservices: Architecture for Containerized .NET Applications](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns).</span></span>

### <a name="event-sourcing"></a><span data-ttu-id="806c8-234">事件来源</span><span class="sxs-lookup"><span data-stu-id="806c8-234">Event sourcing</span></span>

<span data-ttu-id="806c8-235">优化大容量数据方案的另一种方法涉及到[事件来源](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing)。</span><span class="sxs-lookup"><span data-stu-id="806c8-235">Another approach to optimizing high volume data scenarios involves [Event Sourcing](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing).</span></span>

<span data-ttu-id="806c8-236">系统通常存储数据实体的当前状态。</span><span class="sxs-lookup"><span data-stu-id="806c8-236">A system typically stores the current state of a data entity.</span></span> <span data-ttu-id="806c8-237">例如，如果用户更改了其电话号码，则会用新编号更新客户记录。</span><span class="sxs-lookup"><span data-stu-id="806c8-237">If a user changes their phone number, for example, the customer record is updated with the new number.</span></span> <span data-ttu-id="806c8-238">我们始终知道数据实体的当前状态，但每个更新都会覆盖以前的状态。</span><span class="sxs-lookup"><span data-stu-id="806c8-238">We always know the current state of a data entity, but each update overwrites the previous state.</span></span> 

<span data-ttu-id="806c8-239">在大多数情况下，此模型正常工作。</span><span class="sxs-lookup"><span data-stu-id="806c8-239">In most cases, this model works fine.</span></span> <span data-ttu-id="806c8-240">然而，在高容量系统中，事务锁定和频繁更新操作的开销可能会影响数据库性能、响应能力和限制可伸缩性。</span><span class="sxs-lookup"><span data-stu-id="806c8-240">In high volume systems, however, overhead from transactional locking and frequent update operations can impact database performance, responsiveness, and limit scalability.</span></span>

<span data-ttu-id="806c8-241">事件源采用不同的方法来捕获数据。</span><span class="sxs-lookup"><span data-stu-id="806c8-241">Event Sourcing takes a different approach to capturing data.</span></span> <span data-ttu-id="806c8-242">影响数据的每个操作都将持久保存到事件存储区中。</span><span class="sxs-lookup"><span data-stu-id="806c8-242">Each operation that affects data is persisted to an event store.</span></span> <span data-ttu-id="806c8-243">我们不会更新数据记录的状态，而是将每个更改追加到过去事件的顺序列表中-类似于会计师的分类帐。</span><span class="sxs-lookup"><span data-stu-id="806c8-243">Instead of updating the state of a data record, we append each change to a sequential list of past events - similar to an accountant's ledger.</span></span> <span data-ttu-id="806c8-244">事件存储区成为数据的记录系统。</span><span class="sxs-lookup"><span data-stu-id="806c8-244">The Event Store becomes the system of record for the data.</span></span> <span data-ttu-id="806c8-245">它用于在微服务的绑定上下文内传播各种具体化视图。</span><span class="sxs-lookup"><span data-stu-id="806c8-245">It's used to propagate various materialized views within the bounded context of a microservice.</span></span> <span data-ttu-id="806c8-246">图5.8 显示模式。</span><span class="sxs-lookup"><span data-stu-id="806c8-246">Figure 5.8 shows the pattern.</span></span>

![事件来源](./media/event-sourcing.png)

<span data-ttu-id="806c8-248">**图 5-8**。</span><span class="sxs-lookup"><span data-stu-id="806c8-248">**Figure 5-8**.</span></span> <span data-ttu-id="806c8-249">事件来源</span><span class="sxs-lookup"><span data-stu-id="806c8-249">Event Sourcing</span></span>

<span data-ttu-id="806c8-250">在上图中，请注意如何将用户购物车的每个条目（蓝色）附加到基础事件存储。</span><span class="sxs-lookup"><span data-stu-id="806c8-250">In the previous figure, note how each entry (in blue) for a user's shopping cart is appended to an underlying event store.</span></span> <span data-ttu-id="806c8-251">在相邻的具体化视图中，系统将通过重播与每个购物车关联的所有事件来投影当前状态。</span><span class="sxs-lookup"><span data-stu-id="806c8-251">In the adjoining materialized view, the system projects the current state by replaying all the events associated with each shopping cart.</span></span> <span data-ttu-id="806c8-252">然后，将此视图或读取模型公开回 UI。</span><span class="sxs-lookup"><span data-stu-id="806c8-252">This view, or read model, is then exposed back to the UI.</span></span> <span data-ttu-id="806c8-253">事件还可以与外部系统和应用程序集成，或查询以确定实体的当前状态。</span><span class="sxs-lookup"><span data-stu-id="806c8-253">Events can also be integrated with external systems and applications or queried to determine the current state of an entity.</span></span> <span data-ttu-id="806c8-254">利用此方法，你可以保留历史记录。</span><span class="sxs-lookup"><span data-stu-id="806c8-254">With this approach, you maintain history.</span></span> <span data-ttu-id="806c8-255">您不仅知道实体的当前状态，还知道您如何达到此状态。</span><span class="sxs-lookup"><span data-stu-id="806c8-255">You know not only the current state of an entity, but also how you reached this state.</span></span>

<span data-ttu-id="806c8-256">在机械上，事件来源简化了写入模式。</span><span class="sxs-lookup"><span data-stu-id="806c8-256">Mechanically speaking, event sourcing simplifies the write model.</span></span> <span data-ttu-id="806c8-257">没有更新或删除。</span><span class="sxs-lookup"><span data-stu-id="806c8-257">There are no updates or deletes.</span></span> <span data-ttu-id="806c8-258">将每个数据项追加为不可变事件，可最大程度地减少争用、锁定和与关系数据库相关的并发冲突。</span><span class="sxs-lookup"><span data-stu-id="806c8-258">Appending each data entry as an immutable event minimizes contention, locking, and concurrency conflicts associated with relational databases.</span></span> <span data-ttu-id="806c8-259">通过利用具体化视图模式生成读取模型，可以将视图与写入模型分离，并选择最佳数据存储以优化应用程序 UI 的需求。</span><span class="sxs-lookup"><span data-stu-id="806c8-259">Building read models with the materialized view pattern enables you to decouple the view from the write model and choose the best data store to optimize the needs of your application UI.</span></span>

<span data-ttu-id="806c8-260">对于此模式，请考虑直接支持事件源的数据存储。</span><span class="sxs-lookup"><span data-stu-id="806c8-260">For this pattern, consider a data store that directly supports event sourcing.</span></span> <span data-ttu-id="806c8-261">Azure Cosmos DB、MongoDB、Cassandra、CouchDB 和 RavenDB 是良好的候选项。</span><span class="sxs-lookup"><span data-stu-id="806c8-261">Azure Cosmos DB, MongoDB, Cassandra, CouchDB, and RavenDB are good candidates.</span></span>

<span data-ttu-id="806c8-262">与所有模式和技术一样，在需要时实现战略和。</span><span class="sxs-lookup"><span data-stu-id="806c8-262">As with all patterns and technologies, implement strategically and when needed.</span></span> <span data-ttu-id="806c8-263">尽管事件源可以提供更高的性能和可伸缩性，但这会降低复杂性和学习曲线。</span><span class="sxs-lookup"><span data-stu-id="806c8-263">While event sourcing can provide increased performance and scalability, it comes at the expense of complexity and a learning curve.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="806c8-264">[上一页](service-mesh-communication-infrastructure.md)
>[下一页](relational-vs-nosql-data.md)</span><span class="sxs-lookup"><span data-stu-id="806c8-264">[Previous](service-mesh-communication-infrastructure.md)
[Next](relational-vs-nosql-data.md)</span></span>
