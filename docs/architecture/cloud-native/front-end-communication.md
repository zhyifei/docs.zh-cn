---
title: 前端客户端通信
description: 了解前端客户端如何与云本机系统进行通信
author: robvet
ms.date: 05/13/2020
ms.openlocfilehash: 97421e9b90b19c720b1ab0ff8dd1e5f029cba5e4
ms.sourcegitcommit: 27db07ffb26f76912feefba7b884313547410db5
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/19/2020
ms.locfileid: "83614053"
---
# <a name="front-end-client-communication"></a><span data-ttu-id="8fad6-103">前端客户端通信</span><span class="sxs-lookup"><span data-stu-id="8fad6-103">Front-end client communication</span></span>

<span data-ttu-id="8fad6-104">在云本机系统中，前端客户端（移动、web 和桌面应用程序）要求通信通道与独立后端微服务交互。</span><span class="sxs-lookup"><span data-stu-id="8fad6-104">In a cloud-native system, front-end clients (mobile, web, and desktop applications) require a communication channel to interact with independent back-end microservices.</span></span>  

<span data-ttu-id="8fad6-105">有哪些选项？</span><span class="sxs-lookup"><span data-stu-id="8fad6-105">What are the options?</span></span>

<span data-ttu-id="8fad6-106">为简单起见，前端客户端可以直接与后端微服务*通信*，如图4-2 所示。</span><span class="sxs-lookup"><span data-stu-id="8fad6-106">To keep things simple, a front-end client could *directly communicate* with the back-end microservices, shown in Figure 4-2.</span></span>

![直接客户端到服务的通信](./media/direct-client-to-service-communication.png)

<span data-ttu-id="8fad6-108">**图 4-2**。</span><span class="sxs-lookup"><span data-stu-id="8fad6-108">**Figure 4-2.**</span></span> <span data-ttu-id="8fad6-109">直接客户端到服务的通信</span><span class="sxs-lookup"><span data-stu-id="8fad6-109">Direct client to service communication</span></span>

<span data-ttu-id="8fad6-110">使用此方法时，每个微服务都有一个公共终结点，可供前端客户端访问。</span><span class="sxs-lookup"><span data-stu-id="8fad6-110">With this approach, each microservice has a public endpoint that is accessible by front-end clients.</span></span> <span data-ttu-id="8fad6-111">在生产环境中，可以将负载均衡器放在微服务的前面，按比例路由流量。</span><span class="sxs-lookup"><span data-stu-id="8fad6-111">In a production environment, you'd place a load balancer in front of the microservices, routing traffic proportionately.</span></span>

<span data-ttu-id="8fad6-112">虽然实现简单，但仅对简单的微服务应用程序进行直接客户端通信。</span><span class="sxs-lookup"><span data-stu-id="8fad6-112">While simple to implement, direct client communication would be acceptable only for simple microservice applications.</span></span> <span data-ttu-id="8fad6-113">此模式将前端客户端紧密耦合到核心后端服务，从而为一些问题打开门，其中包括：</span><span class="sxs-lookup"><span data-stu-id="8fad6-113">This pattern tightly couples front-end clients to core back-end services, opening the door for a number of problems, including:</span></span>

- <span data-ttu-id="8fad6-114">对后端服务重构的客户端敏感。</span><span class="sxs-lookup"><span data-stu-id="8fad6-114">Client susceptibility to back-end service refactoring.</span></span>
- <span data-ttu-id="8fad6-115">因为核心后端服务直接公开，所以攻击面会更广泛。</span><span class="sxs-lookup"><span data-stu-id="8fad6-115">A wider attack surface as core back-end services are directly exposed.</span></span>
- <span data-ttu-id="8fad6-116">跨每个微服务的交叉切削问题的重复。</span><span class="sxs-lookup"><span data-stu-id="8fad6-116">Duplication of cross-cutting concerns across each microservice.</span></span>
- <span data-ttu-id="8fad6-117">过于复杂的客户端代码-客户端必须跟踪多个终结点并以弹性方式处理故障。</span><span class="sxs-lookup"><span data-stu-id="8fad6-117">Overly complex client code - clients must keep track of multiple endpoints and handle failures in a resilient way.</span></span>

<span data-ttu-id="8fad6-118">相反，广泛接受的云设计模式是在前端应用程序和后端服务之间实现[API 网关服务](../microservices/architect-microservice-container-applications/direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)。</span><span class="sxs-lookup"><span data-stu-id="8fad6-118">Instead, a widely accepted cloud design pattern is to implement an [API Gateway Service](../microservices/architect-microservice-container-applications/direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md) between the front-end applications and back-end services.</span></span> <span data-ttu-id="8fad6-119">模式如图4-3 所示。</span><span class="sxs-lookup"><span data-stu-id="8fad6-119">The pattern is shown in Figure 4-3.</span></span>

![API 网关模式](./media/api-gateway-pattern.png)

<span data-ttu-id="8fad6-121">**图4-3。**</span><span class="sxs-lookup"><span data-stu-id="8fad6-121">**Figure 4-3.**</span></span> <span data-ttu-id="8fad6-122">API 网关模式</span><span class="sxs-lookup"><span data-stu-id="8fad6-122">API gateway pattern</span></span>

<span data-ttu-id="8fad6-123">在上图中，请注意 API 网关服务如何抽象后端核心微服务。</span><span class="sxs-lookup"><span data-stu-id="8fad6-123">In the previous figure, note how the API Gateway service abstracts the back-end core microservices.</span></span> <span data-ttu-id="8fad6-124">作为 web API 实现，它充当*反向代理*，将传入流量路由到内部微服务。</span><span class="sxs-lookup"><span data-stu-id="8fad6-124">Implemented as a web API, it acts as a *reverse proxy*, routing incoming traffic to the internal microservices.</span></span>

<span data-ttu-id="8fad6-125">网关将客户端与内部服务分区和重构隔离开来。</span><span class="sxs-lookup"><span data-stu-id="8fad6-125">The gateway insulates the client from internal service partitioning and refactoring.</span></span> <span data-ttu-id="8fad6-126">如果更改后端服务，则可以在网关上使用它，而无需中断客户端。</span><span class="sxs-lookup"><span data-stu-id="8fad6-126">If you change a back-end service, you accommodate for it in the gateway without breaking the client.</span></span> <span data-ttu-id="8fad6-127">这也是你的第一道防线，用于进行交叉切削关注，如标识、缓存、复原、计量和限制。</span><span class="sxs-lookup"><span data-stu-id="8fad6-127">It's also your first line of defense for cross-cutting concerns, such as identity, caching, resiliency, metering, and throttling.</span></span> <span data-ttu-id="8fad6-128">许多这些交叉切削问题都可以从后端核心服务关闭到网关，简化后端服务。</span><span class="sxs-lookup"><span data-stu-id="8fad6-128">Many of these cross-cutting concerns can be off-loaded from the back-end core services to the gateway, simplifying the back-end services.</span></span>

<span data-ttu-id="8fad6-129">必须小心，使 API 网关保持简单快捷。</span><span class="sxs-lookup"><span data-stu-id="8fad6-129">Care must be taken to keep the API Gateway simple and fast.</span></span> <span data-ttu-id="8fad6-130">通常，业务逻辑会在网关之外。</span><span class="sxs-lookup"><span data-stu-id="8fad6-130">Typically, business logic is kept out of the gateway.</span></span> <span data-ttu-id="8fad6-131">复杂的网关风险成为瓶颈，最终成为单体架构本身。</span><span class="sxs-lookup"><span data-stu-id="8fad6-131">A complex gateway risks becoming a bottleneck and eventually a monolith itself.</span></span> <span data-ttu-id="8fad6-132">较大的系统通常会公开多个 API 网关，并按客户端类型（移动、web、桌面）或后端功能进行分段。</span><span class="sxs-lookup"><span data-stu-id="8fad6-132">Larger systems often expose multiple API Gateways segmented by client type (mobile, web, desktop) or back-end functionality.</span></span> <span data-ttu-id="8fad6-133">前端模式的[后端](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends)提供了实现多个网关的方向。</span><span class="sxs-lookup"><span data-stu-id="8fad6-133">The [Backend for Frontends](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends) pattern provides direction for implementing multiple gateways.</span></span> <span data-ttu-id="8fad6-134">模式如图4-4 所示。</span><span class="sxs-lookup"><span data-stu-id="8fad6-134">The pattern is shown in Figure 4-4.</span></span>

![API 网关模式](./media/backend-for-frontend-pattern.png)

<span data-ttu-id="8fad6-136">**图4-4。**</span><span class="sxs-lookup"><span data-stu-id="8fad6-136">**Figure 4-4.**</span></span> <span data-ttu-id="8fad6-137">前端模式</span><span class="sxs-lookup"><span data-stu-id="8fad6-137">Backend for frontend pattern</span></span>

<span data-ttu-id="8fad6-138">请注意，在上图中，如何将传入流量发送到特定的 API 网关（基于客户端类型）： web、移动或桌面应用。</span><span class="sxs-lookup"><span data-stu-id="8fad6-138">Note in the previous figure how incoming traffic is sent to a specific API gateway - based upon client type: web, mobile, or desktop app.</span></span> <span data-ttu-id="8fad6-139">这种方法非常合理，因为每个设备的功能在外形规格、性能和显示限制方面的差异大不相同。</span><span class="sxs-lookup"><span data-stu-id="8fad6-139">This approach makes sense as the capabilities of each device differ significantly across form factor, performance, and display limitations.</span></span> <span data-ttu-id="8fad6-140">通常，移动应用程序的功能与浏览器或桌面应用程序的功能不同。</span><span class="sxs-lookup"><span data-stu-id="8fad6-140">Typically mobile applications expose less functionality than a browser or desktop applications.</span></span> <span data-ttu-id="8fad6-141">可以对每个网关进行优化，以匹配相应设备的功能和功能。</span><span class="sxs-lookup"><span data-stu-id="8fad6-141">Each gateway can be optimized to match the capabilities and functionality of the corresponding device.</span></span>

<span data-ttu-id="8fad6-142">首先，你可以构建自己的 API 网关服务。</span><span class="sxs-lookup"><span data-stu-id="8fad6-142">To start, you could build your own API Gateway service.</span></span> <span data-ttu-id="8fad6-143">GitHub 快速搜索将提供许多示例。</span><span class="sxs-lookup"><span data-stu-id="8fad6-143">A quick search of GitHub will provide many examples.</span></span> <span data-ttu-id="8fad6-144">但是，有几个框架和商业网关产品可用。</span><span class="sxs-lookup"><span data-stu-id="8fad6-144">However, there are several frameworks and commercial gateway products available.</span></span>

## <a name="ocelot-gateway"></a><span data-ttu-id="8fad6-145">Ocelot 关</span><span class="sxs-lookup"><span data-stu-id="8fad6-145">Ocelot Gateway</span></span>

<span data-ttu-id="8fad6-146">对于简单的 .NET 云本机应用程序，你可能会考虑到[Ocelot 网关](https://github.com/ThreeMammals/Ocelot)。</span><span class="sxs-lookup"><span data-stu-id="8fad6-146">For simple .NET cloud-native applications, you might consider the [Ocelot Gateway](https://github.com/ThreeMammals/Ocelot).</span></span> <span data-ttu-id="8fad6-147">Ocelot 是为 .NET 微服务创建的开源 API 网关，需要在其系统中提供统一的入口点。</span><span class="sxs-lookup"><span data-stu-id="8fad6-147">Ocelot is an Open Source API Gateway created for .NET microservices that require a unified point of entry into their system.</span></span> <span data-ttu-id="8fad6-148">它是轻型、快速、可缩放的。</span><span class="sxs-lookup"><span data-stu-id="8fad6-148">It's lightweight, fast, scalable.</span></span>

<span data-ttu-id="8fad6-149">与任何 API 网关一样，其主要功能是将传入的 HTTP 请求转发到下游服务。</span><span class="sxs-lookup"><span data-stu-id="8fad6-149">Like any API Gateway, its primary functionality is to forward incoming HTTP requests to downstream services.</span></span> <span data-ttu-id="8fad6-150">此外，它还支持 .NET Core 中间件管道中可配置的各种功能。</span><span class="sxs-lookup"><span data-stu-id="8fad6-150">Additionally, it supports a wide variety of capabilities that are configurable in a .NET Core middleware pipeline.</span></span> <span data-ttu-id="8fad6-151">下表中提供了其功能集。</span><span class="sxs-lookup"><span data-stu-id="8fad6-151">Its feature set is presented in following table.</span></span>

|<span data-ttu-id="8fad6-152">Ocelot 功能</span><span class="sxs-lookup"><span data-stu-id="8fad6-152">Ocelot Features</span></span>  | |
| :-------- | :-------- |
| <span data-ttu-id="8fad6-153">路由</span><span class="sxs-lookup"><span data-stu-id="8fad6-153">Routing</span></span> | <span data-ttu-id="8fad6-154">身份验证</span><span class="sxs-lookup"><span data-stu-id="8fad6-154">Authentication</span></span> |
| <span data-ttu-id="8fad6-155">请求聚合</span><span class="sxs-lookup"><span data-stu-id="8fad6-155">Request Aggregation</span></span> | <span data-ttu-id="8fad6-156">授权</span><span class="sxs-lookup"><span data-stu-id="8fad6-156">Authorization</span></span> |
| <span data-ttu-id="8fad6-157">服务发现（带 Consul 和 Eureka）</span><span class="sxs-lookup"><span data-stu-id="8fad6-157">Service Discovery (with Consul and Eureka)</span></span> | <span data-ttu-id="8fad6-158">限制</span><span class="sxs-lookup"><span data-stu-id="8fad6-158">Throttling</span></span> |
| <span data-ttu-id="8fad6-159">负载平衡</span><span class="sxs-lookup"><span data-stu-id="8fad6-159">Load Balancing</span></span> | <span data-ttu-id="8fad6-160">日志记录、跟踪</span><span class="sxs-lookup"><span data-stu-id="8fad6-160">Logging, Tracing</span></span> |
| <span data-ttu-id="8fad6-161">Caching</span><span class="sxs-lookup"><span data-stu-id="8fad6-161">Caching</span></span> | <span data-ttu-id="8fad6-162">标头/查询字符串转换</span><span class="sxs-lookup"><span data-stu-id="8fad6-162">Headers/Query String Transformation</span></span> |
| <span data-ttu-id="8fad6-163">相关传递</span><span class="sxs-lookup"><span data-stu-id="8fad6-163">Correlation Pass-Through</span></span> | <span data-ttu-id="8fad6-164">自定义中间件</span><span class="sxs-lookup"><span data-stu-id="8fad6-164">Custom Middleware</span></span> |
| <span data-ttu-id="8fad6-165">服务质量</span><span class="sxs-lookup"><span data-stu-id="8fad6-165">Quality of Service</span></span> | <span data-ttu-id="8fad6-166">重试策略</span><span class="sxs-lookup"><span data-stu-id="8fad6-166">Retry Policies</span></span> |

<span data-ttu-id="8fad6-167">每个 Ocelot 网关指定 JSON 配置文件中的上游和下游地址和可配置功能。</span><span class="sxs-lookup"><span data-stu-id="8fad6-167">Each Ocelot gateway specifies the upstream and downstream addresses and configurable features in a JSON configuration file.</span></span> <span data-ttu-id="8fad6-168">客户端将 HTTP 请求发送到 Ocelot 网关。</span><span class="sxs-lookup"><span data-stu-id="8fad6-168">The client sends an HTTP request to the Ocelot gateway.</span></span> <span data-ttu-id="8fad6-169">接收后，Ocelot 通过其管道将 HttpRequest 对象传递到其配置所指定的状态。</span><span class="sxs-lookup"><span data-stu-id="8fad6-169">Once received, Ocelot passes the HttpRequest object through its pipeline manipulating it into the state specified by its configuration.</span></span> <span data-ttu-id="8fad6-170">管道结束时，Ocelot 会创建一个新的 HTTPResponseObject，并将其传递给下游服务。</span><span class="sxs-lookup"><span data-stu-id="8fad6-170">At the end of pipeline, Ocelot creates a new HTTPResponseObject and passes it to the downstream service.</span></span> <span data-ttu-id="8fad6-171">对于响应，Ocelot 会反转管道，并将响应发送回客户端。</span><span class="sxs-lookup"><span data-stu-id="8fad6-171">For the response, Ocelot reverses the pipeline, sending the response back to client.</span></span>

<span data-ttu-id="8fad6-172">Ocelot 以 NuGet 包的形式提供。</span><span class="sxs-lookup"><span data-stu-id="8fad6-172">Ocelot is available as a NuGet package.</span></span> <span data-ttu-id="8fad6-173">它以 NET Standard 2.0 为目标，使其与 .NET Core 2.0 + 和 .NET Framework 4.6.1 + 运行时兼容。</span><span class="sxs-lookup"><span data-stu-id="8fad6-173">It targets the NET Standard 2.0, making it compatible with both .NET Core 2.0+ and .NET Framework 4.6.1+ runtimes.</span></span> <span data-ttu-id="8fad6-174">Ocelot 与说 HTTP 的任何内容集成，并在 .NET Core 支持的平台上运行： Linux、macOS 和 Windows。</span><span class="sxs-lookup"><span data-stu-id="8fad6-174">Ocelot integrates with anything that speaks HTTP and runs on the platforms which .NET Core supports: Linux, macOS, and Windows.</span></span> <span data-ttu-id="8fad6-175">Ocelot 可扩展，并支持许多现代平台，包括 Docker 容器、Azure Kubernetes 服务或其他公有云。</span><span class="sxs-lookup"><span data-stu-id="8fad6-175">Ocelot is extensible and supports many modern platforms, including Docker containers, Azure Kubernetes Services, or other public clouds.</span></span>  <span data-ttu-id="8fad6-176">Ocelot 与开源包（如[Consul](https://www.consul.io)、 [GraphQL](https://graphql.org)和 Netflix 的[Eureka](https://github.com/Netflix/eureka)）集成。</span><span class="sxs-lookup"><span data-stu-id="8fad6-176">Ocelot integrates with open-source packages like [Consul](https://www.consul.io), [GraphQL](https://graphql.org), and Netflix's [Eureka](https://github.com/Netflix/eureka).</span></span>

<span data-ttu-id="8fad6-177">对于简单的云本机应用程序，请考虑使用 Ocelot，这些应用程序不需要商业 API 网关的丰富功能集。</span><span class="sxs-lookup"><span data-stu-id="8fad6-177">Consider Ocelot for simple cloud-native applications that don't require the rich feature-set of a commercial API gateway.</span></span>

## <a name="azure-application-gateway"></a><span data-ttu-id="8fad6-178">Azure 应用程序网关</span><span class="sxs-lookup"><span data-stu-id="8fad6-178">Azure Application Gateway</span></span>

<span data-ttu-id="8fad6-179">对于简单的网关要求，你可以考虑[Azure 应用程序网关](https://docs.microsoft.com/azure/application-gateway/overview)。</span><span class="sxs-lookup"><span data-stu-id="8fad6-179">For simple gateway requirements, you may consider [Azure Application Gateway](https://docs.microsoft.com/azure/application-gateway/overview).</span></span> <span data-ttu-id="8fad6-180">它以 Azure [PaaS 服务](https://azure.microsoft.com/overview/what-is-paas/)的形式提供，包括 URL 路由、SSL 终止和 Web 应用程序防火墙等基本网关功能。</span><span class="sxs-lookup"><span data-stu-id="8fad6-180">Available as an Azure [PaaS service](https://azure.microsoft.com/overview/what-is-paas/), it includes basic gateway features such as URL routing, SSL termination, and a Web Application Firewall.</span></span> <span data-ttu-id="8fad6-181">该服务支持[第7层负载均衡](https://www.nginx.com/resources/glossary/layer-7-load-balancing/)功能。</span><span class="sxs-lookup"><span data-stu-id="8fad6-181">The service supports [Layer-7 load balancing](https://www.nginx.com/resources/glossary/layer-7-load-balancing/) capabilities.</span></span> <span data-ttu-id="8fad6-182">使用第7层时，可以根据 HTTP 消息的实际内容来路由请求，而不是只路由低级 TCP 网络数据包。</span><span class="sxs-lookup"><span data-stu-id="8fad6-182">With Layer 7, you can route requests based on the actual content of an HTTP message, not just low-level TCP network packets.</span></span>

<span data-ttu-id="8fad6-183">在本指南中，我们宣传在[Kubernetes](https://www.infoworld.com/article/3268073/what-is-kubernetes-your-next-application-platform.html)中托管云本机系统。</span><span class="sxs-lookup"><span data-stu-id="8fad6-183">Throughout this book, we evangelize hosting cloud-native systems in [Kubernetes](https://www.infoworld.com/article/3268073/what-is-kubernetes-your-next-application-platform.html).</span></span> <span data-ttu-id="8fad6-184">容器 orchestrator Kubernetes 自动执行容器化工作负荷的部署、缩放和操作问题。</span><span class="sxs-lookup"><span data-stu-id="8fad6-184">A container orchestrator, Kubernetes automates the deployment, scaling, and operational concerns of containerized workloads.</span></span> <span data-ttu-id="8fad6-185">Azure 应用程序网关可配置为[Azure Kubernetes Service](https://azure.microsoft.com/services/kubernetes-service/)群集的 API 网关。</span><span class="sxs-lookup"><span data-stu-id="8fad6-185">Azure Application Gateway can be configured as an API gateway for [Azure Kubernetes Service](https://azure.microsoft.com/services/kubernetes-service/) cluster.</span></span>

<span data-ttu-id="8fad6-186">利用[应用程序网关入口控制器](https://azure.github.io/application-gateway-kubernetes-ingress/)，Azure 应用程序网关可以直接使用[Azure Kubernetes 服务](https://azure.microsoft.com/services/kubernetes-service/)。</span><span class="sxs-lookup"><span data-stu-id="8fad6-186">The [Application Gateway Ingress Controller](https://azure.github.io/application-gateway-kubernetes-ingress/) enables Azure Application Gateway to work directly with [Azure Kubernetes Service](https://azure.microsoft.com/services/kubernetes-service/).</span></span> <span data-ttu-id="8fad6-187">图4.5 显示了此体系结构。</span><span class="sxs-lookup"><span data-stu-id="8fad6-187">Figure 4.5 shows the architecture.</span></span>

![应用程序网关入口控制器](./media/application-gateway-ingress-controller.png)

<span data-ttu-id="8fad6-189">**图4-5。**</span><span class="sxs-lookup"><span data-stu-id="8fad6-189">**Figure 4-5.**</span></span> <span data-ttu-id="8fad6-190">应用程序网关入口控制器</span><span class="sxs-lookup"><span data-stu-id="8fad6-190">Application Gateway Ingress Controller</span></span>

<span data-ttu-id="8fad6-191">Kubernetes 包含支持 HTTP （级别7）负载平衡的内置功能，称为[入口](https://kubernetes.io/docs/concepts/services-networking/ingress/)。</span><span class="sxs-lookup"><span data-stu-id="8fad6-191">Kubernetes includes a built-in feature that supports HTTP (Level 7) load balancing, called [Ingress](https://kubernetes.io/docs/concepts/services-networking/ingress/).</span></span> <span data-ttu-id="8fad6-192">入口定义一组规则，用于确定如何将 AKS 中的微服务实例公开给外界。</span><span class="sxs-lookup"><span data-stu-id="8fad6-192">Ingress defines a set of rules for how microservice instances inside AKS can be exposed to the outside world.</span></span> <span data-ttu-id="8fad6-193">在上图中，入口控制器解释为群集配置的入口规则并自动配置 Azure 应用程序网关。</span><span class="sxs-lookup"><span data-stu-id="8fad6-193">In the previous image, the ingress controller interprets the ingress rules configured for the cluster and automatically configures the Azure Application Gateway.</span></span> <span data-ttu-id="8fad6-194">根据这些规则，应用程序网关将流量路由到在 AKS 内运行的微服务。</span><span class="sxs-lookup"><span data-stu-id="8fad6-194">Based on those rules, the Application Gateway routes traffic to microservices running inside AKS.</span></span> <span data-ttu-id="8fad6-195">入口控制器侦听入站规则的更改，并对 Azure 应用程序网关进行适当的更改。</span><span class="sxs-lookup"><span data-stu-id="8fad6-195">The ingress controller listens for changes to ingress rules and makes the appropriate changes to the Azure Application Gateway.</span></span>

## <a name="azure-api-management"></a><span data-ttu-id="8fad6-196">Azure API 管理</span><span class="sxs-lookup"><span data-stu-id="8fad6-196">Azure API Management</span></span>

<span data-ttu-id="8fad6-197">对于适中到大规模的云本机系统，可以考虑[AZURE API 管理](https://azure.microsoft.com/services/api-management/)。</span><span class="sxs-lookup"><span data-stu-id="8fad6-197">For moderate to large-scale cloud-native systems, you may consider [Azure API Management](https://azure.microsoft.com/services/api-management/).</span></span> <span data-ttu-id="8fad6-198">这是一项基于云的服务，不仅能解决 API 网关需求，而且还提供全面的开发人员和管理体验。</span><span class="sxs-lookup"><span data-stu-id="8fad6-198">It's a cloud-based service that not only solves your API Gateway needs, but provides a full-featured developer and administrative experience.</span></span> <span data-ttu-id="8fad6-199">API 管理如图4-6 所示。</span><span class="sxs-lookup"><span data-stu-id="8fad6-199">API Management is shown in Figure 4-6.</span></span>

![Azure API 管理](./media/azure-api-management.png)

<span data-ttu-id="8fad6-201">**图 4-6.**</span><span class="sxs-lookup"><span data-stu-id="8fad6-201">**Figure 4-6.**</span></span> <span data-ttu-id="8fad6-202">Azure API 管理</span><span class="sxs-lookup"><span data-stu-id="8fad6-202">Azure API Management</span></span>

<span data-ttu-id="8fad6-203">首先，API 管理公开了一个网关服务器，该服务器允许根据可配置的规则和策略对后端服务进行受控访问。</span><span class="sxs-lookup"><span data-stu-id="8fad6-203">To start, API Management exposes a gateway server that allows controlled access to back-end services based upon configurable rules and policies.</span></span> <span data-ttu-id="8fad6-204">这些服务可以位于 Azure 云中、本地的数据中心或其他公有云。</span><span class="sxs-lookup"><span data-stu-id="8fad6-204">These services can be in the Azure cloud, your on-prem data center, or other public clouds.</span></span> <span data-ttu-id="8fad6-205">API 密钥和 JWT 令牌决定谁可以执行什么操作。</span><span class="sxs-lookup"><span data-stu-id="8fad6-205">API keys and JWT tokens determine who can do what.</span></span> <span data-ttu-id="8fad6-206">出于分析目的记录所有流量。</span><span class="sxs-lookup"><span data-stu-id="8fad6-206">All traffic is logged for analytical purposes.</span></span>

<span data-ttu-id="8fad6-207">对于开发人员而言，API 管理提供了一个开发人员门户，该门户提供对服务、文档以及调用这些服务的示例代码的访问。</span><span class="sxs-lookup"><span data-stu-id="8fad6-207">For developers, API Management offers a developer portal that provides access to services, documentation, and sample code for invoking them.</span></span> <span data-ttu-id="8fad6-208">开发人员可以使用 Swagger/开放式 API 来检查服务终结点并分析其使用情况。</span><span class="sxs-lookup"><span data-stu-id="8fad6-208">Developers can use Swagger/Open API to inspect service endpoints and analyze their usage.</span></span> <span data-ttu-id="8fad6-209">此服务适用于主要开发平台： .NET、Java、Golang 等。</span><span class="sxs-lookup"><span data-stu-id="8fad6-209">The service works across the major development platforms: .NET, Java, Golang, and more.</span></span>

<span data-ttu-id="8fad6-210">发布者门户公开管理仪表板，管理员在此仪表板中公开 Api 并管理其行为。</span><span class="sxs-lookup"><span data-stu-id="8fad6-210">The publisher portal exposes a management dashboard where administrators expose APIs and manage their behavior.</span></span> <span data-ttu-id="8fad6-211">可以授予服务访问权限、监视服务运行状况和收集服务遥测。</span><span class="sxs-lookup"><span data-stu-id="8fad6-211">Service access can be granted, service health monitored, and service telemetry gathered.</span></span> <span data-ttu-id="8fad6-212">管理员将*策略*应用于每个终结点，以影响行为。</span><span class="sxs-lookup"><span data-stu-id="8fad6-212">Administrators apply *policies* to each endpoint to affect behavior.</span></span> <span data-ttu-id="8fad6-213">[策略](https://docs.microsoft.com/azure/api-management/api-management-howto-policies)是针对每个服务调用按顺序执行的预生成语句。</span><span class="sxs-lookup"><span data-stu-id="8fad6-213">[Policies](https://docs.microsoft.com/azure/api-management/api-management-howto-policies) are pre-built statements that execute sequentially for each service call.</span></span>  <span data-ttu-id="8fad6-214">将策略配置为入站调用、出站调用，或在出现错误时调用。</span><span class="sxs-lookup"><span data-stu-id="8fad6-214">Policies are configured for an inbound call, outbound call, or invoked upon an error.</span></span> <span data-ttu-id="8fad6-215">策略可以在不同的服务范围内应用，以便在结合策略时启用确定性排序。</span><span class="sxs-lookup"><span data-stu-id="8fad6-215">Policies can be applied at different service scopes as to enable deterministic ordering when combining policies.</span></span> <span data-ttu-id="8fad6-216">该产品附带了大量预先生成的[策略](https://docs.microsoft.com/azure/api-management/api-management-policies)。</span><span class="sxs-lookup"><span data-stu-id="8fad6-216">The product ships with a large number of prebuilt [policies](https://docs.microsoft.com/azure/api-management/api-management-policies).</span></span>

<span data-ttu-id="8fad6-217">以下示例说明了策略如何影响云本机服务的行为：</span><span class="sxs-lookup"><span data-stu-id="8fad6-217">Here are examples of how policies can affect the behavior of your cloud-native services:</span></span>  

- <span data-ttu-id="8fad6-218">限制服务访问。</span><span class="sxs-lookup"><span data-stu-id="8fad6-218">Restrict service access.</span></span>
- <span data-ttu-id="8fad6-219">强制执行身份验证。</span><span class="sxs-lookup"><span data-stu-id="8fad6-219">Enforce authentication.</span></span>  
- <span data-ttu-id="8fad6-220">如果需要，限制来自单个源的调用。</span><span class="sxs-lookup"><span data-stu-id="8fad6-220">Throttle calls from a single source, if necessary.</span></span>
- <span data-ttu-id="8fad6-221">启用缓存。</span><span class="sxs-lookup"><span data-stu-id="8fad6-221">Enable caching.</span></span>
- <span data-ttu-id="8fad6-222">阻止从特定 IP 地址进行的调用。</span><span class="sxs-lookup"><span data-stu-id="8fad6-222">Block calls from specific IP addresses.</span></span>
- <span data-ttu-id="8fad6-223">控制服务的流。</span><span class="sxs-lookup"><span data-stu-id="8fad6-223">Control the flow of the service.</span></span>
- <span data-ttu-id="8fad6-224">将请求从 SOAP 转换为 REST 或不同数据格式（如从 XML 到 JSON）。</span><span class="sxs-lookup"><span data-stu-id="8fad6-224">Convert requests from SOAP to REST or between different data formats, such as from XML to JSON.</span></span>

<span data-ttu-id="8fad6-225">Azure API 管理可以公开托管在云或数据中心的任何位置托管的后端服务。</span><span class="sxs-lookup"><span data-stu-id="8fad6-225">Azure API Management can expose back-end services that are hosted anywhere – in the cloud or your data center.</span></span> <span data-ttu-id="8fad6-226">对于可以在云本机系统中公开的旧服务，它支持 REST 和 SOAP Api。</span><span class="sxs-lookup"><span data-stu-id="8fad6-226">For legacy services that you may expose in your cloud-native systems, it supports both REST and SOAP APIs.</span></span> <span data-ttu-id="8fad6-227">甚至可以通过 API 管理公开其他 Azure 服务。</span><span class="sxs-lookup"><span data-stu-id="8fad6-227">Even other Azure services can be exposed through API Management.</span></span> <span data-ttu-id="8fad6-228">可以在 azure[服务总线](https://azure.microsoft.com/services/service-bus/)或[azure 逻辑应用](https://azure.microsoft.com/services/logic-apps/)等 azure 支持服务的基础上放置托管 API。</span><span class="sxs-lookup"><span data-stu-id="8fad6-228">You could place a managed API on top of an Azure backing service like [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) or [Azure Logic Apps](https://azure.microsoft.com/services/logic-apps/).</span></span> <span data-ttu-id="8fad6-229">Azure API 管理不包括内置负载平衡支持，应结合使用负载均衡服务。</span><span class="sxs-lookup"><span data-stu-id="8fad6-229">Azure API Management doesn't include built-in load-balancing support and should be used in conjunction with a load-balancing service.</span></span>

<span data-ttu-id="8fad6-230">Azure API 管理跨[四个不同的层](https://azure.microsoft.com/pricing/details/api-management/)提供：</span><span class="sxs-lookup"><span data-stu-id="8fad6-230">Azure API Management is available across [four different tiers](https://azure.microsoft.com/pricing/details/api-management/):</span></span>

- <span data-ttu-id="8fad6-231">开发人员</span><span class="sxs-lookup"><span data-stu-id="8fad6-231">Developer</span></span>
- <span data-ttu-id="8fad6-232">基本</span><span class="sxs-lookup"><span data-stu-id="8fad6-232">Basic</span></span>
- <span data-ttu-id="8fad6-233">Standard</span><span class="sxs-lookup"><span data-stu-id="8fad6-233">Standard</span></span>
- <span data-ttu-id="8fad6-234">高级</span><span class="sxs-lookup"><span data-stu-id="8fad6-234">Premium</span></span>

<span data-ttu-id="8fad6-235">开发人员层适用于非生产工作负荷和评估。</span><span class="sxs-lookup"><span data-stu-id="8fad6-235">The Developer tier is meant for non-production workloads and evaluation.</span></span> <span data-ttu-id="8fad6-236">其他层提供更多的功能、功能和更高的服务级别协议（Sla）。</span><span class="sxs-lookup"><span data-stu-id="8fad6-236">The other tiers offer progressively more power, features, and higher service level agreements (SLAs).</span></span> <span data-ttu-id="8fad6-237">高级层提供了[Azure 虚拟网络](https://docs.microsoft.com/azure/virtual-network/virtual-networks-overview)和[多区域支持](https://docs.microsoft.com/azure/api-management/api-management-howto-deploy-multi-region)。</span><span class="sxs-lookup"><span data-stu-id="8fad6-237">The Premium tier provides [Azure Virtual Network](https://docs.microsoft.com/azure/virtual-network/virtual-networks-overview) and [multi-region support](https://docs.microsoft.com/azure/api-management/api-management-howto-deploy-multi-region).</span></span> <span data-ttu-id="8fad6-238">所有层都具有固定的每小时价格。</span><span class="sxs-lookup"><span data-stu-id="8fad6-238">All tiers have a fixed price per hour.</span></span>

<span data-ttu-id="8fad6-239">Azure 云还为 Azure API 管理提供[无服务器层](https://azure.microsoft.com/blog/announcing-azure-api-management-for-serverless-architectures/)。</span><span class="sxs-lookup"><span data-stu-id="8fad6-239">The Azure cloud also offers a [serverless tier](https://azure.microsoft.com/blog/announcing-azure-api-management-for-serverless-architectures/) for Azure API Management.</span></span> <span data-ttu-id="8fad6-240">作为*消耗定价层*，该服务是围绕无服务器计算模型设计的 API 管理的一个变体。</span><span class="sxs-lookup"><span data-stu-id="8fad6-240">Referred to as the *consumption pricing tier*, the service is a variant of API Management designed around the serverless computing model.</span></span> <span data-ttu-id="8fad6-241">与先前显示的 "预分配" 定价层不同，消耗层提供即时预配和按操作付费定价。</span><span class="sxs-lookup"><span data-stu-id="8fad6-241">Unlike the "pre-allocated" pricing tiers previously shown, the consumption tier provides  instant provisioning and pay-per-action pricing.</span></span>

<span data-ttu-id="8fad6-242">它在以下用例中启用 API 网关功能：</span><span class="sxs-lookup"><span data-stu-id="8fad6-242">It enables API Gateway features for the following use cases:</span></span>

- <span data-ttu-id="8fad6-243">使用[Azure Functions](https://docs.microsoft.com/azure/azure-functions/functions-overview)和[Azure 逻辑应用](https://azure.microsoft.com/services/logic-apps/)等无服务器技术实现了微服务。</span><span class="sxs-lookup"><span data-stu-id="8fad6-243">Microservices implemented using serverless technologies such as [Azure Functions](https://docs.microsoft.com/azure/azure-functions/functions-overview) and [Azure Logic Apps](https://azure.microsoft.com/services/logic-apps/).</span></span>
- <span data-ttu-id="8fad6-244">Azure 后备服务资源（如服务总线队列和主题、Azure 存储等）。</span><span class="sxs-lookup"><span data-stu-id="8fad6-244">Azure backing service resources such as Service Bus queues and topics, Azure storage, and others.</span></span>
- <span data-ttu-id="8fad6-245">微服务：流量偶尔出现大的峰值，但大部分时间都不变。</span><span class="sxs-lookup"><span data-stu-id="8fad6-245">Microservices where traffic has occasional large spikes but remains low the majority of the time.</span></span>

<span data-ttu-id="8fad6-246">消耗层使用相同的基础服务 API 管理组件，但基于动态分配的资源使用完全不同的体系结构。</span><span class="sxs-lookup"><span data-stu-id="8fad6-246">The consumption tier uses the same underlying service API Management components, but employs an entirely different architecture based on dynamically allocated resources.</span></span> <span data-ttu-id="8fad6-247">它与无服务器计算模型完全一致：</span><span class="sxs-lookup"><span data-stu-id="8fad6-247">It aligns perfectly with the serverless computing model:</span></span>

- <span data-ttu-id="8fad6-248">没有要管理的基础结构。</span><span class="sxs-lookup"><span data-stu-id="8fad6-248">No infrastructure to manage.</span></span>
- <span data-ttu-id="8fad6-249">无空闲容量。</span><span class="sxs-lookup"><span data-stu-id="8fad6-249">No idle capacity.</span></span>
- <span data-ttu-id="8fad6-250">高可用性。</span><span class="sxs-lookup"><span data-stu-id="8fad6-250">High-availability.</span></span>
- <span data-ttu-id="8fad6-251">自动缩放。</span><span class="sxs-lookup"><span data-stu-id="8fad6-251">Automatic scaling.</span></span>
- <span data-ttu-id="8fad6-252">成本基于实际使用情况。</span><span class="sxs-lookup"><span data-stu-id="8fad6-252">Cost is based on actual usage.</span></span>
  
<span data-ttu-id="8fad6-253">对于将无服务器资源作为 Api 公开的云本机系统，新的消耗层是一个不错的选择。</span><span class="sxs-lookup"><span data-stu-id="8fad6-253">The new consumption tier is a great choice for cloud-native systems that expose serverless resources as APIs.</span></span>

## <a name="real-time-communication"></a><span data-ttu-id="8fad6-254">实时通信</span><span class="sxs-lookup"><span data-stu-id="8fad6-254">Real-time communication</span></span>

<span data-ttu-id="8fad6-255">对于通过 HTTP 与后端云本机系统进行通信的前端应用程序，"实时" 或 "推送" 是一种选择。</span><span class="sxs-lookup"><span data-stu-id="8fad6-255">Real-time, or push, communication is another option for front-end applications that communicate with back-end cloud-native systems over HTTP.</span></span> <span data-ttu-id="8fad6-256">应用程序（如财政股票、在线教育、游戏和作业进度更新）需要来自后端的即时实时响应。</span><span class="sxs-lookup"><span data-stu-id="8fad6-256">Applications, such as financial-tickers, online education, gaming, and job-progress updates, require instantaneous, real-time responses from the back-end.</span></span> <span data-ttu-id="8fad6-257">对于普通的 HTTP 通信，客户端无法知道何时有新数据可用。</span><span class="sxs-lookup"><span data-stu-id="8fad6-257">With normal HTTP communication, there's no way for the client to know when new data is available.</span></span> <span data-ttu-id="8fad6-258">客户端必须持续*轮询*或向服务器发送请求。</span><span class="sxs-lookup"><span data-stu-id="8fad6-258">The client must continually *poll* or send requests to the server.</span></span> <span data-ttu-id="8fad6-259">通过*实时*通信，服务器可以随时将新数据推送到客户端。</span><span class="sxs-lookup"><span data-stu-id="8fad6-259">With *real-time* communication, the server can push new data to the client at any time.</span></span>

<span data-ttu-id="8fad6-260">实时系统通常由高频数据流和大量并发客户端连接来表征。</span><span class="sxs-lookup"><span data-stu-id="8fad6-260">Real-time systems are often characterized by high-frequency data flows and large numbers of concurrent client connections.</span></span> <span data-ttu-id="8fad6-261">手动实现实时连接可能很快就会变得复杂，这需要不重要的基础结构来确保可伸缩性和可靠的消息传送到连接的客户端。</span><span class="sxs-lookup"><span data-stu-id="8fad6-261">Manually implementing real-time connectivity can quickly become complex, requiring non-trivial infrastructure to ensure scalability and reliable messaging to connected clients.</span></span> <span data-ttu-id="8fad6-262">你可以自行管理 Azure Redis 缓存实例，以及一组配置了用于客户端关联的粘滞会话的负载均衡器。</span><span class="sxs-lookup"><span data-stu-id="8fad6-262">You could find yourself managing an  instance of Azure Redis Cache and a set of load balancers configured with sticky sessions for client affinity.</span></span>

<span data-ttu-id="8fad6-263">[Azure SignalR 服务](https://azure.microsoft.com/services/signalr-service/)是一项完全托管的 azure 服务，可简化云本机应用程序的实时通信。</span><span class="sxs-lookup"><span data-stu-id="8fad6-263">[Azure SignalR Service](https://azure.microsoft.com/services/signalr-service/) is a fully managed Azure service that simplifies real-time communication for your cloud-native applications.</span></span> <span data-ttu-id="8fad6-264">精简的技术实现细节，如容量预配、缩放和持续连接。</span><span class="sxs-lookup"><span data-stu-id="8fad6-264">Technical implementation details like capacity provisioning, scaling, and persistent connections are abstracted away.</span></span> <span data-ttu-id="8fad6-265">使用99.9% 的服务级别协议处理它们。</span><span class="sxs-lookup"><span data-stu-id="8fad6-265">They're handled for you with a 99.9% service-level agreement.</span></span> <span data-ttu-id="8fad6-266">你专注于应用程序功能，而不是基础结构管道。</span><span class="sxs-lookup"><span data-stu-id="8fad6-266">You focus on application features, not infrastructure plumbing.</span></span>

<span data-ttu-id="8fad6-267">启用后，基于云的 HTTP 服务可以直接将内容更新推送到连接的客户端，包括浏览器、移动和桌面应用程序。</span><span class="sxs-lookup"><span data-stu-id="8fad6-267">Once enabled, a cloud-based HTTP service can push content updates directly to connected clients, including browser, mobile and desktop applications.</span></span> <span data-ttu-id="8fad6-268">无需轮询服务器就可以更新客户端。</span><span class="sxs-lookup"><span data-stu-id="8fad6-268">Clients are updated without the need to poll the server.</span></span> <span data-ttu-id="8fad6-269">Azure SignalR 对创建实时连接的传输技术（包括 Websocket、服务器端事件和长轮询）进行了抽象。</span><span class="sxs-lookup"><span data-stu-id="8fad6-269">Azure SignalR abstracts the transport technologies that create real-time connectivity, including WebSockets, Server-Side Events, and Long Polling.</span></span> <span data-ttu-id="8fad6-270">开发人员重点介绍如何将消息发送到连接的客户端的所有或特定子集。</span><span class="sxs-lookup"><span data-stu-id="8fad6-270">Developers focus on sending messages to all or specific subsets of connected clients.</span></span>

<span data-ttu-id="8fad6-271">图4-7 显示了一组 HTTP 客户端，这些客户端连接到启用了 Azure SignalR 的云本机应用程序。</span><span class="sxs-lookup"><span data-stu-id="8fad6-271">Figure 4-7 shows a set of HTTP Clients connecting to a Cloud-native application with Azure SignalR enabled.</span></span>

![Azure SignalR](./media/azure-signalr-service.png)

<span data-ttu-id="8fad6-273">**图 4-7.**</span><span class="sxs-lookup"><span data-stu-id="8fad6-273">**Figure 4-7.**</span></span> <span data-ttu-id="8fad6-274">Azure SignalR</span><span class="sxs-lookup"><span data-stu-id="8fad6-274">Azure SignalR</span></span>

<span data-ttu-id="8fad6-275">Azure SignalR 服务的另一个优点是实现无服务器云本机服务。</span><span class="sxs-lookup"><span data-stu-id="8fad6-275">Another advantage of Azure SignalR Service comes with implementing Serverless cloud-native services.</span></span> <span data-ttu-id="8fad6-276">或许你的代码是按需执行的，Azure Functions 触发器。</span><span class="sxs-lookup"><span data-stu-id="8fad6-276">Perhaps your code is executed on demand with Azure Functions triggers.</span></span> <span data-ttu-id="8fad6-277">这种情况可能比较棘手，因为你的代码不会与客户端保持长时间的连接。</span><span class="sxs-lookup"><span data-stu-id="8fad6-277">This scenario can be tricky because your code doesn't maintain long connections with clients.</span></span> <span data-ttu-id="8fad6-278">Azure SignalR 服务可以处理这种情况，因为该服务已为用户管理连接。</span><span class="sxs-lookup"><span data-stu-id="8fad6-278">Azure SignalR Service can handle this situation since the service already manages connections for you.</span></span>

<span data-ttu-id="8fad6-279">Azure SignalR 服务可与其他 Azure 服务（例如 Azure SQL 数据库、服务总线或 Redis 缓存）紧密集成，从而为你的云本机应用程序打开了许多可能性。</span><span class="sxs-lookup"><span data-stu-id="8fad6-279">Azure SignalR Service closely integrates with other Azure services, such as Azure SQL Database, Service Bus, or Redis Cache, opening up many possibilities for your cloud-native applications.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="8fad6-280">[上一页](communication-patterns.md)
>[下一页](service-to-service-communication.md)</span><span class="sxs-lookup"><span data-stu-id="8fad6-280">[Previous](communication-patterns.md)
[Next](service-to-service-communication.md)</span></span>
