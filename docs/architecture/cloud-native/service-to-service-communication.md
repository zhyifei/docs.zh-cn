---
title: 服务到服务通信
description: 了解后端云和本地微服务与其他后端微服务通信的方式。
author: robvet
ms.date: 09/09/2019
ms.openlocfilehash: a5124b8b83f62ff17b1230ead63db26e0c1f2a5b
ms.sourcegitcommit: 515469828d0f040e01bde01df6b8e4eb43630b06
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/06/2020
ms.locfileid: "78675139"
---
# <a name="service-to-service-communication"></a><span data-ttu-id="dc8cd-103">服务到服务通信</span><span class="sxs-lookup"><span data-stu-id="dc8cd-103">Service-to-service communication</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="dc8cd-104">从前端客户端开始，我们会解决后端微服务之间的通信。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-104">Moving from the front-end client, we now address back-end microservices communicate with each other.</span></span>

<span data-ttu-id="dc8cd-105">构造云本机应用程序时，您需要对后端服务之间的通信方式保密。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-105">When constructing a cloud-native application, you'll want to be sensitive to how back-end services communicate with each other.</span></span> <span data-ttu-id="dc8cd-106">理想情况下，服务间通信越少，性能越好。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-106">Ideally, the less inter-service communication, the better.</span></span> <span data-ttu-id="dc8cd-107">不过，由于后端服务通常相互依赖于另一项来完成操作，因此不一定能避免这种情况。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-107">However, avoidance isn't always possible as back-end services often rely on one another to complete an operation.</span></span>

<span data-ttu-id="dc8cd-108">有几种广泛接受的方法来实现跨服务通信。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-108">There are several widely accepted approaches to implementing cross-service communication.</span></span> <span data-ttu-id="dc8cd-109">*通信交互的类型*通常会确定最佳方法。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-109">The *type of communication interaction* will often determine the best approach.</span></span>

<span data-ttu-id="dc8cd-110">请考虑下列交互类型：</span><span class="sxs-lookup"><span data-stu-id="dc8cd-110">Consider the following interaction types:</span></span>

- <span data-ttu-id="dc8cd-111">*Query* –调用微服务需要来自称为微服务的响应，例如，"你好，为给定客户 Id 提供买方信息。"</span><span class="sxs-lookup"><span data-stu-id="dc8cd-111">*Query* – when a calling microservice requires a response from a called microservice, such as, "Hey, give me the buyer information for a given customer Id."</span></span>

- <span data-ttu-id="dc8cd-112">*Command* –调用微服务需要另一个微服务来执行操作，但不需要响应，如 "你好，只是发送此订单"。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-112">*Command* – when the calling microservice needs another microservice to execute an action but doesn't require a response, such as, "Hey, just ship this order."</span></span>

- <span data-ttu-id="dc8cd-113">*事件*–当名为发布服务器的微服务引发状态已更改或操作已发生的事件时。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-113">*Event* – when a microservice, called the publisher, raises an event that state has changed or an action has occurred.</span></span> <span data-ttu-id="dc8cd-114">其他感兴趣的微服务（称为订户）可以相应地对事件做出反应。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-114">Other microservices, called subscribers, who are interested, can react to the event appropriately.</span></span> <span data-ttu-id="dc8cd-115">发布服务器和订阅服务器彼此之间并不知道。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-115">The publisher and the subscribers aren't aware of each other.</span></span>

<span data-ttu-id="dc8cd-116">当执行需要跨服务交互的操作时，微服务系统通常会结合使用这些交互类型。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-116">Microservice systems typically use a combination of these interaction types when executing operations that require cross-service interaction.</span></span> <span data-ttu-id="dc8cd-117">我们来看一看每个问题及其实现方式。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-117">Let's take a close look at each and how you might implement them.</span></span>

## <a name="queries"></a><span data-ttu-id="dc8cd-118">查询</span><span class="sxs-lookup"><span data-stu-id="dc8cd-118">Queries</span></span>

<span data-ttu-id="dc8cd-119">很多时候，一个微服务可能需要*查询*另一个，需要立即响应才能完成操作。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-119">Many times, one microservice might need to *query* another, requiring an immediate response to complete an operation.</span></span> <span data-ttu-id="dc8cd-120">购物篮微服务可能需要产品信息和价格才能将物品添加到购物篮中。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-120">A shopping basket microservice may need product information and a price to add an item to its basket.</span></span> <span data-ttu-id="dc8cd-121">有多种方法可实现查询操作。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-121">There are a number of approaches for implementing query operations.</span></span>

### <a name="requestresponse-messaging"></a><span data-ttu-id="dc8cd-122">请求/响应消息传送</span><span class="sxs-lookup"><span data-stu-id="dc8cd-122">Request/Response Messaging</span></span>

<span data-ttu-id="dc8cd-123">实现此方案的一种方法是，调用后端微服务向其需要查询的微服务发出直接 HTTP 请求，如图4-8 所示。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-123">One option for implementing this scenario is for the calling back-end microservice to make direct HTTP requests to the microservices it needs to query, shown in Figure 4-8.</span></span>

![直接 HTTP 通信](./media/direct-http-communication.png)

<span data-ttu-id="dc8cd-125">**图 4-8**。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-125">**Figure 4-8**.</span></span> <span data-ttu-id="dc8cd-126">直接 HTTP 通信</span><span class="sxs-lookup"><span data-stu-id="dc8cd-126">Direct HTTP communication</span></span>

<span data-ttu-id="dc8cd-127">尽管微服务之间的直接 HTTP 调用相对简单，但要执行此操作，但要尽量减少这种做法。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-127">While direct HTTP calls between microservices are relatively simple to implement, care should be taken to minimize this practice.</span></span> <span data-ttu-id="dc8cd-128">首先，这些调用始终*同步*，并将阻止操作，直到返回结果或请求超时。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-128">To start, these calls are always *synchronous* and will block the operation until a result is returned or the request times outs.</span></span> <span data-ttu-id="dc8cd-129">如果是自包含的独立服务，可以独立地单独进行发展并经常进行部署，现在会相互耦合。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-129">What were once self-contained, independent services, able to evolve independently and deploy frequently, now become coupled to each other.</span></span> <span data-ttu-id="dc8cd-130">随着微服务的增长，它们的体系结构优势得以降低。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-130">As coupling among microservices increase, their architectural benefits diminish.</span></span>

<span data-ttu-id="dc8cd-131">如果执行的是不频繁的请求，则会对某些系统允许单个直接 HTTP 调用另一个微服务。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-131">Executing an infrequent request that makes a single direct HTTP call to another microservice might be acceptable for some systems.</span></span> <span data-ttu-id="dc8cd-132">但是，调用多个微服务的直接 HTTP 调用的高容量调用并不可取。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-132">However, high-volume calls that invoke direct HTTP calls to multiple microservices aren't advisable.</span></span> <span data-ttu-id="dc8cd-133">它们可能会增加延迟，并对系统的性能、可伸缩性和可用性产生负面影响。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-133">They can increase latency and negatively impact the performance, scalability, and availability of your system.</span></span> <span data-ttu-id="dc8cd-134">更糟的是，长串直接 HTTP 通信可能导致同步微服务调用的深层和复杂链，如图4-9 所示：</span><span class="sxs-lookup"><span data-stu-id="dc8cd-134">Even worse, a long series of direct HTTP communication can lead to deep and complex chains of synchronous microservices calls, shown in Figure 4-9:</span></span>

![链接 HTTP 查询](./media/chaining-http-queries.png)

<span data-ttu-id="dc8cd-136">**图 4-9**.</span><span class="sxs-lookup"><span data-stu-id="dc8cd-136">**Figure 4-9**.</span></span> <span data-ttu-id="dc8cd-137">链接 HTTP 查询</span><span class="sxs-lookup"><span data-stu-id="dc8cd-137">Chaining HTTP queries</span></span>

<span data-ttu-id="dc8cd-138">当然，您可以想像一下设计上图中所示的风险。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-138">You can certainly imagine the risk in the design shown in the previous image.</span></span> <span data-ttu-id="dc8cd-139">如果步骤 \#3 失败，会发生什么情况？</span><span class="sxs-lookup"><span data-stu-id="dc8cd-139">What happens if Step \#3 fails?</span></span> <span data-ttu-id="dc8cd-140">或步骤 \#8 失败？</span><span class="sxs-lookup"><span data-stu-id="dc8cd-140">Or Step \#8 fails?</span></span> <span data-ttu-id="dc8cd-141">如何进行恢复？</span><span class="sxs-lookup"><span data-stu-id="dc8cd-141">How do you recover?</span></span> <span data-ttu-id="dc8cd-142">如果由于基础服务繁忙而导致步骤 \#6 慢，会怎么样？</span><span class="sxs-lookup"><span data-stu-id="dc8cd-142">What if Step \#6 is slow because the underlying service is busy?</span></span> <span data-ttu-id="dc8cd-143">如何继续？</span><span class="sxs-lookup"><span data-stu-id="dc8cd-143">How do you continue?</span></span> <span data-ttu-id="dc8cd-144">即使全部工作正常，也可以考虑此调用会产生的延迟，这是每个步骤的延迟的总和。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-144">Even if all works correctly, think of the latency this call would incur, which is the sum of the latency of each step.</span></span>

<span data-ttu-id="dc8cd-145">上图中的大量耦合建议，服务未进行最佳建模。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-145">The large degree of coupling in the previous image suggests the services weren't optimally modeled.</span></span> <span data-ttu-id="dc8cd-146">这会使团队重新访问其设计来说。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-146">It would behoove the team to revisit their design.</span></span>

### <a name="materialized-view-pattern"></a><span data-ttu-id="dc8cd-147">具体化视图模式</span><span class="sxs-lookup"><span data-stu-id="dc8cd-147">Materialized View pattern</span></span>

<span data-ttu-id="dc8cd-148">用于删除微服务耦合的常用选项为[具体化视图模式](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-148">A popular option for removing microservice coupling is the [Materialized View pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span></span> <span data-ttu-id="dc8cd-149">使用此模式，微服务存储其自己的本地非规范化数据副本，这些数据由其他服务拥有。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-149">With this pattern, a microservice stores its own local, denormalized copy of data that's owned by other services.</span></span> <span data-ttu-id="dc8cd-150">它不会微服务查询产品目录和定价微服务，而是保留其自己的本地数据副本。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-150">Instead of the Shopping Basket microservice querying the Product Catalog and Pricing microservices, it maintains its own local copy of that data.</span></span> <span data-ttu-id="dc8cd-151">此模式消除了不必要的耦合，并改进了可靠性和响应时间。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-151">This pattern eliminates unnecessary coupling and improves reliability and response time.</span></span> <span data-ttu-id="dc8cd-152">整个操作在一个进程内执行。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-152">The entire operation executes inside a single process.</span></span> <span data-ttu-id="dc8cd-153">我们将在第5章探讨此模式和其他数据问题。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-153">We explore this pattern and other data concerns in Chapter 5.</span></span>

### <a name="service-aggregator-pattern"></a><span data-ttu-id="dc8cd-154">服务聚合器模式</span><span class="sxs-lookup"><span data-stu-id="dc8cd-154">Service Aggregator Pattern</span></span>

<span data-ttu-id="dc8cd-155">消除微服务与微服务耦合的另一个选项是聚合器[微服务](https://devblogs.microsoft.com/cesardelatorre/designing-and-implementing-api-gateways-with-ocelot-in-a-microservices-and-container-based-architecture/)，如图4-10 中所示。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-155">Another option for eliminating microservice-to-microservice coupling is an [Aggregator microservice](https://devblogs.microsoft.com/cesardelatorre/designing-and-implementing-api-gateways-with-ocelot-in-a-microservices-and-container-based-architecture/), shown in purple in Figure 4-10.</span></span>

![聚合器服务](./media/aggregator-service.png)

<span data-ttu-id="dc8cd-157">**图 4-10**。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-157">**Figure 4-10**.</span></span> <span data-ttu-id="dc8cd-158">聚合微服务</span><span class="sxs-lookup"><span data-stu-id="dc8cd-158">Aggregator microservice</span></span>

<span data-ttu-id="dc8cd-159">此模式隔离了对多个后端微服务进行调用的操作，从而将其逻辑集中到专门的微服务中。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-159">The pattern isolates an operation that makes calls to multiple back-end microservices, centralizing its logic into a specialized microservice.</span></span>  <span data-ttu-id="dc8cd-160">上图中的紫色结帐聚合器微服务协调结帐操作的工作流。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-160">The purple checkout aggregator microservice in the previous figure orchestrates the workflow for the Checkout operation.</span></span> <span data-ttu-id="dc8cd-161">它包括按顺序顺序调用多个后端微服务。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-161">It includes calls to several back-end microservices in a sequenced order.</span></span> <span data-ttu-id="dc8cd-162">工作流中的数据将聚合并返回给调用方。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-162">Data from the workflow is aggregated and returned to the caller.</span></span> <span data-ttu-id="dc8cd-163">尽管它仍实现直接 HTTP 调用，但聚合器微服务减少了后端微服务之间的直接依赖关系。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-163">While it still implements direct HTTP calls, the aggregator microservice reduces direct dependencies among back-end microservices.</span></span>

### <a name="requestreply-pattern"></a><span data-ttu-id="dc8cd-164">请求/答复模式</span><span class="sxs-lookup"><span data-stu-id="dc8cd-164">Request/Reply Pattern</span></span>

<span data-ttu-id="dc8cd-165">分离同步 HTTP 消息的另一种方法是[请求-答复模式](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html)，这种模式使用队列通信。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-165">Another approach for decoupling synchronous HTTP messages is a [Request-Reply Pattern](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html), which uses queuing communication.</span></span> <span data-ttu-id="dc8cd-166">使用队列的通信始终是单向通道，生成方发送消息，使用者接收消息。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-166">Communication using a queue is always a one-way channel, with a producer sending the message and consumer receiving it.</span></span> <span data-ttu-id="dc8cd-167">使用此模式时，将实现请求队列和响应队列，如图4-11 所示。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-167">With this pattern, both a request queue and response queue are implemented, shown in Figure 4-11.</span></span>

![请求-答复模式](./media/request-reply-pattern.png)

<span data-ttu-id="dc8cd-169">**图 4-11**。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-169">**Figure 4-11**.</span></span> <span data-ttu-id="dc8cd-170">请求-答复模式</span><span class="sxs-lookup"><span data-stu-id="dc8cd-170">Request-reply pattern</span></span>

<span data-ttu-id="dc8cd-171">此处，消息创建者创建包含唯一相关 ID 的基于查询的消息，并将其放入请求队列。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-171">Here, the message producer creates a query-based message that contains a unique correlation ID and places it into a request queue.</span></span> <span data-ttu-id="dc8cd-172">使用服务取消排队消息，处理消息，并将响应放入具有相同相关 ID 的响应队列。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-172">The consuming service dequeues the messages, processes it and places the response into the response queue with the same correlation ID.</span></span> <span data-ttu-id="dc8cd-173">制造者服务取消排队该消息，并将其与相关 ID 匹配并继续处理。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-173">The producer service dequeues the message, matches it with the correlation ID and continues processing.</span></span> <span data-ttu-id="dc8cd-174">我们将在下一节中详细介绍队列。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-174">We cover queues in detail in the next section.</span></span>

## <a name="commands"></a><span data-ttu-id="dc8cd-175">命令</span><span class="sxs-lookup"><span data-stu-id="dc8cd-175">Commands</span></span>

<span data-ttu-id="dc8cd-176">另一种类型的通信交互是*命令*。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-176">Another type of communication interaction is a *command*.</span></span> <span data-ttu-id="dc8cd-177">微服务可能需要另一个微服务才能执行操作。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-177">A microservice may need another microservice to perform an action.</span></span> <span data-ttu-id="dc8cd-178">订单微服务可能需要发货微服务才能创建已批准订单的发货。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-178">The Ordering microservice may need the Shipping microservice to create a shipment for an approved order.</span></span> <span data-ttu-id="dc8cd-179">在图4-12 中，一个名为制造者的微服务将一条消息发送给另一个微服务。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-179">In Figure 4-12, one microservice, called a Producer, sends a message to another microservice, the Consumer, commanding it to do something.</span></span>

![与队列的命令交互](./media/command-interaction-with-queue.png)

<span data-ttu-id="dc8cd-181">图 4-12。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-181">**Figure 4-12**.</span></span> <span data-ttu-id="dc8cd-182">与队列的命令交互</span><span class="sxs-lookup"><span data-stu-id="dc8cd-182">Command interaction with a queue</span></span>

<span data-ttu-id="dc8cd-183">大多数情况下，制造者不需要响应，可以*激发消息并*将其遗忘。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-183">Most often, the Producer doesn't require a response and can *fire-and-forget* the message.</span></span> <span data-ttu-id="dc8cd-184">如果需要答复，则使用者将单独的消息发送回另一个通道上的制造者。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-184">If a reply is needed, the Consumer sends a separate message back to Producer on another channel.</span></span> <span data-ttu-id="dc8cd-185">命令消息最好通过消息队列异步发送。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-185">A command message is best sent asynchronously with a message queue.</span></span> <span data-ttu-id="dc8cd-186">由轻型消息代理支持。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-186">supported by a lightweight message broker.</span></span> <span data-ttu-id="dc8cd-187">在前面的关系图中，请注意队列如何分隔并分离这两个服务。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-187">In the previous diagram, note how a queue separates and decouples both services.</span></span>

<span data-ttu-id="dc8cd-188">消息队列是一个中介构造，使用者和使用者传递一条消息。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-188">A message queue is an intermediary construct through which a producer and consumer pass a message.</span></span> <span data-ttu-id="dc8cd-189">队列实现了异步的点到点消息传递模式。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-189">Queues implement an asynchronous, point-to-point messaging pattern.</span></span> <span data-ttu-id="dc8cd-190">制造者知道需要将命令发送到何处并正确路由。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-190">The Producer knows where a command needs to be sent and routes appropriately.</span></span> <span data-ttu-id="dc8cd-191">队列保证消息仅由从通道读取的一个使用者实例处理。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-191">The queue guarantees that a message is processed by exactly one of the consumer instances that are reading from the channel.</span></span> <span data-ttu-id="dc8cd-192">在此方案中，制造者或使用者服务可以横向扩展，而不会影响另一个。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-192">In this scenario, either the producer or consumer service can scale out without affecting the other.</span></span> <span data-ttu-id="dc8cd-193">而且，每一方都可以完全不同的技术，这意味着我们可能会有一个 Java 微服务调用[Golang](https://golang.org)微服务。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-193">As well, technologies can be disparate on each side, meaning that we might have a Java microservice calling a [Golang](https://golang.org) microservice.</span></span>

<span data-ttu-id="dc8cd-194">第1章介绍了有关*后备服务*的信息。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-194">In chapter 1, we talked about *backing services*.</span></span> <span data-ttu-id="dc8cd-195">支持服务是云本机系统所依赖的辅助资源。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-195">Backing services are ancillary resources upon which cloud-native systems depend.</span></span> <span data-ttu-id="dc8cd-196">消息队列是支持服务。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-196">Message queues are backing services.</span></span> <span data-ttu-id="dc8cd-197">Azure 云支持通过两种类型的消息队列来实现命令消息传递： Azure 存储队列和 Azure 服务总线队列。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-197">The Azure cloud supports two types of message queues that your cloud-native systems can consume to implement command messaging: Azure Storage Queues and Azure Service Bus Queues.</span></span>

### <a name="azure-storage-queues"></a><span data-ttu-id="dc8cd-198">Azure 存储队列</span><span class="sxs-lookup"><span data-stu-id="dc8cd-198">Azure Storage Queues</span></span>

<span data-ttu-id="dc8cd-199">Azure 存储队列提供了一个简单的排队基础结构，该基础结构快速、经济实惠，并由 Azure 存储帐户提供支持。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-199">Azure storage queues offer a simple queueing infrastructure that is fast, affordable, and backed by Azure storage accounts.</span></span>

<span data-ttu-id="dc8cd-200">[Azure 存储队列](https://docs.microsoft.com/azure/storage/queues/storage-queues-introduction)使用基于 REST 的排队机制，提供可靠且持久的消息传递机制。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-200">[Azure Storage Queues](https://docs.microsoft.com/azure/storage/queues/storage-queues-introduction) feature a REST-based queuing mechanism with reliable and persistent messaging.</span></span> <span data-ttu-id="dc8cd-201">它们提供了最小的功能集，但价格较低，并存储数百万条消息。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-201">They provide a minimal feature set, but are inexpensive and store millions of messages.</span></span> <span data-ttu-id="dc8cd-202">其容量范围最大为 500 TB。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-202">Their capacity ranges up to 500 TB.</span></span> <span data-ttu-id="dc8cd-203">单个消息的大小最大可为 64 KB。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-203">A single message can be up to 64 KB in size.</span></span>

<span data-ttu-id="dc8cd-204">可以通过使用 HTTP 或 HTTPS 的经过身份验证的调用，从世界上的任何地方访问消息。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-204">You can access messages from anywhere in the world via authenticated calls using HTTP or HTTPS.</span></span> <span data-ttu-id="dc8cd-205">存储队列可横向扩展到大量并发客户端，以处理流量高峰。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-205">Storage queues can scale out to large numbers of concurrent clients to handle traffic spikes.</span></span>

<span data-ttu-id="dc8cd-206">也就是说，该服务有一些限制：</span><span class="sxs-lookup"><span data-stu-id="dc8cd-206">That said, there are limitations with the service:</span></span>

- <span data-ttu-id="dc8cd-207">不保证消息顺序。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-207">Message order isn't guaranteed.</span></span>

- <span data-ttu-id="dc8cd-208">消息在被自动删除前只能保留7天。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-208">A message can only persist for seven days before it's automatically removed.</span></span>

- <span data-ttu-id="dc8cd-209">支持状态管理、重复检测或事务。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-209">Support for state management, duplicate detection, or transactions isn't available.</span></span>

<span data-ttu-id="dc8cd-210">图4-13 显示了 Azure 存储队列的层次结构。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-210">Figure 4-13 shows the hierarchy of an Azure Storage Queue.</span></span>

![存储队列层次结构](./media/storage-queue-hierarchy.png)

<span data-ttu-id="dc8cd-212">图 4-13。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-212">**Figure 4-13**.</span></span> <span data-ttu-id="dc8cd-213">存储队列层次结构</span><span class="sxs-lookup"><span data-stu-id="dc8cd-213">Storage queue hierarchy</span></span>

<span data-ttu-id="dc8cd-214">在上图中，请注意存储队列如何将其消息存储在底层 Azure 存储帐户中。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-214">In the previous figure, note how storage queues store their messages in the underlying Azure Storage account.</span></span>

<span data-ttu-id="dc8cd-215">对于开发人员，Microsoft 提供了多个用于存储队列处理的客户端和服务器端库。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-215">For developers, Microsoft provides several client and server-side libraries for Storage queue processing.</span></span> <span data-ttu-id="dc8cd-216">支持大多数主要平台，包括 .NET、Java、JavaScript、Ruby、Python 和中转。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-216">Most major platforms are supported including .NET, Java, JavaScript, Ruby, Python, and Go.</span></span> <span data-ttu-id="dc8cd-217">开发人员决不会直接与这些库通信。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-217">Developers should never communicate directly with these libraries.</span></span> <span data-ttu-id="dc8cd-218">这样做会将微服务代码紧密地用于 Azure 存储队列服务。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-218">Doing so will tightly couple your microservice code to the Azure Storage Queue service.</span></span> <span data-ttu-id="dc8cd-219">更好的做法是，隔离 API 的实现细节。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-219">It's a better practice to insulate the implementation details of the API.</span></span> <span data-ttu-id="dc8cd-220">引入公开泛型操作并封装具体库的 intermediation 层或中间 API。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-220">Introduce an intermediation layer, or intermediate API, that exposes generic operations and encapsulates the concrete library.</span></span> <span data-ttu-id="dc8cd-221">这种松散耦合使你能够将一个队列服务换出，而无需更改主线服务代码。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-221">This loose coupling enables you to swap out one queuing service for another without having to make changes to the mainline service code.</span></span>

<span data-ttu-id="dc8cd-222">Azure 存储队列是在你的云本机应用程序中实现命令消息传递的经济实惠的选项。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-222">Azure Storage queues are an economical option to implement command messaging in your cloud-native applications.</span></span> <span data-ttu-id="dc8cd-223">尤其是当队列大小超过 80 GB 时，或简单的功能集是可接受的。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-223">Especially when a queue size will exceed 80 GB, or a simple feature set is acceptable.</span></span> <span data-ttu-id="dc8cd-224">只需为消息存储付费;没有固定的每小时费用。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-224">You only pay for the storage of the messages; there are no fixed hourly charges.</span></span>

### <a name="azure-service-bus-queues"></a><span data-ttu-id="dc8cd-225">Azure 服务总线队列</span><span class="sxs-lookup"><span data-stu-id="dc8cd-225">Azure Service Bus Queues</span></span>

<span data-ttu-id="dc8cd-226">对于更复杂的消息传送要求，请考虑 Azure 服务总线队列。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-226">For more complex messaging requirements, consider Azure Service Bus queues.</span></span>

<span data-ttu-id="dc8cd-227">在强大的消息基础结构的顶部， [Azure 服务总线](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview)支持*中转消息传送模型*。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-227">Sitting atop a robust message infrastructure, [Azure Service Bus](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview) supports a *brokered messaging model*.</span></span> <span data-ttu-id="dc8cd-228">消息可靠地存储在代理（队列）中，直到使用者接收。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-228">Messages are reliably stored in a broker (the queue) until received by the consumer.</span></span> <span data-ttu-id="dc8cd-229">队列保证先进先出（FIFO）消息传递，与将消息添加到队列中的顺序相同。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-229">The queue guarantees First-In/First-Out (FIFO) message delivery, respecting the order in which messages were added to the queue.</span></span>

<span data-ttu-id="dc8cd-230">消息的大小可以大得多，最高可达 256 KB。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-230">The size of a message can be much larger, up to 256 KB.</span></span> <span data-ttu-id="dc8cd-231">消息在队列中保持无限长的时间。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-231">Messages are persisted in the queue for an unlimited period of time.</span></span> <span data-ttu-id="dc8cd-232">Service Bus 不仅支持基于 HTTP 的调用，而且还支持[AMPQ 协议](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-overview)的完全支持。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-232">Service Bus supports not only HTTP-based calls, but also provides full support for the [AMPQ protocol](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-overview).</span></span> <span data-ttu-id="dc8cd-233">AMPQ 是一种跨供应商的开放标准，支持二进制协议和更高的可靠性。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-233">AMPQ is an open-standard across vendors that supports a binary protocol and higher degrees of reliability.</span></span>

<span data-ttu-id="dc8cd-234">服务总线提供了一组丰富的功能，包括[事务支持](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions)和[重复检测功能](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection)。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-234">Service Bus provides a rich set of features, including [transaction support](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions) and a [duplicate detection feature](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection).</span></span> <span data-ttu-id="dc8cd-235">队列保证每条消息 "最多传递一次"。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-235">The queue guarantees "at most once delivery" per message.</span></span> <span data-ttu-id="dc8cd-236">它会自动丢弃已经发送的消息。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-236">It automatically discards a message that has already been sent.</span></span> <span data-ttu-id="dc8cd-237">如果制造者不确定，它可以重新发送相同的消息，服务总线保证只处理一个副本。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-237">If a producer is in doubt, it can resend the same message, and Service Bus guarantees that only one copy will be processed.</span></span> <span data-ttu-id="dc8cd-238">重复检测使你无需构建其他基础结构管道。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-238">Duplicate detection frees you from  having to build additional infrastructure plumbing.</span></span>

<span data-ttu-id="dc8cd-239">还有两个企业功能，即分区和会话。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-239">Two more enterprise features are partitioning and sessions.</span></span> <span data-ttu-id="dc8cd-240">常规服务总线队列由单个消息代理处理，并存储在单个消息存储区中。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-240">A conventional Service Bus queue is handled by a single message broker and stored in a single message store.</span></span> <span data-ttu-id="dc8cd-241">但是，[服务总线分区](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning)跨多个消息代理和消息存储分散队列。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-241">But, [Service Bus Partitioning](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) spreads the queue across multiple message brokers and message stores.</span></span> <span data-ttu-id="dc8cd-242">总体吞吐量不再受单个消息代理或消息存储的性能限制。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-242">The overall throughput is no longer limited by the performance of a single message broker or messaging store.</span></span> <span data-ttu-id="dc8cd-243">消息存储的临时中断不会导致分区的队列不可用。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-243">A temporary outage of a messaging store doesn't render a partitioned queue unavailable.</span></span>

<span data-ttu-id="dc8cd-244">[服务总线会话](https://codingcanvas.com/azure-service-bus-sessions/)提供了一种对相关消息进行分组的方法。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-244">[Service Bus Sessions](https://codingcanvas.com/azure-service-bus-sessions/) provide a way to group-related messages.</span></span> <span data-ttu-id="dc8cd-245">假设工作流方案中，消息必须一起处理并且操作在结束时完成。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-245">Imagine a workflow scenario where messages must be processed together and the operation completed at the end.</span></span> <span data-ttu-id="dc8cd-246">若要充分利用会话，必须为队列显式启用会话，并且每个相关消息必须包含相同的会话 ID。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-246">To take advantage, sessions must be explicitly enabled for the queue and each related messaged must contain the same session ID.</span></span>

<span data-ttu-id="dc8cd-247">但是，有一些重要的注意事项：服务总线队列大小限制为 80 GB，这比存储队列中的可用值小得多。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-247">However, there are some important caveats: Service Bus queues size is limited to 80 GB, which is much smaller than what's available from store queues.</span></span> <span data-ttu-id="dc8cd-248">此外，服务总线队列在每个操作中产生基本成本和费用。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-248">Additionally, Service Bus queues incur a base cost and charge per operation.</span></span>

<span data-ttu-id="dc8cd-249">图4-14 概述了服务总线队列的高级体系结构。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-249">Figure 4-14 outlines the high-level architecture of a Service Bus queue.</span></span>

![服务总线队列](./media/service-bus-queue.png)

<span data-ttu-id="dc8cd-251">图 4-14。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-251">**Figure 4-14**.</span></span> <span data-ttu-id="dc8cd-252">服务总线队列</span><span class="sxs-lookup"><span data-stu-id="dc8cd-252">Service Bus queue</span></span>

<span data-ttu-id="dc8cd-253">在上图中，请注意点到点关系。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-253">In the previous figure, note the point-to-point relationship.</span></span> <span data-ttu-id="dc8cd-254">同一个提供程序的两个实例将消息排队到单个服务总线队列。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-254">Two instances of the same provider are enqueuing messages into a single Service Bus queue.</span></span> <span data-ttu-id="dc8cd-255">每条消息仅由右侧三个使用者实例中的一个使用。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-255">Each message is consumed by only one of three consumer instances on the right.</span></span> <span data-ttu-id="dc8cd-256">接下来，我们将讨论如何实现消息传递，其中不同的使用者可能会对同一消息感兴趣。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-256">Next, we discuss how to implement messaging where different consumers may all be interested the same message.</span></span>

## <a name="events"></a><span data-ttu-id="dc8cd-257">事件</span><span class="sxs-lookup"><span data-stu-id="dc8cd-257">Events</span></span>

<span data-ttu-id="dc8cd-258">消息队列是实现通信的有效方法，在此方法中，制造者可以异步发送使用者 a 消息。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-258">Message queuing is an effective way to implement communication where a producer can asynchronously send a consumer a message.</span></span> <span data-ttu-id="dc8cd-259">但是，当*多个不同的使用者*对同一消息感兴趣时，会发生什么情况呢？</span><span class="sxs-lookup"><span data-stu-id="dc8cd-259">However, what happens when *many different consumers* are interested in the same message?</span></span> <span data-ttu-id="dc8cd-260">每个使用者的专用消息队列不能很好地进行缩放，因此很难管理。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-260">A dedicated message queue for each consumer wouldn't scale well and would become difficult to manage.</span></span>

<span data-ttu-id="dc8cd-261">为了应对这种情况，我们将转到第三种类型的消息交互（即*事件*）。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-261">To address this scenario, we move to the third type of message interaction, the *event*.</span></span> <span data-ttu-id="dc8cd-262">一个微服务宣布发生了某个操作。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-262">One microservice announces that an action had occurred.</span></span> <span data-ttu-id="dc8cd-263">其他微服务，如有兴趣，对操作或事件做出反应。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-263">Other microservices, if interested, react to the action, or event.</span></span>

<span data-ttu-id="dc8cd-264">事件是一个两步过程。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-264">Eventing is a two-step process.</span></span> <span data-ttu-id="dc8cd-265">对于给定状态更改，微服务向消息代理发布事件，使其可供任何其他感兴趣的微服务使用。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-265">For a given state change, a microservice publishes an event to a message broker, making it available to any other interested microservice.</span></span> <span data-ttu-id="dc8cd-266">相关的微服务会通过订阅消息代理中的事件获得通知。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-266">The interested microservice is notified by subscribing to the event in the message broker.</span></span> <span data-ttu-id="dc8cd-267">使用[发布/订阅](https://docs.microsoft.com/azure/architecture/patterns/publisher-subscriber)模式来实现[基于事件的通信](https://docs.microsoft.com/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/integration-event-based-microservice-communications)。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-267">You use the [Publish/Subscribe](https://docs.microsoft.com/azure/architecture/patterns/publisher-subscriber) pattern to implement [event-based communication](https://docs.microsoft.com/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/integration-event-based-microservice-communications).</span></span>

<span data-ttu-id="dc8cd-268">图4-15 显示了一个购物篮微服务，其中包含两个其他微服务订阅的事件。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-268">Figure 4-15 shows a shopping basket microservice publishing an event with two other microservices subscribing to it.</span></span>

![事件驱动的消息传递](./media/event-driven-messaging.png)

<span data-ttu-id="dc8cd-270">**图 4-15**。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-270">**Figure 4-15**.</span></span> <span data-ttu-id="dc8cd-271">事件驱动的消息传递</span><span class="sxs-lookup"><span data-stu-id="dc8cd-271">Event-Driven messaging</span></span>

<span data-ttu-id="dc8cd-272">请注意位于信道中间的*事件总线*组件。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-272">Note the *event bus* component that sits in the middle of the communication channel.</span></span> <span data-ttu-id="dc8cd-273">它是一个自定义类，它封装消息代理并将其与基础应用程序分离。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-273">It's a custom class that encapsulates the message broker and decouples it from the underlying application.</span></span> <span data-ttu-id="dc8cd-274">订购和库存微服务独立运营事件，无任何其他知识，也不会微服务购物篮。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-274">The ordering and inventory microservices independently operate the event with no knowledge of each other, nor the shopping basket microservice.</span></span> <span data-ttu-id="dc8cd-275">当注册的事件发布到事件总线时，它们会对其执行操作。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-275">When the registered event is published to the event bus, they act upon it.</span></span>

<span data-ttu-id="dc8cd-276">对于事件，我们将从队列技术转向*主题*。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-276">With eventing, we move from queuing technology to *topics*.</span></span> <span data-ttu-id="dc8cd-277">[主题](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)类似于队列，但支持一对多消息模式。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-277">A [topic](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions) is similar to a queue, but supports a one-to-many messaging pattern.</span></span> <span data-ttu-id="dc8cd-278">一个微服务发布一条消息。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-278">One microservice publishes a message.</span></span> <span data-ttu-id="dc8cd-279">多个订阅微服务可以选择接收并处理该消息。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-279">Multiple subscribing microservices can choose to receive and act upon that message.</span></span> <span data-ttu-id="dc8cd-280">图4-16 显示了一个主题体系结构。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-280">Figure 4-16 shows a topic architecture.</span></span>

![主题体系结构](./media/topic-architecture.png)

<span data-ttu-id="dc8cd-282">**图 4-16**。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-282">**Figure 4-16**.</span></span> <span data-ttu-id="dc8cd-283">主题体系结构</span><span class="sxs-lookup"><span data-stu-id="dc8cd-283">Topic architecture</span></span>

<span data-ttu-id="dc8cd-284">在上图中，发布服务器将消息发送到主题。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-284">In the previous figure, publishers send messages to the topic.</span></span> <span data-ttu-id="dc8cd-285">最终，订阅者从订阅接收消息。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-285">At the end, subscribers receive messages from subscriptions.</span></span> <span data-ttu-id="dc8cd-286">在中间，主题将基于一组*规则*将消息转发到订阅，如深蓝框中所示。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-286">In the middle, the topic forwards messages to subscriptions based on a set of *rules*, shown in dark blue boxes.</span></span> <span data-ttu-id="dc8cd-287">规则作为将特定消息转发到订阅的筛选器。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-287">Rules act as a filter that forward specific messages to a subscription.</span></span> <span data-ttu-id="dc8cd-288">此处，"CreateOrder" 事件将发送到订阅 \#1 和订阅 \#3，而不会发送到订阅 \#2。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-288">Here, a "CreateOrder" event would be sent to Subscription \#1 and Subscription \#3, but not to Subscription \#2.</span></span> <span data-ttu-id="dc8cd-289">"OrderCompleted" 事件将发送到订阅 \#2 和订阅 \#3。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-289">An "OrderCompleted" event would be sent to Subscription \#2 and Subscription \#3.</span></span>

<span data-ttu-id="dc8cd-290">Azure 云支持两个不同的主题服务： Azure 服务总线主题和 Azure EventGrid。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-290">The Azure cloud supports two different topic services: Azure Service Bus Topics and Azure EventGrid.</span></span>

### <a name="azure-service-bus-topics"></a><span data-ttu-id="dc8cd-291">Azure 服务总线主题</span><span class="sxs-lookup"><span data-stu-id="dc8cd-291">Azure Service Bus Topics</span></span>

<span data-ttu-id="dc8cd-292">在 Azure 服务总线队列的相同可靠的中转消息模型的基础上，是[Azure 服务总线主题](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-292">Sitting on top of the same robust brokered message model of Azure Service Bus queues are [Azure Service Bus Topics](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span> <span data-ttu-id="dc8cd-293">主题可以接收来自多个独立发布服务器的消息，并将消息发送到最多2000个订阅服务器。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-293">A topic can receive messages from multiple independent publishers and send messages to up to 2,000 subscribers.</span></span> <span data-ttu-id="dc8cd-294">订阅可以在运行时动态添加或删除，而无需停止系统或重新创建主题。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-294">Subscriptions can be dynamically added or removed at runtime without stopping the system or recreating the topic.</span></span>

<span data-ttu-id="dc8cd-295">Azure 服务总线队列中的许多高级功能也可用于主题，包括[重复检测](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection)和[事务支持](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions)。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-295">Many advanced features from Azure Service Bus queues are also available for topics, including [Duplicate Detection](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection) and [Transaction support](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions).</span></span> <span data-ttu-id="dc8cd-296">默认情况下，服务总线主题由单个消息代理处理，并存储在单个消息存储区中。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-296">By default, Service Bus topics are handled by a single message broker and stored in a single message store.</span></span> <span data-ttu-id="dc8cd-297">但是，[服务总线分区](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning)会通过将其分布到多个消息代理和消息存储区来缩放主题。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-297">But, [Service Bus Partitioning](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) scales a topic by spreading it across many message brokers and message stores.</span></span>

<span data-ttu-id="dc8cd-298">[计划的消息传递](https://docs.microsoft.com/azure/service-bus-messaging/message-sequencing)将标记有特定时间进行处理的消息。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-298">[Scheduled Message Delivery](https://docs.microsoft.com/azure/service-bus-messaging/message-sequencing) tags a message with a specific time for processing.</span></span> <span data-ttu-id="dc8cd-299">消息不会在该时间之前出现在主题中。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-299">The message won't appear in the topic before that time.</span></span> <span data-ttu-id="dc8cd-300">通过[消息延迟](https://docs.microsoft.com/azure/service-bus-messaging/message-deferral)，可以将消息的检索推迟到以后的某个时间进行。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-300">[Message Deferral](https://docs.microsoft.com/azure/service-bus-messaging/message-deferral) enables you to defer a retrieval of a message to a later time.</span></span> <span data-ttu-id="dc8cd-301">这两者通常用于工作流处理方案，在这些方案中，按特定顺序处理操作。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-301">Both are commonly used in workflow processing scenarios where operations are processed in a particular order.</span></span> <span data-ttu-id="dc8cd-302">您可以推迟收到的消息的处理，直到上一工作完成。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-302">You can postpone processing of received messages until prior work has been completed.</span></span>

<span data-ttu-id="dc8cd-303">Service Bus 主题是一项强大的、经过验证的技术，可用于在云本机系统中启用发布/订阅通信。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-303">Service Bus topics are a robust and proven technology for enabling publish/subscribe communication in your cloud-native systems.</span></span>

### <a name="azure-event-grid"></a><span data-ttu-id="dc8cd-304">Azure 事件网格</span><span class="sxs-lookup"><span data-stu-id="dc8cd-304">Azure Event Grid</span></span>

<span data-ttu-id="dc8cd-305">尽管 Azure 服务总线是已经过测试的、具有一整套企业功能的消息传递代理，但[Azure 事件网格](https://docs.microsoft.com/azure/event-grid/overview)是块上的新孩子。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-305">While Azure Service Bus is a battle-tested messaging broker with a full set of enterprise features, [Azure Event Grid](https://docs.microsoft.com/azure/event-grid/overview) is the new kid on the block.</span></span>

<span data-ttu-id="dc8cd-306">乍一看，事件网格可能只是另一个基于主题的消息系统。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-306">At first glance, Event Grid may look like just another topic-based messaging system.</span></span> <span data-ttu-id="dc8cd-307">但是，它在许多方面都是不同的。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-307">However, it's different in many ways.</span></span> <span data-ttu-id="dc8cd-308">它侧重于事件驱动的工作负荷，实现实时事件处理、深层 Azure 集成和开放平台的所有功能。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-308">Focused on event-driven workloads, it enables real-time event processing, deep Azure integration, and an open-platform - all on serverless infrastructure.</span></span> <span data-ttu-id="dc8cd-309">它适用于当代云本机和无服务器应用程序</span><span class="sxs-lookup"><span data-stu-id="dc8cd-309">It's designed for contemporary cloud-native and serverless applications</span></span>

<span data-ttu-id="dc8cd-310">作为集中式*事件底板*（或管道），事件网格可对 Azure 资源内的事件和来自你自己的服务的事件做出反应。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-310">As a centralized *eventing backplane*, or pipe, Event Grid reacts to events inside Azure resources and from your own services.</span></span>

<span data-ttu-id="dc8cd-311">事件通知发布到事件网格主题，后者又将每个事件路由到订阅。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-311">Event notifications are published to an Event Grid Topic, which, in turn, routes each event to a subscription.</span></span> <span data-ttu-id="dc8cd-312">订阅服务器映射到订阅并使用事件。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-312">Subscribers map to subscriptions and consume the events.</span></span> <span data-ttu-id="dc8cd-313">与 Service Bus 类似，事件网格还支持*经过筛选的订户模式*，其中的订阅会针对其想要接收的事件设置规则。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-313">Like Service Bus, Event Grid supports a *filtered subscriber model* where a subscription sets rule for the events it wishes to receive.</span></span> <span data-ttu-id="dc8cd-314">事件网格提供快速的吞吐量，每秒保证10000000事件，从而实现近乎实时的交付-远远超过了 Azure 服务总线可以生成的内容。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-314">Event Grid provides fast throughput with a guarantee of 10 million events per second enabling near real-time delivery - far more than what Azure Service Bus can generate.</span></span>

<span data-ttu-id="dc8cd-315">事件网格的一个非常适合的位置是它与 Azure 基础结构的结构的深度集成。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-315">A sweet spot for Event Grid is its deep integration into the fabric of Azure infrastructure.</span></span> <span data-ttu-id="dc8cd-316">Azure 资源（如 Cosmos DB）可以将内置事件直接发布到其他感兴趣的 Azure 资源，而无需自定义代码。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-316">An Azure resource, such as Cosmos DB, can publish built-in events directly to other interested Azure resources - without the need for custom code.</span></span> <span data-ttu-id="dc8cd-317">事件网格可以从 Azure 订阅、资源组或服务发布事件，使开发人员可以精细控制云资源的生命周期。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-317">Event Grid can publish events from an Azure Subscription, Resource Group, or Service, giving developers fine-grained control over the lifecycle of cloud resources.</span></span> <span data-ttu-id="dc8cd-318">不过，事件网格并不局限于 Azure。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-318">However, Event Grid isn't limited to Azure.</span></span> <span data-ttu-id="dc8cd-319">它是一个开放平台，可以使用发布自应用程序或第三方服务的自定义 HTTP 事件，并将事件路由到外部订阅服务器。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-319">It's an open platform that can consume custom HTTP events published from applications or third-party services and route events to external subscribers.</span></span>

<span data-ttu-id="dc8cd-320">在从 Azure 资源发布和订阅本机事件时，无需进行任何编码。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-320">When publishing and subscribing to native events from Azure resources, no coding is required.</span></span> <span data-ttu-id="dc8cd-321">通过简单的配置，可以将事件从一个 Azure 资源集成到另一个 Azure 资源，从而利用了主题和订阅的内置管道。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-321">With simple configuration, you can integrate events from one Azure resource to another leveraging built-in plumbing for Topics and Subscriptions.</span></span> <span data-ttu-id="dc8cd-322">图4-17 显示事件网格分析。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-322">Figure 4-17 shows the anatomy of Event Grid.</span></span>

![事件网格解析](./media/event-grid-anatomy.png)

<span data-ttu-id="dc8cd-324">**图 4-17**。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-324">**Figure 4-17**.</span></span> <span data-ttu-id="dc8cd-325">事件网格解析</span><span class="sxs-lookup"><span data-stu-id="dc8cd-325">Event Grid anatomy</span></span>

<span data-ttu-id="dc8cd-326">EventGrid 和服务总线之间的主要区别是基础*消息交换模式*。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-326">A major difference between EventGrid and Service Bus is the underlying *message exchange pattern*.</span></span>

<span data-ttu-id="dc8cd-327">服务总线实现了一个较旧的样式*请求模型*，其中下游订阅服务器积极轮询主题订阅中的新消息。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-327">Service Bus implements an older style *pull model* in which the downstream subscriber actively polls the topic subscription for new messages.</span></span> <span data-ttu-id="dc8cd-328">在优势上，此方法使订阅者能够完全控制其处理消息的速度。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-328">On the upside, this approach gives the subscriber full control of the pace at which it processes messages.</span></span> <span data-ttu-id="dc8cd-329">它控制在任意给定时间要处理的消息的时间和数量。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-329">It controls when and how many messages to process at any given time.</span></span> <span data-ttu-id="dc8cd-330">在处理之前，未读邮件保留在订阅中。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-330">Unread messages remain in the subscription until processed.</span></span> <span data-ttu-id="dc8cd-331">严重缺点是生成事件的时间与将该消息提取到订阅服务器进行处理之间的延迟时间。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-331">A significant shortcoming is the latency between the time the event is generated and the polling operation that pulls that message to the subscriber for processing.</span></span> <span data-ttu-id="dc8cd-332">此外，对于下一个事件，持续轮询的开销会消耗资源和资金。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-332">Also, the overhead of constant polling for the next event consumes resources and money.</span></span>

<span data-ttu-id="dc8cd-333">不过，EventGrid 是不同的。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-333">EventGrid, however, is different.</span></span> <span data-ttu-id="dc8cd-334">它实现了一种*推送模型*，在该模型中，事件会按接收发送到 EventHandlers，从而提供近乎实时的事件传递。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-334">It implements a *push model* in which events are sent to the EventHandlers as received, giving near real-time event delivery.</span></span> <span data-ttu-id="dc8cd-335">它还可降低成本，因为服务仅在需要使用事件时触发，而不是在轮询期间持续。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-335">It also reduces cost as the service is triggered only when it's needed to consume an event – not continually as with polling.</span></span> <span data-ttu-id="dc8cd-336">也就是说，事件处理程序必须处理传入的负载并提供阻止机制，以防止其成为不堪。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-336">That said, an event handler must handle the incoming load and provide throttling mechanisms to protect itself from becoming overwhelmed.</span></span> <span data-ttu-id="dc8cd-337">许多使用这些事件的 Azure 服务（例如 Azure Functions 和逻辑应用）提供自动自动缩放功能来处理增加的负载。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-337">Many Azure services that consume these events, such as Azure Functions and Logic Apps provide automatic autoscaling capabilities to handle increased loads.</span></span>  

<span data-ttu-id="dc8cd-338">事件网格是一种完全托管的无服务器云服务。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-338">Event Grid is a fully managed serverless cloud service.</span></span> <span data-ttu-id="dc8cd-339">它可根据流量动态缩放，并仅对实际使用情况收费，而不是预先购买的容量。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-339">It dynamically scales based on your traffic and charges you only for your actual usage, not pre-purchased capacity.</span></span> <span data-ttu-id="dc8cd-340">每个月的前100000个操作是免费的–定义为事件入口（传入事件通知）、订阅传递尝试、管理调用和按主题筛选的操作。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-340">The first 100,000 operations per month are free – operations being defined as event ingress (incoming event notifications), subscription delivery attempts, management calls, and filtering by subject.</span></span> <span data-ttu-id="dc8cd-341">使用99.99% 的可用性，EventGrid 保证在24小时内交付事件，并使用内置重试功能实现不成功的传递。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-341">With 99.99% availability, EventGrid guarantees the delivery of an event within a 24-hour period, with built-in retry functionality for unsuccessful delivery.</span></span> <span data-ttu-id="dc8cd-342">未传递的消息可以移动到 "死信" 队列以解决问题。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-342">Undelivered messages can be moved to a "dead-letter" queue for resolution.</span></span>  <span data-ttu-id="dc8cd-343">不同于 Azure 服务总线，事件网格进行优化以实现快速性能，并且不支持排序消息、事务和会话等功能。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-343">Unlike Azure Service Bus, Event Grid is tuned for fast performance and doesn't support features like ordered messaging, transactions, and sessions.</span></span>

### <a name="streaming-messages-in-the-azure-cloud"></a><span data-ttu-id="dc8cd-344">在 Azure 云中传输消息</span><span class="sxs-lookup"><span data-stu-id="dc8cd-344">Streaming messages in the Azure cloud</span></span>

<span data-ttu-id="dc8cd-345">Azure 服务总线和事件网格为公开单一独立事件（例如新 Cosmos DB 文档）的应用程序提供了很大的支持。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-345">Azure Service Bus and Event Grid provide great support for applications that expose single, discrete events like a new document has been inserted into a Cosmos DB.</span></span> <span data-ttu-id="dc8cd-346">但是，如果您的云本机系统需要处理*相关事件流*，该怎么办？</span><span class="sxs-lookup"><span data-stu-id="dc8cd-346">But, what if your cloud-native system needs to process a *stream of related events*?</span></span> <span data-ttu-id="dc8cd-347">[事件流](https://docs.microsoft.com/archive/msdn-magazine/2015/february/microsoft-azure-the-rise-of-event-stream-oriented-systems)更复杂。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-347">[Event streams](https://docs.microsoft.com/archive/msdn-magazine/2015/february/microsoft-azure-the-rise-of-event-stream-oriented-systems) are more complex.</span></span> <span data-ttu-id="dc8cd-348">它们通常是按时间顺序排列的、相互关联的，并且必须作为一个组进行处理。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-348">They're typically time-ordered, interrelated, and must be processed as a group.</span></span>

<span data-ttu-id="dc8cd-349">[Azure 事件中心](https://azure.microsoft.com/services/event-hubs/)是一种数据流式处理平台和事件引入服务，可收集、转换和存储事件。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-349">[Azure Event Hub](https://azure.microsoft.com/services/event-hubs/) is a data streaming platform and event ingestion service that collects, transforms, and stores events.</span></span> <span data-ttu-id="dc8cd-350">它经过优化，可捕获流式处理数据，如从遥测上下文发出的连续事件通知。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-350">It's fine-tuned to capture streaming data, such as continuous event notifications emitted from a telemetry context.</span></span> <span data-ttu-id="dc8cd-351">此服务可高度缩放，每秒可以存储和[处理数百万事件](https://docs.microsoft.com/azure/event-hubs/event-hubs-about)。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-351">The service is highly scalable and can store and [process millions of events per second](https://docs.microsoft.com/azure/event-hubs/event-hubs-about).</span></span> <span data-ttu-id="dc8cd-352">图4-18 所示，它通常是事件管道的前门，它将插入流与事件使用分离。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-352">Shown in Figure 4-18, it's often a front door for an event pipeline, decoupling ingest stream from event consumption.</span></span>

![Azure 事件中心](./media/azure-event-hub.png)

<span data-ttu-id="dc8cd-354">**图 4-18**.</span><span class="sxs-lookup"><span data-stu-id="dc8cd-354">**Figure 4-18**.</span></span> <span data-ttu-id="dc8cd-355">Azure 事件中心</span><span class="sxs-lookup"><span data-stu-id="dc8cd-355">Azure Event Hub</span></span>

<span data-ttu-id="dc8cd-356">事件中心支持低延迟和可配置的时间保留。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-356">Event Hub supports low latency and configurable time retention.</span></span> <span data-ttu-id="dc8cd-357">与队列和主题不同，事件中心会在被使用者读取后保留事件数据。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-357">Unlike queues and topics, Event Hubs keep event data after it's been read by a consumer.</span></span> <span data-ttu-id="dc8cd-358">此功能使其他数据分析服务（内部和外部）能够重播数据以供进一步分析。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-358">This feature enables other data analytic services, both internal and external, to replay the data for further analysis.</span></span> <span data-ttu-id="dc8cd-359">存储在事件中心中的事件只会在保留期到期时删除，默认情况下为一天，但可配置。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-359">Events stored in event hub are only deleted upon expiration of the retention period, which is one day by default, but configurable.</span></span>

<span data-ttu-id="dc8cd-360">事件中心支持常见的事件发布协议，包括 HTTPS 和 AMQP。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-360">Event Hub supports common event publishing protocols including HTTPS and AMQP.</span></span> <span data-ttu-id="dc8cd-361">它还支持 Kafka 1.0。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-361">It also supports Kafka 1.0.</span></span> <span data-ttu-id="dc8cd-362">[现有的 Kafka 应用程序可使用 Kafka 协议与事件中心进行通信](https://docs.microsoft.com/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview)，该协议提供了管理大型 Kafka 群集的替代方法。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-362">[Existing Kafka applications can communicate with Event Hub](https://docs.microsoft.com/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview) using the Kafka protocol providing an alternative to managing large Kafka clusters.</span></span> <span data-ttu-id="dc8cd-363">许多开源云本机系统都接受 Kafka。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-363">Many open-source cloud-native systems embrace Kafka.</span></span>

<span data-ttu-id="dc8cd-364">事件中心通过[分区使用者模型](https://docs.microsoft.com/azure/event-hubs/event-hubs-features)实现消息流式处理，其中每个使用者只读取消息流的特定子集或分区。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-364">Event Hubs implements message streaming through a [partitioned consumer model](https://docs.microsoft.com/azure/event-hubs/event-hubs-features) in which each consumer only reads a specific subset, or partition, of the message stream.</span></span> <span data-ttu-id="dc8cd-365">此模式允许以极大的水平缩放规模进行事件处理，并提供队列和主题所不能提供的其他面向流的功能。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-365">This pattern enables tremendous horizontal scale for event processing and provides other stream-focused features that are unavailable in queues and topics.</span></span> <span data-ttu-id="dc8cd-366">分区是事件中心内保留的有序事件。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-366">A partition is an ordered sequence of events that is held in an event hub.</span></span> <span data-ttu-id="dc8cd-367">当较新的事件到达时，它们将被添加到此序列的末尾。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-367">As newer events arrive, they're added to the end of this sequence.</span></span><span data-ttu-id="dc8cd-368"> 图4-19 显示事件中心中的分区。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-368"> Figure 4-19 shows partitioning in an Event Hub.</span></span>

![事件中心分区](./media/event-hub-partitioning.png)

<span data-ttu-id="dc8cd-370">**图 4-19**.</span><span class="sxs-lookup"><span data-stu-id="dc8cd-370">**Figure 4-19**.</span></span> <span data-ttu-id="dc8cd-371">事件中心分区</span><span class="sxs-lookup"><span data-stu-id="dc8cd-371">Event Hub partitioning</span></span>

<span data-ttu-id="dc8cd-372">每个使用者组读取消息流的一个子集或分区，而不是从同一资源中进行读取。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-372">Instead of reading from the same resource, each consumer group reads across a subset, or partition, of the message stream.</span></span>

<span data-ttu-id="dc8cd-373">对于必须流式处理大量事件的云本机应用程序，Azure 事件中心可以是一个功能强大且经济实惠的解决方案。</span><span class="sxs-lookup"><span data-stu-id="dc8cd-373">For cloud-native applications that must stream large numbers of events, Azure Event Hub can be a robust and affordable solution.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="dc8cd-374">[上一页](front-end-communication.md)
>[下一页](rest-grpc.md)</span><span class="sxs-lookup"><span data-stu-id="dc8cd-374">[Previous](front-end-communication.md)
[Next](rest-grpc.md)</span></span>
