---
title: gRPC
description: 了解 gRPC，它在云本机应用程序中的作用，以及它与 HTTP RESTful 通信有何不同。
author: robvet
ms.date: 05/13/2020
ms.openlocfilehash: f34b267d7f5c6b4e593841c80df44d1ccbde95ae
ms.sourcegitcommit: 27db07ffb26f76912feefba7b884313547410db5
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/19/2020
ms.locfileid: "83614040"
---
# <a name="grpc"></a><span data-ttu-id="9d4fa-103">gRPC</span><span class="sxs-lookup"><span data-stu-id="9d4fa-103">gRPC</span></span>

<span data-ttu-id="9d4fa-104">到目前为止，我们致力于[基于 REST 的](https://docs.microsoft.com/azure/architecture/best-practices/api-design)通信。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-104">So far in this book, we've focused on [REST-based](https://docs.microsoft.com/azure/architecture/best-practices/api-design) communication.</span></span> <span data-ttu-id="9d4fa-105">我们已经看到，REST 是一种灵活的体系结构样式，它定义了对实体资源的基于 CRUD 的操作。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-105">We've seen that REST is a flexible architectural style that defines CRUD-based operations against entity resources.</span></span> <span data-ttu-id="9d4fa-106">客户端使用请求/响应通信模型跨 HTTP 与资源进行交互。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-106">Clients interact with resources across HTTP with a request/response communication model.</span></span> <span data-ttu-id="9d4fa-107">尽管 REST 是广泛实现的，但一种较新的通信技术 gRPC 已在云本机社区中获得巨大的动力。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-107">While REST is widely implemented, a newer communication technology, gRPC, has gained tremendous momentum across the cloud-native community.</span></span>

## <a name="what-is-grpc"></a><span data-ttu-id="9d4fa-108">什么是 gRPC？</span><span class="sxs-lookup"><span data-stu-id="9d4fa-108">What is gRPC?</span></span>

<span data-ttu-id="9d4fa-109">gRPC 是一种新式的高性能框架，可发展旧的[远程过程调用（RPC）](https://en.wikipedia.org/wiki/Remote_procedure_call)协议。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-109">gRPC is a modern, high-performance framework that evolves the age-old [remote procedure call (RPC)](https://en.wikipedia.org/wiki/Remote_procedure_call) protocol.</span></span> <span data-ttu-id="9d4fa-110">在应用程序级别，gRPC 简化了客户端和后端服务之间的消息传送。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-110">At the application level, gRPC streamlines messaging between clients and back-end services.</span></span> <span data-ttu-id="9d4fa-111">GRPC 源自 Google，是云本机产品/服务的开放源和[云本机计算基础（CNCF）](https://www.cncf.io/)生态系统的一部分。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-111">Originating from Google, gRPC is open source and part of the  [Cloud Native Computing Foundation (CNCF)](https://www.cncf.io/) ecosystem of cloud-native offerings.</span></span> <span data-ttu-id="9d4fa-112">CNCF 考虑 gRPC[孵化项目](https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc)。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-112">CNCF considers gRPC an [incubating project](https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc).</span></span> <span data-ttu-id="9d4fa-113">孵化表示最终用户在生产应用程序中使用技术，而项目的参与者数量是正常的。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-113">Incubating means end users are using the technology in production applications, and the project has a healthy number of contributors.</span></span>

<span data-ttu-id="9d4fa-114">典型的 gRPC 客户端应用程序将公开一个用于实现业务操作的本地进程内函数。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-114">A typical gRPC client app will expose a local, in-process function that implements a business operation.</span></span> <span data-ttu-id="9d4fa-115">在这种情况下，该本地函数调用远程计算机上的另一个函数。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-115">Under the covers, that local function invokes another function on a remote machine.</span></span> <span data-ttu-id="9d4fa-116">本地调用似乎是对远程服务的透明进程外调用。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-116">What appears to be a local call essentially becomes a transparent out-of-process call to a remote service.</span></span> <span data-ttu-id="9d4fa-117">RPC 管道对计算机之间的点到点网络通信、序列化和执行进行了抽象。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-117">The RPC plumbing abstracts the point-to-point networking communication, serialization, and execution between computers.</span></span>

<span data-ttu-id="9d4fa-118">在云本机应用程序中，开发人员通常跨编程语言、框架和技术。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-118">In cloud-native applications, developers often work across programming languages, frameworks, and technologies.</span></span> <span data-ttu-id="9d4fa-119">此*互操作性*使消息协定和跨平台通信所需的管道复杂化。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-119">This *interoperability* complicates message contracts and the plumbing required for cross-platform communication.</span></span>  <span data-ttu-id="9d4fa-120">gRPC 提供了一个 "统一的水平层" 来抽象这些问题。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-120">gRPC provides a "uniform horizontal layer" that abstracts these concerns.</span></span> <span data-ttu-id="9d4fa-121">开发人员代码在其本地平台上侧重于业务功能，而 gRPC 则负责处理通信。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-121">Developers code in their native platform focused on business functionality, while gRPC handles communication plumbing.</span></span>

<span data-ttu-id="9d4fa-122">gRPC 提供跨最常见开发堆栈（包括 Java、JavaScript、c #、中转、Swift 和 NodeJS）的全面支持。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-122">gRPC offers comprehensive support across most popular development stacks, including Java, JavaScript, C#, Go, Swift, and NodeJS.</span></span>

## <a name="grpc-benefits"></a><span data-ttu-id="9d4fa-123">gRPC 权益</span><span class="sxs-lookup"><span data-stu-id="9d4fa-123">gRPC Benefits</span></span>

<span data-ttu-id="9d4fa-124">gRPC 对其传输协议使用 HTTP/2。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-124">gRPC uses HTTP/2 for its transport protocol.</span></span> <span data-ttu-id="9d4fa-125">与 HTTP 1.1 兼容，HTTP/2 功能很多高级功能：</span><span class="sxs-lookup"><span data-stu-id="9d4fa-125">While compatible with HTTP 1.1, HTTP/2 features many advanced capabilities:</span></span>

- <span data-ttu-id="9d4fa-126">用于数据传输的二进制协议-不同于 HTTP 1.1，后者以明文形式发送数据。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-126">A binary protocol for data transport - unlike HTTP 1.1, which sends data as clear text.</span></span>
- <span data-ttu-id="9d4fa-127">多路复用支持通过同一连接发送多个并行请求-HTTP 1.1 限制处理一次请求/响应消息。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-127">Multiplexing support for sending multiple parallel requests over the same connection - HTTP 1.1 limits processing to one request/response message at a time.</span></span>
- <span data-ttu-id="9d4fa-128">同时发送客户端请求和服务器响应的双向全双工通信。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-128">Bidirectional full-duplex communication for sending both client requests and server responses simultaneously.</span></span>
- <span data-ttu-id="9d4fa-129">内置流式处理可对大型数据集进行异步流式处理的请求和响应。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-129">Built-in streaming enabling requests and responses to asynchronously stream large data sets.</span></span>

<span data-ttu-id="9d4fa-130">gRPC 是轻型且高性能的。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-130">gRPC is lightweight and highly performant.</span></span> <span data-ttu-id="9d4fa-131">与 JSON 序列化相比，与 JSON 序列化相比，它的最高速率为60-80%。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-131">It can be up to 8x faster than JSON serialization with messages 60-80% smaller.</span></span> <span data-ttu-id="9d4fa-132">在 Microsoft [Windows Communication Foundation （WCF）](https://docs.microsoft.com/dotnet/framework/wcf/whats-wcf)行话中，gRPC 性能超出了高度优化的[wcf-nettcp 绑定](https://docs.microsoft.com/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8)的速度和效率。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-132">In Microsoft [Windows Communication Foundation (WCF)](https://docs.microsoft.com/dotnet/framework/wcf/whats-wcf) parlance, gRPC performance exceeds the speed and efficiency of the highly optimized [NetTCP bindings](https://docs.microsoft.com/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8).</span></span> <span data-ttu-id="9d4fa-133">不同于 Microsoft stack 的 Wcf-nettcp，gRPC 是跨平台的。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-133">Unlike NetTCP, which favors the Microsoft stack, gRPC is cross-platform.</span></span>

## <a name="protocol-buffers"></a><span data-ttu-id="9d4fa-134">协议缓冲区</span><span class="sxs-lookup"><span data-stu-id="9d4fa-134">Protocol Buffers</span></span>

<span data-ttu-id="9d4fa-135">gRPC 拥有称为[协议缓冲区](https://developers.google.com/protocol-buffers/docs/overview)的开源技术。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-135">gRPC embraces an open-source technology called [Protocol Buffers](https://developers.google.com/protocol-buffers/docs/overview).</span></span> <span data-ttu-id="9d4fa-136">它们提供了一种高效且平台中立的序列化格式，用于序列化服务相互发送的结构化消息。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-136">They provide a highly efficient and platform-neutral serialization format for serializing structured messages that services send to each other.</span></span> <span data-ttu-id="9d4fa-137">开发人员使用跨平台接口定义语言（IDL）为每个微服务定义服务协定。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-137">Using a cross-platform Interface Definition Language (IDL), developers define a service contract for each microservice.</span></span> <span data-ttu-id="9d4fa-138">作为基于文本的文件实现的协定将 `.proto` 描述每个服务的方法、输入和输出。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-138">The contract, implemented as a text-based `.proto` file, describes the methods, inputs, and outputs for each service.</span></span> <span data-ttu-id="9d4fa-139">同一约定文件可用于在不同开发平台上构建的 gRPC 客户端和服务。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-139">The same contract file can be used for gRPC clients and services built on different development platforms.</span></span>

<span data-ttu-id="9d4fa-140">使用 proto 文件，Protobuf 编译器 `protoc` 生成目标平台的客户端和服务代码。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-140">Using the proto file, the Protobuf compiler, `protoc`, generates both client and service code for your target platform.</span></span> <span data-ttu-id="9d4fa-141">此代码包括以下组件：</span><span class="sxs-lookup"><span data-stu-id="9d4fa-141">The code includes the following components:</span></span>

- <span data-ttu-id="9d4fa-142">由客户端和服务共享的强类型对象，表示消息的服务操作和数据元素。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-142">Strongly-typed objects, shared by the client and service, that represent the service operations and data elements for a message.</span></span>
- <span data-ttu-id="9d4fa-143">一个强类型的基类，其中包含远程 gRPC 服务可以继承和扩展的必需的网络管道。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-143">A strongly-typed base class with the required network plumbing that the remote gRPC service can inherit and extend.</span></span>
- <span data-ttu-id="9d4fa-144">包含调用远程 gRPC 服务所需的管道的客户端存根。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-144">A client stub that contains the required plumbing to invoke the remote gRPC service.</span></span>

<span data-ttu-id="9d4fa-145">在运行时，每条消息都序列化为标准 Protobuf 表示形式，并在客户端和远程服务之间交换。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-145">At runtime, each message is serialized as a standard Protobuf representation and exchanged between the client and remote service.</span></span> <span data-ttu-id="9d4fa-146">与 JSON 或 XML 不同，Protobuf 消息会序列化为已编译的二进制字节。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-146">Unlike JSON or XML, Protobuf messages are serialized as compiled binary bytes.</span></span>

<span data-ttu-id="9d4fa-147">Microsoft 体系结构站点提供了[gRPC FOR WCF 开发人员](https://docs.microsoft.com/dotnet/architecture/grpc-for-wcf-developers/)的书籍，提供了 GRPC 和协议缓冲区的深入介绍。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-147">The book, [gRPC for WCF Developers](https://docs.microsoft.com/dotnet/architecture/grpc-for-wcf-developers/), available from the Microsoft Architecture site, provides in-depth coverage of gRPC and Protocol Buffers.</span></span>

## <a name="grpc-support-in-net"></a><span data-ttu-id="9d4fa-148">.NET 中的 gRPC 支持</span><span class="sxs-lookup"><span data-stu-id="9d4fa-148">gRPC support in .NET</span></span>

<span data-ttu-id="9d4fa-149">gRPC 集成到 .NET Core 3.0 SDK 和更高版本中。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-149">gRPC is integrated into .NET Core 3.0 SDK and later.</span></span> <span data-ttu-id="9d4fa-150">以下工具支持它：</span><span class="sxs-lookup"><span data-stu-id="9d4fa-150">The following tools support it:</span></span>

- <span data-ttu-id="9d4fa-151">安装了 web 开发工作负荷的 Visual Studio 2019、版本16.3 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-151">Visual Studio 2019, version 16.3 or later, with the web development workload installed.</span></span>
- <span data-ttu-id="9d4fa-152">Visual Studio Code</span><span class="sxs-lookup"><span data-stu-id="9d4fa-152">Visual Studio Code</span></span>
- <span data-ttu-id="9d4fa-153">dotnet CLI</span><span class="sxs-lookup"><span data-stu-id="9d4fa-153">the dotnet CLI</span></span>

<span data-ttu-id="9d4fa-154">SDK 包括用于终结点路由、内置 IoC 和日志记录的工具。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-154">The SDK includes tooling for endpoint routing, built-in IoC, and logging.</span></span> <span data-ttu-id="9d4fa-155">开源 Kestrel web 服务器支持 HTTP/2 连接。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-155">The open-source Kestrel web server supports HTTP/2 connections.</span></span> <span data-ttu-id="9d4fa-156">图4-20 显示了一个 Visual Studio 2019 模板，该模板基架了 gRPC 服务的主干项目。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-156">Figure 4-20 shows a Visual Studio 2019 template that scaffolds a skeleton project for a gRPC service.</span></span> <span data-ttu-id="9d4fa-157">请注意 .NET Core 如何完全支持 Windows、Linux 和 macOS。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-157">Note how .NET Core fully supports Windows, Linux, and macOS.</span></span>

![Visual Studio 2019 中的 gRPC 支持](./media/visual-studio-2019-grpc-template.png)

<span data-ttu-id="9d4fa-159">图 4-20\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-159">**Figure 4-20**.</span></span> <span data-ttu-id="9d4fa-160">Visual Studio 2019 中的 gRPC 支持</span><span class="sxs-lookup"><span data-stu-id="9d4fa-160">gRPC support in Visual Studio 2019</span></span>
  
<span data-ttu-id="9d4fa-161">图4-21 显示了 Visual Studio 2019 中包含的内置基架生成的主干 gRPC 服务。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-161">Figure 4-21 shows the skeleton gRPC service generated from the built-in scaffolding included in Visual Studio 2019.</span></span>  

![Visual Studio 2019 中的 gRPC 项目](./media/grpc-project.png  )

<span data-ttu-id="9d4fa-163">图 4-21  。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-163">**Figure 4-21**.</span></span> <span data-ttu-id="9d4fa-164">Visual Studio 2019 中的 gRPC 项目</span><span class="sxs-lookup"><span data-stu-id="9d4fa-164">gRPC project in Visual Studio 2019</span></span>

<span data-ttu-id="9d4fa-165">在上图中，记下 proto 说明文件和服务代码。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-165">In the previous figure, note the proto description file and service code.</span></span> <span data-ttu-id="9d4fa-166">正如您很快将看到的那样，Visual Studio 会在 Startup 类和基础项目文件中同时生成附加配置。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-166">As you'll see shortly, Visual Studio generates additional configuration in both the Startup class and underlying project file.</span></span>

## <a name="grpc-usage"></a><span data-ttu-id="9d4fa-167">gRPC 用法</span><span class="sxs-lookup"><span data-stu-id="9d4fa-167">gRPC usage</span></span>

<span data-ttu-id="9d4fa-168">为以下方案优选 gRPC：</span><span class="sxs-lookup"><span data-stu-id="9d4fa-168">Favor gRPC for the following scenarios:</span></span>

- <span data-ttu-id="9d4fa-169">同步后端微服务到微服务的通信，需要立即响应才能继续处理。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-169">Synchronous backend microservice-to-microservice communication where an immediate response is required to continue processing.</span></span>
- <span data-ttu-id="9d4fa-170">需要支持混合编程平台的 Polyglot 环境。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-170">Polyglot environments that need to support mixed programming platforms.</span></span>
- <span data-ttu-id="9d4fa-171">低延迟和高吞吐量通信，其中的性能至关重要。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-171">Low latency and high throughput communication where performance is critical.</span></span>
- <span data-ttu-id="9d4fa-172">点到点实时通信-gRPC 可以实时推送消息而无需轮询，并对双向流式处理提供了极佳支持。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-172">Point-to-point real-time communication - gRPC can push messages in real time without polling and has excellent support for bi-directional streaming.</span></span>
- <span data-ttu-id="9d4fa-173">网络约束环境–二进制 gRPC 消息始终小于等效的基于文本的 JSON 消息。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-173">Network constrained environments – binary gRPC messages are always smaller than an equivalent text-based JSON message.</span></span>

<span data-ttu-id="9d4fa-174">在撰写本文时，gRPC 主要用于后端服务。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-174">At the time, of this writing, gRPC is primarily used with backend services.</span></span> <span data-ttu-id="9d4fa-175">大多数新式浏览器不能提供支持前端 gRPC 客户端所需的 HTTP/2 控制级别。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-175">Most modern browsers can't provide the level of HTTP/2 control required to support a front-end gRPC client.</span></span> <span data-ttu-id="9d4fa-176">这就是，这是一项[早期的计划](https://devblogs.microsoft.com/aspnet/grpc-web-experiment/)，可让你从使用 JavaScript 或 Blazor WebAssembly 技术生成的基于浏览器的应用 gRPC 通信。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-176">That said, there's an [early initiative](https://devblogs.microsoft.com/aspnet/grpc-web-experiment/) that enables gRPC communication from browser-based apps built with JavaScript or Blazor WebAssembly technologies.</span></span> <span data-ttu-id="9d4fa-177">[GRPC for .net](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md)允许 ASP.NET Core gRPC 应用在浏览器应用中支持 gRPC 功能：</span><span class="sxs-lookup"><span data-stu-id="9d4fa-177">The  [gRPC-Web for .NET](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md) enables an ASP.NET Core gRPC app to support gRPC features in browser apps:</span></span>

- <span data-ttu-id="9d4fa-178">强类型代码生成的客户端</span><span class="sxs-lookup"><span data-stu-id="9d4fa-178">Strongly-typed code-generated clients</span></span>
- <span data-ttu-id="9d4fa-179">Compact Protobuf 消息</span><span class="sxs-lookup"><span data-stu-id="9d4fa-179">Compact Protobuf messages</span></span>
- <span data-ttu-id="9d4fa-180">服务器流式处理</span><span class="sxs-lookup"><span data-stu-id="9d4fa-180">Server streaming</span></span>

## <a name="grpc-implementation"></a><span data-ttu-id="9d4fa-181">gRPC 实现</span><span class="sxs-lookup"><span data-stu-id="9d4fa-181">gRPC implementation</span></span>

<span data-ttu-id="9d4fa-182">Microsoft 的[容器上](https://github.com/dotnet-architecture/eShopOnContainers)的微服务参考体系结构 eShop，演示了如何在 .net Core 应用程序中实现 gRPC 服务。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-182">The microservice reference architecture, [eShop on Containers](https://github.com/dotnet-architecture/eShopOnContainers), from Microsoft, shows how to implement gRPC services in .NET Core applications.</span></span> <span data-ttu-id="9d4fa-183">图4-22 显示后端体系结构。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-183">Figure 4-22 presents the back-end architecture.</span></span>

![容器上的 eShop 的后端体系结构](./media/eshop-with-aggregators.png)

<span data-ttu-id="9d4fa-185">**图 4-22**。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-185">**Figure 4-22**.</span></span> <span data-ttu-id="9d4fa-186">容器上的 eShop 的后端体系结构</span><span class="sxs-lookup"><span data-stu-id="9d4fa-186">Backend architecture for eShop on Containers</span></span>

<span data-ttu-id="9d4fa-187">在上图中，请注意 eShop 如何通过公开多个 API 网关来使用前端模式（BFF）的[后端](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends)。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-187">In the previous figure, note how eShop embraces the [Backend for Frontends pattern](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends) (BFF) by exposing multiple API gateways.</span></span> <span data-ttu-id="9d4fa-188">本章前面介绍了 BFF 模式。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-188">We discussed the BFF pattern earlier in this chapter.</span></span> <span data-ttu-id="9d4fa-189">请密切注意位于 Web 购物 API 网关和后端购物微服务之间的聚合器微服务（灰）。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-189">Pay close attention to the Aggregator microservice (in gray) that sits between the Web-Shopping API Gateway and backend Shopping microservices.</span></span> <span data-ttu-id="9d4fa-190">聚合器接收来自客户端的单个请求，将其调度到不同的微服务，聚合结果并将其发送回发出请求的客户端。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-190">The Aggregator receives a single request from a client, dispatches it to various microservices, aggregates the results, and sends them back to the requesting client.</span></span> <span data-ttu-id="9d4fa-191">此类操作通常需要同步通信，才能生成立即响应。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-191">Such operations typically require synchronous communication as to produce an immediate response.</span></span> <span data-ttu-id="9d4fa-192">在 eShop 中，使用 gRPC 执行从聚合器的后端调用，如图4-23 所示。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-192">In eShop, backend calls from the Aggregator are performed using gRPC as shown in Figure 4-23.</span></span>

![容器的 eShop 中的 gRPC](./media/grpc-implementation.png)

<span data-ttu-id="9d4fa-194">图 4-23  。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-194">**Figure 4-23**.</span></span> <span data-ttu-id="9d4fa-195">容器的 eShop 中的 gRPC</span><span class="sxs-lookup"><span data-stu-id="9d4fa-195">gRPC in eShop on Containers</span></span>

<span data-ttu-id="9d4fa-196">gRPC 通信需要客户端和服务器组件。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-196">gRPC communication requires both client and server components.</span></span> <span data-ttu-id="9d4fa-197">在上图中，请注意购物聚合器如何实现 gRPC 客户端。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-197">In the previous figure, note how the Shopping Aggregator implements a gRPC client.</span></span> <span data-ttu-id="9d4fa-198">客户端将同步 gRPC 调用（以红色表示）给后端微服务，每个调用都实现 gRPC 服务器。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-198">The client makes synchronous gRPC calls (in red) to backend microservices, each of which implement a gRPC server.</span></span> <span data-ttu-id="9d4fa-199">客户端和服务器都利用 .NET Core SDK 中内置的 gRPC 管道。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-199">Both the client and server take advantage of the built-in gRPC plumbing from the .NET Core SDK.</span></span> <span data-ttu-id="9d4fa-200">客户端*存根*提供用于调用远程 gRPC 调用的管道。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-200">Client-side *stubs* provide the plumbing to invoke remote gRPC calls.</span></span> <span data-ttu-id="9d4fa-201">服务器端组件提供自定义服务类可以继承和使用的 gRPC 管道。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-201">Server-side components provide gRPC plumbing that custom service classes can inherit and consume.</span></span>

<span data-ttu-id="9d4fa-202">同时公开 RESTful API 和 gRPC 通信的微服务需要使用多个终结点来管理流量。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-202">Microservices that expose both a RESTful API and gRPC communication require multiple endpoints to manage traffic.</span></span> <span data-ttu-id="9d4fa-203">你将打开一个终结点，该终结点侦听 RESTful 调用的 HTTP 流量，另一个用于 gRPC 调用。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-203">You would open an endpoint that listens for HTTP traffic for the RESTful calls and another for gRPC calls.</span></span> <span data-ttu-id="9d4fa-204">必须为 gRPC 通信所需的 HTTP/2 协议配置 gRPC 终结点。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-204">The gRPC endpoint must be configured for the HTTP/2 protocol that is required for gRPC communication.</span></span>

<span data-ttu-id="9d4fa-205">尽管我们正在努力将微服务与异步通信模式分离，但某些操作需要直接调用。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-205">While we strive to decouple microservices with asynchronous communication patterns, some operations require direct calls.</span></span> <span data-ttu-id="9d4fa-206">gRPC 应该是微服务之间直接同步通信的主要选择。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-206">gRPC should be the primary choice for direct synchronous communication between microservices.</span></span> <span data-ttu-id="9d4fa-207">基于 HTTP/2 和协议缓冲区的高性能通信协议使其成为最佳选择。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-207">Its high-performance communication protocol, based on HTTP/2 and protocol buffers, make it a perfect choice.</span></span>

## <a name="looking-ahead"></a><span data-ttu-id="9d4fa-208">正在寻找</span><span class="sxs-lookup"><span data-stu-id="9d4fa-208">Looking ahead</span></span>

<span data-ttu-id="9d4fa-209">仔细看，gRPC 将继续为云本机系统提供吸引力。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-209">Looking ahead, gRPC will continue to gain traction for cloud-native systems.</span></span> <span data-ttu-id="9d4fa-210">性能优势和轻松开发非常引人注目。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-210">The performance benefits and ease of development are compelling.</span></span> <span data-ttu-id="9d4fa-211">但是，REST 可能会长时间发生。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-211">However, REST will likely be around for a long time.</span></span> <span data-ttu-id="9d4fa-212">它 transact-sql 公开的 Api 和向后兼容性的原因。</span><span class="sxs-lookup"><span data-stu-id="9d4fa-212">It excels for publicly exposed APIs and for backward compatibility reasons.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="9d4fa-213">[上一页](service-to-service-communication.md)
>[下一页](service-mesh-communication-infrastructure.md)</span><span class="sxs-lookup"><span data-stu-id="9d4fa-213">[Previous](service-to-service-communication.md)
[Next](service-mesh-communication-infrastructure.md)</span></span>
