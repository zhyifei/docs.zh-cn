---
title: 无服务器体系结构注意事项 - 无服务器应用
description: 从状态管理和持久存储到缩放、日志记录、跟踪和诊断，了解构建无服务器应用程序所面临的挑战。
author: JEREMYLIKNESS
ms.author: jeliknes
ms.date: 04/06/2020
ms.openlocfilehash: 3c07e1149e6af41a6b9a9317238e5c71015d2c4e
ms.sourcegitcommit: 8b02d42f93adda304246a47f49f6449fc74a3af4
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/24/2020
ms.locfileid: "82135667"
---
# <a name="serverless-architecture-considerations"></a><span data-ttu-id="9d0f1-103">无服务器体系结构注意事项</span><span class="sxs-lookup"><span data-stu-id="9d0f1-103">Serverless architecture considerations</span></span>

<span data-ttu-id="9d0f1-104">采用无服务器体系结构确实带来一些挑战。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-104">Adopting a serverless architecture does come with certain challenges.</span></span> <span data-ttu-id="9d0f1-105">本节探讨了一些需要注意的较为常见的注意事项。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-105">This section explores some of the more common considerations to be aware of.</span></span> <span data-ttu-id="9d0f1-106">所有这些挑战都具有解决方案。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-106">All of these challenges have solutions.</span></span> <span data-ttu-id="9d0f1-107">与所有体系结构选择一样，只有在仔细权衡利弊之后才可以决定采用无服务器。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-107">As with all architecture choices, the decision to go serverless should be made only after carefully considering the pros and cons.</span></span> <span data-ttu-id="9d0f1-108">根据应用程序的需求，你可能会认为无服务器实现并非某些组件的正确解决方案。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-108">Depending on the needs of your application, you may decide a serverless implementation isn't the right solution for certain components.</span></span>

## <a name="managing-state"></a><span data-ttu-id="9d0f1-109">管理状态</span><span class="sxs-lookup"><span data-stu-id="9d0f1-109">Managing state</span></span>

<span data-ttu-id="9d0f1-110">与一般的微服务一样，无服务器函数默认情况下是无状态的。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-110">Serverless functions, as with microservices in general, are stateless by default.</span></span> <span data-ttu-id="9d0f1-111">避免状态使无服务器生存期变短、可横向扩展并在中心点故障的情况下提供复原能力。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-111">Avoiding state enables serverless to be ephemeral, to scale out, and to provide resiliency without a central point of failure.</span></span> <span data-ttu-id="9d0f1-112">在某些情况下，业务流程需要状态。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-112">In some circumstances, business processes require state.</span></span> <span data-ttu-id="9d0f1-113">如果流程需要状态，则有两个选择。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-113">If your process requires state, you have two options.</span></span> <span data-ttu-id="9d0f1-114">你可以采用无服务器以外的模型，也可以与提供状态的单独服务进行交互。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-114">You can adopt a model other than serverless, or interact with a separate service that provides state.</span></span> <span data-ttu-id="9d0f1-115">添加状态会使解决方案复杂化，使其难以缩放，并可能产生单一故障点。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-115">Adding state can complicate the solution and make it harder to scale, and potentially create a single point of failure.</span></span> <span data-ttu-id="9d0f1-116">仔细考虑功能是否绝对需要状态。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-116">Carefully consider whether your function absolutely requires state.</span></span> <span data-ttu-id="9d0f1-117">如果答案是“是”，请确定使用无服务器实现它是否仍然有意义。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-117">If the answer is "yes," determine whether it still makes sense to implement it with serverless.</span></span>

<span data-ttu-id="9d0f1-118">有几种解决方案可以采用状态而不会削弱无服务器的优势。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-118">There are several solutions to adopt state without compromising the benefits of serverless.</span></span> <span data-ttu-id="9d0f1-119">一些更常见的解决方案包括：</span><span class="sxs-lookup"><span data-stu-id="9d0f1-119">Some of the more popular solutions include:</span></span>

- <span data-ttu-id="9d0f1-120">使用临时数据存储或分布式缓存，例如 Redis</span><span class="sxs-lookup"><span data-stu-id="9d0f1-120">Use a temporary data store or distributed cache, like Redis</span></span>
- <span data-ttu-id="9d0f1-121">将状态存储在数据库中，例如 SQL 或 CosmosDB</span><span class="sxs-lookup"><span data-stu-id="9d0f1-121">Store state in a database, like SQL or CosmosDB</span></span>
- <span data-ttu-id="9d0f1-122">通过工作流引擎（如[持久函数](https://docs.microsoft.com/azure/azure-functions/durable/durable-functions-overview)）处理状态</span><span class="sxs-lookup"><span data-stu-id="9d0f1-122">Handle state through a workflow engine like [durable functions](https://docs.microsoft.com/azure/azure-functions/durable/durable-functions-overview)</span></span>

<span data-ttu-id="9d0f1-123">关键在于，你应该明白正在考虑使用无服务器实现的进程中是否需要进行任何状态管理。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-123">The bottom line is that you should be aware of the need for any state management within processes you're considering to implement with serverless.</span></span>

## <a name="long-running-processes"></a><span data-ttu-id="9d0f1-124">长时间运行的进程</span><span class="sxs-lookup"><span data-stu-id="9d0f1-124">Long-running processes</span></span>

<span data-ttu-id="9d0f1-125">无服务器的诸多优势均依赖于短暂的进程。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-125">Many benefits of serverless rely on the processes being ephemeral.</span></span> <span data-ttu-id="9d0f1-126">较短的运行时间使无服务器提供程序更容易在函数结束时释放资源并在主机之间共享函数。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-126">Short run times make it easier for the serverless provider to free up resources as functions end and share functions across hosts.</span></span> <span data-ttu-id="9d0f1-127">大多数云提供商将函数可以运行的总时间限制在 10 分钟左右。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-127">Most cloud providers limit the total time your function can run to around 10 minutes.</span></span> <span data-ttu-id="9d0f1-128">如果进程可能花费更长时间，则可以考虑使用其他方式实现。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-128">If your process may take longer, you might consider an alternative implementation.</span></span>

<span data-ttu-id="9d0f1-129">有几个例外情况和解决方案。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-129">There are a few exceptions and solutions.</span></span> <span data-ttu-id="9d0f1-130">一种解决方法是将进程分解为单独花费更少运行时间的小组件。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-130">One solution may be to break your process into smaller components that individually take less time to run.</span></span> <span data-ttu-id="9d0f1-131">如果进程因依赖项而导致运行时间很长，那么还可以考虑使用诸如持久函数之类的解决方案来实现异步工作流。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-131">If your process runs long because of dependencies, you can also consider an asynchronous workflow using a solution like durable functions.</span></span> <span data-ttu-id="9d0f1-132">持久函数会在等待外部进程完成的时间内暂停并维护进程状态。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-132">Durable functions pause and maintain the state of your process while it's waiting on an external process to finish.</span></span> <span data-ttu-id="9d0f1-133">异步处理减少了实际进程运行的时间。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-133">Asynchronous handling reduces the time the actual process runs.</span></span>

## <a name="startup-time"></a><span data-ttu-id="9d0f1-134">启动时间</span><span class="sxs-lookup"><span data-stu-id="9d0f1-134">Startup time</span></span>

<span data-ttu-id="9d0f1-135">无服务器实现的一个潜在问题是启动时间。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-135">One potential concern with serverless implementations is startup time.</span></span> <span data-ttu-id="9d0f1-136">为了节省资源，许多无服务器提供程序都可以“按需”创建基础结构。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-136">To conserve resources, many serverless providers create infrastructure "on demand."</span></span> <span data-ttu-id="9d0f1-137">如果在一段时间后触发了无服务器函数，则可能需要创建或重启托管该函数的资源。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-137">When a serverless function is triggered after a period of time, the resources to host the function may need to be created or restarted.</span></span> <span data-ttu-id="9d0f1-138">在某些情况下，冷启动可能会导致几秒钟的延迟。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-138">In some situations, cold starts may result in delays of several seconds.</span></span> <span data-ttu-id="9d0f1-139">启动时间因提供程序和服务级别而异。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-139">Startup time varies across providers and service levels.</span></span> <span data-ttu-id="9d0f1-140">如果尽量减少启动时间对于软件是否成功来说非常重要，那么有几种方法可以解决启动时间问题。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-140">There are a few approaches to address startup time if it's important to minimize for the success of the app.</span></span>

- <span data-ttu-id="9d0f1-141">一些提供程序允许用户为可保证基础结构“始终可用”的服务级别付费。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-141">Some providers allow users to pay for service levels that guarantee infrastructure is "always on".</span></span>
- <span data-ttu-id="9d0f1-142">实现一个保持连接的机制（对终结点执行 ping 操作以使其保持“唤醒”状态）。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-142">Implement a keep-alive mechanism (ping the endpoint to keep it "awake").</span></span>
- <span data-ttu-id="9d0f1-143">将 Kubernetes 之类的业务流程与容器化函数方法结合使用（主机已经在运行，因此配置新实例的速度非常快）。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-143">Use orchestration like Kubernetes with a containerized function approach (the host is already running so spinning up new instances is extremely fast).</span></span>

## <a name="database-updates-and-migrations"></a><span data-ttu-id="9d0f1-144">数据库更新和迁移</span><span class="sxs-lookup"><span data-stu-id="9d0f1-144">Database updates and migrations</span></span>

<span data-ttu-id="9d0f1-145">无服务器代码的一个优点是不必重新部署整个应用程序就可以释放新函数。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-145">An advantage of serverless code is that you can release new functions without having to redeploy the entire application.</span></span> <span data-ttu-id="9d0f1-146">当涉及到关系数据库时，此优势可能成为一个缺点。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-146">This advantage can become a disadvantage when there's a relational database involved.</span></span> <span data-ttu-id="9d0f1-147">对数据库架构的更改很难与无服务器更新同步。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-147">Changes to database schemas are difficult to synchronize with serverless updates.</span></span> <span data-ttu-id="9d0f1-148">当出现问题并且必须回滚这些更改时，还会带来其他挑战。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-148">Additional challenges are posed when things go wrong and the changes must be rolled back.</span></span> <span data-ttu-id="9d0f1-149">数据完整性是微服务最佳做法的原因之一，无服务器函数最佳做法原因之一是它们拥有自己的数据。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-149">Data integrity is one reason that a best practice for microservices and serverless functions is that they own their own data.</span></span> <span data-ttu-id="9d0f1-150">可以将更改作为计算和数据的单个单元部署。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-150">It is possible to deploy changes as a single unit of compute and data.</span></span> <span data-ttu-id="9d0f1-151">现实情况是，许多旧的系统都具有大型后端数据库，该数据库必须与无服务器体系结构进行协调。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-151">The reality is that many legacy systems feature a large back-end database that must be reconciled with the serverless architecture.</span></span>

<span data-ttu-id="9d0f1-152">解决架构版本控制的常用方法是从不修改现有属性和列，而是添加新信息。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-152">A popular approach to solve schema versioning is to never modify existing properties and columns, but instead add new information.</span></span> <span data-ttu-id="9d0f1-153">例如，考虑从待办事项列表的布尔“已完成”标记移动到“完成日期”的更改。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-153">For example, consider a change to move from a Boolean "completed" flag for a todo list to a "completed date."</span></span> <span data-ttu-id="9d0f1-154">数据库更改不会删除旧字段，而是会：</span><span class="sxs-lookup"><span data-stu-id="9d0f1-154">Instead of removing the old field, the database change will:</span></span>

1. <span data-ttu-id="9d0f1-155">添加新的“完成日期”字段。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-155">Add a new "completed date" field.</span></span>
1. <span data-ttu-id="9d0f1-156">将“已完成”布尔字段转换为计算函数，该函数计算完成日期是否在当前日期之后。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-156">Transform the "completed" Boolean field to a computed function that evaluates whether the completed date is after the current date.</span></span>
1. <span data-ttu-id="9d0f1-157">当“已完成”布尔值设置为 true 时，添加触发器以将“完成日期”设置为当前日期。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-157">Add a trigger to set the completed date to the current date when the completed Boolean is set to true.</span></span>

<span data-ttu-id="9d0f1-158">更改顺序确保旧代码继续“按原样”运行，而更新的无服务器函数可以利用新的字段。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-158">The sequence of changes ensures that legacy code continues to run "as is" while newer serverless functions can take advantage of the new field.</span></span>

<span data-ttu-id="9d0f1-159">有关无服务器体系结构中数据的详细信息，请参阅[分布式数据管理的挑战和解决方案](../microservices/architect-microservice-container-applications/distributed-data-management.md)。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-159">For more information about data in serverless architectures, see [Challenges and solutions for distributed data management](../microservices/architect-microservice-container-applications/distributed-data-management.md).</span></span>

## <a name="scaling"></a><span data-ttu-id="9d0f1-160">缩放</span><span class="sxs-lookup"><span data-stu-id="9d0f1-160">Scaling</span></span>

<span data-ttu-id="9d0f1-161">无服务器意味着“没有服务器”，这是一个常见的误解。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-161">It's a common misconception that serverless means "no server."</span></span> <span data-ttu-id="9d0f1-162">事实上，这是“更少服务器”的意思。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-162">It's in fact "less server."</span></span> <span data-ttu-id="9d0f1-163">事实证明，有一个后备基础结构对于了解缩放很重要。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-163">The fact there is a backing infrastructure is important to understand when it comes to scaling.</span></span> <span data-ttu-id="9d0f1-164">大多数无服务器平台都提供一组控件，以处理事件密度增加时基础结构应如何缩放。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-164">Most serverless platforms provide a set of controls to handle how the infrastructure should scale when event density increases.</span></span> <span data-ttu-id="9d0f1-165">你可以从多种选项中进行选择，但是策略可能因函数而异。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-165">You can choose from a variety of options, but your strategy may vary depending on the function.</span></span> <span data-ttu-id="9d0f1-166">而且，函数通常在相关主机下运行，因此同一主机上的函数具有相同的缩放选项。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-166">Furthermore, functions are typically run under a related host, so that functions on the same host have the same scale options.</span></span> <span data-ttu-id="9d0f1-167">因此，有必要根据缩放要求来组织和规划将哪些函数托管在一起。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-167">Therefore it is necessary to organize and strategize which functions are hosted together based on scale requirements.</span></span>

<span data-ttu-id="9d0f1-168">规则通常会根据不同参数指定如何纵向扩展（增加主机资源）和横向扩展（增加主机实例的数量）。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-168">Rules often specify how to scale-up (increase the host resources) and scale-out (increase the number of host instances) based on varying parameters.</span></span> <span data-ttu-id="9d0f1-169">缩放的触发器可能包括日程安排、请求速率、CPU 使用率和内存使用率。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-169">Triggers for scales may include schedule, request rates, CPU utilization, and memory usage.</span></span> <span data-ttu-id="9d0f1-170">更高的性能通常要付出更高的成本。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-170">Higher performance often comes at a greater cost.</span></span> <span data-ttu-id="9d0f1-171">当请求率突然增加时，较便宜的基于消耗的方法可能无法迅速缩放。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-171">The less expensive, consumption-based approaches may not scale as quickly when the request rate suddenly increases.</span></span> <span data-ttu-id="9d0f1-172">在预先付费“保险成本”与严格即付“即用”之间存在权衡，由于需求突然增加而导致风险响应速度变慢。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-172">There is a trade-off between paying up front "insurance cost" versus paying strictly "as you go" and risking slower responses due to sudden increases in demand.</span></span>

## <a name="monitoring-tracing-and-logging"></a><span data-ttu-id="9d0f1-173">监视、跟踪和日志记录</span><span class="sxs-lookup"><span data-stu-id="9d0f1-173">Monitoring, tracing, and logging</span></span>

<span data-ttu-id="9d0f1-174">DevOps 经常被忽略的方面是一旦部署就会监视应用程序。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-174">An often overlooked aspect of DevOps is monitoring applications once deployed.</span></span> <span data-ttu-id="9d0f1-175">制定监视无服务器函数的策略非常重要。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-175">It's important to have a strategy for monitoring serverless functions.</span></span> <span data-ttu-id="9d0f1-176">最大的挑战通常是关联的，或者在用户将多个函数作为同一交互的一部分调用时进行识别。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-176">The biggest challenge is often correlation, or recognizing when a user calls multiple functions as part of the same interaction.</span></span> <span data-ttu-id="9d0f1-177">大多数无服务器平台允许可导入第三方工具的控制台日志记录。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-177">Most serverless platforms allow console logging that can be imported into third-party tools.</span></span> <span data-ttu-id="9d0f1-178">还提供了一些选项，可用于自动收集遥测数据、生成和跟踪相关 ID 以及监视特定操作，以提供详细的见解。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-178">There are also options to automate collection of telemetry, generate and track correlation IDs, and monitor specific actions to provide detailed insights.</span></span> <span data-ttu-id="9d0f1-179">Azure 提供了用于监视和分析的高级 [Application Insights 平台](https://docs.microsoft.com/azure/azure-functions/functions-monitoring)。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-179">Azure provides the advanced [Application Insights platform](https://docs.microsoft.com/azure/azure-functions/functions-monitoring) for monitoring and analytics.</span></span>

## <a name="inter-service-dependencies"></a><span data-ttu-id="9d0f1-180">服务间依赖项</span><span class="sxs-lookup"><span data-stu-id="9d0f1-180">Inter-service dependencies</span></span>

<span data-ttu-id="9d0f1-181">无服务器体系结构可包含依赖于其他函数的函数。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-181">A serverless architecture may include functions that rely on other functions.</span></span> <span data-ttu-id="9d0f1-182">实际上，在无服务器体系结构中，将多个服务作为交互或分布式事务的一部分相互调用并不罕见。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-182">In fact, it isn't uncommon in a serverless architecture to have multiple services call each other as part of an interaction or distributed transaction.</span></span> <span data-ttu-id="9d0f1-183">为避免强耦合，建议服务不要直接相互引用。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-183">To avoid strong coupling, it's recommended that services don't reference each other directly.</span></span> <span data-ttu-id="9d0f1-184">当服务的终结点需要更改时，直接引用可能会导致主要重构。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-184">When the endpoint for a service needs to change, direct references could result in major refactoring.</span></span> <span data-ttu-id="9d0f1-185">建议的解决方案是提供一种服务发现机制（例如注册表），该机制为请求类型提供适当的终结点。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-185">A suggested solution is to provide a service discovery mechanism, such as a registry, that provides the appropriate end point for a request type.</span></span> <span data-ttu-id="9d0f1-186">另一个解决方案是利用消息服务（例如队列或主题）在服务之间进行通信。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-186">Another solution is to leverage messaging services like queues or topics for communication between services.</span></span>

## <a name="managing-failure-and-providing-resiliency"></a><span data-ttu-id="9d0f1-187">管理故障并提供复原能力</span><span class="sxs-lookup"><span data-stu-id="9d0f1-187">Managing failure and providing resiliency</span></span>

<span data-ttu-id="9d0f1-188">考虑使用断路器模式  也很重要：如果由于某种原因而导致服务继续失败，则不建议重复调用该服务。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-188">It's also important to consider the *circuit-breaker pattern*: If, for some reason, a service continues to fail, it isn't advisable to call that service repeatedly.</span></span> <span data-ttu-id="9d0f1-189">相反，调用替代服务或返回一条消息，直到重新建立依赖服务的运行状况。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-189">Instead, an alternative service is called or a message returned until the health of the dependent service is re-established.</span></span> <span data-ttu-id="9d0f1-190">无服务器体系结构需要考虑建立解决和管理服务间依赖项的策略。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-190">The serverless architecture needs to take into account the strategy for resolving and managing inter-service dependencies.</span></span>

<span data-ttu-id="9d0f1-191">要继续使用断路器模式，服务需要具有容错能力并可复原。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-191">To continue the circuit-breaker pattern, services need to be fault tolerant and resilient.</span></span> <span data-ttu-id="9d0f1-192">容错是指即使遇到意外异常或无效状态，应用程序也可以继续运行的能力。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-192">Fault tolerance refers to the ability of your application to continue running even after unexpected exceptions or invalid states are encountered.</span></span> <span data-ttu-id="9d0f1-193">容错通常是代码本身的一项功能，以及如何编写它来处理异常。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-193">Fault tolerance is typically a function of the code itself and how it's written to handle exceptions.</span></span> <span data-ttu-id="9d0f1-194">复原能力是指应用程序从故障中恢复的能力。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-194">Resiliency refers to how capable the app is at recovering from failures.</span></span> <span data-ttu-id="9d0f1-195">复原能力通常由无服务器平台管理。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-195">Resiliency is often managed by the serverless platform.</span></span> <span data-ttu-id="9d0f1-196">当现有无服务器函数实例出现故障时，该平台应能够启动一个新的无服务器函数实例。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-196">The platform should be able to spin up a new serverless function instance when the existing one fails.</span></span> <span data-ttu-id="9d0f1-197">该平台还应该足够智能，可在每个新实例失败时停止启动新实例。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-197">The platform should also be intelligent enough to stop spinning up new instances when every new instance fails.</span></span>

<span data-ttu-id="9d0f1-198">有关详细信息，请参阅[实现断路器模式](../microservices/implement-resilient-applications/implement-circuit-breaker-pattern.md)。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-198">For more information, see [Implementing the Circuit Breaker pattern](../microservices/implement-resilient-applications/implement-circuit-breaker-pattern.md).</span></span>

## <a name="versioning-and-greenblue-deployments"></a><span data-ttu-id="9d0f1-199">版本控制和绿色/蓝色部署</span><span class="sxs-lookup"><span data-stu-id="9d0f1-199">Versioning and green/blue deployments</span></span>

<span data-ttu-id="9d0f1-200">无服务器的主要优势是无需重新部署整个应用程序即可升级特定函数。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-200">A major benefit of serverless is the ability to upgrade a specific function without having to redeploy the entire application.</span></span> <span data-ttu-id="9d0f1-201">为使升级成功，必须对函数进行版本控制，以便将调用它们的服务路由到正确的代码版本。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-201">For upgrades to be successful, functions must be versioned so that services calling them are routed to the correct version of code.</span></span> <span data-ttu-id="9d0f1-202">部署新版本的策略也很重要。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-202">A strategy for deploying new versions is also important.</span></span> <span data-ttu-id="9d0f1-203">一种常见的方法是使用“绿色/蓝色部署”。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-203">A common approach is to use "green/blue deployments."</span></span> <span data-ttu-id="9d0f1-204">绿色部署是当前函数。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-204">The green deployment is the current function.</span></span> <span data-ttu-id="9d0f1-205">新的“蓝色”版本已部署到生产环境中并进行了测试。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-205">A new "blue" version is deployed to production and tested.</span></span> <span data-ttu-id="9d0f1-206">测试通过时，绿色和蓝色版本会互换，因此新版本生效。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-206">When testing passes, the green and blue versions are swapped so the new version comes live.</span></span> <span data-ttu-id="9d0f1-207">如果遇到任何问题，可以将它们调换回来。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-207">If any issues are encountered, they can be swapped back.</span></span> <span data-ttu-id="9d0f1-208">支持版本控制和绿色/蓝色部署需要编写函数以适应版本更改以及与无服务器平台一起处理部署的组合。</span><span class="sxs-lookup"><span data-stu-id="9d0f1-208">Supporting versioning and green/blue deployments requires a combination of authoring the functions to accommodate version changes and working with the serverless platform to handle deployments.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="9d0f1-209">[上一页](serverless-architecture.md)
>[下一页](serverless-design-examples.md)</span><span class="sxs-lookup"><span data-stu-id="9d0f1-209">[Previous](serverless-architecture.md)
[Next](serverless-design-examples.md)</span></span>
