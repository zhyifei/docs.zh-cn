---
title: 包、元包和框架
description: 了解包、元包和框架的术语。
author: richlander
ms.author: mairaw
ms.date: 06/20/2016
ms.openlocfilehash: e68c63d26133ac76b718bb3696d16c81bd943dc2
ms.sourcegitcommit: 6eac9a01ff5d70c6d18460324c016a3612c5e268
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/16/2018
ms.locfileid: "45597656"
---
# <a name="packages-metapackages-and-frameworks"></a><span data-ttu-id="c479c-103">包、元包和框架</span><span class="sxs-lookup"><span data-stu-id="c479c-103">Packages, metapackages and frameworks</span></span>

<span data-ttu-id="c479c-104">.NET Core 是一种由 NuGet 包组成的平台。</span><span class="sxs-lookup"><span data-stu-id="c479c-104">.NET Core is a platform made of NuGet packages.</span></span> <span data-ttu-id="c479c-105">有些产品体验受益于包的细粒度定义，而另一些受益于粗粒度的定义。</span><span class="sxs-lookup"><span data-stu-id="c479c-105">Some product experiences benefit from fine-grained definition of packages while others from coarse-grained.</span></span> <span data-ttu-id="c479c-106">为了适应这种二元定义，一款好的产品应该作为一组细粒度的包发布，然后在更粗的粒度组块中进行描述，单个包的正式的名字叫做“元包”。</span><span class="sxs-lookup"><span data-stu-id="c479c-106">To accommodate this duality, the product is distributed as a fine-grained set of packages and then described in coarser chunks with a package type informally called a "metapackage".</span></span>

<span data-ttu-id="c479c-107">每个 .Net Core 包都支持以框架形式通过多个 .Net 实现代码运行。</span><span class="sxs-lookup"><span data-stu-id="c479c-107">Each of the .NET Core packages support being run on multiple .NET implementations, represented as frameworks.</span></span> <span data-ttu-id="c479c-108">其中有些框架是传统框架，例如表示 .NET Framework 的 `net46`。</span><span class="sxs-lookup"><span data-stu-id="c479c-108">Some of those frameworks are traditional frameworks, like `net46`, representing the .NET Framework.</span></span> <span data-ttu-id="c479c-109">而另一些则是新框架，可视为是“基于包的框架”，这种是框架的另外一种新的定义模型。</span><span class="sxs-lookup"><span data-stu-id="c479c-109">Another set is new frameworks that can be thought of as "package-based frameworks", which establish a new model for defining frameworks.</span></span> <span data-ttu-id="c479c-110">这些基于包的框架整个都是由包组成的，它们自身也被定义成包，这就在包与框架之间形成了一种比较密切的关系。</span><span class="sxs-lookup"><span data-stu-id="c479c-110">These package-based frameworks are entirely formed and defined as packages, forming a strong relationship between packages and frameworks.</span></span>

## <a name="packages"></a><span data-ttu-id="c479c-111">包</span><span class="sxs-lookup"><span data-stu-id="c479c-111">Packages</span></span>

<span data-ttu-id="c479c-112">.NET Core 被分成一组包，它们提供了基元类型，以及更高层的数据类型，应用组合类型和通用实用工具。</span><span class="sxs-lookup"><span data-stu-id="c479c-112">.NET Core is split into a set of packages, which provide primitives, higher-level data types, app composition types and common utilities.</span></span> <span data-ttu-id="c479c-113">每一个包都代表着单独的同名程序集。</span><span class="sxs-lookup"><span data-stu-id="c479c-113">Each of these packages represent a single assembly of the same name.</span></span> <span data-ttu-id="c479c-114">例如，[System.Runtime](https://www.nuget.org/packages/System.Runtime) 这个包就包含了 System.Runtime.dll 程序集。</span><span class="sxs-lookup"><span data-stu-id="c479c-114">For example, [System.Runtime](https://www.nuget.org/packages/System.Runtime) contains System.Runtime.dll.</span></span> 

<span data-ttu-id="c479c-115">以细粒度方式定义这些包具有以下好处：</span><span class="sxs-lookup"><span data-stu-id="c479c-115">There are advantages to defining packages in a fine-grained manner:</span></span>

- <span data-ttu-id="c479c-116">细粒度的包可以在它自己的计划内交付，只需完成仅对相关的其他有限的包进行测试即可。</span><span class="sxs-lookup"><span data-stu-id="c479c-116">Fine-grained packages can ship on their own schedule with relatively limited testing of other packages.</span></span>
- <span data-ttu-id="c479c-117">细粒度的包可以提供不同的 OS 和 CPU 支持。</span><span class="sxs-lookup"><span data-stu-id="c479c-117">Fine-grained packages can provide differing OS and CPU support.</span></span>
- <span data-ttu-id="c479c-118">细粒度的包可以单独依赖于某一个库。</span><span class="sxs-lookup"><span data-stu-id="c479c-118">Fine-grained packages can have dependencies specific to only one library.</span></span>
- <span data-ttu-id="c479c-119">应用可以变得更小，因为没有引用的包不会变成应用发行的一部分。</span><span class="sxs-lookup"><span data-stu-id="c479c-119">Apps are smaller because unreferenced packages don't become part of the app distribution.</span></span>

<span data-ttu-id="c479c-120">上述某些好处只适用于某些特定场合。</span><span class="sxs-lookup"><span data-stu-id="c479c-120">Some of these benefits are only used in certain circumstances.</span></span> <span data-ttu-id="c479c-121">例如，.NET Core 的所有包通常都会在同一计划内提供对同一平台的支持。</span><span class="sxs-lookup"><span data-stu-id="c479c-121">For example, NET Core packages will typically ship on the same schedule with the same platform support.</span></span> <span data-ttu-id="c479c-122">在这种情况下，补丁与更新会以小的单独包的形式发布和安装。</span><span class="sxs-lookup"><span data-stu-id="c479c-122">In the case of servicing, fixes can be distributed and installed as small single package updates.</span></span> <span data-ttu-id="c479c-123">由于这种小范围的变化，补丁的验证与时间花费，都可以限制到单个库的需求范围中。</span><span class="sxs-lookup"><span data-stu-id="c479c-123">Due to the narrow scope of change, the validation and time to make a fix available is limited to what is needed for a single library.</span></span>

<span data-ttu-id="c479c-124">以下是 .NET Core 重要的 NuGet 包列表：</span><span class="sxs-lookup"><span data-stu-id="c479c-124">The following is a list of the key NuGet packages for .NET Core:</span></span>

- <span data-ttu-id="c479c-125">[System.Runtime](https://www.nuget.org/packages/System.Runtime) - 最基础的 .NET Core 包，包括 <xref:System.Object>、<xref:System.String>、<xref:System.Array>、<xref:System.Action> 和 <xref:System.Collections.Generic.IList%601>。</span><span class="sxs-lookup"><span data-stu-id="c479c-125">[System.Runtime](https://www.nuget.org/packages/System.Runtime) - The most fundamental .NET Core package, including <xref:System.Object>, <xref:System.String>, <xref:System.Array>, <xref:System.Action>, and <xref:System.Collections.Generic.IList%601>.</span></span>
- <span data-ttu-id="c479c-126">[System.Collections](https://www.nuget.org/packages/System.Collections) - 一组（主要）泛型集合，包括 <xref:System.Collections.Generic.List%601> 和 <xref:System.Collections.Generic.Dictionary%602>。</span><span class="sxs-lookup"><span data-stu-id="c479c-126">[System.Collections](https://www.nuget.org/packages/System.Collections) - A set of (primarily) generic collections, including <xref:System.Collections.Generic.List%601> and <xref:System.Collections.Generic.Dictionary%602>.</span></span>
- <span data-ttu-id="c479c-127">[System.Net.Http](https://www.nuget.org/packages/System.Net.Http) - 一组用于 HTTP 网络通信的类型，包括 <xref:System.Net.Http.HttpClient> 和 <xref:System.Net.Http.HttpResponseMessage>。</span><span class="sxs-lookup"><span data-stu-id="c479c-127">[System.Net.Http](https://www.nuget.org/packages/System.Net.Http) - A set of types for HTTP network communication, including <xref:System.Net.Http.HttpClient> and <xref:System.Net.Http.HttpResponseMessage>.</span></span>
- <span data-ttu-id="c479c-128">[System.IO.FileSystem](https://www.nuget.org/packages/System.IO.FileSystem) - 一组用于读写到本地或网络磁盘存储的类型，包括 <xref:System.IO.File> 和 <xref:System.IO.Directory>。</span><span class="sxs-lookup"><span data-stu-id="c479c-128">[System.IO.FileSystem](https://www.nuget.org/packages/System.IO.FileSystem) - A set of types for reading and writing to local or networked disk-based storage, including <xref:System.IO.File> and <xref:System.IO.Directory>.</span></span>
- <span data-ttu-id="c479c-129">[System.Linq](https://www.nuget.org/packages/System.Linq) - 一组用于查询对象的类型，包括 `Enumerable` 和 <xref:System.Linq.ILookup%602>。</span><span class="sxs-lookup"><span data-stu-id="c479c-129">[System.Linq](https://www.nuget.org/packages/System.Linq) - A set of types for querying objects, including `Enumerable` and <xref:System.Linq.ILookup%602>.</span></span>
- <span data-ttu-id="c479c-130">[System.Reflection](https://www.nuget.org/packages/System.Reflection) - 一组用于加载、检查和激活类型的类型，包括 <xref:System.Reflection.Assembly>、<xref:System.Reflection.TypeInfo> 和 <xref:System.Reflection.MethodInfo>。</span><span class="sxs-lookup"><span data-stu-id="c479c-130">[System.Reflection](https://www.nuget.org/packages/System.Reflection) - A set of types for loading, inspecting, and activating types, including <xref:System.Reflection.Assembly>, <xref:System.Reflection.TypeInfo> and <xref:System.Reflection.MethodInfo>.</span></span>

<span data-ttu-id="c479c-131">通常情况下，相较于逐个地将包包含在项目中，包含*元包*会简单得多，元包是指通常配合在一起使用的一组包。</span><span class="sxs-lookup"><span data-stu-id="c479c-131">Typically, rather than including packages in your projects on a package-by-package basis, it is far easier to include a *metapackage*, which is a set of packages that are often used together.</span></span> <span data-ttu-id="c479c-132">（有关元包的更多信息，请参见下一部分。）但是当需要单个包时，可以按以下示例所示的那样来包含它，此示例引用 [System.Runtime](https://www.nuget.org/packages/System.Runtime/) 包。</span><span class="sxs-lookup"><span data-stu-id="c479c-132">(For more information on metapackages, see the following section.) However, when you need a single package, you can include it as in the example below, which references the [System.Runtime](https://www.nuget.org/packages/System.Runtime/) package.</span></span> 

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>netstandard1.6</TargetFramework>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="System.Runtime" Version="4.3.0" />
  </ItemGroup>
</Project>
```

## <a name="metapackages"></a><span data-ttu-id="c479c-133">元包</span><span class="sxs-lookup"><span data-stu-id="c479c-133">Metapackages</span></span>

<span data-ttu-id="c479c-134">元包就是一个 NuGet 包约定，描述了一组意义相关的包。</span><span class="sxs-lookup"><span data-stu-id="c479c-134">Metapackages are a NuGet package convention for describing a set of packages that are meaningful together.</span></span> <span data-ttu-id="c479c-135">开发团队利用依赖项来描述这一组包。</span><span class="sxs-lookup"><span data-stu-id="c479c-135">They represent this set of packages by making them dependencies.</span></span> <span data-ttu-id="c479c-136">他们通过这一组包来描述一个框架，然后有选择地发布出去。</span><span class="sxs-lookup"><span data-stu-id="c479c-136">They can optionally establish a framework for this set of packages by specifying a framework.</span></span> 

<span data-ttu-id="c479c-137">默认情况下，早期版本的 .NET Core 工具（同时基于 project.json 和 csproj 的工具）指定一个框架和一个元包。</span><span class="sxs-lookup"><span data-stu-id="c479c-137">Previous versions of the .NET Core tools (both project.json and csproj-based tools) by default specified both a framework and a metapackage.</span></span> <span data-ttu-id="c479c-138">但目前，由目标框架隐式引用元包，以便将每个元包绑定到一个目标框架。</span><span class="sxs-lookup"><span data-stu-id="c479c-138">Currently, however, the metapackage is implicitly referenced by the target framework, so that each metapackage is tied to a target framework.</span></span> <span data-ttu-id="c479c-139">例如，`netstandard1.6` 框架引用 NetStandard.Library 1.6.0 版元包。</span><span class="sxs-lookup"><span data-stu-id="c479c-139">For example, the `netstandard1.6` framework references the NetStandard.Library version 1.6.0 metapackage.</span></span> <span data-ttu-id="c479c-140">同样，`netcoreapp2.1` 框架引用 Microsoft.NETCore.App 2.1.0 版元包。</span><span class="sxs-lookup"><span data-stu-id="c479c-140">Similarly, the `netcoreapp2.1` framework references the Microsoft.NETCore.App Version 2.1.0 metapackage.</span></span> <span data-ttu-id="c479c-141">有关详细信息，请参阅 [.NET Core SDK 中的隐式元包引用](https://github.com/dotnet/core/blob/master/release-notes/1.0/sdk/1.0-rc3-implicit-package-refs.md)。</span><span class="sxs-lookup"><span data-stu-id="c479c-141">For more information, see [Implicit metapackage package reference in the .NET Core SDK](https://github.com/dotnet/core/blob/master/release-notes/1.0/sdk/1.0-rc3-implicit-package-refs.md).</span></span>

<span data-ttu-id="c479c-142">以某个框架为目标以及隐式引用元包，这实际上是添加了对元包中每一个独立包的引用依赖。</span><span class="sxs-lookup"><span data-stu-id="c479c-142">Targeting a framework and implicitly referencing a metapackage means that you in effect are adding a reference to each of its dependent packages as a single gesture.</span></span> <span data-ttu-id="c479c-143">这使这些包中的所有库都可用于 IntelliSense（或类似体验），同时也可用于发布应用。</span><span class="sxs-lookup"><span data-stu-id="c479c-143">That makes all of the libraries in those packages available for IntelliSense (or similar experience) and for publishing your app.</span></span>  

<span data-ttu-id="c479c-144">使用元包具有以下好处：</span><span class="sxs-lookup"><span data-stu-id="c479c-144">There are advantages to using metapackages:</span></span>

- <span data-ttu-id="c479c-145">在引用大量细粒度包方面，提供了一种方便的用户体验。</span><span class="sxs-lookup"><span data-stu-id="c479c-145">Provides a convenient user experience to reference a large set of fine-grained packages.</span></span> 
- <span data-ttu-id="c479c-146">定义了一组经过充分测试且运行良好的包（包括指定的各种版本）。</span><span class="sxs-lookup"><span data-stu-id="c479c-146">Defines a set of packages (including specific versions) that are tested and work well together.</span></span>

<span data-ttu-id="c479c-147">.NET Standard 元包为：</span><span class="sxs-lookup"><span data-stu-id="c479c-147">The .NET Standard metapackage is:</span></span>

- <span data-ttu-id="c479c-148">[NETStandard.Library](https://www.nuget.org/packages/NETStandard.Library) - 描述了属于“.NET Standard”一部分的各种库。</span><span class="sxs-lookup"><span data-stu-id="c479c-148">[NETStandard.Library](https://www.nuget.org/packages/NETStandard.Library) - Describes the libraries that are part of the ".NET Standard".</span></span> <span data-ttu-id="c479c-149">适用于所有支持 .NET Standard 的 .NET 实现（例如，.NET Framework、.NET Core 和 Mono）。</span><span class="sxs-lookup"><span data-stu-id="c479c-149">Applies to all .NET implementations (for example, .NET Framework, .NET Core and Mono) that support .NET Standard.</span></span> <span data-ttu-id="c479c-150">也就是“netstandard”框架。</span><span class="sxs-lookup"><span data-stu-id="c479c-150">Establishes the 'netstandard' framework.</span></span>

<span data-ttu-id="c479c-151">重要的 .NET Core 元包有：</span><span class="sxs-lookup"><span data-stu-id="c479c-151">The key .NET Core metapackages are:</span></span>

- <span data-ttu-id="c479c-152">[Microsoft.NETCore.App](https://www.nuget.org/packages/Microsoft.NETCore.App) - 描述了属于 .NET Core 发行版的部分库。</span><span class="sxs-lookup"><span data-stu-id="c479c-152">[Microsoft.NETCore.App](https://www.nuget.org/packages/Microsoft.NETCore.App) - Describes the libraries that are part of the .NET Core distribution.</span></span> <span data-ttu-id="c479c-153">也就是 [`.NETCoreApp` 框架](https://github.com/dotnet/core-setup/blob/release/1.1.0/pkg/projects/Microsoft.NETCore.App/Microsoft.NETCore.App.pkgproj)。</span><span class="sxs-lookup"><span data-stu-id="c479c-153">Establishes the [`.NETCoreApp` framework](https://github.com/dotnet/core-setup/blob/release/1.1.0/pkg/projects/Microsoft.NETCore.App/Microsoft.NETCore.App.pkgproj).</span></span> <span data-ttu-id="c479c-154">它依赖于更小的 `NETStandard.Library`。</span><span class="sxs-lookup"><span data-stu-id="c479c-154">Depends on the smaller `NETStandard.Library`.</span></span>
- <span data-ttu-id="c479c-155">[Microsoft.AspNetCore.All](https://www.nuget.org/packages/Microsoft.AspNetCore.All) - 包含来自 ASP.NET Core、Entity Framework Core 以及 ASP.NET Core 和 Entity Framework Core 使用的内部和第三方依赖项的所有受支持包。</span><span class="sxs-lookup"><span data-stu-id="c479c-155">[Microsoft.AspNetCore.All](https://www.nuget.org/packages/Microsoft.AspNetCore.All) - Includes all the supported packages from ASP.NET Core, Entity Framework Core, and internal and third-party dependencies used by ASP.NET Core and Entity Framework Core.</span></span> <span data-ttu-id="c479c-156">有关详细信息，请参阅 [ASP.NET Core 2.x 的 Microsoft.AspNetCore.All 元包](/aspnet/core/fundamentals/metapackage)。</span><span class="sxs-lookup"><span data-stu-id="c479c-156">See [Microsoft.AspNetCore.All metapackage for ASP.NET Core 2.x](/aspnet/core/fundamentals/metapackage) for more information.</span></span>
- <span data-ttu-id="c479c-157">[Microsoft.NETCore.Portable.Compatibility](https://www.nuget.org/packages/Microsoft.NETCore.Portable.Compatibility) - 一组兼容外观，使基于 mscorlib 的可移植类库(PCL) 得以在 .Net Core上运行。</span><span class="sxs-lookup"><span data-stu-id="c479c-157">[Microsoft.NETCore.Portable.Compatibility](https://www.nuget.org/packages/Microsoft.NETCore.Portable.Compatibility) - A set of compatibility facades that enable mscorlib-based Portable Class Libraries (PCLs) to run on .NET Core.</span></span>

## <a name="frameworks"></a><span data-ttu-id="c479c-158">框架</span><span class="sxs-lookup"><span data-stu-id="c479c-158">Frameworks</span></span>

<span data-ttu-id="c479c-159">每个 .NET Core 包支持一组运行时框架。</span><span class="sxs-lookup"><span data-stu-id="c479c-159">.NET Core packages each support a set of runtime frameworks.</span></span> <span data-ttu-id="c479c-160">框架描述了一组可用的 API（以及潜在的其他特性），所以你可以在指定一个目标框架时使用这些功能。</span><span class="sxs-lookup"><span data-stu-id="c479c-160">Frameworks describe an available API set (and potentially other characteristics) that you can rely on when you target a given framework.</span></span> <span data-ttu-id="c479c-161">添加新的 API 时，它们就会进入版本控制流程。</span><span class="sxs-lookup"><span data-stu-id="c479c-161">They are versioned as new APIs are added.</span></span>

<span data-ttu-id="c479c-162">例如，[System.IO.FileSystem](https://www.nuget.org/packages/System.IO.FileSystem) 支持以下框架：</span><span class="sxs-lookup"><span data-stu-id="c479c-162">For example, [System.IO.FileSystem](https://www.nuget.org/packages/System.IO.FileSystem) supports the following frameworks:</span></span>

- <span data-ttu-id="c479c-163">.NETFramework,Version=4.6</span><span class="sxs-lookup"><span data-stu-id="c479c-163">.NETFramework,Version=4.6</span></span>
- <span data-ttu-id="c479c-164">.NETStandard,Version=1.3</span><span class="sxs-lookup"><span data-stu-id="c479c-164">.NETStandard,Version=1.3</span></span>
- <span data-ttu-id="c479c-165">6 种 Xamarin 平台（例如，xamarinios10）</span><span class="sxs-lookup"><span data-stu-id="c479c-165">6 Xamarin platforms (for example, xamarinios10)</span></span>

<span data-ttu-id="c479c-166">将前两个框架进行对比很有帮助，因为它们各自代表了一种不同的框架定义方式。</span><span class="sxs-lookup"><span data-stu-id="c479c-166">It is useful to contrast the first two of these frameworks, since they are examples of the two different ways that frameworks are defined.</span></span>

<span data-ttu-id="c479c-167">`.NETFramework,Version=4.6` 框架表示 .NET Framework 4.6 中可用的 API。</span><span class="sxs-lookup"><span data-stu-id="c479c-167">The `.NETFramework,Version=4.6` framework represents the available APIs in the .NET Framework 4.6.</span></span> <span data-ttu-id="c479c-168">你可以生成使用 .NET Framework 4.6 引用程序集编译的库，并以NuGet 包的方式在 net46 lib 文件夹中发布这些库。</span><span class="sxs-lookup"><span data-stu-id="c479c-168">You can produce libraries  compiled with the .NET Framework 4.6 reference assemblies and then distribute those libraries in NuGet packages in a net46 lib folder.</span></span> <span data-ttu-id="c479c-169">这样，你的库就会被那些基于或者兼容 .Net Framework 4.6 的应用所使用。</span><span class="sxs-lookup"><span data-stu-id="c479c-169">It will be used for apps that target the .NET Framework 4.6 or that are compatible with it.</span></span> <span data-ttu-id="c479c-170">这是所有框架的传统工作原理。</span><span class="sxs-lookup"><span data-stu-id="c479c-170">This is how all frameworks have traditionally worked.</span></span>

<span data-ttu-id="c479c-171">`.NETStandard,Version=1.3` 框架是一个基于包的框架。</span><span class="sxs-lookup"><span data-stu-id="c479c-171">The `.NETStandard,Version=1.3` framework is a package-based framework.</span></span> <span data-ttu-id="c479c-172">它依赖基于框架的包，来定义和公开与框架有关的 API。</span><span class="sxs-lookup"><span data-stu-id="c479c-172">It relies on packages that target the framework to define and expose APIs in terms of the framework.</span></span>

## <a name="package-based-frameworks"></a><span data-ttu-id="c479c-173">基于包的框架</span><span class="sxs-lookup"><span data-stu-id="c479c-173">Package-based frameworks</span></span>

<span data-ttu-id="c479c-174">框架和包之间是一种双向关系。</span><span class="sxs-lookup"><span data-stu-id="c479c-174">There is a two-way relationship between frameworks and packages.</span></span> <span data-ttu-id="c479c-175">首先是为一个给定的框架定义了 API，例如 `netstandard1.3`。</span><span class="sxs-lookup"><span data-stu-id="c479c-175">The first part is defining the APIs available for a given framework, for example `netstandard1.3`.</span></span> <span data-ttu-id="c479c-176">以 `netstandard1.3` 为目标的包（或兼容的框架，如 `netstandard1.0`）定义了适用于 `netstandard1.3` 的 API。</span><span class="sxs-lookup"><span data-stu-id="c479c-176">Packages that target `netstandard1.3` (or compatible frameworks, like `netstandard1.0`) define the APIs available for `netstandard1.3`.</span></span> <span data-ttu-id="c479c-177">听起来像是循环定义，然而并不是。</span><span class="sxs-lookup"><span data-stu-id="c479c-177">That may sound like a circular definition, but it isn't.</span></span> <span data-ttu-id="c479c-178">从“基于包的”这个词本身的角度来讲，框架的 API 定义是来自于包的。</span><span class="sxs-lookup"><span data-stu-id="c479c-178">By virtue of being "package-based", the API definition for the framework comes from packages.</span></span> <span data-ttu-id="c479c-179">框架本身并不定义任何 API。</span><span class="sxs-lookup"><span data-stu-id="c479c-179">The framework itself doesn't define any APIs.</span></span>

<span data-ttu-id="c479c-180">其次，是这个双向关系中的资产选择。</span><span class="sxs-lookup"><span data-stu-id="c479c-180">The second part of the relationship is asset selection.</span></span> <span data-ttu-id="c479c-181">包可以包含多个框架的资产。</span><span class="sxs-lookup"><span data-stu-id="c479c-181">Packages can contain assets for multiple frameworks.</span></span> <span data-ttu-id="c479c-182">对于一组包和/或元包的引用，框架需要决定它应选择哪些资产，例如，是 `net46` 还是 `netstandard1.3`。</span><span class="sxs-lookup"><span data-stu-id="c479c-182">Given a reference to a set of packages and/or metapackages, the framework is needed to determine which asset should be selected, for example `net46` or `netstandard1.3`.</span></span> <span data-ttu-id="c479c-183">选择正确的资产很重要。</span><span class="sxs-lookup"><span data-stu-id="c479c-183">It is important to select the correct asset.</span></span> <span data-ttu-id="c479c-184">例如，`net46` 资产可能并不与 .NET Framework 4.0 或 .NET Core 1.0 兼容。</span><span class="sxs-lookup"><span data-stu-id="c479c-184">For example, a `net46` asset is not likely to be compatible with .NET Framework 4.0 or .NET Core 1.0.</span></span>


<span data-ttu-id="c479c-185">可以在下图中看到这种关系。</span><span class="sxs-lookup"><span data-stu-id="c479c-185">You can see this relationship in the following image.</span></span> <span data-ttu-id="c479c-186">*API* 选择框架作为目标并定义了框架。</span><span class="sxs-lookup"><span data-stu-id="c479c-186">The *API* targets and defines the *framework*.</span></span> <span data-ttu-id="c479c-187">而*框架*用于*资产选择*。</span><span class="sxs-lookup"><span data-stu-id="c479c-187">The *framework* is used for *asset selection*.</span></span> <span data-ttu-id="c479c-188">*资产*实现了 API。</span><span class="sxs-lookup"><span data-stu-id="c479c-188">The *asset* gives you the API.</span></span>

![基于包的框架组合](./media/packages/package-framework.png)

<span data-ttu-id="c479c-190">在 .Net Core 基础之上，基于包的框架主要有两个：</span><span class="sxs-lookup"><span data-stu-id="c479c-190">The two primary package-based frameworks used with .NET Core are:</span></span>

- `netstandard`
- `netcoreapp`

### <a name="net-standard"></a><span data-ttu-id="c479c-191">.NET Standard</span><span class="sxs-lookup"><span data-stu-id="c479c-191">.NET Standard</span></span>

<span data-ttu-id="c479c-192">.NET Standard（目标框架名字对象：`netstandard`）框架表示在 [.NET Standard](../standard/net-standard.md) 基础之上生成并由其定义的 API。</span><span class="sxs-lookup"><span data-stu-id="c479c-192">The .NET Standard (target framework moniker: `netstandard`) framework represents the APIs defined by and built on top of the [.NET Standard](../standard/net-standard.md).</span></span> <span data-ttu-id="c479c-193">如果构建的库将用于在多个运行时上运行，就应将此框架作为目标。</span><span class="sxs-lookup"><span data-stu-id="c479c-193">Libraries that are intended to run on multiple runtimes should target this framework.</span></span> <span data-ttu-id="c479c-194">这样便可在任何一种兼容 .NET 标准的运行时上受支持，例如 .NET Core、.NET Framework 和 Mono/Xamarin。</span><span class="sxs-lookup"><span data-stu-id="c479c-194">They will be supported on any .NET Standard compliant runtime, such as .NET Core, .NET Framework and Mono/Xamarin.</span></span> <span data-ttu-id="c479c-195">每个运行时都支持一组 .NET Standard 版本，具体取决于实现的 API。</span><span class="sxs-lookup"><span data-stu-id="c479c-195">Each of these runtimes supports a set of .NET Standard versions, depending on which APIs they implement.</span></span>

<span data-ttu-id="c479c-196">`netstandard` 框架隐式引用 [`NETStandard.Library`](https://www.nuget.org/packages/NETStandard.Library) 元包。</span><span class="sxs-lookup"><span data-stu-id="c479c-196">The `netstandard` framework implicitly references the [`NETStandard.Library`](https://www.nuget.org/packages/NETStandard.Library) metapackage.</span></span> <span data-ttu-id="c479c-197">例如，以下 MSBuild 项目文件指示项目以 `netstandard1.6` 为目标，其引用 [`NETStandard.Library` 1.6 版](https://www.nuget.org/packages/NETStandard.Library/1.6.0)元包。</span><span class="sxs-lookup"><span data-stu-id="c479c-197">For example, the following MSBuild project file indicates that the project targets `netstandard1.6`, which references the [`NETStandard.Library` version 1.6](https://www.nuget.org/packages/NETStandard.Library/1.6.0) metapackage.</span></span>

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>netstandard1.6</TargetFramework>
  </PropertyGroup>
</Project>
```

<span data-ttu-id="c479c-198">但项目文件中的框架和元包引用不需要匹配，并且可使用项目文件中的 `<NetStandardImplicitPackageVersion>` 元素指定低于元包版本的框架版本。</span><span class="sxs-lookup"><span data-stu-id="c479c-198">However, the framework and metapackage references in the project file do not need to match, and you can use the `<NetStandardImplicitPackageVersion>` element in your project file to specify a framework version that is lower than the metapackage version.</span></span> <span data-ttu-id="c479c-199">例如，以下项目文件有效。</span><span class="sxs-lookup"><span data-stu-id="c479c-199">For example, the following project file is valid.</span></span>

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>netstandard1.3</TargetFramework>
    <NetStandardImplicitPackageVersion>1.6.0</NetStandardImplicitPackageVersion>
  </PropertyGroup>
</Project>
```

<span data-ttu-id="c479c-200">面向 `netstandard1.3` 却使用 `NETStandard.Library` 1.6.0 版本，这一点很奇怪。</span><span class="sxs-lookup"><span data-stu-id="c479c-200">It may seem strange to target `netstandard1.3` but use the 1.6.0 version of `NETStandard.Library`.</span></span> <span data-ttu-id="c479c-201">然而，这是一个有效的用例，因为元包支持更旧的 `netstandard` 版本。</span><span class="sxs-lookup"><span data-stu-id="c479c-201">It is a valid use-case, since the metapackage maintains support for older `netstandard` versions.</span></span> <span data-ttu-id="c479c-202">可能恰好你已将 1.6.0 版的元包进行了标准化，然后将其用于所有库，而这些库可以面向各种 `netstandard` 版本。</span><span class="sxs-lookup"><span data-stu-id="c479c-202">It could be the case you've standardized on the 1.6.0 version of the metapackage and use it for all your libraries, which target a variety of `netstandard` versions.</span></span> <span data-ttu-id="c479c-203">使用此方法，只需还原 `NETStandard.Library` 1.6.0，无需加载早期版本。</span><span class="sxs-lookup"><span data-stu-id="c479c-203">With this approach, you only need to restore `NETStandard.Library` 1.6.0 and not earlier versions.</span></span> 

<span data-ttu-id="c479c-204">反之，把 `netstandard1.6` 设为目标，却使用 1.3.0 版的 `NETStandard.Library` 也是无效的。</span><span class="sxs-lookup"><span data-stu-id="c479c-204">The reverse would not be valid: targeting `netstandard1.6` with the 1.3.0 version of `NETStandard.Library`.</span></span> <span data-ttu-id="c479c-205">你不能把更高版本的框架设为目标，却使用更低版本的元包，因为更低版本的元包不会公开任何更高版本框架的资产。</span><span class="sxs-lookup"><span data-stu-id="c479c-205">You cannot target a higher framework with a lower metapackage, since the lower version metapackage will not expose any assets for that higher framework.</span></span> <span data-ttu-id="c479c-206">元包资产的版本控制方案与描述框架的最高版本匹配。</span><span class="sxs-lookup"><span data-stu-id="c479c-206">The versioning scheme for metapackages asserts that metapackages match the highest version of the framework they describe.</span></span> <span data-ttu-id="c479c-207">借助于版本控制方案，`NETStandard.Library` 的第一个版本是 v1.6.0，因为它包含 `netstandard1.6` 资产。</span><span class="sxs-lookup"><span data-stu-id="c479c-207">By virtue of the versioning scheme, the first version of `NETStandard.Library` is v1.6.0 given that it contains `netstandard1.6` assets.</span></span> <span data-ttu-id="c479c-208">而上例中的 v1.3.0 版本，只是为了举例方便，实际上并不存在。</span><span class="sxs-lookup"><span data-stu-id="c479c-208">v1.3.0 is used in the example above, for symmetry with the example above, but does not actually exist.</span></span>

### <a name="net-core-application"></a><span data-ttu-id="c479c-209">.NET Core 应用程序</span><span class="sxs-lookup"><span data-stu-id="c479c-209">.NET Core application</span></span>

<span data-ttu-id="c479c-210">.NET Core 应用程序 (TFM: `netcoreapp`) 框架表示 .NET Core 发行版及其提供的控制台应用程序模型附带的包和相关 API。</span><span class="sxs-lookup"><span data-stu-id="c479c-210">The .NET Core Application (TFM: `netcoreapp`) framework represents the packages and associated APIs that come with the .NET Core distribution and the console application model that it provides.</span></span> <span data-ttu-id="c479c-211">.NET Core 必须使用此框架，因为必须要使用其中的控制台应用程序模型。同时只运行于 .Net Core 平台的库也应使用此模型。</span><span class="sxs-lookup"><span data-stu-id="c479c-211">.NET Core apps must use this framework, due to targeting the console application model, as should libraries that intended to run only on .NET Core.</span></span> <span data-ttu-id="c479c-212">使用此框架后，所有应用和库将只能够在 .Net Core 上运行。</span><span class="sxs-lookup"><span data-stu-id="c479c-212">Using this framework restricts apps and libraries to running only on .NET Core.</span></span> 

<span data-ttu-id="c479c-213">`Microsoft.NETCore.App` 元包的目标框架是 `netcoreapp`。</span><span class="sxs-lookup"><span data-stu-id="c479c-213">The `Microsoft.NETCore.App` metapackage targets the `netcoreapp` framework.</span></span> <span data-ttu-id="c479c-214">它提供了约 60 个库的访问权限，其中约 40 个由 `NETStandard.Library` 包提供，还有另外 20 个库。</span><span class="sxs-lookup"><span data-stu-id="c479c-214">It provides access to ~60 libraries, ~40 provided by the `NETStandard.Library` package and ~20 more in addition.</span></span> <span data-ttu-id="c479c-215">可以引用目标框架为 `netcoreapp` 或与框架（如 `netstandard`）兼容的库获得对其他 API 的访问权限。</span><span class="sxs-lookup"><span data-stu-id="c479c-215">You can reference additional libraries that target `netcoreapp` or compatible frameworks, such as `netstandard`, to get access to additional APIs.</span></span> 

<span data-ttu-id="c479c-216">由 `Microsoft.NETCore.App` 提供的大部分其他库还可以使用 `netstandard` 作为目标，如果其他 `netstandard` 库满足这些框架的依赖项的话。</span><span class="sxs-lookup"><span data-stu-id="c479c-216">Most of the additional libraries provided by `Microsoft.NETCore.App` also target `netstandard` given that their dependencies are satisfied by other `netstandard` libraries.</span></span> <span data-ttu-id="c479c-217">这意味着，`netstandard` 库也可以引用这些包作为依赖项。</span><span class="sxs-lookup"><span data-stu-id="c479c-217">That means that `netstandard` libraries can also reference those packages as dependencies.</span></span> 
