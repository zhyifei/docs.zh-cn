---
title: .NET 中的程序集
description: 程序集是基于 .NET 的应用程序的部署、版本控制、重用、激活范围和安全权限的基本单元。
ms.date: 08/15/2019
ms.assetid: 149f5ca5-5b34-4746-9542-1ae43b2d0256
helpviewer_keywords:
- dynamic assemblies
- security [.NET Framework], boundaries
- boundaries of assemblies
- assemblies [.NET Framework], about
- assemblies [.NET Framework], boundaries
- reference scope boundaries
- assemblies [.NET Framework]
- version boundaries
- type boundaries
ms.openlocfilehash: 87030bf9770c464709559b2fb8f4c0004009e48d
ms.sourcegitcommit: d6bd7903d7d46698e9d89d3725f3bb4876891aa3
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/13/2020
ms.locfileid: "83379916"
---
# <a name="assemblies-in-net"></a><span data-ttu-id="5af7a-103">.NET 中的程序集</span><span class="sxs-lookup"><span data-stu-id="5af7a-103">Assemblies in .NET</span></span>

<span data-ttu-id="5af7a-104">程序集构成了 .NET 应用程序的部署、版本控制、重用、激活范围和安全权限的基本单元。</span><span class="sxs-lookup"><span data-stu-id="5af7a-104">Assemblies form the fundamental units of deployment, version control, reuse, activation scoping, and security permissions for .NET-based applications.</span></span> <span data-ttu-id="5af7a-105">程序集是为协同工作而生成的类型和资源的集合，这些类型和资源构成了一个逻辑功能单元。</span><span class="sxs-lookup"><span data-stu-id="5af7a-105">An assembly is a collection of types and resources that are built to work together and form a logical unit of functionality.</span></span> <span data-ttu-id="5af7a-106">程序集采用可执行文件 (.exe) 或动态链接库文件 (.dll) 的形式，是 .NET 应用程序的构建基块   。</span><span class="sxs-lookup"><span data-stu-id="5af7a-106">Assemblies take the form of executable (*.exe*) or dynamic link library (*.dll*) files, and are the building blocks of .NET applications.</span></span> <span data-ttu-id="5af7a-107">它们向公共语言运行时提供了注意类型实现代码所需的信息。</span><span class="sxs-lookup"><span data-stu-id="5af7a-107">They provide the common language runtime with the information it needs to be aware of type implementations.</span></span>

<span data-ttu-id="5af7a-108">在 .NET Core 和 .NET Framework 中，可以从一个或多个源代码文件生成程序集。</span><span class="sxs-lookup"><span data-stu-id="5af7a-108">In .NET Core and .NET Framework, you can build an assembly from one or more source code files.</span></span> <span data-ttu-id="5af7a-109">在 .NET Framework 中，程序集可以包含一个或多个模块。</span><span class="sxs-lookup"><span data-stu-id="5af7a-109">In .NET Framework, assemblies can contain one or more modules.</span></span> <span data-ttu-id="5af7a-110">因此，大型项目可以采用以下规划：由多个开发者单独开发各源代码文件或模块，最后整合所有这些内容以创建一个程序集。</span><span class="sxs-lookup"><span data-stu-id="5af7a-110">This allows larger projects to be planned so that several developers can work on separate source code files or modules, which are combined to create a single assembly.</span></span> <span data-ttu-id="5af7a-111">若要详细了解模块，请参阅[操作说明：生成多文件程序集](../../framework/app-domains/build-multifile-assembly.md)。</span><span class="sxs-lookup"><span data-stu-id="5af7a-111">For more information about modules, see [How to: Build a multifile assembly](../../framework/app-domains/build-multifile-assembly.md).</span></span>

<span data-ttu-id="5af7a-112">程序集具有以下属性：</span><span class="sxs-lookup"><span data-stu-id="5af7a-112">Assemblies have the following properties:</span></span>

- <span data-ttu-id="5af7a-113">程序集以 .exe 或 .dll 文件的形式实现   。</span><span class="sxs-lookup"><span data-stu-id="5af7a-113">Assemblies are implemented as *.exe* or *.dll* files.</span></span>

- <span data-ttu-id="5af7a-114">对于面向 .NET Framework 的库，可以通过将程序集放入[全局程序集缓存 (GAC)](../../framework/app-domains/gac.md)，在应用程序之间共享程序集。</span><span class="sxs-lookup"><span data-stu-id="5af7a-114">For libraries that target the .NET Framework, you can share assemblies between applications by putting them in the [global assembly cache (GAC)](../../framework/app-domains/gac.md).</span></span> <span data-ttu-id="5af7a-115">必须先对程序集进行强命名，然后才能将它们包含到 GAC 中。</span><span class="sxs-lookup"><span data-stu-id="5af7a-115">You must strong-name assemblies before you can include them in the GAC.</span></span> <span data-ttu-id="5af7a-116">有关详细信息，请参阅[具有强名称的程序集](strong-named.md)。</span><span class="sxs-lookup"><span data-stu-id="5af7a-116">For more information, see [Strong-named assemblies](strong-named.md).</span></span>

- <span data-ttu-id="5af7a-117">只有在需要使用时才会将程序集加载到内存中。</span><span class="sxs-lookup"><span data-stu-id="5af7a-117">Assemblies are only loaded into memory if they are required.</span></span> <span data-ttu-id="5af7a-118">如果未使用程序集，则不加载。</span><span class="sxs-lookup"><span data-stu-id="5af7a-118">If they aren't used, they aren't loaded.</span></span> <span data-ttu-id="5af7a-119">也就是说，使用程序集，可以在大型项目中高效管理资源。</span><span class="sxs-lookup"><span data-stu-id="5af7a-119">This means that assemblies can be an efficient way to manage resources in larger projects.</span></span>

- <span data-ttu-id="5af7a-120">可以使用反射，以编程方式获取程序集的相关信息。</span><span class="sxs-lookup"><span data-stu-id="5af7a-120">You can programmatically obtain information about an assembly by using reflection.</span></span> <span data-ttu-id="5af7a-121">有关详细信息，请参阅[反射 (C#)](../../csharp/programming-guide/concepts/reflection.md) 或[反射 (Visual Basic)](../../visual-basic/programming-guide/concepts/reflection.md)。</span><span class="sxs-lookup"><span data-stu-id="5af7a-121">For more information, see [Reflection (C#)](../../csharp/programming-guide/concepts/reflection.md) or [Reflection (Visual Basic)](../../visual-basic/programming-guide/concepts/reflection.md).</span></span>

- <span data-ttu-id="5af7a-122">你可以加载一个程序集，以使用 .NET Core 中的 <xref:System.Reflection.MetadataLoadContext> 类以及 .NET Core 和 .NET Framework 中的 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> 或 <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A?displayProperty=nameWithType> 方法来检查该程序集。</span><span class="sxs-lookup"><span data-stu-id="5af7a-122">You can load an assembly just to inspect it by using the <xref:System.Reflection.MetadataLoadContext> class in .NET Core and the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A?displayProperty=nameWithType> methods in .NET Core and .NET Framework.</span></span>

## <a name="assemblies-in-the-common-language-runtime"></a><span data-ttu-id="5af7a-123">公共语言运行时中的程序集</span><span class="sxs-lookup"><span data-stu-id="5af7a-123">Assemblies in the common language runtime</span></span>

<span data-ttu-id="5af7a-124">程序集向公共语言运行时提供了注意类型实现代码所需的信息。</span><span class="sxs-lookup"><span data-stu-id="5af7a-124">Assemblies provide the common language runtime with the information it needs to be aware of type implementations.</span></span> <span data-ttu-id="5af7a-125">对于运行时，类型不存在于程序集上下文之外。</span><span class="sxs-lookup"><span data-stu-id="5af7a-125">To the runtime, a type does not exist outside the context of an assembly.</span></span>

<span data-ttu-id="5af7a-126">程序集定义以下信息：</span><span class="sxs-lookup"><span data-stu-id="5af7a-126">An assembly defines the following information:</span></span>

- <span data-ttu-id="5af7a-127">公共语言运行时执行的代码。</span><span class="sxs-lookup"><span data-stu-id="5af7a-127">Code that the common language runtime executes.</span></span> <span data-ttu-id="5af7a-128">请注意，每个程序集只能有一个入口点：`DllMain`、`WinMain` 或 `Main`。</span><span class="sxs-lookup"><span data-stu-id="5af7a-128">Note that each assembly can have only one entry point: `DllMain`, `WinMain`, or `Main`.</span></span>

- <span data-ttu-id="5af7a-129">安全边界。</span><span class="sxs-lookup"><span data-stu-id="5af7a-129">Security boundary.</span></span> <span data-ttu-id="5af7a-130">程序集就是在其中请求和授予权限的单元。</span><span class="sxs-lookup"><span data-stu-id="5af7a-130">An assembly is the unit at which permissions are requested and granted.</span></span> <span data-ttu-id="5af7a-131">有关程序集中安全边界的详细信息，请参阅[程序集安全注意事项](security-considerations.md)。</span><span class="sxs-lookup"><span data-stu-id="5af7a-131">For more information about security boundaries in assemblies, see [Assembly security considerations](security-considerations.md).</span></span>

- <span data-ttu-id="5af7a-132">类型边界。</span><span class="sxs-lookup"><span data-stu-id="5af7a-132">Type boundary.</span></span> <span data-ttu-id="5af7a-133">每一类型的标识均包括该类型所驻留的程序集的名称。</span><span class="sxs-lookup"><span data-stu-id="5af7a-133">Every type's identity includes the name of the assembly in which it resides.</span></span> <span data-ttu-id="5af7a-134">在一个程序集的范围中加载的称为 `MyType` 的类型不同于在另一个程序集范围中加载的称为 `MyType` 的类型。</span><span class="sxs-lookup"><span data-stu-id="5af7a-134">A type called `MyType` that is loaded in the scope of one assembly is not the same as a type called `MyType` that is loaded in the scope of another assembly.</span></span>

- <span data-ttu-id="5af7a-135">引用范围边界。</span><span class="sxs-lookup"><span data-stu-id="5af7a-135">Reference scope boundary.</span></span> <span data-ttu-id="5af7a-136">[程序集清单](#assembly-manifest)包含用于解析类型和满足资源请求的元数据。</span><span class="sxs-lookup"><span data-stu-id="5af7a-136">The [assembly manifest](#assembly-manifest) has metadata that is used for resolving types and satisfying resource requests.</span></span> <span data-ttu-id="5af7a-137">该清单指定要在程序集外公开的类型和资源，并枚举它所依赖的其他程序集。</span><span class="sxs-lookup"><span data-stu-id="5af7a-137">The manifest specifies the types and resources to expose outside the assembly, and enumerates other assemblies on which it depends.</span></span> <span data-ttu-id="5af7a-138">除非可迁移可执行 (PE) 文件中的 Microsoft 中间语言 (MSIL) 代码具有相关的[程序集清单](#assembly-manifest)，否则不执行此代码。</span><span class="sxs-lookup"><span data-stu-id="5af7a-138">Microsoft intermediate language (MSIL) code in a portable executable (PE) file won't be executed unless it has an associated [assembly manifest](#assembly-manifest).</span></span>

- <span data-ttu-id="5af7a-139">版本边界。</span><span class="sxs-lookup"><span data-stu-id="5af7a-139">Version boundary.</span></span> <span data-ttu-id="5af7a-140">程序集是公共语言运行时中无版本冲突的最小单元。</span><span class="sxs-lookup"><span data-stu-id="5af7a-140">The assembly is the smallest versionable unit in the common language runtime.</span></span> <span data-ttu-id="5af7a-141">同一程序集中的所有类型和资源均会被版本化为一个单元。</span><span class="sxs-lookup"><span data-stu-id="5af7a-141">All types and resources in the same assembly are versioned as a unit.</span></span> <span data-ttu-id="5af7a-142">[程序集清单](#assembly-manifest)描述你为任何依赖项程序集所指定的版本依赖性。</span><span class="sxs-lookup"><span data-stu-id="5af7a-142">The [assembly manifest](#assembly-manifest) describes the version dependencies you specify for any dependent assemblies.</span></span> <span data-ttu-id="5af7a-143">有关版本控制的详细信息，请参阅[程序集版本控制](versioning.md)。</span><span class="sxs-lookup"><span data-stu-id="5af7a-143">For more information about versioning, see [Assembly versioning](versioning.md).</span></span>

- <span data-ttu-id="5af7a-144">部署单元。</span><span class="sxs-lookup"><span data-stu-id="5af7a-144">Deployment unit.</span></span> <span data-ttu-id="5af7a-145">当一个应用程序启动时，只有该应用程序最初调用的程序集必须存在。</span><span class="sxs-lookup"><span data-stu-id="5af7a-145">When an application starts, only the assemblies that the application initially calls must be present.</span></span> <span data-ttu-id="5af7a-146">其他程序集（例如，包含本地化资源或实用工具类的程序集）可以按需检索。</span><span class="sxs-lookup"><span data-stu-id="5af7a-146">Other assemblies, such as assemblies containing localization resources or utility classes, can be retrieved on demand.</span></span> <span data-ttu-id="5af7a-147">这样，应用在第一次下载时就会比较精简。</span><span class="sxs-lookup"><span data-stu-id="5af7a-147">This allows apps to be simple and thin when first downloaded.</span></span> <span data-ttu-id="5af7a-148">有关部署程序集的详细信息，请参阅[部署应用程序](../../framework/deployment/index.md)。</span><span class="sxs-lookup"><span data-stu-id="5af7a-148">For more information about deploying assemblies, see [Deploy applications](../../framework/deployment/index.md).</span></span>

- <span data-ttu-id="5af7a-149">并行执行单元。</span><span class="sxs-lookup"><span data-stu-id="5af7a-149">Side-by-side execution unit.</span></span> <span data-ttu-id="5af7a-150">有关运行多个版本的程序集的详细信息，请参阅[程序集和并行执行](side-by-side-execution.md)。</span><span class="sxs-lookup"><span data-stu-id="5af7a-150">For more information about running multiple versions of an assembly, see [Assemblies and side-by-side execution](side-by-side-execution.md).</span></span>

## <a name="create-an-assembly"></a><span data-ttu-id="5af7a-151">创建程序集</span><span class="sxs-lookup"><span data-stu-id="5af7a-151">Create an assembly</span></span>

<span data-ttu-id="5af7a-152">程序集可以为静态或动态。</span><span class="sxs-lookup"><span data-stu-id="5af7a-152">Assemblies can be static or dynamic.</span></span> <span data-ttu-id="5af7a-153">静态程序集存储在磁盘上的可迁移可执行 (PE) 文件中。</span><span class="sxs-lookup"><span data-stu-id="5af7a-153">Static assemblies are stored on disk in portable executable (PE) files.</span></span> <span data-ttu-id="5af7a-154">静态程序集可以包括接口、类和资源（如位图、JPEG 文件和其他资源文件）。</span><span class="sxs-lookup"><span data-stu-id="5af7a-154">Static assemblies can include interfaces, classes, and resources like bitmaps, JPEG files, and other resource files.</span></span> <span data-ttu-id="5af7a-155">你还可以创建动态程序集，动态程序集直接从内存运行并且在执行前不保存到磁盘上。</span><span class="sxs-lookup"><span data-stu-id="5af7a-155">You can also create dynamic assemblies, which are run directly from memory and aren't saved to disk before execution.</span></span> <span data-ttu-id="5af7a-156">你可以在执行动态程序集后将它们保存在磁盘上。</span><span class="sxs-lookup"><span data-stu-id="5af7a-156">You can save dynamic assemblies to disk after they have executed.</span></span>

<span data-ttu-id="5af7a-157">有几种创建程序集的方法。</span><span class="sxs-lookup"><span data-stu-id="5af7a-157">There are several ways to create assemblies.</span></span> <span data-ttu-id="5af7a-158">你可以使用可创建 .dll 或 .exe 文件的开发工具，例如 Visual Studio   。</span><span class="sxs-lookup"><span data-stu-id="5af7a-158">You can use development tools, such as Visual Studio, that can create *.dll* or *.exe* files.</span></span> <span data-ttu-id="5af7a-159">可以使用 Windows SDK 中的工具创建具有从其他开发环境中创建的模块的程序集。</span><span class="sxs-lookup"><span data-stu-id="5af7a-159">You can use tools in the Windows SDK to create assemblies with modules from other development environments.</span></span> <span data-ttu-id="5af7a-160">还可以使用公共语言运行时 API（例如 <xref:System.Reflection.Emit?displayProperty=nameWithType>）来创建动态程序集。</span><span class="sxs-lookup"><span data-stu-id="5af7a-160">You can also use common language runtime APIs, such as <xref:System.Reflection.Emit?displayProperty=nameWithType>, to create dynamic assemblies.</span></span>

<span data-ttu-id="5af7a-161">可以采用以下方法编译程序集：在 Visual Studio 中生成程序集、使用 .NET Core 命令行接口工具生成程序集，或使用命令行编译器生成 .NET Framework 程序集。</span><span class="sxs-lookup"><span data-stu-id="5af7a-161">Compile assemblies by building them in Visual Studio, building them with .NET Core command-line interface tools, or building .NET Framework assemblies with a command-line compiler.</span></span> <span data-ttu-id="5af7a-162">要详细了解如何使用 .NET Core CLI 生成程序集，请参阅 [.NET Core CLI 概述](../../core/tools/index.md)。</span><span class="sxs-lookup"><span data-stu-id="5af7a-162">For more information about building assemblies using .NET Core CLI, see [.NET Core CLI overview](../../core/tools/index.md).</span></span> <span data-ttu-id="5af7a-163">要了解如何使用命令行编译器生成程序集，请参阅[使用 csc.exe 的命令行生成](../../csharp/language-reference/compiler-options/command-line-building-with-csc-exe.md)（适用于 C#），或者[从命令行生成](../../visual-basic/reference/command-line-compiler/building-from-the-command-line.md)（适用于 Visual Basic）。</span><span class="sxs-lookup"><span data-stu-id="5af7a-163">For building assemblies with the command-line compilers, see [Command-line build with csc.exe](../../csharp/language-reference/compiler-options/command-line-building-with-csc-exe.md) for C#, or [Build from the command line](../../visual-basic/reference/command-line-compiler/building-from-the-command-line.md) for Visual Basic.</span></span>

> [!NOTE]
> <span data-ttu-id="5af7a-164">若要在 Visual Studio 中生成程序集，请在“生成”菜单上选择“生成”   。</span><span class="sxs-lookup"><span data-stu-id="5af7a-164">To build an assembly in Visual Studio, on the **Build** menu, select **Build**.</span></span>

## <a name="assembly-manifest"></a><span data-ttu-id="5af7a-165">程序集清单</span><span class="sxs-lookup"><span data-stu-id="5af7a-165">Assembly manifest</span></span>

<span data-ttu-id="5af7a-166">每个程序集都有一个程序集清单文件  。</span><span class="sxs-lookup"><span data-stu-id="5af7a-166">Every assembly has an *assembly manifest* file.</span></span> <span data-ttu-id="5af7a-167">与目录类似，程序集清单包含以下内容：</span><span class="sxs-lookup"><span data-stu-id="5af7a-167">Similar to a table of contents, the assembly manifest contains:</span></span>

- <span data-ttu-id="5af7a-168">程序集的标识（名称和版本）。</span><span class="sxs-lookup"><span data-stu-id="5af7a-168">The assembly's identity (its name and version).</span></span>

- <span data-ttu-id="5af7a-169">文件表，描述构成程序集的其他所有文件（例如，.exe 或 .dll 文件所依赖的你创建的其他程序集、位图文件或自述文件）   。</span><span class="sxs-lookup"><span data-stu-id="5af7a-169">A file table describing all the other files that make up the assembly, such as other assemblies you created that your *.exe* or *.dll* file relies on, bitmap files, or Readme files.</span></span>

- <span data-ttu-id="5af7a-170">程序集引用列表，即所有外部依赖项的列表，如 .dll 或其他文件   。</span><span class="sxs-lookup"><span data-stu-id="5af7a-170">An *assembly reference list*, which is a list of all external dependencies, such as *.dll*s or other files.</span></span> <span data-ttu-id="5af7a-171">程序集既可以引用全局对象，也可以引用私有对象。</span><span class="sxs-lookup"><span data-stu-id="5af7a-171">Assembly references contain references to both global and private objects.</span></span> <span data-ttu-id="5af7a-172">全局对象可用于所有其他应用程序。</span><span class="sxs-lookup"><span data-stu-id="5af7a-172">Global objects are available to all other applications.</span></span> <span data-ttu-id="5af7a-173">在 .NET Core 中，全局对象与特定的 .NET Core 运行时结合使用。</span><span class="sxs-lookup"><span data-stu-id="5af7a-173">In .NET Core, global objects are coupled with a particular .NET Core runtime.</span></span> <span data-ttu-id="5af7a-174">在 .NET Framework 中，全局对象位于全局程序集缓存 (GAC) 中。</span><span class="sxs-lookup"><span data-stu-id="5af7a-174">In .NET Framework, global objects reside in the global assembly cache (GAC).</span></span> <span data-ttu-id="5af7a-175">System.IO.dll 是 GAC 中程序集的一个示例  。</span><span class="sxs-lookup"><span data-stu-id="5af7a-175">*System.IO.dll* is an example of an assembly in the GAC.</span></span> <span data-ttu-id="5af7a-176">私有对象必须位于级别不高于应用安装目录的目录中。</span><span class="sxs-lookup"><span data-stu-id="5af7a-176">Private objects must be in a directory level at or below the directory in which your app is installed.</span></span>

<span data-ttu-id="5af7a-177">由于程序集包含内容、版本控制和依赖项的相关信息，因此使用它们的应用程序不依赖 Windows 系统上的注册表等外部源也能正常运行。</span><span class="sxs-lookup"><span data-stu-id="5af7a-177">Because assemblies contain information about content, versioning, and dependencies, the applications that use them needn't rely on external sources, such as the registry on Windows systems, to function properly.</span></span> <span data-ttu-id="5af7a-178">程序集减少了 .dll 冲突，让应用程序变得更可靠、更易于部署  。</span><span class="sxs-lookup"><span data-stu-id="5af7a-178">Assemblies reduce *.dll* conflicts and make your applications more reliable and easier to deploy.</span></span> <span data-ttu-id="5af7a-179">在许多情况下，只需将 .NET 应用程序的文件复制到目标计算机，即可进行安装。</span><span class="sxs-lookup"><span data-stu-id="5af7a-179">In many cases, you can install a .NET-based application simply by copying its files to the target computer.</span></span> <span data-ttu-id="5af7a-180">有关详细信息，请参阅[程序集清单](manifest.md)。</span><span class="sxs-lookup"><span data-stu-id="5af7a-180">For more information, see [Assembly manifest](manifest.md).</span></span>

## <a name="add-a-reference-to-an-assembly"></a><span data-ttu-id="5af7a-181">添加对程序集的引用</span><span class="sxs-lookup"><span data-stu-id="5af7a-181">Add a reference to an assembly</span></span>

<span data-ttu-id="5af7a-182">必须添加对应用程序中的程序集的引用，才能使用该程序集。</span><span class="sxs-lookup"><span data-stu-id="5af7a-182">To use an assembly in an application, you must add a reference to it.</span></span> <span data-ttu-id="5af7a-183">引用程序集后，应用程序可以使用其名称空间的所有可访问类型、属性、方法和其他成员，就好像它们的代码是源文件的一部分一样。</span><span class="sxs-lookup"><span data-stu-id="5af7a-183">Once an assembly is referenced, all the accessible types, properties, methods, and other members of its namespaces are available to your application as if their code were part of your source file.</span></span>

> [!NOTE]
> <span data-ttu-id="5af7a-184">.NET 类库中的大多数程序集都是自动引用的。</span><span class="sxs-lookup"><span data-stu-id="5af7a-184">Most assemblies from the .NET Class Library are referenced automatically.</span></span> <span data-ttu-id="5af7a-185">如果系统程序集不是自动引用的，则对于 .NET Core，可以添加对包含该程序集的 NuGet 包的引用。</span><span class="sxs-lookup"><span data-stu-id="5af7a-185">If a system assembly isn't automatically referenced, for .NET Core, you can add a reference to the NuGet package that contains the assembly.</span></span> <span data-ttu-id="5af7a-186">请使用 Visual Studio 中的 NuGet 包管理器，或者将程序集的 [\<PackageReference>](../../core/tools/dependencies.md#the-packagereference-element) 元素添加到 .csproj 或 .vbproj 项目   。</span><span class="sxs-lookup"><span data-stu-id="5af7a-186">Either use the NuGet Package Manager in Visual Studio, or add a [\<PackageReference>](../../core/tools/dependencies.md#the-packagereference-element) element for the assembly to the *.csproj* or *.vbproj* project.</span></span> <span data-ttu-id="5af7a-187">在 .NET Framework 中，可以通过在 Visual Studio 中使用“添加引用”对话框，或者通过使用 [C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) 或 [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md) 编译器的 `-reference` 命令行选项，添加对该程序集的引用  。</span><span class="sxs-lookup"><span data-stu-id="5af7a-187">In .NET Framework, you can add a reference to the assembly by using the **Add Reference** dialog in Visual Studio, or by using the `-reference` command line option for the [C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) or [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md) compilers.</span></span>

<span data-ttu-id="5af7a-188">在 C# 中，可以在单个应用程序中使用同一程序集的两个版本。</span><span class="sxs-lookup"><span data-stu-id="5af7a-188">In C#, you can use two versions of the same assembly in a single application.</span></span> <span data-ttu-id="5af7a-189">有关详细信息，请参阅[外部别名](../../csharp/language-reference/keywords/extern-alias.md)。</span><span class="sxs-lookup"><span data-stu-id="5af7a-189">For more information, see [extern alias](../../csharp/language-reference/keywords/extern-alias.md).</span></span>

## <a name="related-content"></a><span data-ttu-id="5af7a-190">相关的内容</span><span class="sxs-lookup"><span data-stu-id="5af7a-190">Related content</span></span>

|<span data-ttu-id="5af7a-191">Title</span><span class="sxs-lookup"><span data-stu-id="5af7a-191">Title</span></span>|<span data-ttu-id="5af7a-192">描述</span><span class="sxs-lookup"><span data-stu-id="5af7a-192">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="5af7a-193">程序集内容</span><span class="sxs-lookup"><span data-stu-id="5af7a-193">Assembly contents</span></span>](contents.md)|<span data-ttu-id="5af7a-194">组成程序集的元素。</span><span class="sxs-lookup"><span data-stu-id="5af7a-194">Elements that make up an assembly.</span></span>|
|[<span data-ttu-id="5af7a-195">程序集清单</span><span class="sxs-lookup"><span data-stu-id="5af7a-195">Assembly manifest</span></span>](manifest.md)|<span data-ttu-id="5af7a-196">程序集清单中的数据，以及它如何存储在程序集中。</span><span class="sxs-lookup"><span data-stu-id="5af7a-196">Data in the assembly manifest, and how it is stored in assemblies.</span></span>|
|[<span data-ttu-id="5af7a-197">全局程序集缓存</span><span class="sxs-lookup"><span data-stu-id="5af7a-197">Global assembly cache</span></span>](../../framework/app-domains/gac.md)|<span data-ttu-id="5af7a-198">GAC 如何存储和使用程序集。</span><span class="sxs-lookup"><span data-stu-id="5af7a-198">How the GAC stores and uses assemblies.</span></span>|
|[<span data-ttu-id="5af7a-199">具有强名称的程序集</span><span class="sxs-lookup"><span data-stu-id="5af7a-199">Strong-named assemblies</span></span>](strong-named.md)|<span data-ttu-id="5af7a-200">具有强名称的程序集的特征。</span><span class="sxs-lookup"><span data-stu-id="5af7a-200">Characteristics of strong-named assemblies.</span></span>|
|[<span data-ttu-id="5af7a-201">程序集安全注意事项</span><span class="sxs-lookup"><span data-stu-id="5af7a-201">Assembly security considerations</span></span>](security-considerations.md)|<span data-ttu-id="5af7a-202">安全性如何作用于程序集。</span><span class="sxs-lookup"><span data-stu-id="5af7a-202">How security works with assemblies.</span></span>|
|[<span data-ttu-id="5af7a-203">程序集版本控制</span><span class="sxs-lookup"><span data-stu-id="5af7a-203">Assembly versioning</span></span>](versioning.md)|<span data-ttu-id="5af7a-204">.NET Framework 版本控制策略的概述。</span><span class="sxs-lookup"><span data-stu-id="5af7a-204">Overview of the .NET Framework versioning policy.</span></span>|
|[<span data-ttu-id="5af7a-205">程序集位置</span><span class="sxs-lookup"><span data-stu-id="5af7a-205">Assembly placement</span></span>](../../framework/app-domains/assembly-placement.md)|<span data-ttu-id="5af7a-206">在何处可以找到程序集。</span><span class="sxs-lookup"><span data-stu-id="5af7a-206">Where to locate assemblies.</span></span>|
|[<span data-ttu-id="5af7a-207">程序集和并行执行</span><span class="sxs-lookup"><span data-stu-id="5af7a-207">Assemblies and side-by-side execution</span></span>](side-by-side-execution.md)|<span data-ttu-id="5af7a-208">同时使用多个版本的运行时或程序集。</span><span class="sxs-lookup"><span data-stu-id="5af7a-208">Use multiple versions of the runtime or an assembly simultaneously.</span></span>|
|[<span data-ttu-id="5af7a-209">发出动态方法和程序集</span><span class="sxs-lookup"><span data-stu-id="5af7a-209">Emit dynamic methods and assemblies</span></span>](../../../docs/framework/reflection-and-codedom/emitting-dynamic-methods-and-assemblies.md)|<span data-ttu-id="5af7a-210">如何创建动态程序集。</span><span class="sxs-lookup"><span data-stu-id="5af7a-210">How to create dynamic assemblies.</span></span>|
|[<span data-ttu-id="5af7a-211">运行时如何定位程序集</span><span class="sxs-lookup"><span data-stu-id="5af7a-211">How the runtime locates assemblies</span></span>](../../../docs/framework/deployment/how-the-runtime-locates-assemblies.md)|<span data-ttu-id="5af7a-212">.NET Framework 如何在运行时解析程序集引用。</span><span class="sxs-lookup"><span data-stu-id="5af7a-212">How the .NET Framework resolves assembly references at run time.</span></span>|

## <a name="reference"></a><span data-ttu-id="5af7a-213">参考</span><span class="sxs-lookup"><span data-stu-id="5af7a-213">Reference</span></span>

<xref:System.Reflection.Assembly?displayProperty=nameWithType>

## <a name="see-also"></a><span data-ttu-id="5af7a-214">请参阅</span><span class="sxs-lookup"><span data-stu-id="5af7a-214">See also</span></span>

- [<span data-ttu-id="5af7a-215">.NET 程序集文件格式</span><span class="sxs-lookup"><span data-stu-id="5af7a-215">.NET assembly file format</span></span>](file-format.md)
- [<span data-ttu-id="5af7a-216">友元程序集</span><span class="sxs-lookup"><span data-stu-id="5af7a-216">Friend assemblies</span></span>](friend.md)
- [<span data-ttu-id="5af7a-217">引用程序集</span><span class="sxs-lookup"><span data-stu-id="5af7a-217">Reference assemblies</span></span>](reference-assemblies.md)
- [<span data-ttu-id="5af7a-218">如何：加载和卸载程序集</span><span class="sxs-lookup"><span data-stu-id="5af7a-218">How to: Load and unload assemblies</span></span>](load-unload.md)
- [<span data-ttu-id="5af7a-219">如何：在 .NET Core 中使用和调试程序集可卸载性</span><span class="sxs-lookup"><span data-stu-id="5af7a-219">How to: Use and debug assembly unloadability in .NET Core</span></span>](unloadability.md)
- [<span data-ttu-id="5af7a-220">如何：确定文件是否为程序集</span><span class="sxs-lookup"><span data-stu-id="5af7a-220">How to: Determine if a file is an assembly</span></span>](identify.md)
- [<span data-ttu-id="5af7a-221">如何：使用 MetadataLoadContext 检查程序集内容</span><span class="sxs-lookup"><span data-stu-id="5af7a-221">How to: Inspect assembly contents using MetadataLoadContext</span></span>](inspect-contents-using-metadataloadcontext.md)
