---
title: XML 序列化简介
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- XML serialization, about XML serialization
- ICollection interface, serializing
- XmlSerializer class, serializing
- serialization, about serialization
- DataSet class, serializing
- XML Schema, serializing
ms.assetid: 8c63200d-db63-4a03-a93d-21641623df62
ms.openlocfilehash: 5de13fc4da371220f46a107ca9b620e1313e75d4
ms.sourcegitcommit: 75567a3cb437009db55949c6092f4e77ed1a9da4
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/15/2019
ms.locfileid: "54307521"
---
# <a name="introducing-xml-serialization"></a><span data-ttu-id="d49a0-102">XML 序列化简介</span><span class="sxs-lookup"><span data-stu-id="d49a0-102">Introducing XML Serialization</span></span>

<span data-ttu-id="d49a0-103">序列化是将对象转换成易于传输的形式的过程。</span><span class="sxs-lookup"><span data-stu-id="d49a0-103">Serialization is the process of converting an object into a form that can be readily transported.</span></span> <span data-ttu-id="d49a0-104">例如，可以序列化对象，并使用 HTTP 通过 Internet 在客户端和服务器之间进行传输。</span><span class="sxs-lookup"><span data-stu-id="d49a0-104">For example, you can serialize an object and transport it over the Internet using HTTP between a client and a server.</span></span> <span data-ttu-id="d49a0-105">另一方面，反序列化在流中重新构建对象。</span><span class="sxs-lookup"><span data-stu-id="d49a0-105">On the other end, deserialization reconstructs the object from the stream.</span></span>

 <span data-ttu-id="d49a0-106">XML 序列化只将对象的公共字段和属性值序列化为 XML 流。</span><span class="sxs-lookup"><span data-stu-id="d49a0-106">XML serialization serializes only the public fields and property values of an object into an XML stream.</span></span> <span data-ttu-id="d49a0-107">XML 序列化不包括类型信息。</span><span class="sxs-lookup"><span data-stu-id="d49a0-107">XML serialization does not include type information.</span></span> <span data-ttu-id="d49a0-108">例如，如果“Library”命名空间中存在“Book”对象，则不能保证将它反序列化为同一类型的对象。</span><span class="sxs-lookup"><span data-stu-id="d49a0-108">For example, if you have a **Book** object that exists in the **Library** namespace, there is no guarantee that it is deserialized into an object of the same type.</span></span>

> [!NOTE]
> <span data-ttu-id="d49a0-109">XML 序列化不能转换方法、索引器、私有字段或只读属性（只读集合除外）。</span><span class="sxs-lookup"><span data-stu-id="d49a0-109">XML serialization does not convert methods, indexers, private fields, or read-only properties (except read-only collections).</span></span> <span data-ttu-id="d49a0-110">若要序列化对象的所有公共和私有字段和属性，请使用 <xref:System.Runtime.Serialization.DataContractSerializer> 而不要使用 XML 序列化。</span><span class="sxs-lookup"><span data-stu-id="d49a0-110">To serialize all an object's fields and properties, both public and private, use the <xref:System.Runtime.Serialization.DataContractSerializer> instead of XML serialization.</span></span>

 <span data-ttu-id="d49a0-111">XML 序列化中的中心类是 <xref:System.Xml.Serialization.XmlSerializer> 类，此类中最重要的方法是 Serialize 和 Deserialize 方法。</span><span class="sxs-lookup"><span data-stu-id="d49a0-111">The central class in XML serialization is the <xref:System.Xml.Serialization.XmlSerializer> class, and the most important methods in this class are the **Serialize** and **Deserialize** methods.</span></span> <span data-ttu-id="d49a0-112"><xref:System.Xml.Serialization.XmlSerializer> 创建 C# 文件并将其编译为 .dll 文件，以执行此序列化。</span><span class="sxs-lookup"><span data-stu-id="d49a0-112">The <xref:System.Xml.Serialization.XmlSerializer> creates C# files and compiles them into .dll files to perform this serialization.</span></span> <span data-ttu-id="d49a0-113">在 .NET Framework 2.0 中，[XML 序列化程序生成器工具 (Sgen.exe)](xml-serializer-generator-tool-sgen-exe.md) 旨在预先生成要与应用程序一起部署的这些序列化程序集，并改进启动性能。</span><span class="sxs-lookup"><span data-stu-id="d49a0-113">In .NET Framework 2.0, the [XML Serializer Generator Tool (Sgen.exe)](xml-serializer-generator-tool-sgen-exe.md) is designed to generate these serialization assemblies in advance to be deployed with your application and improve startup performance.</span></span> <span data-ttu-id="d49a0-114">生成的 XML 流**XmlSerializer**符合 World Wide Web 联合会 (W3C) [XML 架构定义语言 (XSD) 1.0 建议](https://www.w3.org/TR/xslt)。</span><span class="sxs-lookup"><span data-stu-id="d49a0-114">The XML stream generated by the **XmlSerializer** is compliant with the World Wide Web Consortium (W3C) [XML Schema definition language (XSD) 1.0 recommendation](https://www.w3.org/TR/xslt).</span></span> <span data-ttu-id="d49a0-115">此外，生成的数据类型都符合文档标题为"XML 架构第 2 部分：数据类型。"</span><span class="sxs-lookup"><span data-stu-id="d49a0-115">Furthermore, the data types generated are compliant with the document titled "XML Schema Part 2: Datatypes."</span></span>

 <span data-ttu-id="d49a0-116">对象中的数据是用编程语言构造来描述的，如类、字段、属性、基元类型、数组，甚至是 XmlElement 或 XmlAttribute 对象形式的嵌入 XML。</span><span class="sxs-lookup"><span data-stu-id="d49a0-116">The data in your objects is described using programming language constructs like classes, fields, properties, primitive types, arrays, and even embedded XML in the form of **XmlElement** or **XmlAttribute** objects.</span></span> <span data-ttu-id="d49a0-117">您可以创建自己的用特性批注的类，也可以使用 XML 架构定义工具生成基于现有 XML 架构的类。</span><span class="sxs-lookup"><span data-stu-id="d49a0-117">You have the option of creating your own classes, annotated with attributes, or using the XML Schema Definition tool to generate the classes based on an existing XML Schema.</span></span>

 <span data-ttu-id="d49a0-118">如果有 XML 架构，则可以运行 XML 架构定义工具生成一组类，将这组类的类型强制为此架构，并用特性进行批注。</span><span class="sxs-lookup"><span data-stu-id="d49a0-118">If you have an XML Schema, you can run the XML Schema Definition tool to produce a set of classes that are strongly typed to the schema and annotated with attributes.</span></span> <span data-ttu-id="d49a0-119">当序列化这种类的实例时，生成的 XML 符合 XML 架构。</span><span class="sxs-lookup"><span data-stu-id="d49a0-119">When an instance of such a class is serialized, the generated XML adheres to the XML Schema.</span></span> <span data-ttu-id="d49a0-120">对于这种类，可以采用易于操作的对象模型进行编程，同时确保生成的 XML 符合 XML 架构。</span><span class="sxs-lookup"><span data-stu-id="d49a0-120">Provided with such a class, you can program against an easily manipulated object model while being assured that the generated XML conforms to the XML schema.</span></span> <span data-ttu-id="d49a0-121">这是使用 .NET Framework 中的其他类（如 XmlReader 和 XmlWriter 类）分析和编写 XML 流的另一种方法。</span><span class="sxs-lookup"><span data-stu-id="d49a0-121">This is an alternative to using other classes in the .NET Framework, such as the **XmlReader** and **XmlWriter** classes, to parse and write an XML stream.</span></span> <span data-ttu-id="d49a0-122">有关详细信息，请参阅 [XML 文档和数据](../../../docs/standard/data/xml/index.md)。</span><span class="sxs-lookup"><span data-stu-id="d49a0-122">For more information, see [XML Documents and Data](../../../docs/standard/data/xml/index.md).</span></span> <span data-ttu-id="d49a0-123">这些类可让您分析任何 XML 流。</span><span class="sxs-lookup"><span data-stu-id="d49a0-123">These classes allow you to parse any XML stream.</span></span> <span data-ttu-id="d49a0-124">相反，如果 XML 流应符合已知的 XML 架构，则使用 XmlSerializer。</span><span class="sxs-lookup"><span data-stu-id="d49a0-124">In contrast, use the **XmlSerializer** when the XML stream is expected to conform to a known XML Schema.</span></span>

 <span data-ttu-id="d49a0-125">特性可控制 XmlSerializer 类生成的 XML 流，使你能够设置 XML 流的 XML 命名空间、元素名称、特性名称等。</span><span class="sxs-lookup"><span data-stu-id="d49a0-125">Attributes control the XML stream generated by the **XmlSerializer** class, allowing you to set the XML namespace, element name, attribute name, and so on, of the XML stream.</span></span> <span data-ttu-id="d49a0-126">有关这些特性以及它们如何控制 XML 序列化的详细信息，请参阅[使用特性控制 XML 序列化](controlling-xml-serialization-using-attributes.md)。</span><span class="sxs-lookup"><span data-stu-id="d49a0-126">For more information about these attributes and how they control XML serialization, see [Controlling XML Serialization Using Attributes](controlling-xml-serialization-using-attributes.md).</span></span> <span data-ttu-id="d49a0-127">有关那些用于控制生成的 XML 的特性的表格，请参阅[控制 XML 序列化的特性](attributes-that-control-xml-serialization.md)。</span><span class="sxs-lookup"><span data-stu-id="d49a0-127">For a table of those attributes that are used to control the generated XML, see [Attributes That Control XML Serialization](attributes-that-control-xml-serialization.md).</span></span>

 <span data-ttu-id="d49a0-128">XmlSerializer 类可以进一步序列化对象并生成编码的 SOAP XML 流。</span><span class="sxs-lookup"><span data-stu-id="d49a0-128">The **XmlSerializer** class can further serialize an object and generate an encoded SOAP XML stream.</span></span> <span data-ttu-id="d49a0-129">生成的 XML 符合万维网联合会文档“简单对象访问协议 (SOAP) 1.1”(Simple Object Access Protocol (SOAP) 1.1) 的第 5 节。</span><span class="sxs-lookup"><span data-stu-id="d49a0-129">The generated XML adheres to section 5 of the World Wide Web Consortium document titled "Simple Object Access Protocol (SOAP) 1.1."</span></span> <span data-ttu-id="d49a0-130">有关此过程的详细信息，请参阅[如何：SOAP 编码的 XML Stream 将对象序列化为](how-to-serialize-an-object-as-a-soap-encoded-xml-stream.md)。</span><span class="sxs-lookup"><span data-stu-id="d49a0-130">For more information about this process, see [How to: Serialize an Object as a SOAP-Encoded XML Stream](how-to-serialize-an-object-as-a-soap-encoded-xml-stream.md).</span></span> <span data-ttu-id="d49a0-131">有关可控制生成的 XML 的特性的表格，请参阅[控制编码的 SOAP 序列化的特性](attributes-that-control-encoded-soap-serialization.md)。</span><span class="sxs-lookup"><span data-stu-id="d49a0-131">For a table of the attributes that control the generated XML, see [Attributes That Control Encoded SOAP Serialization](attributes-that-control-encoded-soap-serialization.md).</span></span>

 <span data-ttu-id="d49a0-132">XmlSerializer 类生成由 XML Web 服务创建并传递给 XML Web 服务的 SOAP 信息。</span><span class="sxs-lookup"><span data-stu-id="d49a0-132">The **XmlSerializer** class generates the SOAP messages created by, and passed to, XML Web services.</span></span> <span data-ttu-id="d49a0-133">要控制 SOAP 消息，可以将特性应用于在 XML Web services 文件 (.asmx) 中找到的类、返回值、参数和字段。</span><span class="sxs-lookup"><span data-stu-id="d49a0-133">To control the SOAP messages, you can apply attributes to the classes, return values, parameters, and fields found in an XML Web service file (.asmx).</span></span> <span data-ttu-id="d49a0-134">由于 XML Web services 可以使用文本或编码的 SOAP 样式，因此既可以使用“用来控制 XML 序列化的特性”中列出的特性，也可以使用“用来控制编码的 SOAP 序列化的特性”中列出的特性。</span><span class="sxs-lookup"><span data-stu-id="d49a0-134">You can use both the attributes listed in "Attributes That Control XML Serialization" and "Attributes That Control Encoded SOAP Serialization" because an XML Web service can use either the literal or encoded SOAP style.</span></span> <span data-ttu-id="d49a0-135">有关使用特性来控制由 XML Web 服务生成的 XML 的详细信息，请参阅[使用 XML Web 服务进行 XML 序列化](xml-serialization-with-xml-web-services.md)。</span><span class="sxs-lookup"><span data-stu-id="d49a0-135">For more information about using attributes to control the XML generated by an XML Web service, see [XML Serialization with XML Web Services](xml-serialization-with-xml-web-services.md).</span></span> <span data-ttu-id="d49a0-136">有关 SOAP 和 XML Web 服务的详细信息，请参阅[自定义 SOAP 信息](https://msdn.microsoft.com/subscriptions/index/dkwy2d72\(v=vs.71\).aspx)。</span><span class="sxs-lookup"><span data-stu-id="d49a0-136">For more information about SOAP and XML Web services, see [Customizing SOAP Messages](https://msdn.microsoft.com/subscriptions/index/dkwy2d72\(v=vs.71\).aspx).</span></span>

## <a name="security-considerations-for-xmlserializer-applications"></a><span data-ttu-id="d49a0-137">XmlSerializer 应用程序的安全注意事项</span><span class="sxs-lookup"><span data-stu-id="d49a0-137">Security Considerations for XmlSerializer Applications</span></span>

<span data-ttu-id="d49a0-138">创建使用 XmlSerializer 的应用程序时，应了解以下各项及其含义：</span><span class="sxs-lookup"><span data-stu-id="d49a0-138">When creating an application that uses the **XmlSerializer**, you should be aware of the following items and their implications:</span></span>

- <span data-ttu-id="d49a0-139">XmlSerializer 在由 TEMP 环境变量命名的目录中创建 C# (.cs) 文件并将它们编译为 dll 文件；这些 DLL 文件将进行序列化。</span><span class="sxs-lookup"><span data-stu-id="d49a0-139">The **XmlSerializer** creates C# (.cs) files and compiles them into .dll files in the directory named by the TEMP environment variable; serialization occurs with those DLLs.</span></span>

  > [!NOTE]
  > <span data-ttu-id="d49a0-140">可预先生成这些序列化程序集，并使用 SGen.exe 工具对它们进行签名。</span><span class="sxs-lookup"><span data-stu-id="d49a0-140">These serialization assemblies can be generated in advance and signed by using the SGen.exe tool.</span></span> <span data-ttu-id="d49a0-141">这不适用于 Web 服务的服务器。</span><span class="sxs-lookup"><span data-stu-id="d49a0-141">This does not work a server of Web services.</span></span> <span data-ttu-id="d49a0-142">也就是说，这只适用于客户端用法和手动序列化。</span><span class="sxs-lookup"><span data-stu-id="d49a0-142">In other words, it is only for client use and for manual serialization.</span></span>

  <span data-ttu-id="d49a0-143">代码和 DLL 在创建和编译时易受恶意进程破坏。</span><span class="sxs-lookup"><span data-stu-id="d49a0-143">The code and the DLLs are vulnerable to a malicious process at the time of creation and compilation.</span></span> <span data-ttu-id="d49a0-144">当使用的计算机运行 Microsoft Windows NT 4.0 或更高版本时，可能有两个或多个用户共享 TEMP 目录。</span><span class="sxs-lookup"><span data-stu-id="d49a0-144">When using a computer running Microsoft Windows NT 4.0 or later, it might be possible for two or more users to share the TEMP directory.</span></span> <span data-ttu-id="d49a0-145">如果两个帐户的安全权限不同，并且权限较高的帐户使用 XmlSerializer 运行应用程序，则共享 TEMP 目录是危险的操作。</span><span class="sxs-lookup"><span data-stu-id="d49a0-145">Sharing a TEMP directory is dangerous if the two accounts have different security privileges and the higher-privilege account runs an application using the **XmlSerializer**.</span></span> <span data-ttu-id="d49a0-146">在这种情况下，一个用户可能因替换已编译的 .cs 或 .dll 文件而违反计算机的安全性。</span><span class="sxs-lookup"><span data-stu-id="d49a0-146">In this case, one user can breach the computer's security by replacing either the .cs or .dll file that is compiled.</span></span> <span data-ttu-id="d49a0-147">要消除这一问题，应始终确保计算机上的每个帐户具有各自的配置文件。</span><span class="sxs-lookup"><span data-stu-id="d49a0-147">To eliminate this concern, always be sure that each account on the computer has its own profile.</span></span> <span data-ttu-id="d49a0-148">默认情况下，TEMP 环境变量为每个帐户指向不同的目录。</span><span class="sxs-lookup"><span data-stu-id="d49a0-148">By default, the TEMP environment variable points to a different directory for each account.</span></span>

- <span data-ttu-id="d49a0-149">如果恶意用户将连续的 XML 数据流发送至 Web 服务器（拒绝服务攻击），则 XmlSerializer 会继续处理数据，直到计算机资源不足为止。</span><span class="sxs-lookup"><span data-stu-id="d49a0-149">If a malicious user sends a continuous stream of XML data to a Web server (a denial of service attack), then the **XmlSerializer** continues to process the data until the computer runs low on resources.</span></span>

  <span data-ttu-id="d49a0-150">如果您使用的计算机运行了 Internet 信息服务 (IIS)，并且您的应用程序在 IIS 内运行，则可消除这种攻击。</span><span class="sxs-lookup"><span data-stu-id="d49a0-150">This kind of attack is eliminated if you are using a computer running Internet Information Services (IIS), and your application is running within IIS.</span></span> <span data-ttu-id="d49a0-151">IIS 提供了一种网关，这种网关不处理长度超过设定量（默认值为 4 KB）的流。</span><span class="sxs-lookup"><span data-stu-id="d49a0-151">IIS features a gate that does not process streams longer than a set amount (the default is 4 KB).</span></span> <span data-ttu-id="d49a0-152">如果创建的应用程序不使用 IIS 并且使用 XmlSerializer 进行反序列化，则应该实现防止拒绝服务攻击的类似网关。</span><span class="sxs-lookup"><span data-stu-id="d49a0-152">If you create an application that does not use IIS and deserializes with the **XmlSerializer**, you should implement a similar gate that prevents a denial of service attack.</span></span>

- <span data-ttu-id="d49a0-153">XmlSerializer 使用提供给它的任何类型序列化数据并运行任何代码。</span><span class="sxs-lookup"><span data-stu-id="d49a0-153">The **XmlSerializer** serializes data and runs any code using any type given to it.</span></span>

  <span data-ttu-id="d49a0-154">恶意对象造成威胁的方式有两种。</span><span class="sxs-lookup"><span data-stu-id="d49a0-154">There are two ways in which a malicious object presents a threat.</span></span> <span data-ttu-id="d49a0-155">它可以运行恶意代码，也可以将恶意代码插入 XmlSerializer 创建的 C# 文件中。</span><span class="sxs-lookup"><span data-stu-id="d49a0-155">It could run malicious code or it could inject malicious code into the C# file created by the **XmlSerializer**.</span></span> <span data-ttu-id="d49a0-156">在第一种情况下，如果恶意对象试图运行破坏性的过程，代码访问安全有助于防止发生任何损坏。</span><span class="sxs-lookup"><span data-stu-id="d49a0-156">In the first case, if a malicious object tries to run a destructive procedure, code access security helps prevent any damage from being done.</span></span> <span data-ttu-id="d49a0-157">在第二种情况下，从理论上来说，恶意对象有可能以某种方式将代码插入 XmlSerializer 创建的 C# 文件中。</span><span class="sxs-lookup"><span data-stu-id="d49a0-157">In the second case, there is a theoretical possibility that a malicious object may somehow inject code into the C# file created by the **XmlSerializer**.</span></span> <span data-ttu-id="d49a0-158">尽管这一问题已得到彻底检查并且认为不可能发生这种攻击，但还是应当采取防范措施，一定不要使用未知和不受信任的类型来序列化数据。</span><span class="sxs-lookup"><span data-stu-id="d49a0-158">Although this issue has been examined thoroughly, and such an attack is considered unlikely, you should take the precaution of never serializing data with an unknown and untrusted type.</span></span>

- <span data-ttu-id="d49a0-159">已序列化的敏感数据可能容易受到攻击。</span><span class="sxs-lookup"><span data-stu-id="d49a0-159">Serialized sensitive data might be vulnerable.</span></span>

  <span data-ttu-id="d49a0-160">之后**XmlSerializer**包含序列化数据，它可以存储为 XML 文件或其他数据存储。</span><span class="sxs-lookup"><span data-stu-id="d49a0-160">After the **XmlSerializer** has serialized data, it can be stored as an XML file or other data store.</span></span> <span data-ttu-id="d49a0-161">如果数据存储区可供其他进程使用或者可在 Intranet 或 Internet 上看见，则数据可能被盗和恶意使用。</span><span class="sxs-lookup"><span data-stu-id="d49a0-161">If your data store is available to other processes, or is visible on an intranet or the Internet, the data can be stolen and used maliciously.</span></span> <span data-ttu-id="d49a0-162">例如，如果您创建一个应用程序来序列化包含信用卡号码的订单，则数据是高度敏感的。</span><span class="sxs-lookup"><span data-stu-id="d49a0-162">For example, if you create an application that serializes orders that include credit card numbers, the data is highly sensitive.</span></span> <span data-ttu-id="d49a0-163">为防止被盗和恶意使用，应始终保护您的数据存储区并采取步骤保持其私密性。</span><span class="sxs-lookup"><span data-stu-id="d49a0-163">To help prevent this, always protect the store for your data and take steps to keep it private.</span></span>

## <a name="serialization-of-a-simple-class"></a><span data-ttu-id="d49a0-164">简单类的序列化</span><span class="sxs-lookup"><span data-stu-id="d49a0-164">Serialization of a Simple Class</span></span>

<span data-ttu-id="d49a0-165">下面的代码示例显示具有公共字段的基类。</span><span class="sxs-lookup"><span data-stu-id="d49a0-165">The following code example shows a basic class with a public field.</span></span>

```vb
Public Class OrderForm
    Public OrderDate As DateTime
End Class
```

```csharp
public class OrderForm
{
    public DateTime OrderDate;
}
```

<span data-ttu-id="d49a0-166">此类的实例序列化后可能如下所示。</span><span class="sxs-lookup"><span data-stu-id="d49a0-166">When an instance of this class is serialized, it might resemble the following.</span></span>

```xml
<OrderForm>
    <OrderDate>12/12/01</OrderDate>
</OrderForm>
```

<span data-ttu-id="d49a0-167">有关序列化的更多示例，请参阅 [XML 序列化示例](examples-of-xml-serialization.md)。</span><span class="sxs-lookup"><span data-stu-id="d49a0-167">For more examples of serialization, see [Examples of XML Serialization](examples-of-xml-serialization.md).</span></span>

## <a name="items-that-can-be-serialized"></a><span data-ttu-id="d49a0-168">可序列化的项</span><span class="sxs-lookup"><span data-stu-id="d49a0-168">Items That Can Be Serialized</span></span>

<span data-ttu-id="d49a0-169">可使用 XmLSerializer 类对以下各项进行序列化：</span><span class="sxs-lookup"><span data-stu-id="d49a0-169">The following items can be serialized using the **XmLSerializer** class:</span></span>

- <span data-ttu-id="d49a0-170">公共类的公共读/写属性和字段。</span><span class="sxs-lookup"><span data-stu-id="d49a0-170">Public read/write properties and fields of public classes.</span></span>

- <span data-ttu-id="d49a0-171">执行 ICollection 或 IEnumerable 的类。</span><span class="sxs-lookup"><span data-stu-id="d49a0-171">Classes that implement **ICollection** or **IEnumerable**.</span></span>

  > [!NOTE]
  > <span data-ttu-id="d49a0-172">仅序列化集合，不序列化公共属性。</span><span class="sxs-lookup"><span data-stu-id="d49a0-172">Only collections are serialized, not public properties.</span></span>

- <span data-ttu-id="d49a0-173">XmlElement 对象。</span><span class="sxs-lookup"><span data-stu-id="d49a0-173">**XmlElement** objects.</span></span>

- <span data-ttu-id="d49a0-174">XmlNode 对象。</span><span class="sxs-lookup"><span data-stu-id="d49a0-174">**XmlNode** objects.</span></span>

- <span data-ttu-id="d49a0-175">DataSet 对象。</span><span class="sxs-lookup"><span data-stu-id="d49a0-175">**DataSet** objects.</span></span>

 <span data-ttu-id="d49a0-176">有关序列化或反序列化对象的详细信息，请参阅[如何：将对象序列化为](how-to-serialize-an-object.md)和[如何：反序列化对象](how-to-deserialize-an-object.md)。</span><span class="sxs-lookup"><span data-stu-id="d49a0-176">For more information about serializing or deserializing objects, see [How to: Serialize an Object](how-to-serialize-an-object.md) and [How to: Deserialize an Object](how-to-deserialize-an-object.md).</span></span>

## <a name="advantages-of-using-xml-serialization"></a><span data-ttu-id="d49a0-177">使用 XML 序列化的优点</span><span class="sxs-lookup"><span data-stu-id="d49a0-177">Advantages of Using XML Serialization</span></span>

<span data-ttu-id="d49a0-178">**XmlSerializer**类为您提供完整而灵活的控制序列化以 XML 形式的对象时。</span><span class="sxs-lookup"><span data-stu-id="d49a0-178">The **XmlSerializer** class gives you complete and flexible control when you serialize an object as XML.</span></span> <span data-ttu-id="d49a0-179">如果要创建 XML Web services，可以将控制序列化的特性应用于类和成员，以确保 XML 输出符合特定架构。</span><span class="sxs-lookup"><span data-stu-id="d49a0-179">If you are creating an XML Web service, you can apply attributes that control serialization to classes and members to ensure that the XML output conforms to a specific schema.</span></span>

<span data-ttu-id="d49a0-180">例如，XmlSerializer 使你能够：</span><span class="sxs-lookup"><span data-stu-id="d49a0-180">For example, **XmlSerializer** enables you to:</span></span>

- <span data-ttu-id="d49a0-181">指定字段或属性是否应编码为特性或元素。</span><span class="sxs-lookup"><span data-stu-id="d49a0-181">Specify whether a field or property should be encoded as an attribute or an element.</span></span>

- <span data-ttu-id="d49a0-182">指定要使用的 XML 命名空间。</span><span class="sxs-lookup"><span data-stu-id="d49a0-182">Specify an XML namespace to use.</span></span>

- <span data-ttu-id="d49a0-183">指定字段或属性名称不恰当时的元素或特性名称。</span><span class="sxs-lookup"><span data-stu-id="d49a0-183">Specify the name of an element or attribute if a field or property name is inappropriate.</span></span>

<span data-ttu-id="d49a0-184">XML 序列化的另一个优点是，只要生成的 XML 流符合给定的架构，就对开发的应用程序没有任何约束。</span><span class="sxs-lookup"><span data-stu-id="d49a0-184">Another advantage of XML serialization is that you have no constraints on the applications you develop, as long as the XML stream that is generated conforms to a given schema.</span></span> <span data-ttu-id="d49a0-185">假设有一个架构，它用于描述书籍。</span><span class="sxs-lookup"><span data-stu-id="d49a0-185">Imagine a schema that is used to describe books.</span></span> <span data-ttu-id="d49a0-186">它提供有书名、作者、出版商和 ISBN 号元素。</span><span class="sxs-lookup"><span data-stu-id="d49a0-186">It features a title, author, publisher, and ISBN number element.</span></span> <span data-ttu-id="d49a0-187">您可以开发一个应用程序来以任何想要的方式（例如以书籍订单或书籍库存方式）处理 XML 数据。</span><span class="sxs-lookup"><span data-stu-id="d49a0-187">You can develop an application that processes the XML data in any way you want, for example, as a book order, or as an inventory of books.</span></span> <span data-ttu-id="d49a0-188">在任一种情况下，唯一的要求是 XML 流符合指定的 XML 架构定义语言 (XSD) 架构。</span><span class="sxs-lookup"><span data-stu-id="d49a0-188">In either case, the only requirement is that the XML stream conforms to the specified XML Schema definition language (XSD) schema.</span></span>

## <a name="xml-serialization-considerations"></a><span data-ttu-id="d49a0-189">XML 序列化注意事项</span><span class="sxs-lookup"><span data-stu-id="d49a0-189">XML Serialization Considerations</span></span>

<span data-ttu-id="d49a0-190">使用 XmlSerializer 类时，应注意以下事项：</span><span class="sxs-lookup"><span data-stu-id="d49a0-190">The following should be considered when using the **XmlSerializer** class:</span></span>

- <span data-ttu-id="d49a0-191">Sgen.exe 工具特别设计为生成序列化程序集，以获得最佳性能。</span><span class="sxs-lookup"><span data-stu-id="d49a0-191">The Sgen.exe tool is expressly designed to generate serialization assemblies for optimum performance.</span></span>

- <span data-ttu-id="d49a0-192">序列化数据只包含数据本身和类的结构。</span><span class="sxs-lookup"><span data-stu-id="d49a0-192">The serialized data contains only the data itself and the structure of your classes.</span></span> <span data-ttu-id="d49a0-193">类型标识和程序集信息不包括在内。</span><span class="sxs-lookup"><span data-stu-id="d49a0-193">Type identity and assembly information are not included.</span></span>

- <span data-ttu-id="d49a0-194">只能序列化公共属性和字段。</span><span class="sxs-lookup"><span data-stu-id="d49a0-194">Only public properties and fields can be serialized.</span></span> <span data-ttu-id="d49a0-195">属性必须具有公共访问器（get 和 set 方法）。</span><span class="sxs-lookup"><span data-stu-id="d49a0-195">Properties must have public accessors (get and set methods).</span></span> <span data-ttu-id="d49a0-196">如果必须序列化非公共数据，请使用 <xref:System.Runtime.Serialization.DataContractSerializer> 类而不使用 XML 序列化。</span><span class="sxs-lookup"><span data-stu-id="d49a0-196">If you must serialize non-public data, use the <xref:System.Runtime.Serialization.DataContractSerializer> class rather than XML serialization.</span></span>

- <span data-ttu-id="d49a0-197">类必须具有默认构造函数才能被 XmlSerializer 序列化。</span><span class="sxs-lookup"><span data-stu-id="d49a0-197">A class must have a default constructor to be serialized by **XmlSerializer**.</span></span>

- <span data-ttu-id="d49a0-198">方法不能被序列化。</span><span class="sxs-lookup"><span data-stu-id="d49a0-198">Methods cannot be serialized.</span></span>

- <span data-ttu-id="d49a0-199">如下所述，如果实现 IEnumerable 或 ICollection 的类满足某些要求，XmlSerializer 则可以处理这些类。</span><span class="sxs-lookup"><span data-stu-id="d49a0-199">**XmlSerializer** can process classes that implement **IEnumerable** or **ICollection** differently if they meet certain requirements, as follows.</span></span>

  <span data-ttu-id="d49a0-200">实现 IEnumerable 的类必须实现采用单个参数的公共 Add 方法。</span><span class="sxs-lookup"><span data-stu-id="d49a0-200">A class that implements **IEnumerable** must implement a public **Add** method that takes a single parameter.</span></span> <span data-ttu-id="d49a0-201">Add 方法的参数必须与从“IEnumerator.Current”属性返回的类型一致（多态），该属性是从 GetEnumerator 方法返回的。</span><span class="sxs-lookup"><span data-stu-id="d49a0-201">The **Add** method's parameter must be consistent (polymorphic) with the type returned from the **IEnumerator.Current** property returned from the **GetEnumerator** method.</span></span>

  <span data-ttu-id="d49a0-202">除了实现 IEnumerable 之外，还能实现 ICollection 的类（如 CollectionBase）必须具有采用整型的公共“Item”索引属性（在 C# 中为索引器），而且它必须有一个“integer”类型的公共“Count”属性。</span><span class="sxs-lookup"><span data-stu-id="d49a0-202">A class that implements **ICollection** in addition to **IEnumerable** (such as **CollectionBase**) must have a public **Item** indexed property (an indexer in C#) that takes an integer and it must have a public **Count** property of type **integer**.</span></span> <span data-ttu-id="d49a0-203">传递给 Add 方法的参数必须与从“Item”属性返回的类型相同，或者为此类型的基之一。</span><span class="sxs-lookup"><span data-stu-id="d49a0-203">The parameter passed to the **Add** method must be the same type as that returned from the **Item** property, or one of that type's bases.</span></span>

  <span data-ttu-id="d49a0-204">对于实现 ICollection 的类，可从已编制索引的“Item”属性检索要序列化的值，而不是通过调用 GetEnumerator 进行检索。</span><span class="sxs-lookup"><span data-stu-id="d49a0-204">For classes that implement **ICollection**, values to be serialized are retrieved from the indexed **Item** property rather than by calling **GetEnumerator**.</span></span> <span data-ttu-id="d49a0-205">此外，除了返回另一个集合类（实现 ICollection 的一个类）的公共字段外，公共字段和属性不会被序列化。</span><span class="sxs-lookup"><span data-stu-id="d49a0-205">Also, public fields and properties are not serialized, with the exception of public fields that return another collection class (one that implements **ICollection**).</span></span> <span data-ttu-id="d49a0-206">有关示例，请参阅 [XML 序列化示例](examples-of-xml-serialization.md)。</span><span class="sxs-lookup"><span data-stu-id="d49a0-206">For an example, see [Examples of XML Serialization](examples-of-xml-serialization.md).</span></span>

## <a name="xsd-data-type-mapping"></a><span data-ttu-id="d49a0-207">XSD 数据类型映射</span><span class="sxs-lookup"><span data-stu-id="d49a0-207">XSD Data Type Mapping</span></span>

<span data-ttu-id="d49a0-208">标题为的 W3C 文档[XML 架构第 2 部分：数据类型](https://www.w3.org/TR/xmlschema-2/)在 XML 架构定义语言 (XSD) 架构中指定允许的简单数据类型。</span><span class="sxs-lookup"><span data-stu-id="d49a0-208">The W3C document titled [XML Schema Part 2: Datatypes](https://www.w3.org/TR/xmlschema-2/) specifies the simple data types that are allowed in an XML Schema definition language (XSD) schema.</span></span> <span data-ttu-id="d49a0-209">对于其中的许多数据类型（如“int”和“decimal”），.NET Framework 中都有相应的数据类型。</span><span class="sxs-lookup"><span data-stu-id="d49a0-209">For many of these (for example, **int** and **decimal**), there is a corresponding data type in the .NET Framework.</span></span> <span data-ttu-id="d49a0-210">然而，某些 XML 数据类型在 .NET Framework 中没有相应的数据类型（如“NMTOKEN”数据类型）。</span><span class="sxs-lookup"><span data-stu-id="d49a0-210">However, some XML data types do not have a corresponding data type in the .NET Framework (for example, the **NMTOKEN** data type).</span></span> <span data-ttu-id="d49a0-211">在这种情况下，如果使用 XML 架构定义工具（[XML 架构定义工具 (Xsd.exe)](xml-schema-definition-tool-xsd-exe.md)）从架构中生成类，相应的特性会应用到字符串类型的成员，其“DataType”属性会设置为 XML 数据类型名称。</span><span class="sxs-lookup"><span data-stu-id="d49a0-211">In such cases, if you use the XML Schema Definition tool ([XML Schema Definition Tool (Xsd.exe)](xml-schema-definition-tool-xsd-exe.md)) to generate classes from a schema, an appropriate attribute is applied to a member of type string, and its **DataType** property is set to the XML data type name.</span></span> <span data-ttu-id="d49a0-212">例如，如果架构包含 XML 数据类型为“NMTOKEN”且名为“MyToken”的元素，则生成的类可能包含下例中所示的成员。</span><span class="sxs-lookup"><span data-stu-id="d49a0-212">For example, if a schema contains an element named "MyToken" with the XML data type **NMTOKEN**, the generated class might contain a member as shown in the following example.</span></span>

```vb
<XmlElement(DataType:="NMTOKEN")> _
Public MyToken As String
```

```csharp
[XmlElement(DataType = "NMTOKEN")]
public string MyToken;
```

<span data-ttu-id="d49a0-213">同样，如果要创建的类必须符合特定的 XML 架构 (XSD)，则应该应用相应的特性并且将其“DataType”属性设置为所需的 XML 数据类型名称。</span><span class="sxs-lookup"><span data-stu-id="d49a0-213">Similarly, if you are creating a class that must conform to a specific XML Schema (XSD), you should apply the appropriate attribute and set its **DataType** property to the desired XML data type name.</span></span>

<span data-ttu-id="d49a0-214">有关类型映射的完整列表，请参阅以下任一特性类的“DataType”属性：</span><span class="sxs-lookup"><span data-stu-id="d49a0-214">For a complete list of type mappings, see the **DataType** property for any of the following attribute classes:</span></span>

- <xref:System.Xml.Serialization.SoapAttributeAttribute>

- <xref:System.Xml.Serialization.SoapElementAttribute>

- <xref:System.Xml.Serialization.XmlArrayItemAttribute>

- <xref:System.Xml.Serialization.XmlAttributeAttribute>

- <xref:System.Xml.Serialization.XmlElementAttribute>

- <xref:System.Xml.Serialization.XmlRootAttribute>

## <a name="see-also"></a><span data-ttu-id="d49a0-215">请参阅</span><span class="sxs-lookup"><span data-stu-id="d49a0-215">See also</span></span>

- <xref:System.Xml.Serialization.XmlSerializer>
- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.IO.FileStream>
- [<span data-ttu-id="d49a0-216">XML 和 SOAP 序列化</span><span class="sxs-lookup"><span data-stu-id="d49a0-216">XML and SOAP Serialization</span></span>](xml-and-soap-serialization.md)
- [<span data-ttu-id="d49a0-217">二进制序列化</span><span class="sxs-lookup"><span data-stu-id="d49a0-217">Binary Serialization</span></span>](binary-serialization.md)
- [<span data-ttu-id="d49a0-218">序列化</span><span class="sxs-lookup"><span data-stu-id="d49a0-218">Serialization</span></span>](index.md)
- <xref:System.Xml.Serialization.XmlSerializer>
- [<span data-ttu-id="d49a0-219">XML 序列化示例</span><span class="sxs-lookup"><span data-stu-id="d49a0-219">Examples of XML Serialization</span></span>](examples-of-xml-serialization.md)
- [<span data-ttu-id="d49a0-220">如何：将对象序列化</span><span class="sxs-lookup"><span data-stu-id="d49a0-220">How to: Serialize an Object</span></span>](how-to-serialize-an-object.md)
- [<span data-ttu-id="d49a0-221">如何：反序列化对象</span><span class="sxs-lookup"><span data-stu-id="d49a0-221">How to: Deserialize an Object</span></span>](how-to-deserialize-an-object.md)
