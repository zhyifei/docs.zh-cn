---
title: 正则表达式选项
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, options
- constructs, options
- .NET Framework regular expressions, options
- inline option constructs
- options parameter
ms.assetid: c82dc689-7e82-4767-a18d-cd24ce5f05e9
ms.openlocfilehash: a53d7517485d2a0b02b6f11928f478a7da3f9503
ms.sourcegitcommit: f348c84443380a1959294cdf12babcb804cfa987
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/12/2019
ms.locfileid: "73972103"
---
# <a name="regular-expression-options"></a><span data-ttu-id="3c13e-102">正则表达式选项</span><span class="sxs-lookup"><span data-stu-id="3c13e-102">Regular Expression Options</span></span>

<span data-ttu-id="3c13e-103">默认情况下，正则表达式模式中带有任意文本字符的输入字符串比较区分大小写，正则表达式模式中的空白将被解释为文本空白字符且正则表达式中的捕获组通过隐式和显式命名。</span><span class="sxs-lookup"><span data-stu-id="3c13e-103">By default, the comparison of an input string with any literal characters in a regular expression pattern is case sensitive, white space in a regular expression pattern is interpreted as literal white-space characters, and capturing groups in a regular expression are named implicitly as well as explicitly.</span></span> <span data-ttu-id="3c13e-104">可通过指定正则表达式选项修改默认正则表达式行为的这些和其他数个方面。</span><span class="sxs-lookup"><span data-stu-id="3c13e-104">You can modify these and several other aspects of default regular expression behavior by specifying regular expression options.</span></span> <span data-ttu-id="3c13e-105">列于下表的这些选项，可将内联作为正则表达式的一部分包含，或者可将它们作为 <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> 枚举值提供给 <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> 类构造函数或静态模式匹配方法。</span><span class="sxs-lookup"><span data-stu-id="3c13e-105">These options, which are listed in the following table, can be included inline as part of the regular expression pattern, or they can be supplied to a <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class constructor or static pattern matching method as a <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> enumeration value.</span></span>

|<span data-ttu-id="3c13e-106">RegexOptions 成员</span><span class="sxs-lookup"><span data-stu-id="3c13e-106">RegexOptions member</span></span>|<span data-ttu-id="3c13e-107">内联字符</span><span class="sxs-lookup"><span data-stu-id="3c13e-107">Inline character</span></span>|<span data-ttu-id="3c13e-108">效果</span><span class="sxs-lookup"><span data-stu-id="3c13e-108">Effect</span></span>|
|-------------------------|----------------------|------------|
|<xref:System.Text.RegularExpressions.RegexOptions.None>|<span data-ttu-id="3c13e-109">不可用</span><span class="sxs-lookup"><span data-stu-id="3c13e-109">Not available</span></span>|<span data-ttu-id="3c13e-110">使用默认行为。</span><span class="sxs-lookup"><span data-stu-id="3c13e-110">Use default behavior.</span></span> <span data-ttu-id="3c13e-111">有关更多信息，请参见[默认选项](#default-options)。</span><span class="sxs-lookup"><span data-stu-id="3c13e-111">For more information, see [Default Options](#default-options).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase>|`i`|<span data-ttu-id="3c13e-112">使用不区分大小写的匹配。</span><span class="sxs-lookup"><span data-stu-id="3c13e-112">Use case-insensitive matching.</span></span> <span data-ttu-id="3c13e-113">有关更多信息，请参见[不区分大小写的匹配](#case-insensitive-matching)。</span><span class="sxs-lookup"><span data-stu-id="3c13e-113">For more information, see [Case-Insensitive Matching](#case-insensitive-matching).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.Multiline>|`m`|<span data-ttu-id="3c13e-114">使用多线模式，其中 `^` 和 `$` 匹配每行的开头和末尾（不是输入字符串的开头和末尾）。</span><span class="sxs-lookup"><span data-stu-id="3c13e-114">Use multiline mode, where `^` and `$` match the beginning and end of each line (instead of the beginning and end of the input string).</span></span> <span data-ttu-id="3c13e-115">有关更多信息，请参见[多行模式](#multiline-mode)。</span><span class="sxs-lookup"><span data-stu-id="3c13e-115">For more information, see [Multiline Mode](#multiline-mode).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.Singleline>|`s`|<span data-ttu-id="3c13e-116">使用单行模式，其中的句号 (.) 匹配每个字符（而不是除了 `\n` 以外的每个字符)。</span><span class="sxs-lookup"><span data-stu-id="3c13e-116">Use single-line mode, where the period (.) matches every character (instead of every character except `\n`).</span></span> <span data-ttu-id="3c13e-117">有关详细信息，请参阅[单行模式](#single-line-mode)。</span><span class="sxs-lookup"><span data-stu-id="3c13e-117">For more information, see [Single-line Mode](#single-line-mode).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture>|`n`|<span data-ttu-id="3c13e-118">不捕获未命名的组。</span><span class="sxs-lookup"><span data-stu-id="3c13e-118">Do not capture unnamed groups.</span></span> <span data-ttu-id="3c13e-119">唯一有效的捕获是显式命名或编号的 `(?<`*name*`>` *subexpression*`)` 形式的组。</span><span class="sxs-lookup"><span data-stu-id="3c13e-119">The only valid captures are explicitly named or numbered groups of the form `(?<`*name*`>` *subexpression*`)`.</span></span> <span data-ttu-id="3c13e-120">有关更多信息，请参见[仅显式捕获](#explicit-captures-only)。</span><span class="sxs-lookup"><span data-stu-id="3c13e-120">For more information, see [Explicit Captures Only](#explicit-captures-only).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.Compiled>|<span data-ttu-id="3c13e-121">不可用</span><span class="sxs-lookup"><span data-stu-id="3c13e-121">Not available</span></span>|<span data-ttu-id="3c13e-122">将正则表达式编译为程序集。</span><span class="sxs-lookup"><span data-stu-id="3c13e-122">Compile the regular expression to an assembly.</span></span> <span data-ttu-id="3c13e-123">有关更多信息，请参见[已编译的正则表达式](#compiled-regular-expressions)。</span><span class="sxs-lookup"><span data-stu-id="3c13e-123">For more information, see [Compiled Regular Expressions](#compiled-regular-expressions).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace>|`x`|<span data-ttu-id="3c13e-124">从模式中排除保留的空白并启用数字符号 (`#`) 后的注释。</span><span class="sxs-lookup"><span data-stu-id="3c13e-124">Exclude unescaped white space from the pattern, and enable comments after a number sign (`#`).</span></span> <span data-ttu-id="3c13e-125">有关更多信息，请参见[忽略空白](#ignore-white-space)。</span><span class="sxs-lookup"><span data-stu-id="3c13e-125">For more information, see [Ignore White Space](#ignore-white-space).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.RightToLeft>|<span data-ttu-id="3c13e-126">不可用</span><span class="sxs-lookup"><span data-stu-id="3c13e-126">Not available</span></span>|<span data-ttu-id="3c13e-127">更改搜索方向。</span><span class="sxs-lookup"><span data-stu-id="3c13e-127">Change the search direction.</span></span> <span data-ttu-id="3c13e-128">搜索是从右向左而不是从左向右进行。</span><span class="sxs-lookup"><span data-stu-id="3c13e-128">Search moves from right to left instead of from left to right.</span></span> <span data-ttu-id="3c13e-129">有关更多信息，请参见[从右向左模式](#right-to-left-mode)。</span><span class="sxs-lookup"><span data-stu-id="3c13e-129">For more information, see [Right-to-Left Mode](#right-to-left-mode).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.ECMAScript>|<span data-ttu-id="3c13e-130">不可用</span><span class="sxs-lookup"><span data-stu-id="3c13e-130">Not available</span></span>|<span data-ttu-id="3c13e-131">为表达式启用符合 ECMAScript 的行为。</span><span class="sxs-lookup"><span data-stu-id="3c13e-131">Enable ECMAScript-compliant behavior for the expression.</span></span> <span data-ttu-id="3c13e-132">有关更多信息，请参见 [ECMAScript 匹配行为](#ecmascript-matching-behavior)。</span><span class="sxs-lookup"><span data-stu-id="3c13e-132">For more information, see [ECMAScript Matching Behavior](#ecmascript-matching-behavior).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant>|<span data-ttu-id="3c13e-133">不可用</span><span class="sxs-lookup"><span data-stu-id="3c13e-133">Not available</span></span>|<span data-ttu-id="3c13e-134">忽略语言的区域性差异。</span><span class="sxs-lookup"><span data-stu-id="3c13e-134">Ignore cultural differences in language.</span></span> <span data-ttu-id="3c13e-135">有关更多信息，请参见[使用固定区域性的比较](#comparison-using-the-invariant-culture)。</span><span class="sxs-lookup"><span data-stu-id="3c13e-135">For more information, see [Comparison Using the Invariant Culture](#comparison-using-the-invariant-culture).</span></span>|

## <a name="specifying-the-options"></a><span data-ttu-id="3c13e-136">指定选项</span><span class="sxs-lookup"><span data-stu-id="3c13e-136">Specifying the Options</span></span>

<span data-ttu-id="3c13e-137">可以用下面三种方法之一指定正则表达式的选项：</span><span class="sxs-lookup"><span data-stu-id="3c13e-137">You can specify options for regular expressions in one of three ways:</span></span>

- <span data-ttu-id="3c13e-138">在 `options` 类构造函数或静态（在 Visual Basic 中为 <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType>）模式匹配方法的 `Shared` 参数中，如 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> 或 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3c13e-138">In the `options` parameter of a <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class constructor or static (`Shared` in Visual Basic) pattern-matching method, such as <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3c13e-139">`options` 参数是 <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> 枚举值的按位“或”组合。</span><span class="sxs-lookup"><span data-stu-id="3c13e-139">The `options` parameter is a bitwise OR combination of <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> enumerated values.</span></span>

  <span data-ttu-id="3c13e-140">当通过使用类构造函数的 `options` 参数，将选项提供给 <xref:System.Text.RegularExpressions.Regex> 实例时，这些选项将分配给 <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="3c13e-140">When options are supplied to a <xref:System.Text.RegularExpressions.Regex> instance by using the `options` parameter of a class constructor, the options are assigned to the <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="3c13e-141">然而，<xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> 属性不会在正则表达式模式本身中反映内联选项。</span><span class="sxs-lookup"><span data-stu-id="3c13e-141">However, the <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> property does not reflect inline options in the regular expression pattern itself.</span></span>

  <span data-ttu-id="3c13e-142">下面的示例进行了这方面的演示。</span><span class="sxs-lookup"><span data-stu-id="3c13e-142">The following example provides an illustration.</span></span> <span data-ttu-id="3c13e-143">在标识以字母“d”开头的单词时，它使用 `options` 方法的 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> 参数来启用不区分大小写匹配和忽略模式空白。</span><span class="sxs-lookup"><span data-stu-id="3c13e-143">It uses the `options` parameter of the <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</span></span>

  [!code-csharp[Conceptual.Regex.Language.Options#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#6)]
  [!code-vb[Conceptual.Regex.Language.Options#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#6)]

- <span data-ttu-id="3c13e-144">通过在包含语法 `(?imnsx-imnsx)` 的正则表达式模式中应用内联选项。</span><span class="sxs-lookup"><span data-stu-id="3c13e-144">By applying inline options in a regular expression pattern with the syntax `(?imnsx-imnsx)`.</span></span> <span data-ttu-id="3c13e-145">该选项从选项定义为模式末尾的点应用于该模式，或应用于另一内联选项未定义选项的点。</span><span class="sxs-lookup"><span data-stu-id="3c13e-145">The option applies to the pattern from the point that the option is defined to either the end of the pattern or to the point at which the option is undefined by another inline option.</span></span> <span data-ttu-id="3c13e-146">请注意，<xref:System.Text.RegularExpressions.Regex> 实例的 <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> 属性不会反映这些内联选项。</span><span class="sxs-lookup"><span data-stu-id="3c13e-146">Note that the <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> property of a <xref:System.Text.RegularExpressions.Regex> instance does not reflect these inline options.</span></span> <span data-ttu-id="3c13e-147">有关详细信息，请参阅[其他构造](../../../docs/standard/base-types/miscellaneous-constructs-in-regular-expressions.md)主题。</span><span class="sxs-lookup"><span data-stu-id="3c13e-147">For more information, see the [Miscellaneous Constructs](../../../docs/standard/base-types/miscellaneous-constructs-in-regular-expressions.md) topic.</span></span>

  <span data-ttu-id="3c13e-148">下面的示例进行了这方面的演示。</span><span class="sxs-lookup"><span data-stu-id="3c13e-148">The following example provides an illustration.</span></span> <span data-ttu-id="3c13e-149">在标识以字母“d”开头的单词时，它使用内联选项来启用不区分大小写匹配和忽略模式空白。</span><span class="sxs-lookup"><span data-stu-id="3c13e-149">It uses inline options to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</span></span>

  [!code-csharp[Conceptual.Regex.Language.Options#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#7)]
  [!code-vb[Conceptual.Regex.Language.Options#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#7)]

- <span data-ttu-id="3c13e-150">通过在包含语法 `(?imnsx-imnsx:`subexpression  `)` 的正则表达式模式的特定分组构造中，应用内联选项。</span><span class="sxs-lookup"><span data-stu-id="3c13e-150">By applying inline options in a particular grouping construct in a regular expression pattern with the syntax `(?imnsx-imnsx:`*subexpression*`)`.</span></span> <span data-ttu-id="3c13e-151">一组选项前面没有符号用于打开该设置；一组选项前面的减号用于关闭该设置。</span><span class="sxs-lookup"><span data-stu-id="3c13e-151">No sign before a set of options turns the set on; a minus sign before a set of options turns the set off.</span></span> <span data-ttu-id="3c13e-152">（无论选项是启用还是禁用，`?` 都是所需的语言构造语法的固定部分。）选项只应用于该组。</span><span class="sxs-lookup"><span data-stu-id="3c13e-152">(`?` is a fixed part of the language construct's syntax that is required whether options are enabled or disabled.) The option applies only to that group.</span></span> <span data-ttu-id="3c13e-153">有关详细信息，请参阅[分组构造](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="3c13e-153">For more information, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

  <span data-ttu-id="3c13e-154">下面的示例进行了这方面的演示。</span><span class="sxs-lookup"><span data-stu-id="3c13e-154">The following example provides an illustration.</span></span> <span data-ttu-id="3c13e-155">在标识以字母“d”开头的单词时，它使用分组构造中的内联选项来启用不区分大小写匹配和忽略模式空白。</span><span class="sxs-lookup"><span data-stu-id="3c13e-155">It uses inline options in a grouping construct to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</span></span>

  [!code-csharp[Conceptual.Regex.Language.Options#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#8)]
  [!code-vb[Conceptual.Regex.Language.Options#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#8)]

<span data-ttu-id="3c13e-156">如果选项指定为内联，一个选项或一组选项前面的减号 (`-`) 用于关闭这些选项。</span><span class="sxs-lookup"><span data-stu-id="3c13e-156">If options are specified inline, a minus sign (`-`) before an option or set of options turns off those options.</span></span> <span data-ttu-id="3c13e-157">例如，内联构造 `(?ix-ms)` 将打开 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 和 <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> 选项而关闭 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> 和 <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> 选项。</span><span class="sxs-lookup"><span data-stu-id="3c13e-157">For example, the inline construct `(?ix-ms)` turns on the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> options and turns off the <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> options.</span></span> <span data-ttu-id="3c13e-158">默认情况下，关闭所有正则表达式选项。</span><span class="sxs-lookup"><span data-stu-id="3c13e-158">All regular expression options are turned off by default.</span></span>

> [!NOTE]
> <span data-ttu-id="3c13e-159">如果构造函数或方法调用的 `options` 形参中指定的正则表达式选项与正则表达式模式中的内联指定的选项冲突，那么将使用该内联选项。</span><span class="sxs-lookup"><span data-stu-id="3c13e-159">If the regular expression options specified in the `options` parameter of a constructor or method call conflict with the options specified inline in a regular expression pattern, the inline options are used.</span></span>

<span data-ttu-id="3c13e-160">可为下面的五个正则表达式选项同时设置选项形参和内联：</span><span class="sxs-lookup"><span data-stu-id="3c13e-160">The following five regular expression options can be set both with the options parameter and inline:</span></span>

- <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>

<span data-ttu-id="3c13e-161">可为下面的五个正则表达式选项设置使用 `options` 形参，但不能为其设置内联：</span><span class="sxs-lookup"><span data-stu-id="3c13e-161">The following five regular expression options can be set using the `options` parameter but cannot be set inline:</span></span>

- <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType>

## <a name="determining-the-options"></a><span data-ttu-id="3c13e-162">确定选项</span><span class="sxs-lookup"><span data-stu-id="3c13e-162">Determining the Options</span></span>

<span data-ttu-id="3c13e-163">可以确定向 <xref:System.Text.RegularExpressions.Regex> 对象提供哪些选项，在通过检索只读 <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> 属性的值将其实例化时。</span><span class="sxs-lookup"><span data-stu-id="3c13e-163">You can determine which options were provided to a <xref:System.Text.RegularExpressions.Regex> object when it was instantiated by retrieving the value of the read-only <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="3c13e-164">该属性尤其可用于确定为编译的正则表达式定义的选项，该正则表达式由 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> 方法创建。</span><span class="sxs-lookup"><span data-stu-id="3c13e-164">This property is particularly useful for determining the options that are defined for a compiled regular expression created by the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="3c13e-165">要测试除 <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> 之外的任何选项的存在，使用 <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> 属性的值和需要的 <xref:System.Text.RegularExpressions.RegexOptions> 值执行 AND 运算。</span><span class="sxs-lookup"><span data-stu-id="3c13e-165">To test for the presence of any option except <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, perform an AND operation with the value of the <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> property and the <xref:System.Text.RegularExpressions.RegexOptions> value in which you are interested.</span></span> <span data-ttu-id="3c13e-166">然后测试结果是否等于该 <xref:System.Text.RegularExpressions.RegexOptions> 值。</span><span class="sxs-lookup"><span data-stu-id="3c13e-166">Then test whether the result equals that <xref:System.Text.RegularExpressions.RegexOptions> value.</span></span> <span data-ttu-id="3c13e-167">下面的示例测试是否设置了 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 选项。</span><span class="sxs-lookup"><span data-stu-id="3c13e-167">The following example tests whether the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option has been set.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#19](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/determine1.cs#19)]
[!code-vb[Conceptual.Regex.Language.Options#19](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/determine1.vb#19)]

<span data-ttu-id="3c13e-168">要测试 <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>，确定 <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> 属性的值是否等于 <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="3c13e-168">To test for <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, determine whether the value of the <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> property is equal to <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, as the following example illustrates.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#20](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/determine1.cs#20)]
[!code-vb[Conceptual.Regex.Language.Options#20](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/determine1.vb#20)]

<span data-ttu-id="3c13e-169">下面各部分列出了 .NET 正则表达式支持的选项。</span><span class="sxs-lookup"><span data-stu-id="3c13e-169">The following sections list the options supported by regular expression in .NET.</span></span>

## <a name="default-options"></a><span data-ttu-id="3c13e-170">默认选项</span><span class="sxs-lookup"><span data-stu-id="3c13e-170">Default Options</span></span>

<span data-ttu-id="3c13e-171"><xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> 选项指示尚未指定任何选项，正则表达式引擎使用其默认行为。</span><span class="sxs-lookup"><span data-stu-id="3c13e-171">The <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> option indicates that no options have been specified, and the regular expression engine uses its default behavior.</span></span> <span data-ttu-id="3c13e-172">这包括：</span><span class="sxs-lookup"><span data-stu-id="3c13e-172">This includes the following:</span></span>

- <span data-ttu-id="3c13e-173">该模式将被解释为一个规范而非 ECMAScript 正则表达式。</span><span class="sxs-lookup"><span data-stu-id="3c13e-173">The pattern is interpreted as a canonical rather than an ECMAScript regular expression.</span></span>

- <span data-ttu-id="3c13e-174">从左到右在输入字符串中匹配的正则表达式模式。</span><span class="sxs-lookup"><span data-stu-id="3c13e-174">The regular expression pattern is matched in the input string from left to right.</span></span>

- <span data-ttu-id="3c13e-175">比较区分大小写。</span><span class="sxs-lookup"><span data-stu-id="3c13e-175">Comparisons are case-sensitive.</span></span>

- <span data-ttu-id="3c13e-176">`^` 和 `$` 语言元素与输入字符串的开头和结尾匹配。</span><span class="sxs-lookup"><span data-stu-id="3c13e-176">The `^` and `$` language elements match the beginning and end of the input string.</span></span>

- <span data-ttu-id="3c13e-177">`.` 语言元素与除 `\n` 之外的每个字符匹配。</span><span class="sxs-lookup"><span data-stu-id="3c13e-177">The `.` language element matches every character except `\n`.</span></span>

- <span data-ttu-id="3c13e-178">正则表达式模式中的任意空白均解释为文本空白字符。</span><span class="sxs-lookup"><span data-stu-id="3c13e-178">Any white space in a regular expression pattern is interpreted as a literal space character.</span></span>

- <span data-ttu-id="3c13e-179">将模式与输入字符串进行比较时将使用当前区域性的约定。</span><span class="sxs-lookup"><span data-stu-id="3c13e-179">The conventions of the current culture are used when comparing the pattern to the input string.</span></span>

- <span data-ttu-id="3c13e-180">正则表达式模式中的捕获组可以是隐式的，也可以是显式的。</span><span class="sxs-lookup"><span data-stu-id="3c13e-180">Capturing groups in the regular expression pattern are implicit as well as explicit.</span></span>

> [!NOTE]
> <span data-ttu-id="3c13e-181"><xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> 选项没有内联等效项。</span><span class="sxs-lookup"><span data-stu-id="3c13e-181">The <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> option has no inline equivalent.</span></span> <span data-ttu-id="3c13e-182">当内联应用正则表达式选项时，默认行为通过关闭特定选项以逐个选项方式存储。</span><span class="sxs-lookup"><span data-stu-id="3c13e-182">When regular expression options are applied inline, the default behavior is restored on an option-by-option basis, by turning a particular option off.</span></span> <span data-ttu-id="3c13e-183">例如， `(?i)` 打开不区分大小写的比较，`(?-i)` 还原默认区分大小写的比较。</span><span class="sxs-lookup"><span data-stu-id="3c13e-183">For example, `(?i)` turns on case-insensitive comparison, and `(?-i)` restores the default case-sensitive comparison.</span></span>

<span data-ttu-id="3c13e-184">因为 <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> 选项表示正则表达式引擎的默认行为，因此它很少显式地在方法调用中指定。</span><span class="sxs-lookup"><span data-stu-id="3c13e-184">Because the <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> option represents the default behavior of the regular expression engine, it is rarely explicitly specified in a method call.</span></span> <span data-ttu-id="3c13e-185">而改为调用构造函数或静态模式匹配的方法，其中不包含 `options` 参数。</span><span class="sxs-lookup"><span data-stu-id="3c13e-185">A constructor or static pattern-matching method without an `options` parameter is called instead.</span></span>

## <a name="case-insensitive-matching"></a><span data-ttu-id="3c13e-186">不区分大小写的匹配</span><span class="sxs-lookup"><span data-stu-id="3c13e-186">Case-Insensitive Matching</span></span>

<span data-ttu-id="3c13e-187"><xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase> 选项或 `i` 内联选项提供了不区分大小写匹配。</span><span class="sxs-lookup"><span data-stu-id="3c13e-187">The <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase> option, or the `i` inline option, provides case-insensitive matching.</span></span> <span data-ttu-id="3c13e-188">默认情况下，使用当前区域性的大小写约定。</span><span class="sxs-lookup"><span data-stu-id="3c13e-188">By default, the casing conventions of the current culture are used.</span></span>

<span data-ttu-id="3c13e-189">下面的示例定义与以“the”开头的所有单词匹配的正则表达式模式 `\bthe\w*\b`。</span><span class="sxs-lookup"><span data-stu-id="3c13e-189">The following example defines a regular expression pattern, `\bthe\w*\b`, that matches all words starting with "the".</span></span> <span data-ttu-id="3c13e-190">因为对 <xref:System.Text.RegularExpressions.Regex.Match%2A> 方法的第一次调用使用默认区分大小写的比较，因此输出会指示以字符串“The”开头的句子不匹配。</span><span class="sxs-lookup"><span data-stu-id="3c13e-190">Because the first call to the <xref:System.Text.RegularExpressions.Regex.Match%2A> method uses the default case-sensitive comparison, the output indicates that the string "The" that begins the sentence is not matched.</span></span> <span data-ttu-id="3c13e-191">通过将选项设置为 <xref:System.Text.RegularExpressions.Regex.Match%2A>，调用 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase> 方法时对其进行匹配。</span><span class="sxs-lookup"><span data-stu-id="3c13e-191">It is matched when the <xref:System.Text.RegularExpressions.Regex.Match%2A> method is called with options set to <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase>.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/case1.cs#1)]
[!code-vb[Conceptual.Regex.Language.Options#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/case1.vb#1)]

<span data-ttu-id="3c13e-192">下面的示例修改了上一示例中的正则表达式模式，以使用内联选项而不是 `options` 参数来提供不区分大小写的比较。</span><span class="sxs-lookup"><span data-stu-id="3c13e-192">The following example modifies the regular expression pattern from the previous example to use inline options instead of the `options` parameter to provide case-insensitive comparison.</span></span> <span data-ttu-id="3c13e-193">第一个模式定义只应用于字符串“the”中的字母“t”的分组构造中的不区分大小写的选项。</span><span class="sxs-lookup"><span data-stu-id="3c13e-193">The first pattern defines the case-insensitive option in a grouping construct that applies only to the letter "t" in the string "the".</span></span> <span data-ttu-id="3c13e-194">因为选项构造在模式的开始处出现，所以第二个模式将不区分大小写的选项应用于整个正则表达式。</span><span class="sxs-lookup"><span data-stu-id="3c13e-194">Because the option construct occurs at the beginning of the pattern, the second pattern applies the case-insensitive option to the entire regular expression.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/case2.cs#2)]
[!code-vb[Conceptual.Regex.Language.Options#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/case2.vb#2)]

## <a name="multiline-mode"></a><span data-ttu-id="3c13e-195">多行模式</span><span class="sxs-lookup"><span data-stu-id="3c13e-195">Multiline Mode</span></span>

<span data-ttu-id="3c13e-196"><xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> 选项或 `m` 内联选项使正则表达式引擎能够处理由多个行组成的输入字符串。</span><span class="sxs-lookup"><span data-stu-id="3c13e-196">The <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option, or the `m` inline option, enables the regular expression engine to handle an input string that consists of multiple lines.</span></span> <span data-ttu-id="3c13e-197">它更改了 `^` 和 `$` 语言元素的解释，以使它们分别与行的开头和结尾匹配，而不是与输入字符串的开头和结尾匹配。</span><span class="sxs-lookup"><span data-stu-id="3c13e-197">It changes the interpretation of the `^` and `$` language elements so that they match the beginning and end of a line, instead of the beginning and end of the input string.</span></span>

<span data-ttu-id="3c13e-198">默认情况下，`$` 仅与输入字符串的末尾匹配。</span><span class="sxs-lookup"><span data-stu-id="3c13e-198">By default, `$` matches only the end of the input string.</span></span> <span data-ttu-id="3c13e-199">如果指定了 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> 选项，它将与换行符 (`\n`) 或输入字符串的末尾匹配。</span><span class="sxs-lookup"><span data-stu-id="3c13e-199">If you specify the <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option, it matches either the newline character (`\n`) or the end of the input string.</span></span> <span data-ttu-id="3c13e-200">但是，它并不与回车符/换行符的组合匹配。</span><span class="sxs-lookup"><span data-stu-id="3c13e-200">It does not, however, match the carriage return/line feed character combination.</span></span> <span data-ttu-id="3c13e-201">若要成功匹配它们，使用子表达式 `\r?$` 只替代 `$`。</span><span class="sxs-lookup"><span data-stu-id="3c13e-201">To successfully match them, use the subexpression `\r?$` instead of just `$`.</span></span>

<span data-ttu-id="3c13e-202">下面的示例提取投手的姓名和分数，并将它们添加到 <xref:System.Collections.Generic.SortedList%602> 集合中，该集合将按降序顺序对它们进行排序。</span><span class="sxs-lookup"><span data-stu-id="3c13e-202">The following example extracts bowlers' names and scores and adds them to a <xref:System.Collections.Generic.SortedList%602> collection that sorts them in descending order.</span></span> <span data-ttu-id="3c13e-203">调用了两次 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3c13e-203">The <xref:System.Text.RegularExpressions.Regex.Matches%2A> method is called twice.</span></span> <span data-ttu-id="3c13e-204">在第一个方法调用中，正则表达式是 `^(\w+)\s(\d+)$`，且没有设置任何选项。</span><span class="sxs-lookup"><span data-stu-id="3c13e-204">In the first method call, the regular expression is `^(\w+)\s(\d+)$` and no options are set.</span></span> <span data-ttu-id="3c13e-205">如输出所示，因为正则表达式引擎与输入模式及输入字符串的开头和结尾均不匹配，因此没有找到匹配。</span><span class="sxs-lookup"><span data-stu-id="3c13e-205">As the output shows, because the regular expression engine cannot match the input pattern along with the beginning and end of the input string, no matches are found.</span></span> <span data-ttu-id="3c13e-206">在第二个方法调用中，正则表达式更改为 `^(\w+)\s(\d+)\r?$`，选项设置为 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3c13e-206">In the second method call, the regular expression is changed to `^(\w+)\s(\d+)\r?$` and the options are set to <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3c13e-207">如输出所示，姓名和分数成功匹配，且分数按降序顺序显示。</span><span class="sxs-lookup"><span data-stu-id="3c13e-207">As the output shows, the names and scores are successfully matched, and the scores are displayed in descending order.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/multiline1.cs#3)]
[!code-vb[Conceptual.Regex.Language.Options#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/multiline1.vb#3)]

<span data-ttu-id="3c13e-208">正则表达式模式 `^(\w+)\s(\d+)\r*$` 的定义如下表所示。</span><span class="sxs-lookup"><span data-stu-id="3c13e-208">The regular expression pattern `^(\w+)\s(\d+)\r*$` is defined as shown in the following table.</span></span>

|<span data-ttu-id="3c13e-209">模式</span><span class="sxs-lookup"><span data-stu-id="3c13e-209">Pattern</span></span>|<span data-ttu-id="3c13e-210">说明</span><span class="sxs-lookup"><span data-stu-id="3c13e-210">Description</span></span>|
|-------------|-----------------|
|`^`|<span data-ttu-id="3c13e-211">从行首开始。</span><span class="sxs-lookup"><span data-stu-id="3c13e-211">Begin at the start of the line.</span></span>|
|`(\w+)`|<span data-ttu-id="3c13e-212">匹配一个或多个单词字符。</span><span class="sxs-lookup"><span data-stu-id="3c13e-212">Match one or more word characters.</span></span> <span data-ttu-id="3c13e-213">这是第一个捕获组。</span><span class="sxs-lookup"><span data-stu-id="3c13e-213">This is the first capturing group.</span></span>|
|`\s`|<span data-ttu-id="3c13e-214">与空白字符匹配。</span><span class="sxs-lookup"><span data-stu-id="3c13e-214">Match a white-space character.</span></span>|
|`(\d+)`|<span data-ttu-id="3c13e-215">匹配一个或多个十进制数字。</span><span class="sxs-lookup"><span data-stu-id="3c13e-215">Match one or more decimal digits.</span></span> <span data-ttu-id="3c13e-216">这是第二个捕获组。</span><span class="sxs-lookup"><span data-stu-id="3c13e-216">This is the second capturing group.</span></span>|
|`\r?`|<span data-ttu-id="3c13e-217">与零个或一个回车符匹配。</span><span class="sxs-lookup"><span data-stu-id="3c13e-217">Match zero or one carriage return character.</span></span>|
|`$`|<span data-ttu-id="3c13e-218">在行尾结束。</span><span class="sxs-lookup"><span data-stu-id="3c13e-218">End at the end of the line.</span></span>|

<span data-ttu-id="3c13e-219">下面的示例与上一示例等效，不同之处是下面的示例使用内联选项 `(?m)` 来设置多行选项。</span><span class="sxs-lookup"><span data-stu-id="3c13e-219">The following example is equivalent to the previous one, except that it uses the inline option `(?m)` to set the multiline option.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/multiline2.cs#4)]
[!code-vb[Conceptual.Regex.Language.Options#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/multiline2.vb#4)]

## <a name="single-line-mode"></a><span data-ttu-id="3c13e-220">单行模式</span><span class="sxs-lookup"><span data-stu-id="3c13e-220">Single-line Mode</span></span>

<span data-ttu-id="3c13e-221"><xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> 选项或 `s` 内联选项导致正则表达式引擎将输入字符串视为由单行组成。</span><span class="sxs-lookup"><span data-stu-id="3c13e-221">The <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> option, or the `s` inline option, causes the regular expression engine to treat the input string as if it consists of a single line.</span></span> <span data-ttu-id="3c13e-222">它通过更改句号 (`.`) 语言元素的行为，使其与每个字符匹配，而不是与除换行符 `\n` 或 \u000A 之外的每个字符匹配来执行此操作。</span><span class="sxs-lookup"><span data-stu-id="3c13e-222">It does this by changing the behavior of the period (`.`) language element so that it matches every character, instead of matching every character except for the newline character `\n` or \u000A.</span></span>

<span data-ttu-id="3c13e-223">下面的示例演示了在使用 `.` 选项时如何更改 <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> 语言元素的行为。</span><span class="sxs-lookup"><span data-stu-id="3c13e-223">The following example illustrates how the behavior of the `.` language element changes when you use the <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="3c13e-224">正则表达式 `^.+` 在字符串开头开始并匹配每个字符。</span><span class="sxs-lookup"><span data-stu-id="3c13e-224">The regular expression `^.+` starts at the beginning of the string and matches every character.</span></span> <span data-ttu-id="3c13e-225">默认情况下，匹配在第一行的结尾结束；正则表达式模式匹配回车符、`\r` 或 \u000D，但不匹配 `\n`。</span><span class="sxs-lookup"><span data-stu-id="3c13e-225">By default, the match ends at the end of the first line; the regular expression pattern matches the carriage return character, `\r` or \u000D, but it does not match `\n`.</span></span> <span data-ttu-id="3c13e-226">由于 <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> 选项将整个输入字符串解释为单行，因此它匹配输入字符串中的每个字符，包括 `\n`。</span><span class="sxs-lookup"><span data-stu-id="3c13e-226">Because the <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> option interprets the entire input string as a single line, it matches every character in the input string, including `\n`.</span></span>

[!code-csharp[Conceptual.Regex.Language.CharacterClasses#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/any2.cs#5)]
[!code-vb[Conceptual.Regex.Language.CharacterClasses#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/any2.vb#5)]

<span data-ttu-id="3c13e-227">下面的示例与上一示例等效，不同之处是下面的示例使用内联选项 `(?s)` 来启用单行模式。</span><span class="sxs-lookup"><span data-stu-id="3c13e-227">The following example is equivalent to the previous one, except that it uses the inline option `(?s)` to enable single-line mode.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/singleline1.cs#5)]
[!code-vb[Conceptual.Regex.Language.Options#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/singleline1.vb#5)]

## <a name="explicit-captures-only"></a><span data-ttu-id="3c13e-228">仅显式捕获</span><span class="sxs-lookup"><span data-stu-id="3c13e-228">Explicit Captures Only</span></span>

<span data-ttu-id="3c13e-229">默认情况下，通过在正则表达式模式中使用括号来定义捕获组。</span><span class="sxs-lookup"><span data-stu-id="3c13e-229">By default, capturing groups are defined by the use of parentheses in the regular expression pattern.</span></span> <span data-ttu-id="3c13e-230">通过 `(?<`name  `>`subexpression  `)` 语言选项为命名组指定名称或编号，而未命名组按索引进行访问。</span><span class="sxs-lookup"><span data-stu-id="3c13e-230">Named groups are assigned a name or number by the `(?<`*name*`>`*subexpression*`)` language option, whereas unnamed groups are accessible by index.</span></span> <span data-ttu-id="3c13e-231">在 <xref:System.Text.RegularExpressions.GroupCollection> 对象中，未命名的组先于已命名的组。</span><span class="sxs-lookup"><span data-stu-id="3c13e-231">In the <xref:System.Text.RegularExpressions.GroupCollection> object, unnamed groups precede named groups.</span></span>

<span data-ttu-id="3c13e-232">分组构造通常仅用于将限定符应用于多个语言元素，而非应用于捕获的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3c13e-232">Grouping constructs are often used only to apply quantifiers to multiple language elements, and the captured substrings are of no interest.</span></span> <span data-ttu-id="3c13e-233">例如，如果下面的正则表达式：</span><span class="sxs-lookup"><span data-stu-id="3c13e-233">For example, if the following regular expression:</span></span>

`\b\(?((\w+),?\s?)+[\.!?]\)?`

<span data-ttu-id="3c13e-234">旨在仅从文档提取末尾有句号、感叹点或问号的句子，仅产生的句子（这由 <xref:System.Text.RegularExpressions.Match> 对象表示）有意义。</span><span class="sxs-lookup"><span data-stu-id="3c13e-234">is intended only to extract sentences that end with a period, exclamation point, or question mark from a document, only the resulting sentence (which is represented by the <xref:System.Text.RegularExpressions.Match> object) is of interest.</span></span> <span data-ttu-id="3c13e-235">集合中的各单词不是。</span><span class="sxs-lookup"><span data-stu-id="3c13e-235">The individual words in the collection are not.</span></span>

<span data-ttu-id="3c13e-236">随后未使用的捕获组可能很昂贵，因为正则表达式引擎必须填充 <xref:System.Text.RegularExpressions.GroupCollection> 和 <xref:System.Text.RegularExpressions.CaptureCollection> 集合对象。</span><span class="sxs-lookup"><span data-stu-id="3c13e-236">Capturing groups that are not subsequently used can be expensive, because the regular expression engine must populate both the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> collection objects.</span></span> <span data-ttu-id="3c13e-237">作为替换方法，也可以使用 <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> 选项或 `n` 内联选项，指定显式命名的唯一有效捕获，或由 `(?<`名称  `>` 子表达式  `)` 构造指定的编号组。</span><span class="sxs-lookup"><span data-stu-id="3c13e-237">As an alternative, you can use either the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> option or the `n` inline option to specify that the only valid captures are explicitly named or numbered groups that are designated by the `(?<`*name*`>` *subexpression*`)` construct.</span></span>

<span data-ttu-id="3c13e-238">以下示例显示 `\b\(?((\w+),?\s?)+[\.!?]\)?` 正则表达式模式在 <xref:System.Text.RegularExpressions.Regex.Match%2A> 方法被调用且没有 <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> 选项时返回的匹配信息。</span><span class="sxs-lookup"><span data-stu-id="3c13e-238">The following example displays information about the matches returned by the `\b\(?((\w+),?\s?)+[\.!?]\)?` regular expression pattern when the <xref:System.Text.RegularExpressions.Regex.Match%2A> method is called with and without the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="3c13e-239">如第一个方法调用输出所示，正则表达式引擎使用有关已捕获的子字符串的信息完全填充 <xref:System.Text.RegularExpressions.GroupCollection> 和 <xref:System.Text.RegularExpressions.CaptureCollection> 集合对象。</span><span class="sxs-lookup"><span data-stu-id="3c13e-239">As the output from the first method call shows, the regular expression engine fully populates the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> collection objects with information about captured substrings.</span></span> <span data-ttu-id="3c13e-240">因为第二个方法使用设置为 `options` 的 <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> 进行调用，所以它不会捕获有关组的信息。</span><span class="sxs-lookup"><span data-stu-id="3c13e-240">Because the second method is called with `options` set to <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType>, it does not capture information on groups.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/explicit1.cs#9)]
[!code-vb[Conceptual.Regex.Language.Options#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/explicit1.vb#9)]

<span data-ttu-id="3c13e-241">正则表达式模式 `\b\(?((?>\w+),?\s?)+[\.!?]\)?` 的定义如下表所示。</span><span class="sxs-lookup"><span data-stu-id="3c13e-241">The regular expression pattern`\b\(?((?>\w+),?\s?)+[\.!?]\)?` is defined as shown in the following table.</span></span>

|<span data-ttu-id="3c13e-242">模式</span><span class="sxs-lookup"><span data-stu-id="3c13e-242">Pattern</span></span>|<span data-ttu-id="3c13e-243">说明</span><span class="sxs-lookup"><span data-stu-id="3c13e-243">Description</span></span>|
|-------------|-----------------|
|`\b`|<span data-ttu-id="3c13e-244">在单词边界处开始。</span><span class="sxs-lookup"><span data-stu-id="3c13e-244">Begin at a word boundary.</span></span>|
|`\(?`|<span data-ttu-id="3c13e-245">匹配左括号（“(”）的零或一个匹配项。</span><span class="sxs-lookup"><span data-stu-id="3c13e-245">Match zero or one occurrences of the opening parenthesis ("(").</span></span>|
|`(?>\w+),?`|<span data-ttu-id="3c13e-246">匹配一个或多个单词字符，后跟零或一个逗号。</span><span class="sxs-lookup"><span data-stu-id="3c13e-246">Match one or more word characters, followed by zero or one commas.</span></span> <span data-ttu-id="3c13e-247">当匹配单词字符请不要回溯。</span><span class="sxs-lookup"><span data-stu-id="3c13e-247">Do not backtrack when matching word characters.</span></span>|
|`\s?`|<span data-ttu-id="3c13e-248">匹配零个或一个空白字符。</span><span class="sxs-lookup"><span data-stu-id="3c13e-248">Match zero or one white-space characters.</span></span>|
|`((\w+),?\s?)+`|<span data-ttu-id="3c13e-249">一次或多次匹配一个或多个单词字符、零或一个逗号以及零或一个空白字符的组合。</span><span class="sxs-lookup"><span data-stu-id="3c13e-249">Match the combination of one or more word characters, zero or one commas, and zero or one white-space characters one or more times.</span></span>|
|`[\.!?]\)?`|<span data-ttu-id="3c13e-250">与后无右括号或后跟一个右括号（“)”）的三个标点符号匹配。</span><span class="sxs-lookup"><span data-stu-id="3c13e-250">Match any of the three punctuation symbols, followed by zero or one closing parentheses (")").</span></span>|

<span data-ttu-id="3c13e-251">还可以使用 `(?n)` 内联元素来禁止自动捕获。</span><span class="sxs-lookup"><span data-stu-id="3c13e-251">You can also use the `(?n)` inline element to suppress automatic captures.</span></span> <span data-ttu-id="3c13e-252">以下示例修改了上一示例中的正则表达式模式，使用的是内联元素 `(?n)` 而非 <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> 选项。</span><span class="sxs-lookup"><span data-stu-id="3c13e-252">The following example modifies the previous regular expression pattern to use the `(?n)` inline element instead of the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> option.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/explicit2.cs#10)]
[!code-vb[Conceptual.Regex.Language.Options#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/explicit2.vb#10)]

<span data-ttu-id="3c13e-253">最后，可以使用内联组元素 `(?n:)` 禁止逐组进行自动捕获。</span><span class="sxs-lookup"><span data-stu-id="3c13e-253">Finally, you can use the inline group element `(?n:)` to suppress automatic captures on a group-by-group basis.</span></span> <span data-ttu-id="3c13e-254">下面的示例修改了之前的模式，以取消外部组 `((?>\w+),?\s?)` 中的非命名捕获。</span><span class="sxs-lookup"><span data-stu-id="3c13e-254">The following example modifies the previous pattern to suppress unnamed captures in the outer group, `((?>\w+),?\s?)`.</span></span> <span data-ttu-id="3c13e-255">请注意，这也取消了内部组中的非命名捕获。</span><span class="sxs-lookup"><span data-stu-id="3c13e-255">Note that this suppresses unnamed captures in the inner group as well.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#11](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/explicit3.cs#11)]
[!code-vb[Conceptual.Regex.Language.Options#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/explicit3.vb#11)]

## <a name="compiled-regular-expressions"></a><span data-ttu-id="3c13e-256">已编译的正则表达式</span><span class="sxs-lookup"><span data-stu-id="3c13e-256">Compiled Regular Expressions</span></span>

<span data-ttu-id="3c13e-257">默认情况下，.NET 中的正则表达式会有解释。</span><span class="sxs-lookup"><span data-stu-id="3c13e-257">By default, regular expressions in .NET are interpreted.</span></span> <span data-ttu-id="3c13e-258">当实例化 <xref:System.Text.RegularExpressions.Regex> 对象或者调用静态 <xref:System.Text.RegularExpressions.Regex> 方法时，将把正则表达式模式解析为一组自定义操作代码，并且解释器使用这些操作代码来运行正则表达式。</span><span class="sxs-lookup"><span data-stu-id="3c13e-258">When a <xref:System.Text.RegularExpressions.Regex> object is instantiated or a static <xref:System.Text.RegularExpressions.Regex> method is called, the regular expression pattern is parsed into a set of custom opcodes, and an interpreter uses these opcodes to run the regular expression.</span></span> <span data-ttu-id="3c13e-259">这涉及一个权衡：初始化正则表达式引擎的成本通过运行时性能的消耗而最小化。</span><span class="sxs-lookup"><span data-stu-id="3c13e-259">This involves a tradeoff: The cost of initializing the regular expression engine is minimized at the expense of run-time performance.</span></span>

<span data-ttu-id="3c13e-260">通过使用 <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> 选项可以使用编译的而非解释的正则表达式。</span><span class="sxs-lookup"><span data-stu-id="3c13e-260">You can use compiled instead of interpreted regular expressions by using the <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="3c13e-261">在此情况下，当模式传递给正则表达式引擎时，它将分析为一组操作码，然后转换为 Microsoft 中间语言 (MSIL)，该语言可以被直接传递到公共语言运行时。</span><span class="sxs-lookup"><span data-stu-id="3c13e-261">In this case, when a pattern is passed to the regular expression engine, it is parsed into a set of opcodes and then converted to Microsoft intermediate language (MSIL), which can be passed directly to the common language runtime.</span></span> <span data-ttu-id="3c13e-262">已编译的正则表达式最大限度地提高运行时性能，代价是会影响初始化时间。</span><span class="sxs-lookup"><span data-stu-id="3c13e-262">Compiled regular expressions maximize run-time performance at the expense of initialization time.</span></span>

> [!NOTE]
> <span data-ttu-id="3c13e-263">仅可以通过将 <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> 值提供给 `options` 类构造函数或静态模式匹配方法的 <xref:System.Text.RegularExpressions.Regex> 参数来编译正则表达式。</span><span class="sxs-lookup"><span data-stu-id="3c13e-263">A regular expression can be compiled only by supplying the <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> value to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or a static pattern-matching method.</span></span> <span data-ttu-id="3c13e-264">它不可作为内联选项使用。</span><span class="sxs-lookup"><span data-stu-id="3c13e-264">It is not available as an inline option.</span></span>

<span data-ttu-id="3c13e-265">在调用静态和实例正则表达式时，可使用编译的正则表达式。</span><span class="sxs-lookup"><span data-stu-id="3c13e-265">You can use compiled regular expressions in calls to both static and instance regular expressions.</span></span> <span data-ttu-id="3c13e-266">在静态正则表达式中，<xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> 选项将传递到正则表达式模式匹配方法的 `options` 参数。</span><span class="sxs-lookup"><span data-stu-id="3c13e-266">In static regular expressions, the <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> option is passed to the `options` parameter of the regular expression pattern-matching method.</span></span> <span data-ttu-id="3c13e-267">在实例正则表达式中，将它传递到 `options` 类构造函数的 <xref:System.Text.RegularExpressions.Regex> 参数。</span><span class="sxs-lookup"><span data-stu-id="3c13e-267">In instance regular expressions, it is passed to the `options` parameter of the <xref:System.Text.RegularExpressions.Regex> class constructor.</span></span> <span data-ttu-id="3c13e-268">在这两种情况中它将导致性能增强。</span><span class="sxs-lookup"><span data-stu-id="3c13e-268">In both cases, it results in enhanced performance.</span></span>

<span data-ttu-id="3c13e-269">但是，这种性能改进只有在以下情况下才发生：</span><span class="sxs-lookup"><span data-stu-id="3c13e-269">However, this improvement in performance occurs only under the following conditions:</span></span>

- <span data-ttu-id="3c13e-270">表示特定正则表达式的 <xref:System.Text.RegularExpressions.Regex> 对象可用于多个正则表达式模式匹配方法调用。</span><span class="sxs-lookup"><span data-stu-id="3c13e-270">A <xref:System.Text.RegularExpressions.Regex> object that represents a particular regular expression is used in multiple calls to regular expression pattern-matching methods.</span></span>

- <span data-ttu-id="3c13e-271">不允许 <xref:System.Text.RegularExpressions.Regex> 对象超出范围，以便可以重用它。</span><span class="sxs-lookup"><span data-stu-id="3c13e-271">The <xref:System.Text.RegularExpressions.Regex> object is not allowed to go out of scope, so it can be reused.</span></span>

- <span data-ttu-id="3c13e-272">静态正则表达式在对正则表达式模式匹配方法的多个调用中使用。</span><span class="sxs-lookup"><span data-stu-id="3c13e-272">A static regular expression is used in multiple calls to regular expression pattern-matching methods.</span></span> <span data-ttu-id="3c13e-273">（之所以能够提高性能，是因为静态方法调用中使用的正则表达式由正则表达式引擎缓存。）</span><span class="sxs-lookup"><span data-stu-id="3c13e-273">(The performance improvement is possible because regular expressions used in static method calls are cached by the regular expression engine.)</span></span>

> [!NOTE]
> <span data-ttu-id="3c13e-274"><xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> 选项与 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> 方法无关，该方法创建一个特殊用途的程序集，其中包含预定义的已编译的正则表达式。</span><span class="sxs-lookup"><span data-stu-id="3c13e-274">The <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> option is unrelated to the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method, which creates a special-purpose assembly that contains predefined compiled regular expressions.</span></span>

## <a name="ignore-white-space"></a><span data-ttu-id="3c13e-275">忽略空白</span><span class="sxs-lookup"><span data-stu-id="3c13e-275">Ignore White Space</span></span>

<span data-ttu-id="3c13e-276">默认情况下，正则表达式模式中的空白非常重要；它会强制正则表达式引擎与输入字符串中的空白字符相匹配。</span><span class="sxs-lookup"><span data-stu-id="3c13e-276">By default, white space in a regular expression pattern is significant; it forces the regular expression engine to match a white-space character in the input string.</span></span> <span data-ttu-id="3c13e-277">因此，正则表达式“`\b\w+\s`”和“`\b\w+`”是大致等效的正则表达式。</span><span class="sxs-lookup"><span data-stu-id="3c13e-277">Because of this, the regular expression "`\b\w+\s`" and "`\b\w+` " are roughly equivalent regular expressions.</span></span> <span data-ttu-id="3c13e-278">此外，正则表达式模式中出现数字符号 (#) 时，它被解释为要进行匹配的原义字符。</span><span class="sxs-lookup"><span data-stu-id="3c13e-278">In addition, when the number sign (#) is encountered in a regular expression pattern, it is interpreted as a literal character to be matched.</span></span>

<span data-ttu-id="3c13e-279"><xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> 选项或 `x` 内联选项更改此默认行为，如下所示：</span><span class="sxs-lookup"><span data-stu-id="3c13e-279">The <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> option, or the `x` inline option, changes this default behavior as follows:</span></span>

- <span data-ttu-id="3c13e-280">正则表达式模式中的非转义的空白将被忽略。</span><span class="sxs-lookup"><span data-stu-id="3c13e-280">Unescaped white space in the regular expression pattern is ignored.</span></span> <span data-ttu-id="3c13e-281">作为正则表达式模式的部分，必须避开空白字符（例如 `\s` 或“`\`”）。</span><span class="sxs-lookup"><span data-stu-id="3c13e-281">To be part of a regular expression pattern, white-space characters must be escaped (for example, as `\s` or "`\` ").</span></span>

- <span data-ttu-id="3c13e-282">数字符号 (#) 被解释为注释的开头，而不是原义字符。</span><span class="sxs-lookup"><span data-stu-id="3c13e-282">The number sign (#) is interpreted as the beginning of a comment, rather than as a literal character.</span></span> <span data-ttu-id="3c13e-283">正则表达式模式中的所有文本，从 # 字符到字符串的结尾都解释为注释。</span><span class="sxs-lookup"><span data-stu-id="3c13e-283">All text in the regular expression pattern from the # character to the end of the string is interpreted as a comment.</span></span>

<span data-ttu-id="3c13e-284">但是，在下列情况下，不会忽略正则表达式中的空白字符，即使使用 <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> 选项也是如此：</span><span class="sxs-lookup"><span data-stu-id="3c13e-284">However, in the following cases, white-space characters in a regular expression aren't ignored, even if you use the <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> option:</span></span>

- <span data-ttu-id="3c13e-285">始终按原义解释字符内的空格。</span><span class="sxs-lookup"><span data-stu-id="3c13e-285">White space within a character class is always interpreted literally.</span></span> <span data-ttu-id="3c13e-286">例如，正则表达式模式 `[ .,;:]` 匹配任意单个空白字符、句号、逗号、分号或冒号。</span><span class="sxs-lookup"><span data-stu-id="3c13e-286">For example, the regular expression pattern `[ .,;:]` matches any single white-space character, period, comma, semicolon, or colon.</span></span>

- <span data-ttu-id="3c13e-287">加括号的限定符内不允许有空格，如 `{`n  `}`、`{`n  `,}` 和 `{`n  `,`m  `}`。</span><span class="sxs-lookup"><span data-stu-id="3c13e-287">White space isn't allowed within a bracketed quantifier, such as `{`*n*`}`, `{`*n*`,}`, and `{`*n*`,`*m*`}`.</span></span> <span data-ttu-id="3c13e-288">例如，因为它包含一个空白字符，所以正则表达式模式 `\d{1, 3}` 与任何从 1 到 3 位数的数字序列不匹配。</span><span class="sxs-lookup"><span data-stu-id="3c13e-288">For example, the regular expression pattern `\d{1, 3}` fails to match any sequences of digits from one to three digits because it contains a white-space character.</span></span>

- <span data-ttu-id="3c13e-289">引入语言元素的字符序列内不允许有空格。</span><span class="sxs-lookup"><span data-stu-id="3c13e-289">White space isn't allowed within a character sequence that introduces a language element.</span></span> <span data-ttu-id="3c13e-290">例如:</span><span class="sxs-lookup"><span data-stu-id="3c13e-290">For example:</span></span>

  - <span data-ttu-id="3c13e-291">语言元素 `(?:`subexpression  `)` 表示非捕获组，并且该元素的 `(?:` 部分不能有嵌入空格。</span><span class="sxs-lookup"><span data-stu-id="3c13e-291">The language element `(?:`*subexpression*`)` represents a noncapturing group, and the `(?:` portion of the element can't have embedded spaces.</span></span> <span data-ttu-id="3c13e-292">模式 `(? :`子表达式  `)` 在运行时抛出 <xref:System.ArgumentException>，因为正则表达式引擎无法分析此模式，且模式 `( ?:`子表达式  `)` 与子表达式  不匹配。</span><span class="sxs-lookup"><span data-stu-id="3c13e-292">The pattern `(? :`*subexpression*`)` throws an <xref:System.ArgumentException> at run time because the regular expression engine can't parse the pattern, and the pattern `( ?:`*subexpression*`)` fails to match *subexpression*.</span></span>

  - <span data-ttu-id="3c13e-293">语言元素 `\p{`name  `}` 表示一个 Unicode 类别或命名块，它不能在元素的 `\p{` 部分中包括嵌入空格。</span><span class="sxs-lookup"><span data-stu-id="3c13e-293">The language element `\p{`*name*`}`, which represents a Unicode category or named block, can't include embedded spaces in the `\p{` portion of the element.</span></span> <span data-ttu-id="3c13e-294">如果你包括了空格，则该元素会在运行时引发 <xref:System.ArgumentException> 异常。</span><span class="sxs-lookup"><span data-stu-id="3c13e-294">If you do include a white space, the element throws an <xref:System.ArgumentException> at run time.</span></span>

<span data-ttu-id="3c13e-295">启用此选项有助于简化通常很难分析和理解的正则表达式。</span><span class="sxs-lookup"><span data-stu-id="3c13e-295">Enabling this option helps simplify regular expressions that are often difficult to parse and to understand.</span></span> <span data-ttu-id="3c13e-296">它提高了可读性，并可以记录正则表达式。</span><span class="sxs-lookup"><span data-stu-id="3c13e-296">It improves readability, and makes it possible to document a regular expression.</span></span>

<span data-ttu-id="3c13e-297">下面的示例定义以下正则表达式模式：</span><span class="sxs-lookup"><span data-stu-id="3c13e-297">The following example defines the following regular expression pattern:</span></span>

`\b \(? ( (?>\w+) ,?\s? )+  [\.!?] \)? # Matches an entire sentence.`

<span data-ttu-id="3c13e-298">此模式与[仅显式捕获](#explicit-captures-only)部分中定义的模式相似，不同之处在于它使用 <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> 选项忽略模式空格。</span><span class="sxs-lookup"><span data-stu-id="3c13e-298">This pattern is similar to the pattern defined in the [Explicit Captures Only](#explicit-captures-only) section, except that it uses the <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> option to ignore pattern white space.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#12](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/whitespace1.cs#12)]
[!code-vb[Conceptual.Regex.Language.Options#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/whitespace1.vb#12)]

<span data-ttu-id="3c13e-299">下面的示例使用内联选项 `(?x)` 来忽略模式空白。</span><span class="sxs-lookup"><span data-stu-id="3c13e-299">The following example uses the inline option `(?x)` to ignore pattern white space.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#13](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/whitespace2.cs#13)]
[!code-vb[Conceptual.Regex.Language.Options#13](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/whitespace2.vb#13)]

## <a name="right-to-left-mode"></a><span data-ttu-id="3c13e-300">从右到左模式</span><span class="sxs-lookup"><span data-stu-id="3c13e-300">Right-to-Left Mode</span></span>

<span data-ttu-id="3c13e-301">默认情况下，正则表达式引擎从左向右进行搜索。</span><span class="sxs-lookup"><span data-stu-id="3c13e-301">By default, the regular expression engine searches from left to right.</span></span> <span data-ttu-id="3c13e-302">可通过使用 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> 选项反转搜索方向。</span><span class="sxs-lookup"><span data-stu-id="3c13e-302">You can reverse the search direction by using the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="3c13e-303">搜索在字符串的最后一个字符位置自动开始。</span><span class="sxs-lookup"><span data-stu-id="3c13e-303">The search automatically begins at the last character position of the string.</span></span> <span data-ttu-id="3c13e-304">对于包括起始位置参数的模式匹配方法，例如 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>，起始位置是最右边字符位置（即搜索开始位置）的索引。</span><span class="sxs-lookup"><span data-stu-id="3c13e-304">For pattern-matching methods that include a starting position parameter, such as <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>, the starting position is the index of the rightmost character position at which the search is to begin.</span></span>

> [!NOTE]
> <span data-ttu-id="3c13e-305">仅能通过将 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> 值提供给 `options` 类构造函数或静态模式匹配方法的 <xref:System.Text.RegularExpressions.Regex> 参数来提供从右到左模式。</span><span class="sxs-lookup"><span data-stu-id="3c13e-305">Right-to-left pattern mode is available only by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> value to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or static pattern-matching method.</span></span> <span data-ttu-id="3c13e-306">它不可作为内联选项使用。</span><span class="sxs-lookup"><span data-stu-id="3c13e-306">It is not available as an inline option.</span></span>

<span data-ttu-id="3c13e-307"><xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> 选项仅更改搜索方向；它不解释正则表达式模式是从右到左。</span><span class="sxs-lookup"><span data-stu-id="3c13e-307">The <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option changes the search direction only; it does not interpret the regular expression pattern from right to left.</span></span> <span data-ttu-id="3c13e-308">例如，正则表达式 `\bb\w+\s` 匹配以字母“b”开头的单词,且后跟一个空白字符。</span><span class="sxs-lookup"><span data-stu-id="3c13e-308">For example, the regular expression `\bb\w+\s` matches words that begin with the letter "b" and are followed by a white-space character.</span></span> <span data-ttu-id="3c13e-309">在下面的示例中，输入字符串由其中包括一个或多个“b”字符的三个单词组成。</span><span class="sxs-lookup"><span data-stu-id="3c13e-309">In the following example, the input string consists of three words that include one or more "b" characters.</span></span> <span data-ttu-id="3c13e-310">第一个单词以“b”开头，第二个单词以“b”结尾，第三个单词的中间包括两个“b”字符。</span><span class="sxs-lookup"><span data-stu-id="3c13e-310">The first word begins with "b", the second ends with "b", and the third includes two "b" characters in the middle of the word.</span></span> <span data-ttu-id="3c13e-311">如示例输出所示，只有第一个词与正则表达式模式匹配。</span><span class="sxs-lookup"><span data-stu-id="3c13e-311">As the output from the example shows, only the first word matches the regular expression pattern.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#17](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/righttoleft1.cs#17)]
[!code-vb[Conceptual.Regex.Language.Options#17](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/righttoleft1.vb#17)]

<span data-ttu-id="3c13e-312">另请注意，预测先行断言（`(?=`subexpression  `)` 语言元素）和回顾后发断言（`(?<=`subexpression  `)` 语言元素）不会更改方向。</span><span class="sxs-lookup"><span data-stu-id="3c13e-312">Also note that the lookahead assertion (the `(?=`*subexpression*`)` language element) and the lookbehind assertion (the `(?<=`*subexpression*`)` language element) do not change direction.</span></span> <span data-ttu-id="3c13e-313">预测先行断言向右搜索；回顾后发断言向左搜索。</span><span class="sxs-lookup"><span data-stu-id="3c13e-313">The lookahead assertions look to the right; the lookbehind assertions look to the left.</span></span> <span data-ttu-id="3c13e-314">例如，正则表达式 `(?<=\d{1,2}\s)\w+,?\s\d{4}` 使用回顾后发断言测试月份名称前面的日期。</span><span class="sxs-lookup"><span data-stu-id="3c13e-314">For example, the regular expression `(?<=\d{1,2}\s)\w+,?\s\d{4}` uses the lookbehind assertion to test for a date that precedes a month name.</span></span> <span data-ttu-id="3c13e-315">然后该正则表达式匹配月份和年份。</span><span class="sxs-lookup"><span data-stu-id="3c13e-315">The regular expression then matches the month and the year.</span></span> <span data-ttu-id="3c13e-316">有关预测先行和回顾后发断言的信息，请参阅[分组构造](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="3c13e-316">For information on lookahead and lookbehind assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#18](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/righttoleft2.cs#18)]
[!code-vb[Conceptual.Regex.Language.Options#18](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/righttoleft2.vb#18)]

<span data-ttu-id="3c13e-317">正则表达式模式的定义如下表所示。</span><span class="sxs-lookup"><span data-stu-id="3c13e-317">The regular expression pattern is defined as shown in the following table.</span></span>

|<span data-ttu-id="3c13e-318">模式</span><span class="sxs-lookup"><span data-stu-id="3c13e-318">Pattern</span></span>|<span data-ttu-id="3c13e-319">说明</span><span class="sxs-lookup"><span data-stu-id="3c13e-319">Description</span></span>|
|-------------|-----------------|
|`(?<=\d{1,2}\s)`|<span data-ttu-id="3c13e-320">匹配项的开头必须有后跟一个空格的一个或两个十进制数字。</span><span class="sxs-lookup"><span data-stu-id="3c13e-320">The beginning of the match must be preceded by one or two decimal digits followed by a space.</span></span>|
|`\w+`|<span data-ttu-id="3c13e-321">匹配一个或多个单词字符。</span><span class="sxs-lookup"><span data-stu-id="3c13e-321">Match one or more word characters.</span></span>|
|`,?`|<span data-ttu-id="3c13e-322">匹配零个或一个逗号字符。</span><span class="sxs-lookup"><span data-stu-id="3c13e-322">Match zero or one comma characters.</span></span>|
|`\s`|<span data-ttu-id="3c13e-323">与空白字符匹配。</span><span class="sxs-lookup"><span data-stu-id="3c13e-323">Match a white-space character.</span></span>|
|`\d{4}`|<span data-ttu-id="3c13e-324">匹配四个十进制数字。</span><span class="sxs-lookup"><span data-stu-id="3c13e-324">Match four decimal digits.</span></span>|

## <a name="ecmascript-matching-behavior"></a><span data-ttu-id="3c13e-325">ECMAScript 匹配行为</span><span class="sxs-lookup"><span data-stu-id="3c13e-325">ECMAScript Matching Behavior</span></span>

<span data-ttu-id="3c13e-326">默认情况下，当正则表达式模式与输入文本匹配时，正则表达式引擎会采用规范行为。</span><span class="sxs-lookup"><span data-stu-id="3c13e-326">By default, the regular expression engine uses canonical behavior when matching a regular expression pattern to input text.</span></span> <span data-ttu-id="3c13e-327">但是，可以指示正则表达式引擎通过指定 <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> 选项使用 ECMAScript 匹配行为。</span><span class="sxs-lookup"><span data-stu-id="3c13e-327">However, you can instruct the regular expression engine to use ECMAScript matching behavior by specifying the <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> option.</span></span>

> [!NOTE]
> <span data-ttu-id="3c13e-328">仅在通过将 <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> 值提供给 `options` 类构造函数造函数或静态模式匹配方法的 <xref:System.Text.RegularExpressions.Regex> 参数后，符合 ECMAScript 的行为才可用。</span><span class="sxs-lookup"><span data-stu-id="3c13e-328">ECMAScript-compliant behavior is available only by supplying the <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> value to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or static pattern-matching method.</span></span> <span data-ttu-id="3c13e-329">它不可作为内联选项使用。</span><span class="sxs-lookup"><span data-stu-id="3c13e-329">It is not available as an inline option.</span></span>

<span data-ttu-id="3c13e-330"><xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> 选项只能与 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 和 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> 选项结合使用。</span><span class="sxs-lookup"><span data-stu-id="3c13e-330">The <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> option can be combined only with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> options.</span></span> <span data-ttu-id="3c13e-331">在正则表达式中使用其他选项会导致 <xref:System.ArgumentOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="3c13e-331">The use of any other option in a regular expression results in an <xref:System.ArgumentOutOfRangeException>.</span></span>

<span data-ttu-id="3c13e-332">ECMAScript 和规范化正则表达式的行为在三个方面不同：字符类语法、自引用捕获组和八进制与反向引用的解释。</span><span class="sxs-lookup"><span data-stu-id="3c13e-332">The behavior of ECMAScript and canonical regular expressions differs in three areas: character class syntax, self-referencing capturing groups, and octal versus backreference interpretation.</span></span>

- <span data-ttu-id="3c13e-333">字符类语法。</span><span class="sxs-lookup"><span data-stu-id="3c13e-333">Character class syntax.</span></span> <span data-ttu-id="3c13e-334">因为规范的正则表达式支持 Unicode，却不支持 ECMAScript，ECMAScript 中的字符类具有一个受限更多的语法且某些字符类语言元素具有不同的含义。</span><span class="sxs-lookup"><span data-stu-id="3c13e-334">Because canonical regular expressions support Unicode whereas ECMAScript does not, character classes in ECMAScript have a more limited syntax, and some character class language elements have a different meaning.</span></span> <span data-ttu-id="3c13e-335">例如，ECMAScript 不支持语言元素（例如 Unicode 类别或块元素 `\p` 和 `\P`）。</span><span class="sxs-lookup"><span data-stu-id="3c13e-335">For example, ECMAScript does not support language elements such as the Unicode category or block elements `\p` and `\P`.</span></span> <span data-ttu-id="3c13e-336">同样，使用 ECMAScript 时，与单词字符匹配的 `\w` 元素等效于 `[a-zA-Z_0-9]` 字符类，使用规范化行为时，该元素等效于 `[\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\p{Lm}]`。</span><span class="sxs-lookup"><span data-stu-id="3c13e-336">Similarly, the `\w` element, which matches a word character, is equivalent to the `[a-zA-Z_0-9]` character class when using ECMAScript and `[\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\p{Lm}]` when using canonical behavior.</span></span> <span data-ttu-id="3c13e-337">有关更多信息，请参见 [字符类](../../../docs/standard/base-types/character-classes-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="3c13e-337">For more information, see [Character Classes](../../../docs/standard/base-types/character-classes-in-regular-expressions.md).</span></span>

  <span data-ttu-id="3c13e-338">下面的示例阐释了规范化与 ECMAScript 模式匹配之间的差异。</span><span class="sxs-lookup"><span data-stu-id="3c13e-338">The following example illustrates the difference between canonical and ECMAScript pattern matching.</span></span> <span data-ttu-id="3c13e-339">它定义了正则表达式 `\b(\w+\s*)+`，该表达式与后跟空白字符的单词匹配。</span><span class="sxs-lookup"><span data-stu-id="3c13e-339">It defines a regular expression, `\b(\w+\s*)+`, that matches words followed by white-space characters.</span></span> <span data-ttu-id="3c13e-340">由两个字符串组成的输入，其中一个字符串使用拉丁字符集，另一个则使用西里尔字符集。</span><span class="sxs-lookup"><span data-stu-id="3c13e-340">The input consists of two strings, one that uses the Latin character set and the other that uses the Cyrillic character set.</span></span> <span data-ttu-id="3c13e-341">如输出所示，对使用 ECMAScript 匹配的 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> 方法的调用无法与西里尔文的单词匹配，而使用规范化匹配的方法调用与这些单词匹配。</span><span class="sxs-lookup"><span data-stu-id="3c13e-341">As the output shows, the call to the <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method that uses ECMAScript matching fails to match the Cyrillic words, whereas the method call that uses canonical matching does match these words.</span></span>

  [!code-csharp[Conceptual.Regex.Language.Options#16](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/ecmascript1.cs#16)]
  [!code-vb[Conceptual.Regex.Language.Options#16](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/ecmascript1.vb#16)]

- <span data-ttu-id="3c13e-342">自引用捕获组。</span><span class="sxs-lookup"><span data-stu-id="3c13e-342">Self-referencing capturing groups.</span></span> <span data-ttu-id="3c13e-343">自身具有后向引用的正则表达式捕获类必须在每次捕获迭代时得到更新。</span><span class="sxs-lookup"><span data-stu-id="3c13e-343">A regular expression capture class with a backreference to itself must be updated with each capture iteration.</span></span> <span data-ttu-id="3c13e-344">如以下示例所示，此功能将在使用 ECMAScript 时使正则表达式 `((a+)(\1) ?)+` 与输入字符串“aa aaaa aaaaaa”匹配，但在使用规范化匹配时则不会匹配。</span><span class="sxs-lookup"><span data-stu-id="3c13e-344">As the following example shows, this feature enables the regular expression `((a+)(\1) ?)+` to match the input string " aa aaaa aaaaaa " when using ECMAScript, but not when using canonical matching.</span></span>

  [!code-csharp[Conceptual.Regex.Language.Options#21](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/ecmascript2.cs#21)]
  [!code-vb[Conceptual.Regex.Language.Options#21](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/ecmascript2.vb#21)]

  <span data-ttu-id="3c13e-345">该正则表达式的定义如下表所示。</span><span class="sxs-lookup"><span data-stu-id="3c13e-345">The regular expression is defined as shown in the following table.</span></span>

  |<span data-ttu-id="3c13e-346">模式</span><span class="sxs-lookup"><span data-stu-id="3c13e-346">Pattern</span></span>|<span data-ttu-id="3c13e-347">说明</span><span class="sxs-lookup"><span data-stu-id="3c13e-347">Description</span></span>|
  |-------------|-----------------|
  |<span data-ttu-id="3c13e-348">(a+)</span><span class="sxs-lookup"><span data-stu-id="3c13e-348">(a+)</span></span>|<span data-ttu-id="3c13e-349">与字母“a”匹配一次或多次。</span><span class="sxs-lookup"><span data-stu-id="3c13e-349">Match the letter "a" one or more times.</span></span> <span data-ttu-id="3c13e-350">这是第二个捕获组。</span><span class="sxs-lookup"><span data-stu-id="3c13e-350">This is the second capturing group.</span></span>|
  |<span data-ttu-id="3c13e-351">(\1)</span><span class="sxs-lookup"><span data-stu-id="3c13e-351">(\1)</span></span>|<span data-ttu-id="3c13e-352">与第一个捕获组捕获的子字符串匹配。</span><span class="sxs-lookup"><span data-stu-id="3c13e-352">Match the substring captured by the first capturing group.</span></span> <span data-ttu-id="3c13e-353">这是第三个捕获组。</span><span class="sxs-lookup"><span data-stu-id="3c13e-353">This is the third capturing group.</span></span>|
  |<span data-ttu-id="3c13e-354">?</span><span class="sxs-lookup"><span data-stu-id="3c13e-354">?</span></span>|<span data-ttu-id="3c13e-355">匹配零个或一个空白字符。</span><span class="sxs-lookup"><span data-stu-id="3c13e-355">Match zero or one space characters.</span></span>|
  |<span data-ttu-id="3c13e-356">((a+)(\1) ?)+</span><span class="sxs-lookup"><span data-stu-id="3c13e-356">((a+)(\1) ?)+</span></span>|<span data-ttu-id="3c13e-357">与某个模式匹配一次或多次，该模式有一个或多个“a”字符，后跟与第一个捕获组（后无空白字符或后跟一个空白字符）匹配的字符串。</span><span class="sxs-lookup"><span data-stu-id="3c13e-357">Match the pattern of one or more "a" characters followed by a string that matches the first capturing group followed by zero or one space characters one or more times.</span></span> <span data-ttu-id="3c13e-358">这是第一个捕获组。</span><span class="sxs-lookup"><span data-stu-id="3c13e-358">This is the first capturing group.</span></span>|

- <span data-ttu-id="3c13e-359">八进制转义和反向引用间的多义性的解析。</span><span class="sxs-lookup"><span data-stu-id="3c13e-359">Resolution of ambiguities between octal escapes and backreferences.</span></span> <span data-ttu-id="3c13e-360">下表总结了规范化和 ECMAScript 正则表达式在八进制与后向引用解释中的区别。</span><span class="sxs-lookup"><span data-stu-id="3c13e-360">The following table summarizes the differences in octal versus backreference interpretation by canonical and ECMAScript regular expressions.</span></span>

  |<span data-ttu-id="3c13e-361">正则表达式</span><span class="sxs-lookup"><span data-stu-id="3c13e-361">Regular expression</span></span>|<span data-ttu-id="3c13e-362">规范行为</span><span class="sxs-lookup"><span data-stu-id="3c13e-362">Canonical behavior</span></span>|<span data-ttu-id="3c13e-363">ECMAScript 行为</span><span class="sxs-lookup"><span data-stu-id="3c13e-363">ECMAScript behavior</span></span>|
  |------------------------|------------------------|-------------------------|
  |<span data-ttu-id="3c13e-364">`\0` 后跟 0 到 2 个八进制数字</span><span class="sxs-lookup"><span data-stu-id="3c13e-364">`\0` followed by 0 to 2 octal digits</span></span>|<span data-ttu-id="3c13e-365">解释为八进制。</span><span class="sxs-lookup"><span data-stu-id="3c13e-365">Interpret as an octal.</span></span> <span data-ttu-id="3c13e-366">例如，`\044` 总是解释为八进制值并表示“$”。</span><span class="sxs-lookup"><span data-stu-id="3c13e-366">For example, `\044` is always interpreted as an octal value and means "$".</span></span>|<span data-ttu-id="3c13e-367">行为相同。</span><span class="sxs-lookup"><span data-stu-id="3c13e-367">Same behavior.</span></span>|
  |<span data-ttu-id="3c13e-368">`\` 后跟一个从 1 到 9 的数字，后面再没有任何其他十进制数字，</span><span class="sxs-lookup"><span data-stu-id="3c13e-368">`\` followed by a digit from 1 to 9, followed by no additional decimal digits,</span></span>|<span data-ttu-id="3c13e-369">解释为反向引用。</span><span class="sxs-lookup"><span data-stu-id="3c13e-369">Interpret as a backreference.</span></span> <span data-ttu-id="3c13e-370">例如，`\9` 始终表示后向引用 9，即使第九捕获组不存在。</span><span class="sxs-lookup"><span data-stu-id="3c13e-370">For example, `\9` always means backreference 9, even if a ninth capturing group does not exist.</span></span> <span data-ttu-id="3c13e-371">如果捕获组不存在，则正则表达式分析器将引发 <xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="3c13e-371">If the capturing group does not exist, the regular expression parser throws an <xref:System.ArgumentException>.</span></span>|<span data-ttu-id="3c13e-372">如果存在单个十进制数字捕获组，则后向引用该数字。</span><span class="sxs-lookup"><span data-stu-id="3c13e-372">If a single decimal digit capturing group exists, backreference to that digit.</span></span> <span data-ttu-id="3c13e-373">否则将该值解释为文本。</span><span class="sxs-lookup"><span data-stu-id="3c13e-373">Otherwise, interpret the value as a literal.</span></span>|
  |<span data-ttu-id="3c13e-374">`\` 后跟一个从 1 到 9 的数字，后跟其他十进制数字</span><span class="sxs-lookup"><span data-stu-id="3c13e-374">`\` followed by a digit from 1 to 9, followed by additional decimal digits</span></span>|<span data-ttu-id="3c13e-375">将数字解释为十进制值。</span><span class="sxs-lookup"><span data-stu-id="3c13e-375">Interpret the digits as a decimal value.</span></span> <span data-ttu-id="3c13e-376">如果存在该捕获组，则将该表达式解释为后向引用。</span><span class="sxs-lookup"><span data-stu-id="3c13e-376">If that capturing group exists, interpret the expression as a backreference.</span></span><br /><br /> <span data-ttu-id="3c13e-377">否则，将前导的八进制数字解释为不超过八进制值 377 的八进制数字；也就是说，仅考虑该值的后八位。</span><span class="sxs-lookup"><span data-stu-id="3c13e-377">Otherwise, interpret the leading octal digits up to octal 377; that is, consider only the low 8 bits of the value.</span></span> <span data-ttu-id="3c13e-378">将其余数字解释为文本。</span><span class="sxs-lookup"><span data-stu-id="3c13e-378">Interpret the remaining digits as literals.</span></span> <span data-ttu-id="3c13e-379">例如，如果表达式 `\3000` 中存在捕获组 300，则解释为后向引用 300；如果捕获组 300 不存在，则解释为后跟 0 的八进制数字 300。</span><span class="sxs-lookup"><span data-stu-id="3c13e-379">For example, in the expression `\3000`, if capturing group 300 exists, interpret as backreference 300; if capturing group 300 does not exist, interpret as octal 300 followed by 0.</span></span>|<span data-ttu-id="3c13e-380">通过将尽可能多的数字转换为可引用捕获的十进制值解释为反向引用。</span><span class="sxs-lookup"><span data-stu-id="3c13e-380">Interpret as a backreference by converting as many digits as possible to a decimal value that can refer to a capture.</span></span> <span data-ttu-id="3c13e-381">如果任何数字都不能转换，则解释为使用其值不超过八进制值 377 的前导八进制数字的八进制数字；将其余数字解释为文本。</span><span class="sxs-lookup"><span data-stu-id="3c13e-381">If no digits can be converted, interpret as an octal by using the leading octal digits up to octal 377; interpret the remaining digits as literals.</span></span>|

## <a name="comparison-using-the-invariant-culture"></a><span data-ttu-id="3c13e-382">使用固定区域性的比较</span><span class="sxs-lookup"><span data-stu-id="3c13e-382">Comparison Using the Invariant Culture</span></span>

<span data-ttu-id="3c13e-383">默认情况下，当正则表达式引擎执行不区分大小写的比较时，它使用当前区域性的大小写约定来确定等效的大写和小写字符。</span><span class="sxs-lookup"><span data-stu-id="3c13e-383">By default, when the regular expression engine performs case-insensitive comparisons, it uses the casing conventions of the current culture to determine equivalent uppercase and lowercase characters.</span></span>

<span data-ttu-id="3c13e-384">但是，此行为不需要某些类型的比较，尤其是在比较用户输入与系统资源名称时（如密码、文件或 URL）。</span><span class="sxs-lookup"><span data-stu-id="3c13e-384">However, this behavior is undesirable for some types of comparisons, particularly when comparing user input to the names of system resources, such as passwords, files, or URLs.</span></span> <span data-ttu-id="3c13e-385">下面的示例阐释此类方案。</span><span class="sxs-lookup"><span data-stu-id="3c13e-385">The following example illustrates such as scenario.</span></span> <span data-ttu-id="3c13e-386">该代码旨在阻止对 URL 开头为 **FILE://** 的所有资源的访问。</span><span class="sxs-lookup"><span data-stu-id="3c13e-386">The code is intended to block access to any resource whose URL is prefaced with **FILE://**.</span></span> <span data-ttu-id="3c13e-387">正则表达式通过使用正则表达式 `$FILE://` 尝试与字符串的不区分大小写的匹配。</span><span class="sxs-lookup"><span data-stu-id="3c13e-387">The regular expression attempts a case-insensitive match with the string by using the regular expression `$FILE://`.</span></span> <span data-ttu-id="3c13e-388">但是，在当前系统区域性为 tr-TR（土耳其语-土耳其）时，“I”不是“i”的大写等效项。</span><span class="sxs-lookup"><span data-stu-id="3c13e-388">However, when the current system culture is tr-TR (Turkish-Turkey), "I" is not the uppercase equivalent of "i".</span></span> <span data-ttu-id="3c13e-389">因此，对 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> 方法的调用返回 `false`，并允许访问该文件。</span><span class="sxs-lookup"><span data-stu-id="3c13e-389">As a result, the call to the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method returns `false`, and access to the file is allowed.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#14](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/culture1.cs#14)]
[!code-vb[Conceptual.Regex.Language.Options#14](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/culture1.vb#14)]

> [!NOTE]
> <span data-ttu-id="3c13e-390">有关区分大小写和使用固定区域性的字符串比较的更多信息，请参见[针对使用字符串的最佳做法](../../../docs/standard/base-types/best-practices-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="3c13e-390">For more information about string comparisons that are case-sensitive and that use the invariant culture, see [Best Practices for Using Strings](../../../docs/standard/base-types/best-practices-strings.md).</span></span>

<span data-ttu-id="3c13e-391">不使用当前区域性的不区分大小写比较，可以指定 <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType> 选项忽略语言的区域性差异，并使用固定区域性的约定。</span><span class="sxs-lookup"><span data-stu-id="3c13e-391">Instead of using the case-insensitive comparisons of the current culture, you can specify the <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType> option to ignore cultural differences in language and to use the conventions of the invariant culture.</span></span>

> [!NOTE]
> <span data-ttu-id="3c13e-392">仅能通过将 <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType> 值提供给 `options` 类构造函数或静态模式匹配方法的 <xref:System.Text.RegularExpressions.Regex> 参数来提供使用固定区域性的比较。</span><span class="sxs-lookup"><span data-stu-id="3c13e-392">Comparison using the invariant culture is available only by supplying the <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType> value to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or static pattern-matching method.</span></span> <span data-ttu-id="3c13e-393">它不可作为内联选项使用。</span><span class="sxs-lookup"><span data-stu-id="3c13e-393">It is not available as an inline option.</span></span>

<span data-ttu-id="3c13e-394">下面的示例与上一示例相等，不同之处是下面的示例使用包含 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> 的选项调用静态 <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="3c13e-394">The following example is identical to the previous example, except that the static <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method is called with options that include <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3c13e-395">即使设置当前区域性到土耳其语（土耳其），正则表达式引擎仍能够成功匹配“FILE”和“file”并能阻止对文件资源的访问。</span><span class="sxs-lookup"><span data-stu-id="3c13e-395">Even when the current culture is set to Turkish (Turkey), the regular expression engine is able to successfully match "FILE" and "file" and block access to the file resource.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#15](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/culture1.cs#15)]
[!code-vb[Conceptual.Regex.Language.Options#15](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/culture1.vb#15)]

## <a name="see-also"></a><span data-ttu-id="3c13e-396">请参阅</span><span class="sxs-lookup"><span data-stu-id="3c13e-396">See also</span></span>

- [<span data-ttu-id="3c13e-397">正则表达式语言 - 快速参考</span><span class="sxs-lookup"><span data-stu-id="3c13e-397">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)
