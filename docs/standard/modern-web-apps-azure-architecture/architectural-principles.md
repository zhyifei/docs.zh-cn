---
title: "体系结构原则"
description: "设计使用 ASP.NET Core 和 Azure 的现代 Web 应用程序 |体系结构原则"
author: ardalis
ms.author: wiwagn
ms.date: 10/06/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.openlocfilehash: 20524c8aa0e64fd40a1a4a6811063557f74074d2
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/21/2017
---
#<a name="architectural-principles"></a>体系结构原则

> "如果生成器生成建筑物方式程序员编写程序，然后应运而生第一个 woodpecker 将销毁文明。"  
> _\-Gerald Weinberg_

## <a name="summary"></a>摘要

应设计并设计软件解决方案通过记住可维护性。 本部分中概述的原则可帮助指导您向将导致干净、 可维护性应用程序的体系结构决策。 通常情况下，这些原则将指导你向生成传出离散组件到应用程序的其他部分不紧密耦合但而是通过显式接口通信的应用程序或消息传送系统。

## <a name="common-design-principles"></a>常见的设计原则

### <a name="separation-of-concerns"></a>分离问题

在开发时的指导原则是**问题分离**。 这一原则断言应该分隔软件基于它所执行的工作的类型。 例如，假设一个应用程序，包括用于标识要显示给用户，值得注意项的逻辑和该格式以特定的方式，以使它们更明显的此类项。 负责选择要设置格式的项的行为应保持独立于负责项，因为这些是仅而巧合的是与另一个相关的任务分离进行格式设置的行为。

体系结构上，可以以逻辑方式构建应用程序通过将从基础结构和用户界面逻辑中分离核心业务行为遵循这一原则。 理想情况下，业务规则和逻辑应驻留在一个单独的项目，不应依赖于应用程序中其他项目。 这有助于确保业务模型易于测试和可以演化而不进行紧密耦合到低级别的实现详细信息。 分离问题是应用程序体系结构中的层后面使用一个关键考虑事项。

### <a name="encapsulation"></a>封装

应使用的应用程序的不同部分**封装**要使其从应用程序的其他部分。 应用程序组件和层应能够调整其内部实现，而不会破坏其协作者，只要不违反外部的协定。 封装的正确使用有助于实现松散耦合和在应用程序设计中，模块性，因为处理程序，但前提是保留相同的接口可以使用备用实现替换对象和包。

在类中，封装被通过外部对类的内部状态的访问限制。 如果外部参与者想要操作的对象的状态，它应这样做通过明确定义的函数 （或属性 setter），而不是使直接访问的对象的私有状态。 同样，应用程序组件和应用程序本身应公开对其使用，而非是允许直接修改其状态的协作者定义完善的接口。 这会释放应用程序的内部设计的发展方式，随着时间的推移而不必担心，这样做因此将中断协作者，处理程序，但前提保留的公共协定。

### <a name="dependency-inversion"></a>依赖项反转

应用程序中的依赖项的方向应为抽象，不实现详细信息的方向。 大多数应用程序的编写以便编译时依赖项的运行时执行方向流动。 这将产生直接的依赖项关系图。 也就是说，如果模块 A 调用 B，模块中的函数调用的函数在模块 C，然后在编译时间 A 将取决于 B 将依赖于 C，在图 4-1 中所示。

![](./media/image4-1.png)

**图 4-1。** 直接的依赖项关系图。

应用的依赖项反向原则允许 A 调用 B 实现时，调用 B，在运行时，使它可以 a 的抽象方法，但的 B 依赖于接口控制由 A 在编译时 (因此，*反转*典型编译时依赖项）。 在运行时，控制程序执行流程保持不变，但接口简介意味着可以轻松插入这些接口的不同实施。

![](./media/image4-2.png)

**图 4-2。** 倒依赖项关系图。

**依赖项反向**是生成松散耦合的应用程序，因为可以编写实现详细信息为依赖于并实现更高级别的抽象，而不是另一种方法解决的关键部分。 生成的应用程序作为结果是更可测试、 模块化和可维护性。 这一做法*依赖关系注入*可按照依赖反向原则。

### <a name="explicit-dependencies"></a>显式依赖关系

**方法和类应显式要求才能正常工作所需的任何协作对象。** 类构造函数提供类以确定为了处于有效状态，然后才能正常工作所需的内容有机会。 如果你定义的类，可以构造和调用，但这将仅正常工作如果某些全局或基础结构组件均已到位，这些类正在*恶意*与其客户端。 构造函数协定将告诉客户端，但然后在它变为出对象的运行时指定的内容 (可能为 nothing 如果类仅使用默认构造函数)，只需要真正未需要其他内容。

按照显式依赖关系原则，正在诚实有关它们才能正常需要与其客户端类和方法。 这使得自行详细记录你的代码和代码协定更加友好的用户，因为用户将逐渐信任，只要它们提供哪些必需的形式的方法或构造函数参数，它们正在使用的对象的行为正确在运行时。

### <a name="single-responsibility"></a>单独责任

单独责任原则适用于面向对象的设计，但也可以将其视为类似于关注点分离一个体系结构原则。 它指出对象应具有只有一个责任并且也应只有一个确实需要更改。 具体而言，应在其中更改对象的唯一情况是如果必须更新中将执行一个责任的方式。 按照这一原则松散耦合的有助于生成更和模块化系统，因为许多类型的新行为可以实现新类，而不是通过将添加到现有类的其他责任。 添加新类始终是比因为任何代码更改现有类，更安全，但取决于新的类。

在整体应用程序中，我们可以将单独责任原则在高级别应用于应用程序中的层。 演示文稿责任应保留在 UI 项目，而数据访问责任应保留在基础结构项目内。 业务逻辑应保持在应用程序核心项目中，它可以轻松地测试并可以从其他职责独立地变化。

当这一原则应用于应用程序体系结构，并转到其逻辑的终结点时，可以微服务。 给定的微服务应具有单独的责任。 如果你需要扩展系统的行为，则通常最好执行此操作通过添加其他微服务，而不是添加到现有的责任。

[了解有关微服务体系结构的详细信息](http://aka.ms/MicroservicesEbook)

### <a name="dont-repeat-yourself-dry"></a>切勿重复 （干）

应用程序应避免指定与多个位置中的特定概念相关，因为这是错误的根源，频繁的行为。 在某些时候中要求, 的更改将需要更改此行为和可能性行为该至少一个实例将无法更新将导致不一致的行为的系统。

而不会复制逻辑，请将它封装编程构造中。 使此构建单个颁发机构对此行为，并将任何其他部分的应用程序需要此现象，请使用新的构造。

> [!NOTE]
> 避免将绑定在一起才而巧合的是重复的行为。 例如，只是因为两个不同的常数这两个具有相同的值，，并不意味着应将只有一个量，如果从概念上讲指不同的情况。

### <a name="persistence-ignorance"></a>持久性无感知

**持久性无感知**(PI) 是指的类型需要保持不变，但其代码不受持久性技术的选择。 .NET 中的此类类型是有时称为普通旧 CLR 对象 (POCOs)，因为它们不需要从特定的基类继承或实现特定接口。 持久性无感知很有用，因为它允许相同的业务模型，采用多种方式，提供更多灵活性，应用程序保留。 持久性选项可能会更改段时间后，从到另一个数据库技术或其他形式的持久性可能需要除了应用程序与启动的任何内容 (例如，使用 Redis 缓存或 Azure DocumentDb 除了关系数据库）。

这一原则冲突的一些示例包括：

-   所需的基类

-   所需的接口实现

-   类负责保存本身 （例如活动的记录模式中）

-   所需的默认构造函数

-   要求 virtual 关键字的属性

-   特定于持久性的必需的特性

类具有上述功能或行为的任何要求将添加要保留的类型和所选的持久性技术，使它更难以进行将来采用新的数据访问策略之间的耦合。

### <a name="bounded-contexts"></a>绑定的上下文

**绑定上下文**是 Domain-Driven 设计中的中央模式。 它们通过将其分成单独概念模块提供了一种在大型应用程序或组织中的应对复杂性。 每个概念模块则表示分开其他上下文的上下文 （因此，划分边界），并可以独立地变化。 每个界限的上下文理想情况下应随意自己为选择的名称，其中的概念，并应具有其自己的永久性存储到的独占访问权限。

至少，单独的 web 应用程序应尽量可与自身的业务模式，而不与其他应用程序共享一个数据库自己持久性存储区他们自己界限的上下文。 通过编程接口，而不是允许的业务逻辑的共享数据库，则会发生界限上下文之间的通信和事件才能置于响应发生的更改。 限定上下文映射限定密切微服务，它还理想情况下其自己单独的绑定上下文作为实现。

> ### <a name="references--modern-web-applications"></a>引用 – 现代 Web 应用程序
> - **分离问题**  
> <http://deviq.com/separation-of-concerns/>
> - **封装** <http://deviq.com/encapsulation/>
> - **依赖项反向原则**  
> <http://deviq.com/dependency-inversion-principle/>
> - **显式依赖关系原则**  
> <http://deviq.com/explicit-dependencies-principle/>
> - **切勿重复**  
> <http://deviq.com/don-t-repeat-yourself/>
> - **持久性无感知**  
> <http://deviq.com/persistence-ignorance/>
> - **界限的上下文**  
> <https://martinfowler.com/bliki/BoundedContext.html>

> [!div class="step-by-step"]
[以前](choose-between-traditional-web-and-single-page-apps.md) [下一步] (常见-web 的应用程序-architectures.md)
