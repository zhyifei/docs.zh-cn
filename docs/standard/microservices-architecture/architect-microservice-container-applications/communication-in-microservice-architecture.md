---
title: 微服务体系结构中的通信
description: 探索微服务之间的不同通信方式，了解同步和异步方法的含义。
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 09/20/2018
ms.openlocfilehash: 4b57607897e42ff68ff7566120bc3c932040a2a6
ms.sourcegitcommit: 7156c0b9e4ce4ce5ecf48ce3d925403b638b680c
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/26/2019
ms.locfileid: "58466187"
---
# <a name="communication-in-a-microservice-architecture"></a><span data-ttu-id="46805-103">微服务体系结构中的通信</span><span class="sxs-lookup"><span data-stu-id="46805-103">Communication in a microservice architecture</span></span>

<span data-ttu-id="46805-104">在单个进程上运行的整体式应用程序中，组件使用语言级别方法或函数调用进行相互调用。</span><span class="sxs-lookup"><span data-stu-id="46805-104">In a monolithic application running on a single process, components invoke one another using language-level method or function calls.</span></span> <span data-ttu-id="46805-105">如果使用代码创建对象（例如 `new ClassName()`），则可以紧密耦合，或者如果正在通过引用抽象而不是具体对象实例来使用依赖项，则可以在耦合方法中调用。</span><span class="sxs-lookup"><span data-stu-id="46805-105">These can be strongly coupled if you're creating objects with code (for example, `new ClassName()`), or can be invoked in a decoupled way if you're using Dependency Injection by referencing abstractions rather than concrete object instances.</span></span> <span data-ttu-id="46805-106">两种方式中的对象都在同一进程中运行。</span><span class="sxs-lookup"><span data-stu-id="46805-106">Either way, the objects are running within the same process.</span></span> <span data-ttu-id="46805-107">从整体式应用程序更改为基于微服务的应用程序时，最大的挑战在于改变通信机制。</span><span class="sxs-lookup"><span data-stu-id="46805-107">The biggest challenge when changing from a monolithic application to a microservices-based application lies in changing the communication mechanism.</span></span> <span data-ttu-id="46805-108">将进程内的方法调用直接转换为对服务的 RPC 调用将在分布式环境中导致效果不佳且效率低下的通信。</span><span class="sxs-lookup"><span data-stu-id="46805-108">A direct conversion from in-process method calls into RPC calls to services will cause a chatty and not efficient communication that won't perform well in distributed environments.</span></span> <span data-ttu-id="46805-109">正确设计分布式系统的挑战已众所周知，甚至有一个被称为[分布式计算的谬论](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing)的标准，其中列出了开发者在从整体式设计转向分布式设计时经常会做出的假设。</span><span class="sxs-lookup"><span data-stu-id="46805-109">The challenges of designing distributed system properly are well enough known that there's even a canon known as the [Fallacies of distributed computing](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) that lists assumptions that developers often make when moving from monolithic to distributed designs.</span></span>

<span data-ttu-id="46805-110">解决方案不止一种，而是多种。</span><span class="sxs-lookup"><span data-stu-id="46805-110">There isn't one solution, but several.</span></span> <span data-ttu-id="46805-111">一个解决方案包括尽可能多地隔离业务微服务。</span><span class="sxs-lookup"><span data-stu-id="46805-111">One solution involves isolating the business microservices as much as possible.</span></span> <span data-ttu-id="46805-112">然后，使用内部微服务之间的异步通信，并用对象间的进程内通信中典型的细粒度通信代替粗粒度通信。</span><span class="sxs-lookup"><span data-stu-id="46805-112">You then use asynchronous communication between the internal microservices and replace fine-grained communication that's typical in intra-process communication between objects with coarser-grained communication.</span></span> <span data-ttu-id="46805-113">执行此操作的方法有分组调用、将聚合多个内部调用结果的数据返回到客户端。</span><span class="sxs-lookup"><span data-stu-id="46805-113">You can do this by grouping calls, and by returning data that aggregates the results of multiple internal calls, to the client.</span></span>

<span data-ttu-id="46805-114">基于微服务的应用程序是在多个进程或服务上运行的分布式系统，通常甚至跨多个服务器或主机。</span><span class="sxs-lookup"><span data-stu-id="46805-114">A microservices-based application is a distributed system running on multiple processes or services, usually even across multiple servers or hosts.</span></span> <span data-ttu-id="46805-115">每个服务实例通常是一个进程。</span><span class="sxs-lookup"><span data-stu-id="46805-115">Each service instance is typically a process.</span></span> <span data-ttu-id="46805-116">因此，服务必须使用进程内通信协议（如 HTTP、AMQP）或二进制协议（如 TCP）进行交互，具体取决于每个服务的性质。</span><span class="sxs-lookup"><span data-stu-id="46805-116">Therefore, services must interact using an inter-process communication protocol such as HTTP, AMQP, or a binary protocol like TCP, depending on the nature of each service.</span></span>

<span data-ttu-id="46805-117">微服务社区倡导“[智能终结点和哑管道](https://simplicable.com/new/smart-endpoints-and-dumb-pipes)”的理念。这个标语鼓励设计在微服务之间尽可能分离，在单个微服务内尽可能聚合。</span><span class="sxs-lookup"><span data-stu-id="46805-117">The microservice community promotes the philosophy of "[smart endpoints and dumb pipes](https://simplicable.com/new/smart-endpoints-and-dumb-pipes)" This slogan encourages a design that's as decoupled as possible between microservices, and as cohesive as possible within a single microservice.</span></span> <span data-ttu-id="46805-118">如前所述，每个微服务拥有自己的数据和域逻辑。</span><span class="sxs-lookup"><span data-stu-id="46805-118">As explained earlier, each microservice owns its own data and its own domain logic.</span></span> <span data-ttu-id="46805-119">但构成端到端应用程序的微服务通常通过使用 REST 通信而不是复杂协议（如 WS-\*）以及灵活的事件驱动通信而不是集中式业务流程协调程序来简化编排。</span><span class="sxs-lookup"><span data-stu-id="46805-119">But the microservices composing an end-to-end application are usually simply choreographed by using REST communications rather than complex protocols such as WS-\* and flexible event-driven communications instead of centralized business-process-orchestrators.</span></span>

<span data-ttu-id="46805-120">两个常用的协议是具有资源 API 的 HTTP 请求/响应（查询大部分时）和轻量级异步消息传送（跨多个微服务更新通信时）。</span><span class="sxs-lookup"><span data-stu-id="46805-120">The two commonly used protocols are HTTP request/response with resource APIs (when querying most of all), and lightweight asynchronous messaging when communicating updates across multiple microservices.</span></span> <span data-ttu-id="46805-121">以下各节将对此进行更详细地描述。</span><span class="sxs-lookup"><span data-stu-id="46805-121">These are explained in more detail in the following sections.</span></span>

## <a name="communication-types"></a><span data-ttu-id="46805-122">通信类型</span><span class="sxs-lookup"><span data-stu-id="46805-122">Communication types</span></span>

<span data-ttu-id="46805-123">客户端和服务可以通过许多不同类型的通信进行通信，每个通信面向不同的方案和目标。</span><span class="sxs-lookup"><span data-stu-id="46805-123">Client and services can communicate through many different types of communication, each one targeting a different scenario and goals.</span></span> <span data-ttu-id="46805-124">最初，这些类型的通信可以分为两个轴。</span><span class="sxs-lookup"><span data-stu-id="46805-124">Initially, those types of communications can be classified in two axes.</span></span>

<span data-ttu-id="46805-125">第一个轴定义协议是同步还是异步：</span><span class="sxs-lookup"><span data-stu-id="46805-125">The first axis defines if the protocol is synchronous or asynchronous:</span></span>

- <span data-ttu-id="46805-126">同步协议。</span><span class="sxs-lookup"><span data-stu-id="46805-126">Synchronous protocol.</span></span> <span data-ttu-id="46805-127">HTTP 是同步协议。</span><span class="sxs-lookup"><span data-stu-id="46805-127">HTTP is a synchronous protocol.</span></span> <span data-ttu-id="46805-128">客户端发送请求并等待服务响应。</span><span class="sxs-lookup"><span data-stu-id="46805-128">The client sends a request and waits for a response from the service.</span></span> <span data-ttu-id="46805-129">这与客户端代码执行无关，可能是同步的（线程被阻止）或异步的（线程没有被阻止，并且响应最终会到达回调）。</span><span class="sxs-lookup"><span data-stu-id="46805-129">That's independent of the client code execution that could be synchronous (thread is blocked) or asynchronous (thread isn't blocked, and the response will reach a callback eventually).</span></span> <span data-ttu-id="46805-130">重要的一点是，协议 (HTTP/HTTPS) 是同步的，仅当客户端代码接收到 HTTP 服务器响应时，才可以继续其任务。</span><span class="sxs-lookup"><span data-stu-id="46805-130">The important point here is that the protocol (HTTP/HTTPS) is synchronous and the client code can only continue its task when it receives the HTTP server response.</span></span>

- <span data-ttu-id="46805-131">异步协议。</span><span class="sxs-lookup"><span data-stu-id="46805-131">Asynchronous protocol.</span></span> <span data-ttu-id="46805-132">AMQP 之类的其他协议（许多操作系统和云环境支持的协议）使用异步消息。</span><span class="sxs-lookup"><span data-stu-id="46805-132">Other protocols like AMQP (a protocol supported by many operating systems and cloud environments) use asynchronous messages.</span></span> <span data-ttu-id="46805-133">客户端代码或消息发件人通常不会等待响应。</span><span class="sxs-lookup"><span data-stu-id="46805-133">The client code or message sender usually doesn't wait for a response.</span></span> <span data-ttu-id="46805-134">它只是在发送消息到 RabbitMQ 队列或任何其他消息代理时才发送消息。</span><span class="sxs-lookup"><span data-stu-id="46805-134">It just sends the message as when sending a message to a RabbitMQ queue or any other message broker.</span></span>

<span data-ttu-id="46805-135">第二个轴定义通信具有单个还是多个接收方：</span><span class="sxs-lookup"><span data-stu-id="46805-135">The second axis defines if the communication has a single receiver or multiple receivers:</span></span>

- <span data-ttu-id="46805-136">单个接收方。</span><span class="sxs-lookup"><span data-stu-id="46805-136">Single receiver.</span></span> <span data-ttu-id="46805-137">每个请求必须只能由一个接收方或服务来处理。</span><span class="sxs-lookup"><span data-stu-id="46805-137">Each request must be processed by exactly one receiver or service.</span></span> <span data-ttu-id="46805-138">此通信的示例是[命令模式](https://en.wikipedia.org/wiki/Command_pattern)。</span><span class="sxs-lookup"><span data-stu-id="46805-138">An example of this communication is the [Command pattern](https://en.wikipedia.org/wiki/Command_pattern).</span></span>

- <span data-ttu-id="46805-139">多个接收方。</span><span class="sxs-lookup"><span data-stu-id="46805-139">Multiple receivers.</span></span> <span data-ttu-id="46805-140">每个请求可以由零到多个接收方处理。</span><span class="sxs-lookup"><span data-stu-id="46805-140">Each request can be processed by zero to multiple receivers.</span></span> <span data-ttu-id="46805-141">这种类型的通信必须是异步的。</span><span class="sxs-lookup"><span data-stu-id="46805-141">This type of communication must be asynchronous.</span></span> <span data-ttu-id="46805-142">例如[事件驱动体系结构](https://microservices.io/patterns/data/event-driven-architecture.html)等模式中使用的[发布/订阅](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern)机制。</span><span class="sxs-lookup"><span data-stu-id="46805-142">An example is the [publish/subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) mechanism used in patterns like [Event-driven architecture](https://microservices.io/patterns/data/event-driven-architecture.html).</span></span> <span data-ttu-id="46805-143">当通过事件在多个微服务之间传播数据更新时，这基于事件总线接口或消息代理；它通常通过服务总线或类似 [Azure 服务总线](https://azure.microsoft.com/services/service-bus/)的项目使用[主题和订阅](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)并来实现。</span><span class="sxs-lookup"><span data-stu-id="46805-143">This is based on an event-bus interface or message broker when propagating data updates between multiple microservices through events; it's usually implemented through a service bus or similar artifact like [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) by using [topics and subscriptions](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span>

<span data-ttu-id="46805-144">基于微服务的应用程序通常将使用这些通信样式的组合。</span><span class="sxs-lookup"><span data-stu-id="46805-144">A microservice-based application will often use a combination of these communication styles.</span></span> <span data-ttu-id="46805-145">最常见的类型是在调用常规 Web API HTTP 服务时使用 HTTP/HTTPS 等同步协议进行单个接收方通信。</span><span class="sxs-lookup"><span data-stu-id="46805-145">The most common type is single-receiver communication with a synchronous protocol like HTTP/HTTPS when invoking a regular Web API HTTP service.</span></span> <span data-ttu-id="46805-146">微服务通常也使用消息传送协议在微服务之间进行异步通信。</span><span class="sxs-lookup"><span data-stu-id="46805-146">Microservices also typically use messaging protocols for asynchronous communication between microservices.</span></span>

<span data-ttu-id="46805-147">必须知道这些轴以便清楚了解可能的通信机制，但在构建微服务时，它们就不是那么重要了。</span><span class="sxs-lookup"><span data-stu-id="46805-147">These axes are good to know so you have clarity on the possible communication mechanisms, but they're not the important concerns when building microservices.</span></span> <span data-ttu-id="46805-148">集成微服务时，客户端线程执行的异步特性和所选协议的异步特性都不是重点。</span><span class="sxs-lookup"><span data-stu-id="46805-148">Neither the asynchronous nature of client thread execution nor the asynchronous nature of the selected protocol are the important points when integrating microservices.</span></span> <span data-ttu-id="46805-149">重要的是能够异步集成微服务，同时保持微服务独立性，如下节所述。</span><span class="sxs-lookup"><span data-stu-id="46805-149">What *is* important is being able to integrate your microservices asynchronously while maintaining the independence of microservices, as explained in the following section.</span></span>

## <a name="asynchronous-microservice-integration-enforces-microservices-autonomy"></a><span data-ttu-id="46805-150">异步微服务集成强化了微服务的自治性</span><span class="sxs-lookup"><span data-stu-id="46805-150">Asynchronous microservice integration enforces microservice's autonomy</span></span>

<span data-ttu-id="46805-151">如前所述，生成基于微服务的应用程序时，重要的是集成微服务的方法。</span><span class="sxs-lookup"><span data-stu-id="46805-151">As mentioned, the important point when building a microservices-based application is the way you integrate your microservices.</span></span> <span data-ttu-id="46805-152">理想情况下，应尝试减少内部微服务之间的通信。</span><span class="sxs-lookup"><span data-stu-id="46805-152">Ideally, you should try to minimize the communication between the internal microservices.</span></span> <span data-ttu-id="46805-153">微服务间的通信越少越好。</span><span class="sxs-lookup"><span data-stu-id="46805-153">The fewer communications between microservices, the better.</span></span> <span data-ttu-id="46805-154">但在许多情况下，必须以某种方式集成微服务。</span><span class="sxs-lookup"><span data-stu-id="46805-154">But in many cases, you'll have to somehow integrate the microservices.</span></span> <span data-ttu-id="46805-155">当需要执行此操作时，关键的规则是微服务间的通信应为异步。</span><span class="sxs-lookup"><span data-stu-id="46805-155">When you need to do that, the critical rule here is that the communication between the microservices should be asynchronous.</span></span> <span data-ttu-id="46805-156">这并不代表必须使用特定协议（例如，异步消息传送与同步 HTTP）。</span><span class="sxs-lookup"><span data-stu-id="46805-156">That doesn't mean that you have to use a specific protocol (for example, asynchronous messaging versus synchronous HTTP).</span></span> <span data-ttu-id="46805-157">这仅代表微服务之间的通信应该只通过异步传播数据来完成，但不要依赖其他内部微服务作为初始服务的 HTTP 请求/响应操作的一部分。</span><span class="sxs-lookup"><span data-stu-id="46805-157">It just means that the communication between microservices should be done only by propagating data asynchronously, but try not to depend on other internal microservices as part of the initial service's HTTP request/response operation.</span></span>

<span data-ttu-id="46805-158">如果可能，永远不要依赖于多个微服务之间的同步通信（请求/响应），对于查询也是如此。</span><span class="sxs-lookup"><span data-stu-id="46805-158">If possible, never depend on synchronous communication (request/response) between multiple microservices, not even for queries.</span></span> <span data-ttu-id="46805-159">即使属于端到端应用程序的其他服务已关闭或不正常，每个微服务的目标也是自治，并且可供客户使用。</span><span class="sxs-lookup"><span data-stu-id="46805-159">The goal of each microservice is to be autonomous and available to the client consumer, even if the other services that are part of the end-to-end application are down or unhealthy.</span></span> <span data-ttu-id="46805-160">如果认为需要从一个微服务向其他微服务（如执行数据查询的 HTTP 请求）进行调用，以便能够向客户端应用程序提供响应，那么当某些微服务失败时体系结构不会迅速恢复。</span><span class="sxs-lookup"><span data-stu-id="46805-160">If you think you need to make a call from one microservice to other microservices (like performing an HTTP request for a data query) to be able to provide a response to a client application, you have an architecture that won't be resilient when some microservices fail.</span></span>

<span data-ttu-id="46805-161">此外，如图 4-15 的第一部分所示，微服务之间存在 HTTP 依赖项（如使用 HTTP 请求链创建长请求/响应周期时），不仅会使微服务不自治，而且只要该链中的其中一项服务表现不佳，性能就会受到影响。</span><span class="sxs-lookup"><span data-stu-id="46805-161">Moreover, having HTTP dependencies between microservices, like when creating long request/response cycles with HTTP request chains, as shown in the first part of the Figure 4-15, not only makes your microservices not autonomous but also their performance is impacted as soon as one of the services in that chain isn't performing well.</span></span>

<span data-ttu-id="46805-162">在微服务间添加的同步依赖项（如查询请求）越多，客户端应用的整体响应时间就越长。</span><span class="sxs-lookup"><span data-stu-id="46805-162">The more you add synchronous dependencies between microservices, such as query requests, the worse the overall response time gets for the client apps.</span></span>

![在同步通信中，在处理客户端请求的同时，在微服务之间创建请求“链”。](./media/image15.png)

<span data-ttu-id="46805-166">**图 4-15**。</span><span class="sxs-lookup"><span data-stu-id="46805-166">**Figure 4-15**.</span></span> <span data-ttu-id="46805-167">微服务间通信的反模式和模式</span><span class="sxs-lookup"><span data-stu-id="46805-167">Anti-patterns and patterns in communication between microservices</span></span>

<span data-ttu-id="46805-168">如果微服务需要在另一个微服务中引发其他操作，请尽可能不要在原始微服务请求和回复操作中同步执行该操作。</span><span class="sxs-lookup"><span data-stu-id="46805-168">If your microservice needs to raise an additional action in another microservice, if possible, do not perform that action synchronously and as part of the original microservice request and reply operation.</span></span> <span data-ttu-id="46805-169">而是以异步方式执行（使用异步消息传送或集成事件、队列等）。</span><span class="sxs-lookup"><span data-stu-id="46805-169">Instead, do it asynchronously (using asynchronous messaging or integration events, queues, etc.).</span></span> <span data-ttu-id="46805-170">但尽可能不要在原始同步请求和回复操作中同步调用操作。</span><span class="sxs-lookup"><span data-stu-id="46805-170">But, as much as possible, do not invoke the action synchronously as part of the original synchronous request and reply operation.</span></span>

<span data-ttu-id="46805-171">最后（构建微服务时大多数问题会在这里发生），如果初始微服务需要最初由其他微服务拥有的数据，则不要依赖于对该数据进行同步请求。</span><span class="sxs-lookup"><span data-stu-id="46805-171">And finally (and this is where most of the issues arise when building microservices), if your initial microservice needs data that's originally owned by other microservices, do not rely on making synchronous requests for that data.</span></span> <span data-ttu-id="46805-172">而是通过使用最终一致性（通常使用集成事件，如后面几节所述），将该数据（仅需要的属性）复制或传播到初始服务的数据库中。</span><span class="sxs-lookup"><span data-stu-id="46805-172">Instead, replicate or propagate that data (only the attributes you need) into the initial service's database by using eventual consistency (typically by using integration events, as explained in upcoming sections).</span></span>

<span data-ttu-id="46805-173">如前面的[标识每个微服务的域模型边界](identify-microservice-domain-model-boundaries.md)一节中所述，跨多个微服务复制某些数据不是设计错误 - 相反，此操作可以将数据翻译成该附加域或有边界的上下文的特定语言或术语。</span><span class="sxs-lookup"><span data-stu-id="46805-173">As noted earlier in the section [Identifying domain-model boundaries for each microservice](identify-microservice-domain-model-boundaries.md), duplicating some data across several microservices isn't an incorrect design—on the contrary, when doing that you can translate the data into the specific language or terms of that additional domain or Bounded Context.</span></span> <span data-ttu-id="46805-174">例如，在 [eShopOnContainers ](https://github.com/dotnet-architecture/eShopOnContainers) 应用程序中，有一个名为 identity.api 的微服务，它负责名为 User 的实体中的大部分用户数据。</span><span class="sxs-lookup"><span data-stu-id="46805-174">For instance, in the [eShopOnContainers application](https://github.com/dotnet-architecture/eShopOnContainers) you have a microservice named identity.api that's in charge of most of the user's data with an entity named User.</span></span> <span data-ttu-id="46805-175">但在需要存储有关订购微服务内的用户数据时，将其存储为名为 Buyer 的其他实体。</span><span class="sxs-lookup"><span data-stu-id="46805-175">However, when you need to store data about the user within the Ordering microservice, you store it as a different entity named Buyer.</span></span> <span data-ttu-id="46805-176">Buyer 实体与原始 User 实体共享相同的身份，但它可能只具有订购域所需的少量属性，而不是整个用户配置文件。</span><span class="sxs-lookup"><span data-stu-id="46805-176">The Buyer entity shares the same identity with the original User entity, but it might have only the few attributes needed by the Ordering domain, and not the whole user profile.</span></span>

<span data-ttu-id="46805-177">可以使用任何协议在微服务之间异步通信和传播数据，以实现最终的一致性。</span><span class="sxs-lookup"><span data-stu-id="46805-177">You might use any protocol to communicate and propagate data asynchronously across microservices in order to have eventual consistency.</span></span> <span data-ttu-id="46805-178">如前所述，可以通过事件总线或消息代理使用集成事件，或者甚至可以通过轮询其他服务使用 HTTP。</span><span class="sxs-lookup"><span data-stu-id="46805-178">As mentioned, you could use integration events using an event bus or message broker or you could even use HTTP by polling the other services instead.</span></span> <span data-ttu-id="46805-179">这并不重要。</span><span class="sxs-lookup"><span data-stu-id="46805-179">It doesn't matter.</span></span> <span data-ttu-id="46805-180">重要的规则是不在微服务之间创建同步依赖项。</span><span class="sxs-lookup"><span data-stu-id="46805-180">The important rule is to not create synchronous dependencies between your microservices.</span></span>

<span data-ttu-id="46805-181">以下各节介绍了可以考虑在基于微服务的应用程序中使用的多种通信样式。</span><span class="sxs-lookup"><span data-stu-id="46805-181">The following sections explain the multiple communication styles you can consider using in a microservice-based application.</span></span>

## <a name="communication-styles"></a><span data-ttu-id="46805-182">通信样式</span><span class="sxs-lookup"><span data-stu-id="46805-182">Communication styles</span></span>

<span data-ttu-id="46805-183">根据想要使用的通信类型，有许多可以用于通信的协议和选项。</span><span class="sxs-lookup"><span data-stu-id="46805-183">There are many protocols and choices you can use for communication, depending on the communication type you want to use.</span></span> <span data-ttu-id="46805-184">如果正在使用基于同步请求/响应的通信机制，则 HTTP 和 REST 等协议方法是最常见的，尤其是将服务发布到 Docker 主机或微服务集群之外的情况下。</span><span class="sxs-lookup"><span data-stu-id="46805-184">If you're using a synchronous request/response-based communication mechanism, protocols such as HTTP and REST approaches are the most common, especially if you're publishing your services outside the Docker host or microservice cluster.</span></span> <span data-ttu-id="46805-185">如果在内部进行服务间的通信（在 Docker 主机或微服务集群中），则还建议使用二进制格式通信机制（例如使用 TCP 和二进制格式的 Service Fabric 远程处理或 WCF）。</span><span class="sxs-lookup"><span data-stu-id="46805-185">If you're communicating between services internally (within your Docker host or microservices cluster), you might also want to use binary format communication mechanisms (like Service Fabric remoting or WCF using TCP and binary format).</span></span> <span data-ttu-id="46805-186">或者，可以使用基于消息的异步通信机制，如 AMQP。</span><span class="sxs-lookup"><span data-stu-id="46805-186">Alternatively, you can use asynchronous, message-based communication mechanisms such as AMQP.</span></span>

<span data-ttu-id="46805-187">还有 JSON 或 XML 等多种消息格式，或者还有更高效的二进制格式。</span><span class="sxs-lookup"><span data-stu-id="46805-187">There are also multiple message formats like JSON or XML, or even binary formats, which can be more efficient.</span></span> <span data-ttu-id="46805-188">如果选择的二进制格式不是标准格式，那么使用该格式公开发布服务可能并不适合。</span><span class="sxs-lookup"><span data-stu-id="46805-188">If your chosen binary format isn't a standard, it's probably not a good idea to publicly publish your services using that format.</span></span> <span data-ttu-id="46805-189">可以使用非标准格式在微服务之间进行内部通信。</span><span class="sxs-lookup"><span data-stu-id="46805-189">You could use a non-standard format for internal communication between your microservices.</span></span> <span data-ttu-id="46805-190">在 Docker 主机或微服务集群（Docker 业务流程协调程序或 Azure Service Fabric）中的微服务之间进行通信时，或与微服务通信的专用客户端应用程序进行通信时，可能需要执行此操作。</span><span class="sxs-lookup"><span data-stu-id="46805-190">You might do this when communicating between microservices within your Docker host or microservice cluster (Docker orchestrators or Azure Service Fabric), or for proprietary client applications that talk to the microservices.</span></span>

### <a name="requestresponse-communication-with-http-and-rest"></a><span data-ttu-id="46805-191">使用 HTTP 和 REST 进行请求/响应通信</span><span class="sxs-lookup"><span data-stu-id="46805-191">Request/response communication with HTTP and REST</span></span>

<span data-ttu-id="46805-192">当客户端使用请求/响应通信时，它将请求发送到服务，然后服务处理请求并返回响应。</span><span class="sxs-lookup"><span data-stu-id="46805-192">When a client uses request/response communication, it sends a request to a service, then the service processes the request and sends back a response.</span></span> <span data-ttu-id="46805-193">请求/响应通信特别适用于查询客户端应用的实时 UI（实时用户界面）数据。</span><span class="sxs-lookup"><span data-stu-id="46805-193">Request/response communication is especially well suited for querying data for a real-time UI (a live user interface) from client apps.</span></span> <span data-ttu-id="46805-194">因此，在微服务体系结构中，此通信机制可能会用于大多数查询，如图 4-16 所示。</span><span class="sxs-lookup"><span data-stu-id="46805-194">Therefore, in a microservice architecture you'll probably use this communication mechanism for most queries, as shown in Figure 4-16.</span></span>

![当客户端将请求发送到 API 网关时，可以将请求/响应通信用于实时查询（假设来自微服务的响应会在很短时间内到达）。](./media/image16.png)

<span data-ttu-id="46805-196">**图 4-16**。</span><span class="sxs-lookup"><span data-stu-id="46805-196">**Figure 4-16**.</span></span> <span data-ttu-id="46805-197">使用 HTTP 请求/响应通信（同步或异步）</span><span class="sxs-lookup"><span data-stu-id="46805-197">Using HTTP request/response communication (synchronous or asynchronous)</span></span>

<span data-ttu-id="46805-198">当客户端使用请求/响应通信时，假定响应将在短时间内（通常少于一秒或最多几秒）到达。</span><span class="sxs-lookup"><span data-stu-id="46805-198">When a client uses request/response communication, it assumes that the response will arrive in a short time, typically less than a second, or a few seconds at most.</span></span> <span data-ttu-id="46805-199">为了延迟响应，需要根据[消息传送模式](https://docs.microsoft.com/azure/architecture/patterns/category/messaging)和[消息技术](https://en.wikipedia.org/wiki/Message-oriented_middleware)实现异步通信，这是我们在下一节中介绍的另一种方法。</span><span class="sxs-lookup"><span data-stu-id="46805-199">For delayed responses, you need to implement asynchronous communication based on [messaging patterns](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) and [messaging technologies](https://en.wikipedia.org/wiki/Message-oriented_middleware), which is a different approach that we explain in the next section.</span></span>

<span data-ttu-id="46805-200">请求/响应通信的常用体系结构样式是 [REST](https://en.wikipedia.org/wiki/Representational_state_transfer)。</span><span class="sxs-lookup"><span data-stu-id="46805-200">A popular architectural style for request/response communication is [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span></span> <span data-ttu-id="46805-201">此方法基于 [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) 协议并与该协议紧密耦合，接受 GET、POST 和 PUT 等 HTTP 谓词。</span><span class="sxs-lookup"><span data-stu-id="46805-201">This approach is based on, and tightly coupled to, the [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) protocol, embracing HTTP verbs like GET, POST, and PUT.</span></span> <span data-ttu-id="46805-202">REST 是创建服务时最常用的体系结构通信方法。</span><span class="sxs-lookup"><span data-stu-id="46805-202">REST is the most commonly used architectural communication approach when creating services.</span></span> <span data-ttu-id="46805-203">开发 ASP.NET Core Web API 服务时，可以实现 REST 服务。</span><span class="sxs-lookup"><span data-stu-id="46805-203">You can implement REST services when you develop ASP.NET Core Web API services.</span></span>

<span data-ttu-id="46805-204">使用 HTTP REST 服务作为接口定义语言时，还有其他值。</span><span class="sxs-lookup"><span data-stu-id="46805-204">There's additional value when using HTTP REST services as your interface definition language.</span></span> <span data-ttu-id="46805-205">例如，如果使用 [Swagger 元数据](https://swagger.io/)介绍服务 API，则可以使用生成客户端存根的工具来直接发现和使用服务。</span><span class="sxs-lookup"><span data-stu-id="46805-205">For instance, if you use [Swagger metadata](https://swagger.io/) to describe your service API, you can use tools that generate client stubs that can directly discover and consume your services.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="46805-206">其他资源</span><span class="sxs-lookup"><span data-stu-id="46805-206">Additional resources</span></span>

- <span data-ttu-id="46805-207">**Martin Fowler。Richardson 成熟度模型** REST 模型的说明。</span><span class="sxs-lookup"><span data-stu-id="46805-207">**Martin Fowler. Richardson Maturity Model** A description of the REST model.</span></span> \
  [https://martinfowler.com/articles/richardsonMaturityModel.html](https://martinfowler.com/articles/richardsonMaturityModel.html)

- <span data-ttu-id="46805-208">**Swagger** 官方网站。</span><span class="sxs-lookup"><span data-stu-id="46805-208">**Swagger** The official site.</span></span> \
  [https://swagger.io/](https://swagger.io/)

### <a name="push-and-real-time-communication-based-on-http"></a><span data-ttu-id="46805-209">基于 HTTP 的推送和实时通信</span><span class="sxs-lookup"><span data-stu-id="46805-209">Push and real-time communication based on HTTP</span></span>

<span data-ttu-id="46805-210">另一种可能（通常用于不同于 REST 的目的）是与更高级别框架（如 [ASP.NET SignalR](https://www.asp.net/signalr)）和协议（如[WebSocket](https://en.wikipedia.org/wiki/WebSocket)）之间的实时和一对多通信。</span><span class="sxs-lookup"><span data-stu-id="46805-210">Another possibility (usually for different purposes than REST) is a real-time and one-to-many communication with higher-level frameworks such as [ASP.NET SignalR](https://www.asp.net/signalr) and protocols such as [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span></span>

<span data-ttu-id="46805-211">如图 4-17 所示，实时 HTTP 通信意味着可以让服务器代码在数据可用时将内容推送到连接的客户端，而不是让服务器等待客户端请求新数据。</span><span class="sxs-lookup"><span data-stu-id="46805-211">As Figure 4-17 shows, real-time HTTP communication means that you can have server code pushing content to connected clients as the data becomes available, rather than having the server wait for a client to request new data.</span></span>

![SignalR 是实现用于将内容从后端服务器推送到客户端的实时通信的好方法。](./media/image17.png)

<span data-ttu-id="46805-213">**图 4-17**。</span><span class="sxs-lookup"><span data-stu-id="46805-213">**Figure 4-17**.</span></span> <span data-ttu-id="46805-214">一对一实时异步消息通信</span><span class="sxs-lookup"><span data-stu-id="46805-214">One-to-one real-time asynchronous message communication</span></span>

<span data-ttu-id="46805-215">由于通信是实时的，客户端应用几乎立即显示更改。</span><span class="sxs-lookup"><span data-stu-id="46805-215">Since communication is in real time, client apps show the changes almost instantly.</span></span> <span data-ttu-id="46805-216">这通常由 WebSocket 之类的协议使用多个 WebSocket 连接（每个客户端一个）处理。</span><span class="sxs-lookup"><span data-stu-id="46805-216">This is usually handled by a protocol such as WebSockets, using many WebSockets connections (one per client).</span></span> <span data-ttu-id="46805-217">一个典型示例是将体育比赛的比分变化同时传送到多个客户端 Web 应用。</span><span class="sxs-lookup"><span data-stu-id="46805-217">A typical example is when a service communicates a change in the score of a sports game to many client web apps simultaneously.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="46805-218">[上一页](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)
>[下一页](asynchronous-message-based-communication.md)</span><span class="sxs-lookup"><span data-stu-id="46805-218">[Previous](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)
[Next](asynchronous-message-based-communication.md)</span></span>