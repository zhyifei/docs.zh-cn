---
title: "直接与 API 网关模式的微服务构成客户端通信"
description: "为容器化的.NET 应用程序的.NET 微服务体系结构 |直接与 API 网关模式的微服务构成客户端通信"
keywords: "Docker 微服务、 ASP.NET、 容器、 API 网关"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/18/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: c8227ec47888c7cf361f34c4c85a09c0666f886e
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/22/2017
---
# <a name="direct-client-to-microservice-communication-versus-the-api-gateway-pattern"></a><span data-ttu-id="cfeed-104">直接与 API 网关模式的微服务构成客户端通信</span><span class="sxs-lookup"><span data-stu-id="cfeed-104">Direct client-to-microservice communication versus the API Gateway pattern</span></span>

<span data-ttu-id="cfeed-105">在微服务体系结构，每个微服务公开一组 （通常） fine‑grained 终结点。</span><span class="sxs-lookup"><span data-stu-id="cfeed-105">In a microservices architecture, each microservice exposes a set of (typically) fine‑grained endpoints.</span></span> <span data-ttu-id="cfeed-106">这种情况可能会影响 client‑to‑microservice 通信，如本部分中所述。</span><span class="sxs-lookup"><span data-stu-id="cfeed-106">This fact can impact the client‑to‑microservice communication, as explained in this section.</span></span>

## <a name="direct-client-to-microservice-communication"></a><span data-ttu-id="cfeed-107">直接微服务构成客户端通信</span><span class="sxs-lookup"><span data-stu-id="cfeed-107">Direct client-to-microservice communication</span></span>

<span data-ttu-id="cfeed-108">可能的方法是使用直接微服务构成客户端通信体系结构。</span><span class="sxs-lookup"><span data-stu-id="cfeed-108">A possible approach is to use a direct client-to-microservice communication architecture.</span></span> <span data-ttu-id="cfeed-109">在此方法中，客户端应用程序可以直接向提出请求一些微服务，如图 4-12 中所示。</span><span class="sxs-lookup"><span data-stu-id="cfeed-109">In this approach, a client app can make requests directly to some of the microservices, as shown in Figure 4-12.</span></span>

![](./media/image12.png)

<span data-ttu-id="cfeed-110">**图 4-12**。</span><span class="sxs-lookup"><span data-stu-id="cfeed-110">**Figure 4-12**.</span></span> <span data-ttu-id="cfeed-111">使用直接微服务构成客户端通信体系结构</span><span class="sxs-lookup"><span data-stu-id="cfeed-111">Using a direct client-to-microservice communication architecture</span></span>

<span data-ttu-id="cfeed-112">在这种方法。</span><span class="sxs-lookup"><span data-stu-id="cfeed-112">In this approach.</span></span> <span data-ttu-id="cfeed-113">每个微服务具有有时具有每个微服务的其他 TCP 端口的公共终结点。</span><span class="sxs-lookup"><span data-stu-id="cfeed-113">each microservice has a public endpoint, sometimes with a different TCP port for each microservice.</span></span> <span data-ttu-id="cfeed-114">为特定服务的 URL 的示例可能是在 Azure 中的以下 URL:</span><span class="sxs-lookup"><span data-stu-id="cfeed-114">An example of a URL for a particular service could be the following URL in Azure:</span></span>

<span data-ttu-id="cfeed-115"><http://eshoponcontainers.westus.cloudapp.azure.com:88 /></span><span class="sxs-lookup"><span data-stu-id="cfeed-115"><http://eshoponcontainers.westus.cloudapp.azure.com:88/></span></span>

<span data-ttu-id="cfeed-116">在生产环境中基于 URL 将映射到负载平衡器使用在群集中的群集，这反过来之间分配请求微服务。</span><span class="sxs-lookup"><span data-stu-id="cfeed-116">In a production environment based on a cluster, that URL would map to the load balancer used in the cluster, which in turn distributes the requests across the microservices.</span></span> <span data-ttu-id="cfeed-117">在生产环境中，你可以像应用程序传递控制器 (ADC) [Azure 应用程序网关](https://docs.microsoft.com/azure/application-gateway/application-gateway-introduction)你微服务和 Internet 之间。</span><span class="sxs-lookup"><span data-stu-id="cfeed-117">In production environments, you could have an Application Delivery Controller (ADC) like [Azure Application Gateway](https://docs.microsoft.com/azure/application-gateway/application-gateway-introduction) between your microservices and the Internet.</span></span> <span data-ttu-id="cfeed-118">充当一个透明层之间进行负载平衡，不仅保护你的服务通过提供 SSL 终止。</span><span class="sxs-lookup"><span data-stu-id="cfeed-118">This acts as a transparent tier that not only performs load balancing, but secures your services by offering SSL termination.</span></span> <span data-ttu-id="cfeed-119">这将通过卸载 CPU 密集型 SSL 终止和 Azure 应用程序网关到其他路由职责提高你的主机的负载。</span><span class="sxs-lookup"><span data-stu-id="cfeed-119">This improves the load of your hosts by offloading CPU-intensive SSL termination and other routing duties to the Azure Application Gateway.</span></span> <span data-ttu-id="cfeed-120">在任何情况下，负载平衡器和 ADC 都是从逻辑的应用程序体系结构角度来看透明的。</span><span class="sxs-lookup"><span data-stu-id="cfeed-120">In any case, a load balancer and ADC are transparent from a logical application architecture point of view.</span></span>

<span data-ttu-id="cfeed-121">直接微服务构成客户端通信体系结构无法对已经足够好一个小基于微服务构成的应用程序，尤其是当客户端应用程序服务器端 web 应用程序，如 ASP.NET MVC 应用程序。</span><span class="sxs-lookup"><span data-stu-id="cfeed-121">A direct client-to-microservice communication architecture could be good enough for a small microservice-based application, especially if the client app is a server-side web application like an ASP.NET MVC app.</span></span> <span data-ttu-id="cfeed-122">但是，当你生成大型和复杂基于微服务构成的应用程序 （例如，当处理大量微服务类型），并且尤其是在客户端应用程序是远程的移动应用或 SPA web 应用程序时，该方法将面临一些问题。</span><span class="sxs-lookup"><span data-stu-id="cfeed-122">However, when you build large and complex microservice-based applications (for example, when handling dozens of microservice types), and especially when the client apps are remote mobile apps or SPA web applications, that approach faces a few issues.</span></span>

<span data-ttu-id="cfeed-123">开发大型应用程序基于微服务时，请考虑以下问题：</span><span class="sxs-lookup"><span data-stu-id="cfeed-123">Consider the following questions when developing a large application based on microservices:</span></span>

-   <span data-ttu-id="cfeed-124">*如何客户端应用程序最大程度减少到后端的请求数和减少到多个微服务的聊天式通信？*</span><span class="sxs-lookup"><span data-stu-id="cfeed-124">*How can client apps minimize the number of requests to the backend and reduce chatty communication to multiple microservices?*</span></span>

<span data-ttu-id="cfeed-125">通过 Internet 与多个微服务生成单个 UI 屏幕进行交互增加往返的次数。</span><span class="sxs-lookup"><span data-stu-id="cfeed-125">Interacting with multiple microservices to build a single UI screen increases the number of roundtrips across the Internet.</span></span> <span data-ttu-id="cfeed-126">这会增加延迟和 UI 一端的复杂性。</span><span class="sxs-lookup"><span data-stu-id="cfeed-126">This increases latency and complexity on the UI side.</span></span> <span data-ttu-id="cfeed-127">理想情况下，响应应进行高效聚合服务器端中 — 这一功能减少了延迟，因为数据的多个部分回来并行和某些用户界面可以显示数据，只要它是准备。</span><span class="sxs-lookup"><span data-stu-id="cfeed-127">Ideally, responses should be efficiently aggregated in the server side—this reduces latency, since multiple pieces of data come back in parallel and some UI can show data as soon as it is ready.</span></span>

-   <span data-ttu-id="cfeed-128">*如何处理如授权、 数据转换和动态请求调度的跨领域问题？*</span><span class="sxs-lookup"><span data-stu-id="cfeed-128">*How can you handle cross-cutting concerns such as authorization, data transformations, and dynamic request dispatching?*</span></span>

<span data-ttu-id="cfeed-129">实现安全和跨领域问题，如安全和授权上每个微服务可能需要大量的开发工作。</span><span class="sxs-lookup"><span data-stu-id="cfeed-129">Implementing security and cross-cutting concerns like security and authorization on every microservice can require significant development effort.</span></span> <span data-ttu-id="cfeed-130">可能的方法是让在 Docker 主机或内部群集中，这些服务，以便从外部，限制对它们的直接访问和实现在一个集中的位置，例如，API 网关的这些跨领域问题。</span><span class="sxs-lookup"><span data-stu-id="cfeed-130">A possible approach is to have those services within the Docker host or internal cluster, in order to restrict direct access to them from the outside, and to implement those cross-cutting concerns in a centralized place, like an API Gateway.</span></span>

-   <span data-ttu-id="cfeed-131">*客户端应用程序如何使用非 internet 协议的服务进行通信？*</span><span class="sxs-lookup"><span data-stu-id="cfeed-131">*How can client apps communicate with services that use non-Internet-friendly protocols?*</span></span>

<span data-ttu-id="cfeed-132">通常客户端应用中不支持使用在服务器端 （如 AMQP 或二进制协议） 协议。</span><span class="sxs-lookup"><span data-stu-id="cfeed-132">Protocols used on the server side (like AMQP or binary protocols) are usually not supported in client apps.</span></span> <span data-ttu-id="cfeed-133">因此，必须通过类似 HTTP/HTTPS 协议执行请求并将其转换为其他协议之后。</span><span class="sxs-lookup"><span data-stu-id="cfeed-133">Therefore, requests must be performed through protocols like HTTP/HTTPS and translated to the other protocols afterwards.</span></span> <span data-ttu-id="cfeed-134">A*拦截中*方法可帮助在此情况下。</span><span class="sxs-lookup"><span data-stu-id="cfeed-134">A *man-in-the-middle* approach can help in this situation.</span></span>

-   <span data-ttu-id="cfeed-135">*你可以如何形成尤其是对移动应用的外观？*</span><span class="sxs-lookup"><span data-stu-id="cfeed-135">*How can you shape a façade especially made for mobile apps?*</span></span>

<span data-ttu-id="cfeed-136">多个微服务的 API 可能并非很好地设计为不同的客户端应用程序的需求。</span><span class="sxs-lookup"><span data-stu-id="cfeed-136">The API of multiple microservices might not be well designed for the needs of different client applications.</span></span> <span data-ttu-id="cfeed-137">例如，移动应用程序的需求可能不同于 web 应用程序的需求。</span><span class="sxs-lookup"><span data-stu-id="cfeed-137">For instance, the needs of a mobile app might be different than the needs of a web app.</span></span> <span data-ttu-id="cfeed-138">对于移动应用程序，你可能需要进一步优化，以便数据响应可能更有效。</span><span class="sxs-lookup"><span data-stu-id="cfeed-138">For mobile apps, you might need to optimize even further so that data responses can be more efficient.</span></span> <span data-ttu-id="cfeed-139">你可能会执行此方法是从多个微服务聚合数据并返回单个组数据，并有时消除不需要的移动应用程序的响应中的任何数据。</span><span class="sxs-lookup"><span data-stu-id="cfeed-139">You might do this by aggregating data from multiple microservices and returning a single set of data, and sometimes eliminating any data in the response that is not needed by the mobile app.</span></span> <span data-ttu-id="cfeed-140">并且，当然，你可能会压缩该数据。</span><span class="sxs-lookup"><span data-stu-id="cfeed-140">And, of course, you might compress that data.</span></span> <span data-ttu-id="cfeed-141">同样，外观或移动应用程序和微服务之间的 API 会很方便对于此方案。</span><span class="sxs-lookup"><span data-stu-id="cfeed-141">Again, a façade or API in between the mobile app and the microservices can be convenient for this scenario.</span></span>

## <a name="using-an-api-gateway"></a><span data-ttu-id="cfeed-142">使用 API 网关</span><span class="sxs-lookup"><span data-stu-id="cfeed-142">Using an API Gateway</span></span>

<span data-ttu-id="cfeed-143">当你在设计和构建大型或复杂基于微服务构成的应用程序使用多个客户端应用程序时，可以是一个不错的方法要考虑[API 网关](http://microservices.io/patterns/apigateway.html)。</span><span class="sxs-lookup"><span data-stu-id="cfeed-143">When you design and build large or complex microservice-based applications with multiple client apps, a good approach to consider can be an [API Gateway](http://microservices.io/patterns/apigateway.html).</span></span> <span data-ttu-id="cfeed-144">这是提供单一入口点，对于某些微服务的组的服务。</span><span class="sxs-lookup"><span data-stu-id="cfeed-144">This is a service that provides a single entry point for certain groups of microservices.</span></span> <span data-ttu-id="cfeed-145">它是类似于[外观模式](https://en.wikipedia.org/wiki/Facade_pattern)从 object‑oriented 设计，但在此情况下，它是一个分布式系统的一部分。</span><span class="sxs-lookup"><span data-stu-id="cfeed-145">It is similar to the [Facade pattern](https://en.wikipedia.org/wiki/Facade_pattern) from object‑oriented design, but in this case, it is part of a distributed system.</span></span> <span data-ttu-id="cfeed-146">API 网关模式有时也称为"后端个前端" [(BFF)](http://samnewman.io/patterns/architectural/bff/)因为构建时考虑客户端应用程序的需求。</span><span class="sxs-lookup"><span data-stu-id="cfeed-146">The API Gateway pattern is also sometimes known as the “backend for frontend” [(BFF)](http://samnewman.io/patterns/architectural/bff/) because you build it while thinking about the needs of the client app.</span></span>

<span data-ttu-id="cfeed-147">图 4-13 演示如何自定义 API 网关可以放入基于微服务的体系结构。</span><span class="sxs-lookup"><span data-stu-id="cfeed-147">Figure 4-13 shows how a custom API Gateway can fit into a microservice-based architecture.</span></span>
<span data-ttu-id="cfeed-148">务必要在该关系图中突出显示的你将会使用面向多个单个自定义 API 网关服务和不同的客户端应用。</span><span class="sxs-lookup"><span data-stu-id="cfeed-148">It is important to highlight that in that diagram, you would be using a single custom API Gateway service facing multiple and different client apps.</span></span> <span data-ttu-id="cfeed-149">因为你的 API 网关服务将不断增长和演化，事实可以是重要的风险基于从客户端应用程序的许多不同的要求。</span><span class="sxs-lookup"><span data-stu-id="cfeed-149">That fact can be an important risk because your API Gateway service will be growing and evolving based on many different requirements from the client apps.</span></span> <span data-ttu-id="cfeed-150">最终，它将是臃肿由于这些不同的需求而有效地它可以是非常类似于整体应用程序或整体服务。</span><span class="sxs-lookup"><span data-stu-id="cfeed-150">Eventually, it will be bloated because of those different needs and effectively it could be pretty similar to a monolithic application or monolithic service.</span></span> <span data-ttu-id="cfeed-151">正因为如此很大程度建议例如拆分多个服务或多个较小 API 网关，每个外形规格类型之一中的 API 网关。</span><span class="sxs-lookup"><span data-stu-id="cfeed-151">That is why it is very much recommended to split the API Gateway in multiple services or multiple smaller API Gateways, one per form-factor type, for instance.</span></span>

![](./media/image13.png)

<span data-ttu-id="cfeed-152">**图 4-13**。</span><span class="sxs-lookup"><span data-stu-id="cfeed-152">**Figure 4-13**.</span></span> <span data-ttu-id="cfeed-153">使用 API 网关实现为自定义的 Web API 服务</span><span class="sxs-lookup"><span data-stu-id="cfeed-153">Using an API Gateway implemented as a custom Web API service</span></span>

<span data-ttu-id="cfeed-154">在此示例中，将作为运行作为容器的自定义 Web API 服务实现 API 网关。</span><span class="sxs-lookup"><span data-stu-id="cfeed-154">In this example, the API Gateway would be implemented as a custom Web API service running as a container.</span></span>

<span data-ttu-id="cfeed-155">如前文所述，应实现多个 API 网关，以便你可以为每个客户端应用程序的需求的不同外观。</span><span class="sxs-lookup"><span data-stu-id="cfeed-155">As mentioned, you should implement several API Gateways so that you can have a different façade for the needs of each client app.</span></span> <span data-ttu-id="cfeed-156">每个 API 网关可以提供其他 API 针对每个客户端应用程序中，可能是甚至基于客户端外形因素通过实现哪些在调用多个内部微服务特定的适配器代码。</span><span class="sxs-lookup"><span data-stu-id="cfeed-156">Each API Gateway can provide a different API tailored for each client app, possibly even based on the client form factor by implementing specific adapter code which underneath calls multiple internal microservices.</span></span>

<span data-ttu-id="cfeed-157">由于自定义 API 网关通常是数据聚合器，你需要请小心使用它。</span><span class="sxs-lookup"><span data-stu-id="cfeed-157">Since a custom API Gateway is usually a data aggregator, you need to be careful with it.</span></span> <span data-ttu-id="cfeed-158">通常，它不具有一个 API 网关聚合所有内部微服务应用程序的一个好办法。</span><span class="sxs-lookup"><span data-stu-id="cfeed-158">Usually it isn't a good idea to have a single API Gateway aggregating all the internal microservices of your application.</span></span> <span data-ttu-id="cfeed-159">如果是这样，它充当整体聚合器或 orchestrator，并与冲突 microservice 自主性耦合所有微服务。</span><span class="sxs-lookup"><span data-stu-id="cfeed-159">If it does, it acts as a monolithic aggregator or orchestrator and violates microservice autonomy by coupling all the microservices.</span></span> <span data-ttu-id="cfeed-160">因此，API 网关应分离取决于业务边界和不 act 作为聚合器对整个应用程序。</span><span class="sxs-lookup"><span data-stu-id="cfeed-160">Therefore, the API Gateways should be segregated based on business boundaries and not act as an aggregator for the whole application.</span></span>

<span data-ttu-id="cfeed-161">有时精细 API 网关可以独自，同时 microservice，甚至可以安排域或公司名称和相关的数据。</span><span class="sxs-lookup"><span data-stu-id="cfeed-161">Sometimes a granular API Gateway can also be a microservice by itself, and even have a domain or business name and related data.</span></span> <span data-ttu-id="cfeed-162">具有的业务或域由指定的 API 网关的边界将帮助你获得更好的设计。</span><span class="sxs-lookup"><span data-stu-id="cfeed-162">Having the API Gateway’s boundaries dictated by the business or domain will help you to get a better design.</span></span>

<span data-ttu-id="cfeed-163">API 网关层中的粒度可能更高级复合 UI 根据对应用程序微服务，尤其有用，因为细化 API 网关的概念是类似于 UI 组合服务。</span><span class="sxs-lookup"><span data-stu-id="cfeed-163">Granularity in the API Gateway tier can be especially useful for more advanced composite UI applications based on microservices, because the concept of a fine-grained API Gateway is similar to a UI composition service.</span></span> <span data-ttu-id="cfeed-164">我们将讨论这更高版本中[创建复合 UI 基于微服务](#creating-composite-ui-based-on-microservices-including-visual-ui-shape-and-layout-generated-by-multiple-microservices)。</span><span class="sxs-lookup"><span data-stu-id="cfeed-164">We discuss this later in the [Creating composite UI based on microservices](#creating-composite-ui-based-on-microservices-including-visual-ui-shape-and-layout-generated-by-multiple-microservices).</span></span>

<span data-ttu-id="cfeed-165">因此，对于许多中等和较大的规模应用程序，使用自定义 API 网关通常是一个不错的方法，但不是作为一个整体的聚合器或唯一中央自定义 API 网关。</span><span class="sxs-lookup"><span data-stu-id="cfeed-165">Therefore, for many medium- and large-size applications, using a custom-built API Gateway is usually a good approach, but not as a single monolithic aggregator or unique central custom API Gateway.</span></span>

<span data-ttu-id="cfeed-166">另一种方法是使用这样的产品[Azure API 管理](https://azure.microsoft.com/services/api-management/)图 4-14 中所示。</span><span class="sxs-lookup"><span data-stu-id="cfeed-166">Another approach is to use a product like [Azure API Management](https://azure.microsoft.com/services/api-management/) as shown in Figure 4-14.</span></span> <span data-ttu-id="cfeed-167">此方法不仅解决了你 API 网关的需求，但提供功能，如收集 insights 从您的 Api。</span><span class="sxs-lookup"><span data-stu-id="cfeed-167">This approach not only solves your API Gateway needs, but provides features like gathering insights from your APIs.</span></span> <span data-ttu-id="cfeed-168">如果你使用 API 管理解决方案，API 网关是仅在该完整的 API 管理解决方案中的组件。</span><span class="sxs-lookup"><span data-stu-id="cfeed-168">If you are using an API management solution, an API Gateway is only a component within that full API management solution.</span></span>

![](./media/image14.png)

<span data-ttu-id="cfeed-169">**图 4-14**。</span><span class="sxs-lookup"><span data-stu-id="cfeed-169">**Figure 4-14**.</span></span> <span data-ttu-id="cfeed-170">使用 Azure API 管理 API 网关</span><span class="sxs-lookup"><span data-stu-id="cfeed-170">Using Azure API Management for your API Gateway</span></span>

<span data-ttu-id="cfeed-171">在这种情况下，当使用 Azure API 管理中，你可能具有单个 API 网关这样的产品不是因此危险因为这些类型的 API 网关是"越窄"，这意味着你不实现的自定义 C# 代码可能演变朝向整体组件。</span><span class="sxs-lookup"><span data-stu-id="cfeed-171">In this case, when using a product like Azure API Management, the fact that you might have a single API Gateway is not so risky because these kinds of API Gateways are "thinner", meaning that you don't implement custom C# code that could evolve towards a monolithic component.</span></span> 

<span data-ttu-id="cfeed-172">这种类型的产品更像的入站通信，你可以还筛选从内部微服务的 Api 和应用于此单个层中的已发布的 Api 的授权的反向代理。</span><span class="sxs-lookup"><span data-stu-id="cfeed-172">This type of product acts more like a reverse proxy for ingress communication, where you can also filter the APIs from the internal microservices plus apply authorization to the published APIs in this single tier.</span></span>

<span data-ttu-id="cfeed-173">Insights 可从 API 管理系统帮助你了解如何使用您的 API 的性能如何。</span><span class="sxs-lookup"><span data-stu-id="cfeed-173">The insights available from an API Management system help you get an understanding of how your APIs are being used and how they are performing.</span></span> <span data-ttu-id="cfeed-174">这样做允许您查看接近实时分析报表，确定可能会影响你的业务的趋势。</span><span class="sxs-lookup"><span data-stu-id="cfeed-174">They do this by letting you view near real-time analytics reports and identifying trends that might impact your business.</span></span> <span data-ttu-id="cfeed-175">此外，你可以有关请求和响应的活动，以进行进一步联机和脱机的分析日志。</span><span class="sxs-lookup"><span data-stu-id="cfeed-175">Plus, you can have logs about request and response activity for further online and offline analysis.</span></span>

<span data-ttu-id="cfeed-176">使用 Azure API 管理中，你可以保护您的 Api 使用密钥、 令牌，和 IP 筛选。</span><span class="sxs-lookup"><span data-stu-id="cfeed-176">With Azure API Management, you can secure your APIs using a key, a token, and IP filtering.</span></span> <span data-ttu-id="cfeed-177">这些功能允许你强制执行灵活和细化配额和速率限制，修改的形状和使用策略，您的 api 的行为，并随着响应缓存可以提高性能。</span><span class="sxs-lookup"><span data-stu-id="cfeed-177">These features let you enforce flexible and fine-grained quotas and rate limits, modify the shape and behavior of your APIs using policies, and improve performance with response caching.</span></span>

<span data-ttu-id="cfeed-178">在本指南和参考示例应用程序 (eShopOnContainers) 中，我们以便将重点放在纯容器上而无需使用 PaaS 产品，如 Azure API 管理限制到一种更简单的自定义的容器化体系结构的体系结构。</span><span class="sxs-lookup"><span data-stu-id="cfeed-178">In this guide and the reference sample application (eShopOnContainers), we are limiting the architecture to a simpler and custom-made containerized architecture in order to focus on plain containers without using PaaS products like Azure API Management.</span></span> <span data-ttu-id="cfeed-179">但对于大型基于微服务构成的应用程序部署到 Microsoft Azure，我们建议你查看并为您的 API 网关作为基础采用 Azure API 管理。</span><span class="sxs-lookup"><span data-stu-id="cfeed-179">But for large microservice-based applications that are deployed into Microsoft Azure, we encourage you to review and adopt Azure API Management as the base for your API Gateways.</span></span>

## <a name="drawbacks-of-the-api-gateway-pattern"></a><span data-ttu-id="cfeed-180">API 网关模式的缺点</span><span class="sxs-lookup"><span data-stu-id="cfeed-180">Drawbacks of the API Gateway pattern</span></span>

-   <span data-ttu-id="cfeed-181">最重要的缺点是，当您实现 API 网关，你将与内部微服务耦合该层。</span><span class="sxs-lookup"><span data-stu-id="cfeed-181">The most important drawback is that when you implement an API Gateway, you are coupling that tier with the internal microservices.</span></span> <span data-ttu-id="cfeed-182">此类耦合可能会引入你的应用程序的严重问题。</span><span class="sxs-lookup"><span data-stu-id="cfeed-182">Coupling like this might introduce serious difficulties for your application.</span></span> <span data-ttu-id="cfeed-183">Clemens Vaster，架构师在 Azure Service Bus 团队中，引用此潜在的难度，可与"新 ESB"在他"[消息传递和微服务](https://www.youtube.com/watch?v=rXi5CLjIQ9k)"会话在 GOTO 2016。</span><span class="sxs-lookup"><span data-stu-id="cfeed-183">Clemens Vaster, architect at the Azure Service Bus team, refers to this potential difficulty as “the new ESB” in his "[Messaging and Microservices](https://www.youtube.com/watch?v=rXi5CLjIQ9k)" session at GOTO 2016.</span></span>

-   <span data-ttu-id="cfeed-184">使用微服务 API 网关创建其他可能单点故障。</span><span class="sxs-lookup"><span data-stu-id="cfeed-184">Using a microservices API Gateway creates an additional possible single point of failure.</span></span>

-   <span data-ttu-id="cfeed-185">API 网关可以引入响应时间变的长由于其他网络调用。</span><span class="sxs-lookup"><span data-stu-id="cfeed-185">An API Gateway can introduce increased response time due to the additional network call.</span></span> <span data-ttu-id="cfeed-186">但是，此额外调用通常具有不是让客户端接口是太烦琐直接调用内部的微服务的影响更小。</span><span class="sxs-lookup"><span data-stu-id="cfeed-186">However, this extra call usually has less impact than having a client interface that is too chatty directly calling the internal microservices.</span></span>

-   <span data-ttu-id="cfeed-187">如果不正确扩展，API 网关可能成为瓶颈。</span><span class="sxs-lookup"><span data-stu-id="cfeed-187">If not scaled out properly, the API Gateway can become a bottleneck.</span></span>

-   <span data-ttu-id="cfeed-188">如果它包括自定义逻辑和数据聚合，API 网关需要额外的开发成本和将来的维护。</span><span class="sxs-lookup"><span data-stu-id="cfeed-188">An API Gateway requires additional development cost and future maintenance if it includes custom logic and data aggregation.</span></span> <span data-ttu-id="cfeed-189">开发人员必须更新 API 网关，以便公开每个微服务的终结点。</span><span class="sxs-lookup"><span data-stu-id="cfeed-189">Developers must update the API Gateway in order to expose each microservice’s endpoints.</span></span> <span data-ttu-id="cfeed-190">此外，在内部微服务的实现更改可能会导致 API 网关级别的代码更改。</span><span class="sxs-lookup"><span data-stu-id="cfeed-190">Moreover, implementation changes in the internal microservices might cause code changes at the API Gateway level.</span></span> <span data-ttu-id="cfeed-191">但是，如果安全、 日志记录和版本控制，只需将应用 API 网关 （比如在使用 Azure API 管理），此额外的开发成本可能不适用于。</span><span class="sxs-lookup"><span data-stu-id="cfeed-191">However, if the API Gateway is just applying security, logging, and versioning (as when using Azure API Management), this additional development cost might not apply.</span></span>

-   <span data-ttu-id="cfeed-192">如果 API 网关开发了一个组，可以有开发瓶颈。</span><span class="sxs-lookup"><span data-stu-id="cfeed-192">If the API Gateway is developed by a single team, there can be a development bottleneck.</span></span> <span data-ttu-id="cfeed-193">这是为什么更好的方法是让多个细粒度 API 网关对不同的客户端需要作出响应的另一个原因。</span><span class="sxs-lookup"><span data-stu-id="cfeed-193">This is another reason why a better approach is to have several fined-grained API Gateways that respond to different client needs.</span></span> <span data-ttu-id="cfeed-194">你无法为多个区域或图层所拥有的不同的团队处理内部微服务内部分离 API 网关。</span><span class="sxs-lookup"><span data-stu-id="cfeed-194">You could also segregate the API Gateway internally into multiple areas or layers that are owned by the different teams working on the internal microservices.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="cfeed-195">其他资源</span><span class="sxs-lookup"><span data-stu-id="cfeed-195">Additional resources</span></span>

-   <span data-ttu-id="cfeed-196">**Charles Richardson。模式： API 网关 / 后的端前端**
    [*http://microservices.io/patterns/apigateway.html*](http://microservices.io/patterns/apigateway.html)</span><span class="sxs-lookup"><span data-stu-id="cfeed-196">**Charles Richardson. Pattern: API Gateway / Backend for Front-End**
[*http://microservices.io/patterns/apigateway.html*](http://microservices.io/patterns/apigateway.html)</span></span>

-   <span data-ttu-id="cfeed-197">**Azure API 管理**
    [*https://azure.microsoft.com/services/api-management/*](https://azure.microsoft.com/services/api-management/)</span><span class="sxs-lookup"><span data-stu-id="cfeed-197">**Azure API Management**
[*https://azure.microsoft.com/services/api-management/*](https://azure.microsoft.com/services/api-management/)</span></span>

-   <span data-ttu-id="cfeed-198">**Udi Dahan。面向服务的组合**\\</span><span class="sxs-lookup"><span data-stu-id="cfeed-198">**Udi Dahan. Service Oriented Composition**\\</span></span>
    [<span data-ttu-id="cfeed-199">*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*</span><span class="sxs-lookup"><span data-stu-id="cfeed-199">*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*</span></span>](http://udidahan.com/2014/07/30/service-oriented-composition-with-video/)

-   <span data-ttu-id="cfeed-200">**Clemens Vasters。消息传递和微服务在 GOTO 2016** （视频） [ *https://www.youtube.com/watch?v=rXi5CLjIQ9k*](https://www.youtube.com/watch?v=rXi5CLjIQ9k)</span><span class="sxs-lookup"><span data-stu-id="cfeed-200">**Clemens Vasters. Messaging and Microservices at GOTO 2016** (video) [*https://www.youtube.com/watch?v=rXi5CLjIQ9k*](https://www.youtube.com/watch?v=rXi5CLjIQ9k)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="cfeed-201">[以前](标识-微服务构成的域-模型-boundaries.md) [下一步] (通信-中的微服务-architecture.md)</span><span class="sxs-lookup"><span data-stu-id="cfeed-201">[Previous] (identify-microservice-domain-model-boundaries.md) [Next] (communication-in-microservice-architecture.md)</span></span>
