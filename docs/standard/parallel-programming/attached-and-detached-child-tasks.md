---
title: 已附加和已分离的子任务
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, child tasks
ms.assetid: c95788bf-90a6-4e96-b7bc-58e36a228cc5
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 53f31402e78a15289bb996c63e1e8e3cd98e6aac
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/04/2018
ms.locfileid: "33590759"
---
# <a name="attached-and-detached-child-tasks"></a><span data-ttu-id="c080f-102">已附加和已分离的子任务</span><span class="sxs-lookup"><span data-stu-id="c080f-102">Attached and Detached Child Tasks</span></span>
<span data-ttu-id="c080f-103">子任务（或嵌套任务）是在另一个任务（称为“父任务”）的用户委托中创建的 <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 实例。</span><span class="sxs-lookup"><span data-stu-id="c080f-103">A *child task* (or *nested task*) is a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> instance that is created in the user delegate of another task, which is known as the *parent task*.</span></span> <span data-ttu-id="c080f-104">可以分离或附加子任务。</span><span class="sxs-lookup"><span data-stu-id="c080f-104">A child task can be either detached or attached.</span></span> <span data-ttu-id="c080f-105">分离的子任务是独立于父级而执行的任务。</span><span class="sxs-lookup"><span data-stu-id="c080f-105">A *detached child task* is a task that executes independently of its parent.</span></span> <span data-ttu-id="c080f-106">附加的子任务是使用 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> 选项创建的嵌套任务，父级不显式或默认禁止附加任务。</span><span class="sxs-lookup"><span data-stu-id="c080f-106">An *attached child task* is a nested task that is created with the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option whose parent does not explicitly or by default prohibit it from being attached.</span></span> <span data-ttu-id="c080f-107">一个任务可以创建任意数量的附加和分离子任务，这仅受系统资源限制。</span><span class="sxs-lookup"><span data-stu-id="c080f-107">A task may create any number of attached and detached child tasks, limited only by system resources.</span></span>  
  
 <span data-ttu-id="c080f-108">下表列出了两种子任务之间的基本差异。</span><span class="sxs-lookup"><span data-stu-id="c080f-108">The following table lists the basic differences between the two kinds of child tasks.</span></span>  
  
|<span data-ttu-id="c080f-109">类别</span><span class="sxs-lookup"><span data-stu-id="c080f-109">Category</span></span>|<span data-ttu-id="c080f-110">分离子任务</span><span class="sxs-lookup"><span data-stu-id="c080f-110">Detached child tasks</span></span>|<span data-ttu-id="c080f-111">附加子任务</span><span class="sxs-lookup"><span data-stu-id="c080f-111">Attached child tasks</span></span>|  
|--------------|--------------------------|--------------------------|  
|<span data-ttu-id="c080f-112">父级将等待子任务完成。</span><span class="sxs-lookup"><span data-stu-id="c080f-112">Parent waits for child tasks to complete.</span></span>|<span data-ttu-id="c080f-113">否</span><span class="sxs-lookup"><span data-stu-id="c080f-113">No</span></span>|<span data-ttu-id="c080f-114">是</span><span class="sxs-lookup"><span data-stu-id="c080f-114">Yes</span></span>|  
|<span data-ttu-id="c080f-115">父级将传播由子任务引发的异常。</span><span class="sxs-lookup"><span data-stu-id="c080f-115">Parent propagates exceptions thrown by child tasks.</span></span>|<span data-ttu-id="c080f-116">否</span><span class="sxs-lookup"><span data-stu-id="c080f-116">No</span></span>|<span data-ttu-id="c080f-117">是</span><span class="sxs-lookup"><span data-stu-id="c080f-117">Yes</span></span>|  
|<span data-ttu-id="c080f-118">父级的状态取决于子级的状态。</span><span class="sxs-lookup"><span data-stu-id="c080f-118">Status of parent depends on status of child.</span></span>|<span data-ttu-id="c080f-119">否</span><span class="sxs-lookup"><span data-stu-id="c080f-119">No</span></span>|<span data-ttu-id="c080f-120">是</span><span class="sxs-lookup"><span data-stu-id="c080f-120">Yes</span></span>|  
  
 <span data-ttu-id="c080f-121">在大多数情况下，我们建议你使用分离子任务，因为它们与其他任务之间的关系不太复杂。</span><span class="sxs-lookup"><span data-stu-id="c080f-121">In most scenarios, we recommend that you use detached child tasks, because their relationships with other tasks are less complex.</span></span> <span data-ttu-id="c080f-122">这就是父任务内创建的任务会默认分离的原因，并且必须显式指定 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> 选项来创建附加子任务。</span><span class="sxs-lookup"><span data-stu-id="c080f-122">That is why tasks created inside parent tasks are detached by default, and you must explicitly specify the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option to create an attached child task.</span></span>  
  
## <a name="detached-child-tasks"></a><span data-ttu-id="c080f-123">分离子任务</span><span class="sxs-lookup"><span data-stu-id="c080f-123">Detached child tasks</span></span>  
 <span data-ttu-id="c080f-124">尽管子任务是由父任务创建的，但在默认情况下，它独立于父任务。</span><span class="sxs-lookup"><span data-stu-id="c080f-124">Although a child task is created by a parent task, by default it is independent of the parent task.</span></span> <span data-ttu-id="c080f-125">在以下示例中，父任务创建了一个简单的子任务。</span><span class="sxs-lookup"><span data-stu-id="c080f-125">In the following example, a parent task creates one simple child task.</span></span> <span data-ttu-id="c080f-126">如果多次运行该示例的代码，你可能会注意到该示例的输出与所演示的输出不同，并且该输出可能在每次运行代码时，会发生更改。</span><span class="sxs-lookup"><span data-stu-id="c080f-126">If you run the example code multiple times, you may notice that the output from the example differs from that shown, and also that the output may change each time you run the code.</span></span> <span data-ttu-id="c080f-127">发生这种情况的原因是父任务和子任务彼此独立执行；子任务是一个分离任务。</span><span class="sxs-lookup"><span data-stu-id="c080f-127">This occurs because the parent task and child tasks execute independently of each other; the child is a detached task.</span></span> <span data-ttu-id="c080f-128">该示例仅等待父任务完成，并且子任务在控制台应用终止之前，可能无法执行或完成。</span><span class="sxs-lookup"><span data-stu-id="c080f-128">The example waits only for the parent task to complete, and the child task may not execute or complete before the console app terminates.</span></span>  
  
 [!code-csharp[TPL_ChildTasks#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_childtasks/cs/nested1.cs#1)]
 [!code-vb[TPL_ChildTasks#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_childtasks/vb/nested1.vb#1)]  
  
 <span data-ttu-id="c080f-129">如果该子任务由 <xref:System.Threading.Tasks.Task%601> 对象，而不是 <xref:System.Threading.Tasks.Task> 对象表示，则你可以通过访问子任务的 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 属性，确保父任务将等待子任务完成，即使该子任务是一个分离子任务。</span><span class="sxs-lookup"><span data-stu-id="c080f-129">If the child task is represented by a <xref:System.Threading.Tasks.Task%601> object rather than a <xref:System.Threading.Tasks.Task> object, you can ensure that the parent task will wait for the child to complete by accessing the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the child even if it is a detached child task.</span></span> <span data-ttu-id="c080f-130"><xref:System.Threading.Tasks.Task%601.Result%2A> 属性在其任务完成前会进行阻止，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="c080f-130">The <xref:System.Threading.Tasks.Task%601.Result%2A> property blocks until its task completes, as the following example shows.</span></span>  
  
 [!code-csharp[TPL_ChildTasks#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_childtasks/cs/childtasks.cs#4)]
 [!code-vb[TPL_ChildTasks#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_childtasks/vb/tpl_childtasks.vb#4)]  
  
## <a name="attached-child-tasks"></a><span data-ttu-id="c080f-131">附加子任务</span><span class="sxs-lookup"><span data-stu-id="c080f-131">Attached child tasks</span></span>  
 <span data-ttu-id="c080f-132">不同于分离子任务，附加子任务与父任务紧密同步。</span><span class="sxs-lookup"><span data-stu-id="c080f-132">Unlike detached child tasks, attached child tasks are closely synchronized with the parent.</span></span> <span data-ttu-id="c080f-133">可以通过使用任务创建语句中的 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> 选项，将之前示例中的分离子任务更改为附加子任务，如以下示例中所示。</span><span class="sxs-lookup"><span data-stu-id="c080f-133">You can change the detached child task in the previous example to an attached child task by using the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option in the task creation statement, as shown in the following example.</span></span> <span data-ttu-id="c080f-134">在此代码中，附加子任务会在父任务之前完成。</span><span class="sxs-lookup"><span data-stu-id="c080f-134">In this code, the attached child task completes before its parent.</span></span> <span data-ttu-id="c080f-135">因此，每次运行代码时，该示例的输出都是相同的。</span><span class="sxs-lookup"><span data-stu-id="c080f-135">As a result, the output from the example is the same each time you run the code.</span></span>  
  
 [!code-csharp[TPL_ChildTasks#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_childtasks/cs/child1.cs#2)]
 [!code-vb[TPL_ChildTasks#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_childtasks/vb/child1.vb#2)]  
  
 <span data-ttu-id="c080f-136">可以使用附加子任务，创建异步操作的紧密同步关系图。</span><span class="sxs-lookup"><span data-stu-id="c080f-136">You can use attached child tasks to create tightly synchronized graphs of asynchronous operations.</span></span>  
  
 <span data-ttu-id="c080f-137">但是，子任务仅在其父任务不会阻止附加子任务时，才可以附加到其父任务。</span><span class="sxs-lookup"><span data-stu-id="c080f-137">However, a child task can attach to its parent only if its parent does not prohibit attached child tasks.</span></span> <span data-ttu-id="c080f-138">通过在父任务类构造函数中指定 <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>选项或 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> 方法，父任务可以显式阻止子任务附加到其中。</span><span class="sxs-lookup"><span data-stu-id="c080f-138">Parent tasks can explicitly prevent child tasks from attaching to them by specifying the <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> option in the parent task's class constructor or the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c080f-139">如果父任务是通过调用 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> 方法而创建的，则可以隐式阻止子任务附加到其中。</span><span class="sxs-lookup"><span data-stu-id="c080f-139">Parent tasks implicitly prevent child tasks from attaching to them if they are created by calling the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c080f-140">下面的示例阐释了这一点。</span><span class="sxs-lookup"><span data-stu-id="c080f-140">The following example illustrates this.</span></span> <span data-ttu-id="c080f-141">这与上述示例相同，除了该父任务是通过调用 <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> 方法，而不是 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> 方法创建的。</span><span class="sxs-lookup"><span data-stu-id="c080f-141">It is identical to the previous example, except that the parent task is created by calling the <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> method rather than the <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c080f-142">因为子任务不能附加到其父任务，则该示例的输出是不可预知的。</span><span class="sxs-lookup"><span data-stu-id="c080f-142">Because the child task is not able to attach to its parent, the output from the example is unpredictable.</span></span> <span data-ttu-id="c080f-143">因为 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> 重载的默认任务创建选项包括 <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>，所以本示例在功能上等效于“分离子任务”部分中的第一个示例。</span><span class="sxs-lookup"><span data-stu-id="c080f-143">Because the default task creation options for the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> overloads include <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>, this example is functionally equivalent to the first example in the "Detached child tasks" section.</span></span>  
  
 [!code-csharp[TPL_ChildTasks#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_childtasks/cs/child1a.cs#3)]
 [!code-vb[TPL_ChildTasks#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_childtasks/vb/child1a.vb#3)]  
  
## <a name="exceptions-in-child-tasks"></a><span data-ttu-id="c080f-144">子任务中的异常</span><span class="sxs-lookup"><span data-stu-id="c080f-144">Exceptions in child tasks</span></span>  
 <span data-ttu-id="c080f-145">如果分离子任务引发了异常，则该异常必须直接在父任务中进行观察和处理，正如任何非嵌套任务一样。</span><span class="sxs-lookup"><span data-stu-id="c080f-145">If a detached child task throws an exception, that exception must be observed or handled directly in the parent task just as with any non-nested task.</span></span> <span data-ttu-id="c080f-146">如果附加子任务引发了异常，则该异常会自动传播到父任务，并返回到等待或尝试访问任务的 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 属性的线程。</span><span class="sxs-lookup"><span data-stu-id="c080f-146">If an attached child task throws an exception, the exception is automatically propagated to the parent task and back to the thread that waits or tries to access the task's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="c080f-147">因此，通过使用附加子任务，可以一次性处理调用线程上对 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 的调用中的所有异常。</span><span class="sxs-lookup"><span data-stu-id="c080f-147">Therefore, by using attached child tasks, you can handle all exceptions at just one point in the call to <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> on the calling thread.</span></span> <span data-ttu-id="c080f-148">有关详细信息，请参阅[异常处理](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="c080f-148">For more information, see [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
## <a name="cancellation-and-child-tasks"></a><span data-ttu-id="c080f-149">取消和子任务</span><span class="sxs-lookup"><span data-stu-id="c080f-149">Cancellation and child tasks</span></span>  
 <span data-ttu-id="c080f-150">任务取消需要彼此协作。</span><span class="sxs-lookup"><span data-stu-id="c080f-150">Task cancellation is cooperative.</span></span> <span data-ttu-id="c080f-151">也就是说，若要取消任务，则每个附加或分离的子任务必须监视取消标记的状态。</span><span class="sxs-lookup"><span data-stu-id="c080f-151">That is, to be cancelable, every attached or detached child task must monitor the status of the cancellation token.</span></span> <span data-ttu-id="c080f-152">如果想要通过使用一个取消请求来取消父任务及其所有子任务，则需要将作为自变量的相同令牌传递到所有的任务，并在每个任务中提供逻辑，以对每个任务中的请求作出响应。</span><span class="sxs-lookup"><span data-stu-id="c080f-152">If you want to cancel a parent and all its children by using one cancellation request, you pass the same token as an argument to all tasks and provide in each task the logic to respond to the request in each task.</span></span> <span data-ttu-id="c080f-153">有关详细信息，请参阅[任务取消](../../../docs/standard/parallel-programming/task-cancellation.md)和[如何：取消任务及其子任务](../../../docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md)。</span><span class="sxs-lookup"><span data-stu-id="c080f-153">For more information, see [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md) and [How to: Cancel a Task and Its Children](../../../docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).</span></span>  
  
### <a name="when-the-parent-cancels"></a><span data-ttu-id="c080f-154">当父任务取消时</span><span class="sxs-lookup"><span data-stu-id="c080f-154">When the parent cancels</span></span>  
 <span data-ttu-id="c080f-155">如果父任务在其子任务开始前取消了自身，则子任务将永远不会开始。</span><span class="sxs-lookup"><span data-stu-id="c080f-155">If a parent cancels itself before its child task is started, the child never starts.</span></span> <span data-ttu-id="c080f-156">如果父任务在其子任务已开始后取消了自身，则子任务将完成运行，除非它自己具有取消逻辑。</span><span class="sxs-lookup"><span data-stu-id="c080f-156">If a parent cancels itself after its child task has already started, the child runs to completion unless it has its own cancellation logic.</span></span> <span data-ttu-id="c080f-157">有关详细信息，请参阅[任务取消](../../../docs/standard/parallel-programming/task-cancellation.md)。</span><span class="sxs-lookup"><span data-stu-id="c080f-157">For more information, see [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md).</span></span>  
  
### <a name="when-a-detached-child-task-cancels"></a><span data-ttu-id="c080f-158">当分离子任务取消时</span><span class="sxs-lookup"><span data-stu-id="c080f-158">When a detached child task cancels</span></span>  
 <span data-ttu-id="c080f-159">如果分离子任务使用传递到父任务的相同标记取消自身，且父任务不会等待子任务，则不会传播异常，因为该异常将被视为良性协作取消。</span><span class="sxs-lookup"><span data-stu-id="c080f-159">If a detached child task cancels itself by using the same token that was passed to the parent, and the parent does not wait for the child task, no exception is propagated, because the exception is treated as benign cooperation cancellation.</span></span> <span data-ttu-id="c080f-160">此行为与任何顶级任务的行为相同。</span><span class="sxs-lookup"><span data-stu-id="c080f-160">This behavior is the same as that of any top-level task.</span></span>  
  
### <a name="when-an-attached-child-task-cancels"></a><span data-ttu-id="c080f-161">当附加子任务取消时</span><span class="sxs-lookup"><span data-stu-id="c080f-161">When an attached child task cancels</span></span>  
 <span data-ttu-id="c080f-162">当附加子任务使用传递到其父任务的相同标记取消自身时，<xref:System.Threading.Tasks.TaskCanceledException> 将传播到 <xref:System.AggregateException> 中的联接线程。</span><span class="sxs-lookup"><span data-stu-id="c080f-162">When an attached child task cancels itself by using the same token that was passed to its parent task, a <xref:System.Threading.Tasks.TaskCanceledException> is propagated to the joining thread inside an <xref:System.AggregateException>.</span></span> <span data-ttu-id="c080f-163">必须等待父任务，以便你除了所有通过附加子任务的图形传播的错误异常之外，还可以处理所有良性异常。</span><span class="sxs-lookup"><span data-stu-id="c080f-163">You must wait for the parent task so that you can handle all benign exceptions in addition to all faulting exceptions that are propagated up through a graph of attached child tasks.</span></span>  
  
 <span data-ttu-id="c080f-164">有关详细信息，请参阅[异常处理](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="c080f-164">For more information, see [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
## <a name="preventing-a-child-task-from-attaching-to-its-parent"></a><span data-ttu-id="c080f-165">阻止子任务附加到其父任务</span><span class="sxs-lookup"><span data-stu-id="c080f-165">Preventing a child task from attaching to its parent</span></span>  
 <span data-ttu-id="c080f-166">由子任务引发的未经处理的异常将传播到父任务中。</span><span class="sxs-lookup"><span data-stu-id="c080f-166">An unhandled exception that is thrown by a child task is propagated to the parent task.</span></span> <span data-ttu-id="c080f-167">可以使用此行为，从一个根任务而无需遍历任务树来观察所有子任务异常。</span><span class="sxs-lookup"><span data-stu-id="c080f-167">You can use this behavior to observe all child task exceptions from one root task instead of traversing a tree of tasks.</span></span> <span data-ttu-id="c080f-168">但是，当父任务不需要其他代码的附件时，异常传播可能会产生问题。</span><span class="sxs-lookup"><span data-stu-id="c080f-168">However, exception propagation can be problematic when a parent task does not expect attachment from other code.</span></span> <span data-ttu-id="c080f-169">例如，设想下从 <xref:System.Threading.Tasks.Task> 对象调用第三方库组件的应用。</span><span class="sxs-lookup"><span data-stu-id="c080f-169">For example, consider an app that calls a third-party library component from a <xref:System.Threading.Tasks.Task> object.</span></span> <span data-ttu-id="c080f-170">如果第三方库组件也创建一个 <xref:System.Threading.Tasks.Task> 对象，并指定 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> 以将其附加到父任务中，则子任务中出现的任何未经处理的异常将会传播到父任务。</span><span class="sxs-lookup"><span data-stu-id="c080f-170">If the third-party library component also creates a <xref:System.Threading.Tasks.Task> object and specifies <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> to attach it to the parent task, any unhandled exceptions that occur in the child task propagate to the parent.</span></span> <span data-ttu-id="c080f-171">这可能会导致主应用中出现意外行为。</span><span class="sxs-lookup"><span data-stu-id="c080f-171">This could lead to unexpected behavior in the main app.</span></span>  
  
 <span data-ttu-id="c080f-172">若要防止子任务附加到其父任务，请在创建父任务 <xref:System.Threading.Tasks.Task> 或 <xref:System.Threading.Tasks.Task%601> 对象时，指定 <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> 选项。</span><span class="sxs-lookup"><span data-stu-id="c080f-172">To prevent a child task from attaching to its parent task, specify the <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> option when you create the parent <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object.</span></span> <span data-ttu-id="c080f-173">当某项任务尝试附加到其父任务，且其父任务指定了 <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> 选项时，则子任务将不能附加到父任务，并且将像未指定 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> 选项一样进行执行。</span><span class="sxs-lookup"><span data-stu-id="c080f-173">When a task tries to attach to its parent and the parent specifies the <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> option, the child task will not be able to attach to a parent and will execute just as if the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option was not specified.</span></span>  
  
 <span data-ttu-id="c080f-174">可能还想要防止子任务在没有及时完成时附加到其父任务。</span><span class="sxs-lookup"><span data-stu-id="c080f-174">You might also want to prevent a child task from attaching to its parent when the child task does not finish in a timely manner.</span></span> <span data-ttu-id="c080f-175">因为父任务只有在所有子任务完成后才会完成，所以长时间运行的子任务会使整个应用执行得非常缓慢。</span><span class="sxs-lookup"><span data-stu-id="c080f-175">Because a parent task does not finish until all child tasks finish, a long-running child task can cause the overall app to perform poorly.</span></span> <span data-ttu-id="c080f-176">有关展示了如何通过防止子任务附加到父任务来提升应用性能的示例，请参阅[如何：防止子任务附加到父任务](../../../docs/standard/parallel-programming/how-to-prevent-a-child-task-from-attaching-to-its-parent.md)。</span><span class="sxs-lookup"><span data-stu-id="c080f-176">For an example that shows how to improve app performance by preventing a task from attaching to its parent task, see [How to: Prevent a Child Task from Attaching to its Parent](../../../docs/standard/parallel-programming/how-to-prevent-a-child-task-from-attaching-to-its-parent.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c080f-177">请参阅</span><span class="sxs-lookup"><span data-stu-id="c080f-177">See Also</span></span>  
 [<span data-ttu-id="c080f-178">并行编程</span><span class="sxs-lookup"><span data-stu-id="c080f-178">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)  
 [<span data-ttu-id="c080f-179">数据并行</span><span class="sxs-lookup"><span data-stu-id="c080f-179">Data Parallelism</span></span>](../../../docs/standard/parallel-programming/data-parallelism-task-parallel-library.md)
