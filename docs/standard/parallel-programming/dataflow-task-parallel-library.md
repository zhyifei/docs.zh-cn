---
title: 数据流（任务并行库）
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Task Parallel Library, dataflows
- TPL dataflow library
ms.assetid: 643575d0-d26d-4c35-8de7-a9c403e97dd6
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: d44ec0e0601383133e6c59e44cd81031918d4b6d
ms.sourcegitcommit: efff8f331fd9467f093f8ab8d23a203d6ecb5b60
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/02/2018
ms.locfileid: "43385853"
---
# <a name="dataflow-task-parallel-library"></a><span data-ttu-id="f6a47-102">数据流（任务并行库）</span><span class="sxs-lookup"><span data-stu-id="f6a47-102">Dataflow (Task Parallel Library)</span></span>
<a name="top"></a> <span data-ttu-id="f6a47-103">任务并行库 (TPL) 提供数据流组件，可帮助提高启用并发的应用程序的可靠性。</span><span class="sxs-lookup"><span data-stu-id="f6a47-103">The Task Parallel Library (TPL) provides dataflow components to help increase the robustness of concurrency-enabled applications.</span></span> <span data-ttu-id="f6a47-104">这些数据流组件统称为 TPL 数据流库。</span><span class="sxs-lookup"><span data-stu-id="f6a47-104">These dataflow components are collectively referred to as the *TPL Dataflow Library*.</span></span> <span data-ttu-id="f6a47-105">这种数据流模型通过向粗粒度的数据流和管道任务提供进程内消息传递来促进基于角色的编程。</span><span class="sxs-lookup"><span data-stu-id="f6a47-105">This dataflow model promotes actor-based programming by providing in-process message passing for coarse-grained dataflow and pipelining tasks.</span></span> <span data-ttu-id="f6a47-106">数据流组件基于 TPL 的类型和计划基础结构，并集成了 C#、Visual Basic 和 F# 语言的异步编程支持。</span><span class="sxs-lookup"><span data-stu-id="f6a47-106">The dataflow components build on the types and scheduling infrastructure of the TPL and integrate with the C#, Visual Basic, and F# language support for asynchronous programming.</span></span> <span data-ttu-id="f6a47-107">当您有必须相互异步沟通的多个操作或者想要在数据可用时对其处理时，这些数据流组件就非常有用。</span><span class="sxs-lookup"><span data-stu-id="f6a47-107">These dataflow components are useful when you have multiple operations that must communicate with one another asynchronously or when you want to process data as it becomes available.</span></span> <span data-ttu-id="f6a47-108">例如，请考虑一个处理网络摄像机图像数据的应用程序。</span><span class="sxs-lookup"><span data-stu-id="f6a47-108">For example, consider an application that processes image data from a web camera.</span></span> <span data-ttu-id="f6a47-109">通过使用数据流模型，当图像帧可用时，应用程序就可以处理它们。</span><span class="sxs-lookup"><span data-stu-id="f6a47-109">By using the dataflow model, the application can process image frames as they become available.</span></span> <span data-ttu-id="f6a47-110">如果应用程序增强图像帧（例如执行灯光修正或消除红眼），则可以创建数据流组件的管道。</span><span class="sxs-lookup"><span data-stu-id="f6a47-110">If the application enhances image frames, for example, by performing light correction or red-eye reduction, you can create a *pipeline* of dataflow components.</span></span> <span data-ttu-id="f6a47-111">管道的每个阶段可以使用更粗粒度的并行功能（例如 TPL 提供的功能）来转换图像。</span><span class="sxs-lookup"><span data-stu-id="f6a47-111">Each stage of the pipeline might use more coarse-grained parallelism functionality, such as the functionality that is provided by the TPL, to transform the image.</span></span>  
  
 <span data-ttu-id="f6a47-112">本文档对 TPL 数据流库进行了概述。</span><span class="sxs-lookup"><span data-stu-id="f6a47-112">This document provides an overview of the TPL Dataflow Library.</span></span> <span data-ttu-id="f6a47-113">它介绍编程模型，预定义的数据流块类型，以及如何配置数据流块来满足应用程序的特定要求。</span><span class="sxs-lookup"><span data-stu-id="f6a47-113">It describes the programming model, the predefined dataflow block types, and how to configure dataflow blocks to meet the specific requirements of your applications.</span></span>  

[!INCLUDE [tpl-install-instructions](../../../includes/tpl-install-instructions.md)]
  
 <span data-ttu-id="f6a47-114">本文档包含以下各节：</span><span class="sxs-lookup"><span data-stu-id="f6a47-114">This document contains the following sections:</span></span>  
  
-   [<span data-ttu-id="f6a47-115">编程模型</span><span class="sxs-lookup"><span data-stu-id="f6a47-115">Programming Model</span></span>](#model)  
  
-   [<span data-ttu-id="f6a47-116">预定义的数据流块类型</span><span class="sxs-lookup"><span data-stu-id="f6a47-116">Predefined Dataflow Block Types</span></span>](#predefined_types)  
  
-   [<span data-ttu-id="f6a47-117">配置数据流块行为</span><span class="sxs-lookup"><span data-stu-id="f6a47-117">Configuring Dataflow Block Behavior</span></span>](#behavior)  
  
-   [<span data-ttu-id="f6a47-118">自定义数据流块</span><span class="sxs-lookup"><span data-stu-id="f6a47-118">Custom Dataflow Blocks</span></span>](#custom)  
  
<a name="model"></a>   
## <a name="programming-model"></a><span data-ttu-id="f6a47-119">编程模型</span><span class="sxs-lookup"><span data-stu-id="f6a47-119">Programming Model</span></span>  
 <span data-ttu-id="f6a47-120">TPL 数据流库向具有高吞吐量和低滞后时间的占用大量 CPU 和 I/O 操作的应用程序的并行化和消息传递提供了基础。</span><span class="sxs-lookup"><span data-stu-id="f6a47-120">The TPL Dataflow Library provides a foundation for message passing and parallelizing CPU-intensive and I/O-intensive applications that have high throughput and low latency.</span></span> <span data-ttu-id="f6a47-121">它还能显式控制缓存数据的方式以及在系统中移动的方式。</span><span class="sxs-lookup"><span data-stu-id="f6a47-121">It also gives you explicit control over how data is buffered and moves around the system.</span></span> <span data-ttu-id="f6a47-122">为了更好地了解数据流编程模型，请考虑一个以异步方式从磁盘加载图像并创建复合图像的应用程序。</span><span class="sxs-lookup"><span data-stu-id="f6a47-122">To better understand the dataflow programming model, consider an application that asynchronously loads images from disk and creates a composite of those images.</span></span> <span data-ttu-id="f6a47-123">传统编程模型通常需要使用回调和同步对象（例如锁）来协调任务和访问共享数据。</span><span class="sxs-lookup"><span data-stu-id="f6a47-123">Traditional programming models typically require that you use callbacks and synchronization objects, such as locks, to coordinate tasks and access to shared data.</span></span> <span data-ttu-id="f6a47-124">通过使用数据流编程模型，您可以从磁盘读取时创建处理图像的数据流对象。</span><span class="sxs-lookup"><span data-stu-id="f6a47-124">By using the dataflow programming model, you can create dataflow objects that process images as they are read from disk.</span></span> <span data-ttu-id="f6a47-125">在数据流模型下，您可以声明当数据可用时的处理方式，以及数据之间的所有依赖项。</span><span class="sxs-lookup"><span data-stu-id="f6a47-125">Under the dataflow model, you declare how data is handled when it becomes available, and also any dependencies between data.</span></span> <span data-ttu-id="f6a47-126">由于运行时管理数据之间的依赖项，因此通常可以避免这种要求来同步访问共享数据。</span><span class="sxs-lookup"><span data-stu-id="f6a47-126">Because the runtime manages dependencies between data, you can often avoid the requirement to synchronize access to shared data.</span></span> <span data-ttu-id="f6a47-127">此外，因为运行时计划基于数据的异步到达，所以数据流可以通过有效管理基础线程提高响应能力和吞吐量。</span><span class="sxs-lookup"><span data-stu-id="f6a47-127">In addition, because the runtime schedules work based on the asynchronous arrival of data, dataflow can improve responsiveness and throughput by efficiently managing the underlying threads.</span></span> <span data-ttu-id="f6a47-128">有关在 Windows 窗体应用程序中使用数据流编程模型实现图像处理的示例，请参阅[演练：在 Windows 窗体应用程序中使用数据流](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)。</span><span class="sxs-lookup"><span data-stu-id="f6a47-128">For an example that uses the dataflow programming model to implement image processing in a Windows Forms application, see [Walkthrough: Using Dataflow in a Windows Forms Application](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).</span></span>  
  
### <a name="sources-and-targets"></a><span data-ttu-id="f6a47-129">源和目标</span><span class="sxs-lookup"><span data-stu-id="f6a47-129">Sources and Targets</span></span>  
 <span data-ttu-id="f6a47-130">TPL 数据流库包括*数据流块*，它是缓冲并处理数据的数据结构。</span><span class="sxs-lookup"><span data-stu-id="f6a47-130">The TPL Dataflow Library consists of *dataflow blocks*, which are data structures that buffer and process data.</span></span> <span data-ttu-id="f6a47-131">TPL 定义了三种数据流块：源块、目标块和传播器块。</span><span class="sxs-lookup"><span data-stu-id="f6a47-131">The TPL defines three kinds of dataflow blocks: *source blocks*, *target blocks*, and *propagator blocks*.</span></span> <span data-ttu-id="f6a47-132">源块作为数据源，可以读取。</span><span class="sxs-lookup"><span data-stu-id="f6a47-132">A source block acts as a source of data and can be read from.</span></span> <span data-ttu-id="f6a47-133">目标块作为数据接收方，可以写入。</span><span class="sxs-lookup"><span data-stu-id="f6a47-133">A target block acts as a receiver of data and can be written to.</span></span> <span data-ttu-id="f6a47-134">传播器块作为源块和目标块，可以读取和写入。</span><span class="sxs-lookup"><span data-stu-id="f6a47-134">A propagator block acts as both a source block and a target block, and can be read from and written to.</span></span> <span data-ttu-id="f6a47-135">TPL 定义 <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601?displayProperty=nameWithType> 接口来表示源，<xref:System.Threading.Tasks.Dataflow.ITargetBlock%601?displayProperty=nameWithType> 表示目标以及 <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602?displayProperty=nameWithType> 表示传播器。</span><span class="sxs-lookup"><span data-stu-id="f6a47-135">The TPL defines the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601?displayProperty=nameWithType> interface to represent sources, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601?displayProperty=nameWithType> to represent targets, and <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602?displayProperty=nameWithType> to represent propagators.</span></span> <span data-ttu-id="f6a47-136"><xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> 继承自 <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> 和 <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>。</span><span class="sxs-lookup"><span data-stu-id="f6a47-136"><xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> inherits from both <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, and <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.</span></span>  
  
 <span data-ttu-id="f6a47-137">TPL 数据流库提供了多个预定义的数据流块类型，可以实现 <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>、<xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> 和 <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> 接口。</span><span class="sxs-lookup"><span data-stu-id="f6a47-137">The TPL Dataflow Library provides several predefined dataflow block types that implement the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>, and <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> interfaces.</span></span> <span data-ttu-id="f6a47-138">这些数据流块类型在本文档的[预定义的数据流块类型](#predefined_types)部分进行了说明。</span><span class="sxs-lookup"><span data-stu-id="f6a47-138">These dataflow block types are described in this document in the section [Predefined Dataflow Block Types](#predefined_types).</span></span>  
  
### <a name="connecting-blocks"></a><span data-ttu-id="f6a47-139">连接块</span><span class="sxs-lookup"><span data-stu-id="f6a47-139">Connecting Blocks</span></span>  
 <span data-ttu-id="f6a47-140">可以连接数据流块来形成管道（这是数据流块的线性序列），或网络（这是数据流块的图形）。</span><span class="sxs-lookup"><span data-stu-id="f6a47-140">You can connect dataflow blocks to form *pipelines*, which are linear sequences of dataflow blocks, or *networks*, which are graphs of dataflow blocks.</span></span> <span data-ttu-id="f6a47-141">管道是网络的一种形式。</span><span class="sxs-lookup"><span data-stu-id="f6a47-141">A pipeline is one form of network.</span></span> <span data-ttu-id="f6a47-142">在管道或网络中，当数据可用时源向目标异步传播数据。</span><span class="sxs-lookup"><span data-stu-id="f6a47-142">In a pipeline or network, sources asynchronously propagate data to targets as that data becomes available.</span></span> <span data-ttu-id="f6a47-143"><xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> 方法将源数据流块链接到目标块。</span><span class="sxs-lookup"><span data-stu-id="f6a47-143">The <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> method links a source dataflow block to a target block.</span></span> <span data-ttu-id="f6a47-144">源可以链接到零个或多个目标；目标可以从零个或多个源进行链接。</span><span class="sxs-lookup"><span data-stu-id="f6a47-144">A source can be linked to zero or more targets; targets can be linked from zero or more sources.</span></span> <span data-ttu-id="f6a47-145">您可以同时向管道或网络中添加或从其移除数据流块。</span><span class="sxs-lookup"><span data-stu-id="f6a47-145">You can add or remove dataflow blocks to or from a pipeline or network concurrently.</span></span> <span data-ttu-id="f6a47-146">预定义的数据流块类型处理所有的建立或释放链接的线程安全性。</span><span class="sxs-lookup"><span data-stu-id="f6a47-146">The predefined dataflow block types handle all thread-safety aspects of linking and unlinking.</span></span>  
  
 <span data-ttu-id="f6a47-147">有关连接数据流块以形成基本管道的示例，请参阅[演练：创建数据流管道](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md)。</span><span class="sxs-lookup"><span data-stu-id="f6a47-147">For an example that connects dataflow blocks to form a basic pipeline, see [Walkthrough: Creating a Dataflow Pipeline](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md).</span></span> <span data-ttu-id="f6a47-148">有关连接数据流块以形成更复杂的网络的示例，请参阅[演练：在 Windows 窗体应用程序中使用数据流](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)。</span><span class="sxs-lookup"><span data-stu-id="f6a47-148">For an example that connects dataflow blocks to form a more complex network, see [Walkthrough: Using Dataflow in a Windows Forms Application](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).</span></span> <span data-ttu-id="f6a47-149">有关源向目标传递消息后从源取消目标链接的示例，请参阅[如何：取消链接数据流块](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md)。</span><span class="sxs-lookup"><span data-stu-id="f6a47-149">For an example that unlinks a target from a source after the source offers the target a message, see [How to: Unlink Dataflow Blocks](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md).</span></span>  
  
#### <a name="filtering"></a><span data-ttu-id="f6a47-150">筛选</span><span class="sxs-lookup"><span data-stu-id="f6a47-150">Filtering</span></span>  
 <span data-ttu-id="f6a47-151">当您调用 <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> 方法将源链接到目标时，您可以根据消息的值提供一个委托来决定目标块是接受还是拒绝该消息。</span><span class="sxs-lookup"><span data-stu-id="f6a47-151">When you call the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> method to link a source to a target, you can supply a delegate that determines whether the target block accepts or rejects a message based on the value of that message.</span></span> <span data-ttu-id="f6a47-152">这种筛选机制很有用，它可以保证数据流块只接收特定值。</span><span class="sxs-lookup"><span data-stu-id="f6a47-152">This filtering mechanism is a useful way to guarantee that a dataflow block receives only certain values.</span></span> <span data-ttu-id="f6a47-153">对于大多数预定义的数据流块类型，如果源块连接到多个目标块，那么当目标块拒绝消息时，源将向下一个目标提供该消息。</span><span class="sxs-lookup"><span data-stu-id="f6a47-153">For most of the predefined dataflow block types, if a source block is connected to multiple target blocks, when a target block rejects a message, the source offers that message to the next target.</span></span> <span data-ttu-id="f6a47-154">源向目标提供消息的顺序是按源定义的，可以根据源类型的不同而不同。</span><span class="sxs-lookup"><span data-stu-id="f6a47-154">The order in which a source offers messages to targets is defined by the source and can vary according to the type of the source.</span></span> <span data-ttu-id="f6a47-155">一个目标接受消息后，大多数源块类型会停止提供该消息。</span><span class="sxs-lookup"><span data-stu-id="f6a47-155">Most source block types stop offering a message after one target accepts that message.</span></span> <span data-ttu-id="f6a47-156">此规则的例外情况是 <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> 类，这个类向所有目标提供每条消息，即使某些目标拒绝消息。</span><span class="sxs-lookup"><span data-stu-id="f6a47-156">One exception to this rule is the <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> class, which offers each message to all targets, even if some targets reject the message.</span></span> <span data-ttu-id="f6a47-157">有关使用筛选来仅处理特定消息的示例，请参阅[演练：在 Windows 窗体应用程序中使用数据流](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)。</span><span class="sxs-lookup"><span data-stu-id="f6a47-157">For an example that uses filtering to process only certain messages, see [Walkthrough: Using Dataflow in a Windows Forms Application](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f6a47-158">由于每个预定义源数据流块类型确保了消息是按照它们接收的顺序来传播的，因此每一条消息都必须在源块可以处理下一条消息之前从源块读取。</span><span class="sxs-lookup"><span data-stu-id="f6a47-158">Because each predefined source dataflow block type guarantees that messages are propagated out in the order in which they are received, every message must be read from the source block before the source block can process the next message.</span></span> <span data-ttu-id="f6a47-159">因此，当您使用筛选向一个源连接多个目标时，请确保至少一个目标块能够接收每一条消息。</span><span class="sxs-lookup"><span data-stu-id="f6a47-159">Therefore, when you use filtering to connect multiple targets to a source, make sure that at least one target block receives each message.</span></span> <span data-ttu-id="f6a47-160">否则，您的应用程序可能发生死锁。</span><span class="sxs-lookup"><span data-stu-id="f6a47-160">Otherwise, your application might deadlock.</span></span>  
  
### <a name="message-passing"></a><span data-ttu-id="f6a47-161">消息传递</span><span class="sxs-lookup"><span data-stu-id="f6a47-161">Message Passing</span></span>  
 <span data-ttu-id="f6a47-162">数据流编程模型与*消息传递*这一概念相关，其中程序的独立组件通过发送消息相互通信。</span><span class="sxs-lookup"><span data-stu-id="f6a47-162">The dataflow programming model is related to the concept of *message passing*, where independent components of a program communicate with one another by sending messages.</span></span> <span data-ttu-id="f6a47-163">在应用组件间传播消息的一种方法是，调用 <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> 和 <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A?displayProperty=nameWithType> 方法，向目标数据流块发送消息（<xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> 同步运行，<xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A> 异步运行），再调用 <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Receive%2A>、<xref:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync%2A> 和 <xref:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive%2A> 方法接收源数据流块发送的消息。</span><span class="sxs-lookup"><span data-stu-id="f6a47-163">One way to propagate messages among application components is to call the <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> and <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A?displayProperty=nameWithType> methods to send messages to target dataflow blocks post (<xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> acts synchronously; <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A> acts asynchronously) and the <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Receive%2A>, <xref:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync%2A>, and <xref:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive%2A> methods to receive messages from source blocks.</span></span> <span data-ttu-id="f6a47-164">您可以通过向头节点（目标块）发送输入数据，从管道的终端节点或网络的终端节点（一个或多个源块）接收输出数据来使用数据流管道或网络组合使用这些方法。</span><span class="sxs-lookup"><span data-stu-id="f6a47-164">You can combine these methods with dataflow pipelines or networks by sending input data to the head node (a target block), and receiving output data from the terminal node of the pipeline or the terminal nodes of the network (one or more source blocks).</span></span> <span data-ttu-id="f6a47-165">您还可以使用 <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Choose%2A> 方法从提供的第一个拥有可用数据的源读取数据，并对该数据执行操作。</span><span class="sxs-lookup"><span data-stu-id="f6a47-165">You can also use the <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Choose%2A> method to read from the first of the provided sources that has data available and perform action on that data.</span></span>  
  
 <span data-ttu-id="f6a47-166">源数据流块通过调用方法 <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A?displayProperty=nameWithType> 向目标数据流块提供数据。</span><span class="sxs-lookup"><span data-stu-id="f6a47-166">Source blocks offer data to target blocks by calling the <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f6a47-167">目标块通过以下三种方式之一来回应提供的消息：它可以接受消息，拒绝消息或推迟消息。</span><span class="sxs-lookup"><span data-stu-id="f6a47-167">The target block responds to an offered message in one of three ways: it can accept the message, decline the message, or postpone the message.</span></span> <span data-ttu-id="f6a47-168">当目标接受消息时，<xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> 方法会返回 <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted>。</span><span class="sxs-lookup"><span data-stu-id="f6a47-168">When the target accepts the message, the <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> method returns <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted>.</span></span> <span data-ttu-id="f6a47-169">当目标拒绝消息时，<xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> 方法会返回 <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined>。</span><span class="sxs-lookup"><span data-stu-id="f6a47-169">When the target declines the message, the <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> method returns <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined>.</span></span> <span data-ttu-id="f6a47-170">当目标要求它不再接收来自源的任何消息时，<xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> 会返回 <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently>。</span><span class="sxs-lookup"><span data-stu-id="f6a47-170">When the target requires that it no longer receives any messages from the source, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> returns <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently>.</span></span> <span data-ttu-id="f6a47-171">预定义的源块类型在这些返回值接收后不会向链接的目标提供消息，并且它们会自动取消这些目标的链接。</span><span class="sxs-lookup"><span data-stu-id="f6a47-171">The predefined source block types do not offer messages to linked targets after such a return value is received, and they automatically unlink from such targets.</span></span>  
  
 <span data-ttu-id="f6a47-172">当目标块推迟消息以备日后使用时，<xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> 方法会返回 <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed>。</span><span class="sxs-lookup"><span data-stu-id="f6a47-172">When a target block postpones the message for later use, the <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> method returns <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed>.</span></span> <span data-ttu-id="f6a47-173">推迟消息的目标块可以稍后调用 <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A?displayProperty=nameWithType> 方法，以尝试暂留所提供的消息。</span><span class="sxs-lookup"><span data-stu-id="f6a47-173">A target block that postpones a message can later call the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A?displayProperty=nameWithType> method to try to reserve the offered message.</span></span> <span data-ttu-id="f6a47-174">此时，消息仍可用，并且可由该目标块使用，否则表明该消息已由另一个目标接收。</span><span class="sxs-lookup"><span data-stu-id="f6a47-174">At this point, the message is either still available and can be used by the target block, or the message has been taken by another target.</span></span> <span data-ttu-id="f6a47-175">如果目标数据流块稍后需要消息或不再需要消息，它会分别调用 <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> 或 <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f6a47-175">When the target block later requires the message or no longer needs the message, it calls the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> or <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A> method, respectively.</span></span> <span data-ttu-id="f6a47-176">消息预留通常由以非贪婪模式运行的数据流块类型使用。</span><span class="sxs-lookup"><span data-stu-id="f6a47-176">Message reservation is typically used by the dataflow block types that operate in non-greedy mode.</span></span> <span data-ttu-id="f6a47-177">非贪婪模式将在本文档的后面详细介绍。</span><span class="sxs-lookup"><span data-stu-id="f6a47-177">Non-greedy mode is explained later in this document.</span></span> <span data-ttu-id="f6a47-178">除了保留推迟的消息，目标块也可以使用 <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> 方法来尝试直接使用推迟的消息。</span><span class="sxs-lookup"><span data-stu-id="f6a47-178">Instead of reserving a postponed message, a target block can also use the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> method to attempt to directly consume the postponed message.</span></span>  
  
### <a name="dataflow-block-completion"></a><span data-ttu-id="f6a47-179">数据流块完成</span><span class="sxs-lookup"><span data-stu-id="f6a47-179">Dataflow Block Completion</span></span>  
 <span data-ttu-id="f6a47-180">数据流块也支持完成概念。</span><span class="sxs-lookup"><span data-stu-id="f6a47-180">Dataflow blocks also support the concept of *completion*.</span></span> <span data-ttu-id="f6a47-181">完成状态的数据流块不执行任何进一步的工作。</span><span class="sxs-lookup"><span data-stu-id="f6a47-181">A dataflow block that is in the completed state does not perform any further work.</span></span> <span data-ttu-id="f6a47-182">每个数据流块都有相关的 <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 对象（称为“完成任务”），表示数据流块的完成状态。</span><span class="sxs-lookup"><span data-stu-id="f6a47-182">Each dataflow block has an associated <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object, known as a *completion task*, that represents the completion status of the block.</span></span> <span data-ttu-id="f6a47-183">因为您可以使用完成任务等待 <xref:System.Threading.Tasks.Task> 对象完成，所以您可以等待数据流网络的一个或更多终端节点来完成任务。</span><span class="sxs-lookup"><span data-stu-id="f6a47-183">Because you can wait for a <xref:System.Threading.Tasks.Task> object to finish, by using completion tasks, you can wait for one or more terminal nodes of a dataflow network to finish.</span></span> <span data-ttu-id="f6a47-184"><xref:System.Threading.Tasks.Dataflow.IDataflowBlock> 接口定义 <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> 方法（该方法向数据流块通知它完成的请求）和 <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> 属性（该属性返回数据流块的完成任务）。</span><span class="sxs-lookup"><span data-stu-id="f6a47-184">The <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> interface defines the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> method, which informs the dataflow block of a request for it to complete, and the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> property, which returns the completion task for the dataflow block.</span></span> <span data-ttu-id="f6a47-185"><xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> 和 <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> 都继承 <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> 接口。</span><span class="sxs-lookup"><span data-stu-id="f6a47-185">Both <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> and <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> inherit the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> interface.</span></span>  
  
 <span data-ttu-id="f6a47-186">有两种方法来确定数据流块完成时是否没有出错、遇到一个或多个错误或已取消。</span><span class="sxs-lookup"><span data-stu-id="f6a47-186">There are two ways to determine whether a dataflow block completed without error, encountered one or more errors, or was canceled.</span></span> <span data-ttu-id="f6a47-187">第一种方法是在 `try`-`catch` 块（在 Visual Basic 中为 `Try`-`Catch`）中对完成任务调用 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="f6a47-187">The first way is to call the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method on the completion task in a `try`-`catch` block (`Try`-`Catch` in Visual Basic).</span></span> <span data-ttu-id="f6a47-188">下面的示例创建一个 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 对象，该对象在其输入值小于零时会引发 <xref:System.ArgumentOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="f6a47-188">The following example creates an <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object that throws <xref:System.ArgumentOutOfRangeException> if its input value is less than zero.</span></span> <span data-ttu-id="f6a47-189">当此示例在完成任务后调用 <xref:System.AggregateException> 时，将引发 <xref:System.Threading.Tasks.Task.Wait%2A>。</span><span class="sxs-lookup"><span data-stu-id="f6a47-189"><xref:System.AggregateException> is thrown when this example calls <xref:System.Threading.Tasks.Task.Wait%2A> on the completion task.</span></span> <span data-ttu-id="f6a47-190">通过 <xref:System.ArgumentOutOfRangeException> 对象的 <xref:System.AggregateException.InnerExceptions%2A> 属性来访问 <xref:System.AggregateException>。</span><span class="sxs-lookup"><span data-stu-id="f6a47-190">The <xref:System.ArgumentOutOfRangeException> is accessed through the <xref:System.AggregateException.InnerExceptions%2A> property of the <xref:System.AggregateException> object.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#10](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#10)]
 [!code-vb[TPLDataflow_Overview#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#10)]  
  
 <span data-ttu-id="f6a47-191">此示例演示在执行数据流块的委托中异常变成不可处理的情况。</span><span class="sxs-lookup"><span data-stu-id="f6a47-191">This example demonstrates the case in which an exception goes unhandled in the delegate of an execution dataflow block.</span></span> <span data-ttu-id="f6a47-192">建议您在这样的块主体中处理异常。</span><span class="sxs-lookup"><span data-stu-id="f6a47-192">We recommend that you handle exceptions in the bodies of such blocks.</span></span> <span data-ttu-id="f6a47-193">然而，你如果没能这么做，块就表现得好像是它被取消了，而且不会处理传入消息。</span><span class="sxs-lookup"><span data-stu-id="f6a47-193">However, if you are unable to do so, the block behaves as though it was canceled and does not process incoming messages.</span></span>  
  
 <span data-ttu-id="f6a47-194">当显式取消数据流块时，<xref:System.AggregateException> 对象在 <xref:System.OperationCanceledException> 属性中包含 <xref:System.AggregateException.InnerExceptions%2A>。</span><span class="sxs-lookup"><span data-stu-id="f6a47-194">When a dataflow block is canceled explicitly, the <xref:System.AggregateException> object contains <xref:System.OperationCanceledException> in the <xref:System.AggregateException.InnerExceptions%2A> property.</span></span> <span data-ttu-id="f6a47-195">有关数据流取消的详细信息，请参阅[启用取消](#enabling-cancellation)部分。</span><span class="sxs-lookup"><span data-stu-id="f6a47-195">For more information about dataflow cancellation, see [Enabling Cancellation](#enabling-cancellation) section.</span></span>  
  
 <span data-ttu-id="f6a47-196">第二种确定数据流块的完成状态的方法是使用延续执行完成任务，或者使用 C# 和 Visual Basic 的异步语言功能以异步方式等待完成任务。</span><span class="sxs-lookup"><span data-stu-id="f6a47-196">The second way to determine the completion status of a dataflow block is to use a continuation of the completion task, or to use the asynchronous language features of C# and Visual Basic to asynchronously wait for the completion task.</span></span> <span data-ttu-id="f6a47-197">您提供给 <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> 方法的委托采用表示前面任务的 <xref:System.Threading.Tasks.Task> 对象。</span><span class="sxs-lookup"><span data-stu-id="f6a47-197">The delegate that you provide to the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method takes a <xref:System.Threading.Tasks.Task> object that represents the antecedent task.</span></span> <span data-ttu-id="f6a47-198">就 <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> 属性来说，延续的委托自行采用完成任务。</span><span class="sxs-lookup"><span data-stu-id="f6a47-198">In the case of the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> property, the delegate for the continuation takes the completion task itself.</span></span> <span data-ttu-id="f6a47-199">下面的示例与前一个示例相似，不同之处在于它也使用 <xref:System.Threading.Tasks.Task.ContinueWith%2A> 方法创建输出整个数据流操作状态的延续任务。</span><span class="sxs-lookup"><span data-stu-id="f6a47-199">The following example resembles the previous one, except that it also uses the <xref:System.Threading.Tasks.Task.ContinueWith%2A> method to create a continuation task that prints the status of the overall dataflow operation.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#11](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#11)]
 [!code-vb[TPLDataflow_Overview#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#11)]  
  
 <span data-ttu-id="f6a47-200">您也可以使用类似延续任务主体中的属性（例如 <xref:System.Threading.Tasks.Task.IsCanceled%2A>）来确定有关数据流块的完成状态的其他信息。</span><span class="sxs-lookup"><span data-stu-id="f6a47-200">You can also use properties such as <xref:System.Threading.Tasks.Task.IsCanceled%2A> in the body of the continuation task to determine additional information about the completion status of a dataflow block.</span></span> <span data-ttu-id="f6a47-201">若要深入了解延续任务及其与取消和错误处理如何相关，请参阅[使用延续任务链接任务](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)、[任务取消](../../../docs/standard/parallel-programming/task-cancellation.md)和[异常处理](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="f6a47-201">For more information about continuation tasks and how they relate to cancellation and error handling, see [Chaining Tasks by Using Continuation Tasks](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md), [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md), and [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 <span data-ttu-id="f6a47-202">[[转到页首](#top)]</span><span class="sxs-lookup"><span data-stu-id="f6a47-202">[[go to top](#top)]</span></span>  
  
<a name="predefined_types"></a>   
## <a name="predefined-dataflow-block-types"></a><span data-ttu-id="f6a47-203">预定义的数据流块类型</span><span class="sxs-lookup"><span data-stu-id="f6a47-203">Predefined Dataflow Block Types</span></span>  
 <span data-ttu-id="f6a47-204">TPL 数据流库提供了多个预定义的数据流块类型。</span><span class="sxs-lookup"><span data-stu-id="f6a47-204">The TPL Dataflow Library provides several predefined dataflow block types.</span></span> <span data-ttu-id="f6a47-205">这些类型分为三个类别：缓冲块、执行块和分组块。</span><span class="sxs-lookup"><span data-stu-id="f6a47-205">These types are divided into three categories: *buffering blocks*, *execution blocks*, and *grouping blocks*.</span></span> <span data-ttu-id="f6a47-206">以下部分描述了组成这些类别的块类型。</span><span class="sxs-lookup"><span data-stu-id="f6a47-206">The following sections describe the block types that make up these categories.</span></span>  
  
### <a name="buffering-blocks"></a><span data-ttu-id="f6a47-207">缓冲块</span><span class="sxs-lookup"><span data-stu-id="f6a47-207">Buffering Blocks</span></span>  
 <span data-ttu-id="f6a47-208">缓冲块存放的数据供数据使用者使用。</span><span class="sxs-lookup"><span data-stu-id="f6a47-208">Buffering blocks hold data for use by data consumers.</span></span> <span data-ttu-id="f6a47-209">TPL 数据流库提供三种缓冲块类型：<xref:System.Threading.Tasks.Dataflow.BufferBlock%601?displayProperty=nameWithType>、<xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601?displayProperty=nameWithType> 和 <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f6a47-209">The TPL Dataflow Library provides three buffering block types: <xref:System.Threading.Tasks.Dataflow.BufferBlock%601?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601?displayProperty=nameWithType>, and <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601?displayProperty=nameWithType>.</span></span>  
  
#### <a name="bufferblockt"></a><span data-ttu-id="f6a47-210">BufferBlock(T)</span><span class="sxs-lookup"><span data-stu-id="f6a47-210">BufferBlock(T)</span></span>  
 <span data-ttu-id="f6a47-211"><xref:System.Threading.Tasks.Dataflow.BufferBlock%601> 类表示一般用途的异步消息结构。</span><span class="sxs-lookup"><span data-stu-id="f6a47-211">The <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> class represents a general-purpose asynchronous messaging structure.</span></span> <span data-ttu-id="f6a47-212">此类存储先进先出 (FIFO) 消息队列，此消息队列可由多个源写入或从多个目标读取。</span><span class="sxs-lookup"><span data-stu-id="f6a47-212">This class stores a first in, first out (FIFO) queue of messages that can be written to by multiple sources or read from by multiple targets.</span></span> <span data-ttu-id="f6a47-213">在目标收到来自 <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> 对象的消息时，将从消息队列中删除此消息。</span><span class="sxs-lookup"><span data-stu-id="f6a47-213">When a target receives a message from a <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> object, that message is removed from the message queue.</span></span> <span data-ttu-id="f6a47-214">因此，虽然一个 <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> 对象可以具有多个目标，但只有一个目标将接收每条消息。</span><span class="sxs-lookup"><span data-stu-id="f6a47-214">Therefore, although a <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> object can have multiple targets, only one target will receive each message.</span></span> <span data-ttu-id="f6a47-215">需将多条消息传递给另一个组件，且该组件必须接收每条消息时，<xref:System.Threading.Tasks.Dataflow.BufferBlock%601> 类十分有用。</span><span class="sxs-lookup"><span data-stu-id="f6a47-215">The <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> class is useful when you want to pass multiple messages to another component, and that component must receive each message.</span></span>  
  
 <span data-ttu-id="f6a47-216">下面的基本示例将多个 <xref:System.Int32> 值发送到 <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> 对象，然后从该对象读回这些值。</span><span class="sxs-lookup"><span data-stu-id="f6a47-216">The following basic example posts several <xref:System.Int32> values to a <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> object and then reads those values back from that object.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#1)]
 [!code-vb[TPLDataflow_Overview#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#1)]  
  
 <span data-ttu-id="f6a47-217">有关展示了如何对 <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> 对象执行消息写入和读取操作的完整示例，请参阅[如何：对数据流块执行消息写入和读取操作](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)。</span><span class="sxs-lookup"><span data-stu-id="f6a47-217">For a complete example that demonstrates how to write messages to and read messages from a <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> object, see [How to: Write Messages to and Read Messages from a Dataflow Block](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md).</span></span>  
  
#### <a name="broadcastblockt"></a><span data-ttu-id="f6a47-218">BroadcastBlock(T)</span><span class="sxs-lookup"><span data-stu-id="f6a47-218">BroadcastBlock(T)</span></span>  
 <span data-ttu-id="f6a47-219">若您必须将多条消息传递给另一个组件，而该组件只需要最新的值，则 <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> 类很有用。</span><span class="sxs-lookup"><span data-stu-id="f6a47-219">The <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> class is useful when you must pass multiple messages to another component, but that component needs only the most recent value.</span></span> <span data-ttu-id="f6a47-220">需向多个组件广播消息时，此类也很有用。</span><span class="sxs-lookup"><span data-stu-id="f6a47-220">This class is also useful when you want to broadcast a message to multiple components.</span></span>  
  
 <span data-ttu-id="f6a47-221">下面的基本示例将 <xref:System.Double> 值发送给 <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> 对象，然后多次从该对象读回该值。</span><span class="sxs-lookup"><span data-stu-id="f6a47-221">The following basic example posts a <xref:System.Double> value to a <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> object and then reads that value back from that object several times.</span></span> <span data-ttu-id="f6a47-222">由于值在被读取之后不会从 <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> 对象中移除，因此每一次的可用值都相同。</span><span class="sxs-lookup"><span data-stu-id="f6a47-222">Because values are not removed from <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> objects after they are read, the same value is available every time.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#2)]
 [!code-vb[TPLDataflow_Overview#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#2)]  
  
 <span data-ttu-id="f6a47-223">有关展示了如何使用 <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> 将消息广播给多个目标数据流块的完整示例，请参阅[如何：在数据流块中指定任务计划程序](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md)。</span><span class="sxs-lookup"><span data-stu-id="f6a47-223">For a complete example that demonstrates how to use <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> to broadcast a message to multiple target blocks, see [How to: Specify a Task Scheduler in a Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md).</span></span>  
  
#### <a name="writeonceblockt"></a><span data-ttu-id="f6a47-224">WriteOnceBlock(T)</span><span class="sxs-lookup"><span data-stu-id="f6a47-224">WriteOnceBlock(T)</span></span>  
 <span data-ttu-id="f6a47-225"><xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> 类与 <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> 类相似，不同之处在于 <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> 对象仅可被写入一次。</span><span class="sxs-lookup"><span data-stu-id="f6a47-225">The <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> class resembles the <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> class, except that a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object can be written to one time only.</span></span> <span data-ttu-id="f6a47-226">可以将 <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> 视作类似于 C# 中的 [readonly](~/docs/csharp/language-reference/keywords/readonly.md)（Visual Basic 中的 [ReadOnly](~/docs/visual-basic/language-reference/modifiers/readonly.md)）关键字，不同之处在于 <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> 对象在收到值后（而不是在构造时）成为不可变对象。</span><span class="sxs-lookup"><span data-stu-id="f6a47-226">You can think of <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> as being similar to the C# [readonly](~/docs/csharp/language-reference/keywords/readonly.md) ([ReadOnly](~/docs/visual-basic/language-reference/modifiers/readonly.md) in Visual Basic) keyword, except that a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object becomes immutable after it receives a value instead of at construction.</span></span> <span data-ttu-id="f6a47-227">与 <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> 类相似，在目标收到来自 <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> 对象的消息时，不会从该目标删除此消息。</span><span class="sxs-lookup"><span data-stu-id="f6a47-227">Like the <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> class, when a target receives a message from a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object, that message is not removed from that object.</span></span> <span data-ttu-id="f6a47-228">因此，多个目标将接收到该消息的副本。</span><span class="sxs-lookup"><span data-stu-id="f6a47-228">Therefore, multiple targets receive a copy of the message.</span></span> <span data-ttu-id="f6a47-229">当您想要仅传播多条消息中的第一条时，<xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> 类很有用。</span><span class="sxs-lookup"><span data-stu-id="f6a47-229">The <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> class is useful when you want to propagate only the first of multiple messages.</span></span>  
  
 <span data-ttu-id="f6a47-230">下面的基本示例将多个 <xref:System.String> 值发送给 <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> 对象，然后从该对象读回该值。</span><span class="sxs-lookup"><span data-stu-id="f6a47-230">The following basic example posts multiple <xref:System.String> values to a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object and then reads the value back from that object.</span></span> <span data-ttu-id="f6a47-231">由于 <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> 对象在 <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> 对象接收消息后只能写入一次，因此它放弃后续消息。</span><span class="sxs-lookup"><span data-stu-id="f6a47-231">Because a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object can be written to one time only, after a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object receives a message, it discards subsequent messages.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#3)]
 [!code-vb[TPLDataflow_Overview#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#3)]  
  
 <span data-ttu-id="f6a47-232">有关展示了如何使用 <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> 接收完成的第一项操作值的完整示例，请参阅[如何：取消链接数据流块](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md)。</span><span class="sxs-lookup"><span data-stu-id="f6a47-232">For a complete example that demonstrates how to use <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> to receive the value of the first operation that finishes, see [How to: Unlink Dataflow Blocks](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md).</span></span>  
  
### <a name="execution-blocks"></a><span data-ttu-id="f6a47-233">执行块</span><span class="sxs-lookup"><span data-stu-id="f6a47-233">Execution Blocks</span></span>  
 <span data-ttu-id="f6a47-234">执行块为每条接收数据调用用户提供的委托。</span><span class="sxs-lookup"><span data-stu-id="f6a47-234">Execution blocks call a user-provided delegate for each piece of received data.</span></span> <span data-ttu-id="f6a47-235">TPL 数据流库提供三种执行块类型：<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>、<xref:System.Threading.Tasks.Dataflow.TransformBlock%602?displayProperty=nameWithType> 和 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f6a47-235">The TPL Dataflow Library provides three execution block types: <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602?displayProperty=nameWithType>, and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602?displayProperty=nameWithType>.</span></span>  
  
#### <a name="actionblockt"></a><span data-ttu-id="f6a47-236">ActionBlock(T)</span><span class="sxs-lookup"><span data-stu-id="f6a47-236">ActionBlock(T)</span></span>  
 <span data-ttu-id="f6a47-237"><xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 类在接收数据时是调用委托的目标块。</span><span class="sxs-lookup"><span data-stu-id="f6a47-237">The <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> class is a target block that calls a delegate when it receives data.</span></span> <span data-ttu-id="f6a47-238">将 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 对象视为数据可用时异步运行的委托。</span><span class="sxs-lookup"><span data-stu-id="f6a47-238">Think of a <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object as a delegate that runs asynchronously when data becomes available.</span></span> <span data-ttu-id="f6a47-239">您提供给 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 对象的委托可以是类型 <xref:System.Action%601> 或类型 `System.Func<TInput, Task>`。</span><span class="sxs-lookup"><span data-stu-id="f6a47-239">The delegate that you provide to an <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object can be of type <xref:System.Action%601> or type `System.Func<TInput, Task>`.</span></span> <span data-ttu-id="f6a47-240">当通过 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 使用 <xref:System.Action%601> 对象时，每个输入元素的处理在委托返回时视为已完成。</span><span class="sxs-lookup"><span data-stu-id="f6a47-240">When you use an <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object with <xref:System.Action%601>, processing of each input element is considered completed when the delegate returns.</span></span> <span data-ttu-id="f6a47-241">当您通过 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 使用 `System.Func<TInput, Task>` 对象时，只有当返回的 <xref:System.Threading.Tasks.Task> 对象完成时，每个输入元素的处理才可以视为已完成。</span><span class="sxs-lookup"><span data-stu-id="f6a47-241">When you use an <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object with `System.Func<TInput, Task>`, processing of each input element is considered completed only when the returned <xref:System.Threading.Tasks.Task> object is completed.</span></span> <span data-ttu-id="f6a47-242">使用这两种机制，您可使用 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 同步和异步处理每个输入元素。</span><span class="sxs-lookup"><span data-stu-id="f6a47-242">By using these two mechanisms, you can use <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> for both synchronous and asynchronous processing of each input element.</span></span>  
  
 <span data-ttu-id="f6a47-243">下面的基本示例将多个 <xref:System.Int32> 值发送给 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 对象。</span><span class="sxs-lookup"><span data-stu-id="f6a47-243">The following basic example posts multiple <xref:System.Int32> values to an <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object.</span></span> <span data-ttu-id="f6a47-244"><xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 对象将这些值输出到控制台中。</span><span class="sxs-lookup"><span data-stu-id="f6a47-244">The <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object prints those values to the console.</span></span> <span data-ttu-id="f6a47-245">然后此示例将该块设置为已完成状态，并等待所有数据流任务完成。</span><span class="sxs-lookup"><span data-stu-id="f6a47-245">This example then sets the block to the completed state and waits for all dataflow tasks to finish.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#4)]
 [!code-vb[TPLDataflow_Overview#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#4)]  
  
 <span data-ttu-id="f6a47-246">有关展示了如何结合使用委托和 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 类的完整示例，请参阅[如何：在数据流块收到数据时执行操作](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md)。</span><span class="sxs-lookup"><span data-stu-id="f6a47-246">For complete examples that demonstrate how to use delegates with the <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> class, see [How to: Perform Action When a Dataflow Block Receives Data](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).</span></span>  
  
#### <a name="transformblocktinput-toutput"></a><span data-ttu-id="f6a47-247">TransformBlock(TInput, TOutput)</span><span class="sxs-lookup"><span data-stu-id="f6a47-247">TransformBlock(TInput, TOutput)</span></span>  
 <span data-ttu-id="f6a47-248"><xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 类与 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 类相似，不同之处在于它可以同时充当源和目标。</span><span class="sxs-lookup"><span data-stu-id="f6a47-248">The <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> class resembles the <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> class, except that it acts as both a source and as a target.</span></span> <span data-ttu-id="f6a47-249">传递给 <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 对象的委托返回类型为 `TOutput` 的值。</span><span class="sxs-lookup"><span data-stu-id="f6a47-249">The delegate that you pass to a <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object returns a value of type `TOutput`.</span></span> <span data-ttu-id="f6a47-250">您提供给 <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 对象的委托可以是类型 `System.Func<TInput, TOutput>` 或类型 `System.Func<TInput, Task<TOutput>>`。</span><span class="sxs-lookup"><span data-stu-id="f6a47-250">The delegate that you provide to a <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object can be of type `System.Func<TInput, TOutput>` or type `System.Func<TInput, Task<TOutput>>`.</span></span> <span data-ttu-id="f6a47-251">当您搭配使用 <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 和 `System.Func<TInput, TOutput>` 对象时，每个输入元素的处理在委托返回时视为已完成。</span><span class="sxs-lookup"><span data-stu-id="f6a47-251">When you use a <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object with `System.Func<TInput, TOutput>`, processing of each input element is considered completed when the delegate returns.</span></span> <span data-ttu-id="f6a47-252">当您搭配使用 <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 和 `System.Func<TInput, Task<TOutput>>` 对象时，只有当返回的 <xref:System.Threading.Tasks.Task%601> 对象完成时，每个输入元素的处理才可以视为已完成。</span><span class="sxs-lookup"><span data-stu-id="f6a47-252">When you use a <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object used with `System.Func<TInput, Task<TOutput>>`, processing of each input element is considered completed only when the returned <xref:System.Threading.Tasks.Task%601> object is completed.</span></span> <span data-ttu-id="f6a47-253">像 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 一样，通过使用这两种机制，您可使用 <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 同步和异步处理每个输入元素。</span><span class="sxs-lookup"><span data-stu-id="f6a47-253">As with <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, by using these two mechanisms, you can use <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> for both synchronous and asynchronous processing of each input element.</span></span>  
  
 <span data-ttu-id="f6a47-254">下面的基本示例所创建的 <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 对象用于计算输入的平方根。</span><span class="sxs-lookup"><span data-stu-id="f6a47-254">The following basic example creates a <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object that computes the square root of its input.</span></span> <span data-ttu-id="f6a47-255"><xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 对象采用 <xref:System.Int32> 值作为输入并生成 <xref:System.Double> 值作为输出。</span><span class="sxs-lookup"><span data-stu-id="f6a47-255">The <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object takes <xref:System.Int32> values as input and produces <xref:System.Double> values as output.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#5)]
 [!code-vb[TPLDataflow_Overview#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#5)]  
  
 <span data-ttu-id="f6a47-256">有关展示了如何在数据流块网络中使用 <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 在 Windows 窗体应用中执行图像处理的完整示例，请参阅[演练：在 Windows 窗体应用中使用数据流](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)。</span><span class="sxs-lookup"><span data-stu-id="f6a47-256">For complete examples that uses <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> in a network of dataflow blocks that performs image processing in a Windows Forms application, see [Walkthrough: Using Dataflow in a Windows Forms Application](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).</span></span>  
  
#### <a name="transformmanyblocktinput-toutput"></a><span data-ttu-id="f6a47-257">TransformManyBlock(TInput, TOutput)</span><span class="sxs-lookup"><span data-stu-id="f6a47-257">TransformManyBlock(TInput, TOutput)</span></span>  
 <span data-ttu-id="f6a47-258"><xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 类与 <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 类相似，不同之处在于 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 为每一个输入值生成零个或多个输出值，而不是为每个输入值仅生成一个输出值。</span><span class="sxs-lookup"><span data-stu-id="f6a47-258">The <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> class resembles the <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> class, except that <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> produces zero or more output values for each input value, instead of only one output value for each input value.</span></span> <span data-ttu-id="f6a47-259">您提供给 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 对象的委托可以是类型 `System.Func<TInput, IEnumerable<TOutput>>` 或类型 `System.Func<TInput, Task<IEnumerable<TOutput>>>`。</span><span class="sxs-lookup"><span data-stu-id="f6a47-259">The delegate that you provide to a <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object can be of type `System.Func<TInput, IEnumerable<TOutput>>` or type `System.Func<TInput, Task<IEnumerable<TOutput>>>`.</span></span> <span data-ttu-id="f6a47-260">当您搭配使用 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 和 `System.Func<TInput, IEnumerable<TOutput>>` 对象时，每个输入元素的处理在委托返回时视为已完成。</span><span class="sxs-lookup"><span data-stu-id="f6a47-260">When you use a <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object with `System.Func<TInput, IEnumerable<TOutput>>`, processing of each input element is considered completed when the delegate returns.</span></span> <span data-ttu-id="f6a47-261">当您搭配使用 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 和 `System.Func<TInput, Task<IEnumerable<TOutput>>>` 对象时，只有当返回的 `System.Threading.Tasks.Task<IEnumerable<TOutput>>` 对象完成时，每个输入元素的处理才可以视为已完成。</span><span class="sxs-lookup"><span data-stu-id="f6a47-261">When you use a <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object with `System.Func<TInput, Task<IEnumerable<TOutput>>>`, processing of each input element is considered complete only when the returned `System.Threading.Tasks.Task<IEnumerable<TOutput>>` object is completed.</span></span>  
  
 <span data-ttu-id="f6a47-262">下面的基本示例所创建的 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 对象将字符串拆分为单个字符序列。</span><span class="sxs-lookup"><span data-stu-id="f6a47-262">The following basic example creates a <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object that splits strings into their individual character sequences.</span></span> <span data-ttu-id="f6a47-263"><xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 对象采用 <xref:System.String> 值作为输入并生成 <xref:System.Char> 值作为输出。</span><span class="sxs-lookup"><span data-stu-id="f6a47-263">The <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object takes <xref:System.String> values as input and produces <xref:System.Char> values as output.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#6](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#6)]
 [!code-vb[TPLDataflow_Overview#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#6)]  
  
 <span data-ttu-id="f6a47-264">有关展示了如何使用 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 在数据流管道中为每个输入生成多个独立输出的完整示例，请参阅[演练：创建数据流管道](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md)。</span><span class="sxs-lookup"><span data-stu-id="f6a47-264">For complete examples that use <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> to produce multiple independent outputs for each input in a dataflow pipeline, see [Walkthrough: Creating a Dataflow Pipeline](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md).</span></span>  
  
#### <a name="degree-of-parallelism"></a><span data-ttu-id="f6a47-265">并行度</span><span class="sxs-lookup"><span data-stu-id="f6a47-265">Degree of Parallelism</span></span>  
 <span data-ttu-id="f6a47-266">每个 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>、<xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 和 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 对象都缓冲输入消息，直到块准备处理它们。</span><span class="sxs-lookup"><span data-stu-id="f6a47-266">Every <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object buffers input messages until the block is ready to process them.</span></span> <span data-ttu-id="f6a47-267">默认情况下，这些类以接收消息的顺序处理消息，一次处理一条消息。</span><span class="sxs-lookup"><span data-stu-id="f6a47-267">By default, these classes process messages in the order in which they are received, one message at a time.</span></span> <span data-ttu-id="f6a47-268">您还可以指定并行度，使 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>、<xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 和 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 对象同时处理多条消息。</span><span class="sxs-lookup"><span data-stu-id="f6a47-268">You can also specify the degree of parallelism to enable <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> objects to process multiple messages concurrently.</span></span> <span data-ttu-id="f6a47-269">有关并行执行的详细信息，请参阅本文档后面的“指定并行度”部分。</span><span class="sxs-lookup"><span data-stu-id="f6a47-269">For more information about concurrent execution, see the section Specifying the Degree of Parallelism later in this document.</span></span> <span data-ttu-id="f6a47-270">有关如何设置并行度使执行数据流块能够一次处理多条消息的示例，请参阅[如何：指定数据流块中的并行度](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)。</span><span class="sxs-lookup"><span data-stu-id="f6a47-270">For an example that sets the degree of parallelism to enable an execution dataflow block to process more than one message at a time, see [How to: Specify the Degree of Parallelism in a Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).</span></span>  
  
#### <a name="summary-of-delegate-types"></a><span data-ttu-id="f6a47-271">委托类型摘要</span><span class="sxs-lookup"><span data-stu-id="f6a47-271">Summary of Delegate Types</span></span>  
 <span data-ttu-id="f6a47-272">下表汇总了可提供给 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>、<xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 和 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 对象的委托类型。</span><span class="sxs-lookup"><span data-stu-id="f6a47-272">The following table summarizes the delegate types that you can provide to <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> objects.</span></span> <span data-ttu-id="f6a47-273">此表还指出委托类型是同步执行还是异步执行。</span><span class="sxs-lookup"><span data-stu-id="f6a47-273">This table also specifies whether the delegate type operates synchronously or asynchronously.</span></span>  
  
|<span data-ttu-id="f6a47-274">类型</span><span class="sxs-lookup"><span data-stu-id="f6a47-274">Type</span></span>|<span data-ttu-id="f6a47-275">同步委托类型</span><span class="sxs-lookup"><span data-stu-id="f6a47-275">Synchronous Delegate Type</span></span>|<span data-ttu-id="f6a47-276">异步委托类型</span><span class="sxs-lookup"><span data-stu-id="f6a47-276">Asynchronous Delegate Type</span></span>|  
|----------|-------------------------------|--------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|`System.Action`|`System.Func<TInput, Task>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|`System.Func<TInput, TOutput>`|`System.Func<TInput, Task<TOutput>>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|`System.Func<TInput, IEnumerable<TOutput>>`|`System.Func<TInput, Task<IEnumerable<TOutput>>>`|  
  
 <span data-ttu-id="f6a47-277">当处理执行块类型时，还可以使用 lambda 表达式。</span><span class="sxs-lookup"><span data-stu-id="f6a47-277">You can also use lambda expressions when you work with execution block types.</span></span> <span data-ttu-id="f6a47-278">有关如何使用 lambda 表达式处理执行块的示例，请参阅[如何：在数据流块收到数据时执行操作](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md)。</span><span class="sxs-lookup"><span data-stu-id="f6a47-278">For an example that shows how to use a lambda expression with an execution block, see [How to: Perform Action When a Dataflow Block Receives Data](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).</span></span>  
  
### <a name="grouping-blocks"></a><span data-ttu-id="f6a47-279">分组块</span><span class="sxs-lookup"><span data-stu-id="f6a47-279">Grouping Blocks</span></span>  
 <span data-ttu-id="f6a47-280">分组块在各种约束下合并一个或多个源的数据。</span><span class="sxs-lookup"><span data-stu-id="f6a47-280">Grouping blocks combine data from one or more sources and under various constraints.</span></span> <span data-ttu-id="f6a47-281">TPL 数据流库提供三种联接块类型：<xref:System.Threading.Tasks.Dataflow.BatchBlock%601>、<xref:System.Threading.Tasks.Dataflow.JoinBlock%602> 和 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>。</span><span class="sxs-lookup"><span data-stu-id="f6a47-281">The TPL Dataflow Library provides three join block types: <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, and <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>.</span></span>  
  
#### <a name="batchblockt"></a><span data-ttu-id="f6a47-282">BatchBlock(T)</span><span class="sxs-lookup"><span data-stu-id="f6a47-282">BatchBlock(T)</span></span>  
 <span data-ttu-id="f6a47-283"><xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 类将一系列输入数据合并到输出数据数组，即批处理。</span><span class="sxs-lookup"><span data-stu-id="f6a47-283">The <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> class combines sets of input data, which are known as batches, into arrays of output data.</span></span> <span data-ttu-id="f6a47-284">在创建 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 对象时，指定每个批的大小。</span><span class="sxs-lookup"><span data-stu-id="f6a47-284">You specify the size of each batch when you create a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object.</span></span> <span data-ttu-id="f6a47-285">当 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 对象接收指定数量的输入元素时，它会异步传播含这些元素的数组。</span><span class="sxs-lookup"><span data-stu-id="f6a47-285">When the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object receives the specified count of input elements, it asynchronously propagates out an array that contains those elements.</span></span> <span data-ttu-id="f6a47-286">如果 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 对象设置为已完成状态，但不包含足够的元素形成批，则会传播包含其余输入元素的最终数组。</span><span class="sxs-lookup"><span data-stu-id="f6a47-286">If a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object is set to the completed state but does not contain enough elements to form a batch, it propagates out a final array that contains the remaining input elements.</span></span>  
  
 <span data-ttu-id="f6a47-287"><xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 类可以在贪婪或非贪婪模式下运行。</span><span class="sxs-lookup"><span data-stu-id="f6a47-287">The <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> class operates in either *greedy* or *non-greedy* mode.</span></span> <span data-ttu-id="f6a47-288">在默认贪婪模式下，<xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 对象接受它提供的每条消息，并在接收指定数量的元素后传播数组。</span><span class="sxs-lookup"><span data-stu-id="f6a47-288">In greedy mode, which is the default, a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object accepts every message that it is offered and propagates out an array after it receives the specified count of elements.</span></span> <span data-ttu-id="f6a47-289">在非贪婪模式下，<xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 对象推迟所有传入的消息，直到足够的源给块提供消息来形成批。</span><span class="sxs-lookup"><span data-stu-id="f6a47-289">In non-greedy mode, a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object postpones all incoming messages until enough sources have offered messages to the block to form a batch.</span></span> <span data-ttu-id="f6a47-290">贪婪模式处理开销较少，所以通常比非贪婪模式执行得更有效。</span><span class="sxs-lookup"><span data-stu-id="f6a47-290">Greedy mode typically performs better than non-greedy mode because it requires less processing overhead.</span></span> <span data-ttu-id="f6a47-291">但是，当您必须以基本方式协调来自多个源的消耗时，可以使用非贪婪模式。</span><span class="sxs-lookup"><span data-stu-id="f6a47-291">However, you can use non-greedy mode when you must coordinate consumption from multiple sources in an atomic fashion.</span></span> <span data-ttu-id="f6a47-292">在 <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> 构造函数的 `False` 参数中，通过将 `dataflowBlockOptions` 设置为 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.%23ctor%2A> 来指定非贪婪模式。</span><span class="sxs-lookup"><span data-stu-id="f6a47-292">Specify non-greedy mode by setting <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> to `False` in the `dataflowBlockOptions` parameter in the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.%23ctor%2A> constructor.</span></span>  
  
 <span data-ttu-id="f6a47-293">下面的基本示例将多个 <xref:System.Int32> 值发送给一批中能容纳十个元素的 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 对象。</span><span class="sxs-lookup"><span data-stu-id="f6a47-293">The following basic example posts several <xref:System.Int32> values to a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object that holds ten elements in a batch.</span></span> <span data-ttu-id="f6a47-294">为了确保所有值从 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 传播，此示例调用 <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f6a47-294">To guarantee that all values propagate out of the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, this example calls the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> method.</span></span> <span data-ttu-id="f6a47-295"><xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> 方法将 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 对象设置为已完成状态，因此，<xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 对象作为最终批传播剩余的所有元素。</span><span class="sxs-lookup"><span data-stu-id="f6a47-295">The <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> method sets the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object to the completed state, and therefore, the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object propagates out any remaining elements as a final batch.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#7](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#7)]
 [!code-vb[TPLDataflow_Overview#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#7)]  
  
 <span data-ttu-id="f6a47-296">有关展示了如何使用 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 提高数据库插入操作效率的完整示例，请参阅[演练：使用 BatchBlock 和 BatchedJoinBlock 提高效率](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)。</span><span class="sxs-lookup"><span data-stu-id="f6a47-296">For a complete example that uses <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> to improve the efficiency of database insert operations, see [Walkthrough: Using BatchBlock and BatchedJoinBlock to Improve Efficiency](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).</span></span>  
  
#### <a name="joinblockt1-t2-"></a><span data-ttu-id="f6a47-297">JoinBlock(T1, T2, ...)</span><span class="sxs-lookup"><span data-stu-id="f6a47-297">JoinBlock(T1, T2, ...)</span></span>  
 <span data-ttu-id="f6a47-298"><xref:System.Threading.Tasks.Dataflow.JoinBlock%602> 和 <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> 类收集输入元素并传播包含这些元素的 <xref:System.Tuple%602?displayProperty=nameWithType> 或 <xref:System.Tuple%603?displayProperty=nameWithType> 对象。</span><span class="sxs-lookup"><span data-stu-id="f6a47-298">The <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> and <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> classes collect input elements and propagate out <xref:System.Tuple%602?displayProperty=nameWithType> or <xref:System.Tuple%603?displayProperty=nameWithType> objects that contain those elements.</span></span> <span data-ttu-id="f6a47-299"><xref:System.Threading.Tasks.Dataflow.JoinBlock%602> 和 <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> 类不能从 <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> 继承。</span><span class="sxs-lookup"><span data-stu-id="f6a47-299">The <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> and <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> classes do not inherit from <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.</span></span> <span data-ttu-id="f6a47-300">而是提供属性 <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target1%2A>、<xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target2%2A> 和 <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Target3%2A> 来实现 <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>。</span><span class="sxs-lookup"><span data-stu-id="f6a47-300">Instead, they provide properties, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target1%2A>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target2%2A>, and <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Target3%2A>, that implement <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.</span></span>  
  
 <span data-ttu-id="f6a47-301">像在贪婪或非贪婪模式下运行的 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>、<xref:System.Threading.Tasks.Dataflow.JoinBlock%602> 和 <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> 一样。</span><span class="sxs-lookup"><span data-stu-id="f6a47-301">Like <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> and <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> operate in either greedy or non-greedy mode.</span></span> <span data-ttu-id="f6a47-302">在默认贪婪模式下，<xref:System.Threading.Tasks.Dataflow.JoinBlock%602> 或 <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> 对象在其每个目标接收至少一条消息之后接受提供的每条消息并传播元组。</span><span class="sxs-lookup"><span data-stu-id="f6a47-302">In greedy mode, which is the default, a <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> or <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> object accepts every message that it is offered and propagates out a tuple after each of its targets receives at least one message.</span></span> <span data-ttu-id="f6a47-303">在非贪婪模式下，<xref:System.Threading.Tasks.Dataflow.JoinBlock%602> 或 <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> 对象推迟所有传入的消息，直到向任何目标提供了创建元组所需的数据。</span><span class="sxs-lookup"><span data-stu-id="f6a47-303">In non-greedy mode, a <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> or <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> object postpones all incoming messages until all targets have been offered the data that is required to create a tuple.</span></span> <span data-ttu-id="f6a47-304">此时，块参与两阶段提交协议，以原子方式从源中检索所有必需的项。</span><span class="sxs-lookup"><span data-stu-id="f6a47-304">At this point, the block engages in a two-phase commit protocol to atomically retrieve all required items from the sources.</span></span> <span data-ttu-id="f6a47-305">此延迟使得其他实体可以同时使用数据，这使整个系统取得进展。</span><span class="sxs-lookup"><span data-stu-id="f6a47-305">This postponement makes it possible for another entity to consume the data in the meantime, to allow the overall system to make forward progress.</span></span>  
  
 <span data-ttu-id="f6a47-306">下面的基本示例演示 <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> 对象需要多个数据来计算值的情况。</span><span class="sxs-lookup"><span data-stu-id="f6a47-306">The following basic example demonstrates a case in which a <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> object requires multiple data to compute a value.</span></span> <span data-ttu-id="f6a47-307">此示例创建了需要两个 <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> 值和一个 <xref:System.Int32> 值来执行算术运算的 <xref:System.Char> 对象。</span><span class="sxs-lookup"><span data-stu-id="f6a47-307">This example creates a <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> object that requires two <xref:System.Int32> values and a <xref:System.Char> value to perform an arithmetic operation.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#8)]
 [!code-vb[TPLDataflow_Overview#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#8)]  
  
 <span data-ttu-id="f6a47-308">有关展示了如何在非贪婪模式下使用 <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> 对象合作共享资源的完整示例，请参阅[如何：使用 JoinBlock 读取多个源的数据](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md)。</span><span class="sxs-lookup"><span data-stu-id="f6a47-308">For a complete example that uses <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> objects in non-greedy mode to cooperatively share a resource, see [How to: Use JoinBlock to Read Data From Multiple Sources](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md).</span></span>  
  
#### <a name="batchedjoinblockt1-t2-"></a><span data-ttu-id="f6a47-309">BatchedJoinBlock(T1, T2, ...)</span><span class="sxs-lookup"><span data-stu-id="f6a47-309">BatchedJoinBlock(T1, T2, ...)</span></span>  
 <span data-ttu-id="f6a47-310"><xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> 和 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603> 类收集各批输入元素，并传播包含这些元素的 `System.Tuple(IList(T1), IList(T2))` 或 `System.Tuple(IList(T1), IList(T2), IList(T3))` 对象。</span><span class="sxs-lookup"><span data-stu-id="f6a47-310">The <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> and <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603> classes collect batches of input elements and propagate out `System.Tuple(IList(T1), IList(T2))` or `System.Tuple(IList(T1), IList(T2), IList(T3))` objects that contain those elements.</span></span> <span data-ttu-id="f6a47-311">将 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> 视为 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 和 <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> 的组合。</span><span class="sxs-lookup"><span data-stu-id="f6a47-311">Think of <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> as a combination of <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> and <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>.</span></span> <span data-ttu-id="f6a47-312">在创建 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> 对象时，指定每个批的大小。</span><span class="sxs-lookup"><span data-stu-id="f6a47-312">Specify the size of each batch when you create a <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> object.</span></span> <span data-ttu-id="f6a47-313"><xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> 还提供了属性 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> 和 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A> 来实现 <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>。</span><span class="sxs-lookup"><span data-stu-id="f6a47-313"><xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> also provides properties, <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> and <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A>, that implement <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.</span></span> <span data-ttu-id="f6a47-314">当从所有目标收到指定数量的输入元素时，<xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> 对象会异步传播包含这些元素的 `System.Tuple(IList(T1), IList(T2))` 对象。</span><span class="sxs-lookup"><span data-stu-id="f6a47-314">When the specified count of input elements are received from across all targets, the <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> object asynchronously propagates out a `System.Tuple(IList(T1), IList(T2))` object that contains those elements.</span></span>  
  
 <span data-ttu-id="f6a47-315">下面的基本示例创建了一个包含结果、<xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> 值和 <xref:System.Int32> 对象错误的 <xref:System.Exception> 对象。</span><span class="sxs-lookup"><span data-stu-id="f6a47-315">The following basic example creates a <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> object that holds results, <xref:System.Int32> values, and errors that are <xref:System.Exception> objects.</span></span> <span data-ttu-id="f6a47-316">此示例执行多个操作，然后将结果写入 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> 属性，将错误写入 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A> 对象的 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> 属性。</span><span class="sxs-lookup"><span data-stu-id="f6a47-316">This example performs multiple operations and writes results to the <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> property, and errors to the <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A> property, of the <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> object.</span></span> <span data-ttu-id="f6a47-317">由于成功和失败操作的计数事先是未知的，因此 <xref:System.Collections.Generic.IList%601> 对象使每个目标都能收到零个或多个值。</span><span class="sxs-lookup"><span data-stu-id="f6a47-317">Because the count of successful and failed operations is unknown in advance, the <xref:System.Collections.Generic.IList%601> objects enable each target to receive zero or more values.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#9](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#9)]
 [!code-vb[TPLDataflow_Overview#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#9)]  
  
 <span data-ttu-id="f6a47-318">有关展示了如何在程序从数据库读取数据时使用 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> 捕获结果和任何异常的完整示例，请参阅[演练：使用 BatchBlock 和 BatchedJoinBlock 提高效率](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)。</span><span class="sxs-lookup"><span data-stu-id="f6a47-318">For a complete example that uses <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> to capture both the results and any exceptions that occur while the program reads from a database, see [Walkthrough: Using BatchBlock and BatchedJoinBlock to Improve Efficiency](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).</span></span>  
  
 <span data-ttu-id="f6a47-319">[[转到页首](#top)]</span><span class="sxs-lookup"><span data-stu-id="f6a47-319">[[go to top](#top)]</span></span>  
  
<a name="behavior"></a>   
## <a name="configuring-dataflow--block-behavior"></a><span data-ttu-id="f6a47-320">配置数据流块行为</span><span class="sxs-lookup"><span data-stu-id="f6a47-320">Configuring Dataflow  Block Behavior</span></span>  
 <span data-ttu-id="f6a47-321">可以通过给数据流块类型的构造函数提供 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType> 对象来启用其他选项。</span><span class="sxs-lookup"><span data-stu-id="f6a47-321">You can enable additional options by providing a <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType> object to the constructor of dataflow block types.</span></span> <span data-ttu-id="f6a47-322">这些选项控制这类管理基础任务和并行度的调度程序的行为。</span><span class="sxs-lookup"><span data-stu-id="f6a47-322">These options control behavior such the scheduler that manages the underlying task and the degree of parallelism.</span></span> <span data-ttu-id="f6a47-323"><xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> 还包含派生类型，用以指定特定于某些数据流块类型的行为。</span><span class="sxs-lookup"><span data-stu-id="f6a47-323">The <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> also has derived types that specify behavior that is specific to certain dataflow block types.</span></span> <span data-ttu-id="f6a47-324">下表汇总了与每个数据流块类型相关的选项类型。</span><span class="sxs-lookup"><span data-stu-id="f6a47-324">The following table summarizes which options type is associated with each dataflow block type.</span></span>  
  
|<span data-ttu-id="f6a47-325">数据流块类型</span><span class="sxs-lookup"><span data-stu-id="f6a47-325">Dataflow Block Type</span></span>|<span data-ttu-id="f6a47-326"><xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> 类型</span><span class="sxs-lookup"><span data-stu-id="f6a47-326"><xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> type</span></span>|  
|-------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.BufferBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchBlock%601>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.JoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
  
 <span data-ttu-id="f6a47-327">以下各节提供了有关重要数据流块选项（通过 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType>、<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions?displayProperty=nameWithType> 和 <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions?displayProperty=nameWithType> 类提供）的其他信息。</span><span class="sxs-lookup"><span data-stu-id="f6a47-327">The following sections provide additional information about the important kinds of dataflow block options that are available through the <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions?displayProperty=nameWithType>, and <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions?displayProperty=nameWithType> classes.</span></span>  
  
### <a name="specifying-the-task-scheduler"></a><span data-ttu-id="f6a47-328">指定任务计划程序</span><span class="sxs-lookup"><span data-stu-id="f6a47-328">Specifying the Task Scheduler</span></span>  
 <span data-ttu-id="f6a47-329">每个预定义的数据流块在数据可用时使用 TPL 任务计划机制执行一些活动，例如，将数据传播到目标、接收来自源的数据并运行用户定义的委托。</span><span class="sxs-lookup"><span data-stu-id="f6a47-329">Every predefined dataflow block uses the TPL task scheduling mechanism to perform activities such as propagating data to a target, receiving data from a source, and running user-defined delegates when data becomes available.</span></span> <span data-ttu-id="f6a47-330"><xref:System.Threading.Tasks.TaskScheduler> 是抽象类，表示将任务排队成线程的任务计划程序。</span><span class="sxs-lookup"><span data-stu-id="f6a47-330"><xref:System.Threading.Tasks.TaskScheduler> is an abstract class that represents a task scheduler that queues tasks onto threads.</span></span> <span data-ttu-id="f6a47-331">默认任务计划程序 <xref:System.Threading.Tasks.TaskScheduler.Default%2A> 使用 <xref:System.Threading.ThreadPool> 类进行排队并执行工作。</span><span class="sxs-lookup"><span data-stu-id="f6a47-331">The default task scheduler, <xref:System.Threading.Tasks.TaskScheduler.Default%2A>, uses the <xref:System.Threading.ThreadPool> class to queue and execute work.</span></span> <span data-ttu-id="f6a47-332">构造数据流块对象时，您可以通过设置 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.TaskScheduler%2A> 属性重写默认任务计划程序。</span><span class="sxs-lookup"><span data-stu-id="f6a47-332">You can override the default task scheduler by setting the <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.TaskScheduler%2A> property when you construct a dataflow block object.</span></span>  
  
 <span data-ttu-id="f6a47-333">当同一个任务计划程序管理多个数据流块时，它可在它们之间强制实施策略。</span><span class="sxs-lookup"><span data-stu-id="f6a47-333">When the same task scheduler manages multiple dataflow blocks, it can enforce policies across them.</span></span> <span data-ttu-id="f6a47-334">例如，如果多个数据流块分别配置为面向同一 <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> 对象的独占计划程序，则会序列化这些块间运行的所有工作。</span><span class="sxs-lookup"><span data-stu-id="f6a47-334">For example, if multiple dataflow blocks are each configured to target the exclusive scheduler of the same <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> object, all work that runs across these blocks is serialized.</span></span> <span data-ttu-id="f6a47-335">同样，如果这些块配置为面向同一 <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> 对象的并发计划程序，而该计划程序配置为具有最大并发级，则这些块中所有的工作都会受到并发操作数的限制。</span><span class="sxs-lookup"><span data-stu-id="f6a47-335">Similarly, if these blocks are configured to target the concurrent scheduler of the same <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> object, and that scheduler is configured to have a maximum concurrency level, all work from these blocks is limited to that number of concurrent operations.</span></span> <span data-ttu-id="f6a47-336">有关展示了如何使用 <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> 类让读取操作并行执行（但写入操作独立于其他所有操作）的示例，请参阅[如何：在数据流块中指定任务计划程序](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md)。</span><span class="sxs-lookup"><span data-stu-id="f6a47-336">For an example that uses the <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> class to enable read operations to occur in parallel, but write operations to occur exclusively of all other operations, see [How to: Specify a Task Scheduler in a Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md).</span></span> <span data-ttu-id="f6a47-337">有关 TPL 中的任务计划程序的详细信息，请参阅 <xref:System.Threading.Tasks.TaskScheduler> 类主题。</span><span class="sxs-lookup"><span data-stu-id="f6a47-337">For more information about task schedulers in the TPL, see the <xref:System.Threading.Tasks.TaskScheduler> class topic.</span></span>  
  
### <a name="specifying-the-degree-of-parallelism"></a><span data-ttu-id="f6a47-338">指定并行度</span><span class="sxs-lookup"><span data-stu-id="f6a47-338">Specifying the Degree of Parallelism</span></span>  
 <span data-ttu-id="f6a47-339">默认情况下，TPL 数据流库提供三种执行块类型（<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>、<xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 和 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>），一次处理一条消息。</span><span class="sxs-lookup"><span data-stu-id="f6a47-339">By default, the three execution block types that the TPL Dataflow Library provides, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>, process one message at a time.</span></span> <span data-ttu-id="f6a47-340">这些数据流块类型也会按照接收消息的顺序对消息进行处理。</span><span class="sxs-lookup"><span data-stu-id="f6a47-340">These dataflow block types also process messages in the order in which they are received.</span></span> <span data-ttu-id="f6a47-341">若要使这些数据流块同时处理该消息，请在构造数据流对象块时设置 <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="f6a47-341">To enable these dataflow blocks to process messages concurrently, set the <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A?displayProperty=nameWithType> property when you construct the dataflow block object.</span></span>  
  
 <span data-ttu-id="f6a47-342"><xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> 的默认值为 1，这保证了数据流块一次处理一条消息。</span><span class="sxs-lookup"><span data-stu-id="f6a47-342">The default value of <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> is 1, which guarantees that the dataflow block processes one message at a time.</span></span> <span data-ttu-id="f6a47-343">将该属性设置为大于 1 的值将使数据流块可以同时处理多条消息。</span><span class="sxs-lookup"><span data-stu-id="f6a47-343">Setting this property to a value that is larger than 1 enables the dataflow block to process multiple messages concurrently.</span></span> <span data-ttu-id="f6a47-344">将该属性设置为 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType> 将使基础任务计划程序管理最大并发程度。</span><span class="sxs-lookup"><span data-stu-id="f6a47-344">Setting this property to <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType> enables the underlying task scheduler to manage the maximum degree of concurrency.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f6a47-345">当指定大于 1 的最大并行度时，会同时处理多条消息，因此，消息可能不会按照接收的顺序进行处理。</span><span class="sxs-lookup"><span data-stu-id="f6a47-345">When you specify a maximum degree of parallelism that is larger than 1, multiple messages are processed simultaneously, and therefore messages might not be processed in the order in which they are received.</span></span> <span data-ttu-id="f6a47-346">然而，从块输出消息的顺序与接收消息的顺序相同。</span><span class="sxs-lookup"><span data-stu-id="f6a47-346">The order in which the messages are output from the block is, however, the same one in which they are received.</span></span>  
  
 <span data-ttu-id="f6a47-347">由于 <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> 属性表示最大并行度，因此数据流块执行时的并行度可能小于指定的值。</span><span class="sxs-lookup"><span data-stu-id="f6a47-347">Because the <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> property represents the maximum degree of parallelism, the dataflow block might execute with a lesser degree of parallelism than you specify.</span></span> <span data-ttu-id="f6a47-348">为了达到功能要求或因为缺少可用的系统资源，数据流块可能使用较小的并行度。</span><span class="sxs-lookup"><span data-stu-id="f6a47-348">The dataflow block might use a lesser degree of parallelism to meet its functional requirements or because there is a lack of available system resources.</span></span> <span data-ttu-id="f6a47-349">数据流块选择的并行度不会超过您指定的值。</span><span class="sxs-lookup"><span data-stu-id="f6a47-349">A dataflow block never chooses more parallelism than you specify.</span></span>  
  
 <span data-ttu-id="f6a47-350"><xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> 属性的值对于每个数据流块对象而言，都是特有的。</span><span class="sxs-lookup"><span data-stu-id="f6a47-350">The value of the <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> property is exclusive to each dataflow block object.</span></span> <span data-ttu-id="f6a47-351">例如，如果四个数据流对象块中的每一个都指定 1 作为最大并行度，则所有四个数据流对象块可以并行运行。</span><span class="sxs-lookup"><span data-stu-id="f6a47-351">For example, if four dataflow block objects each specify 1 for the maximum degree of parallelism, all four dataflow block objects can potentially run in parallel.</span></span>  
  
 <span data-ttu-id="f6a47-352">有关如何设置最大并行度以启用并行冗长操作的示例，请参阅[如何：指定数据流块中的并行度](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)。</span><span class="sxs-lookup"><span data-stu-id="f6a47-352">For an example that sets the maximum degree of parallelism to enable lengthy operations to occur in parallel, see [How to: Specify the Degree of Parallelism in a Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).</span></span>  
  
### <a name="specifying-the-number-of-messages-per-task"></a><span data-ttu-id="f6a47-353">指定每个任务的消息数</span><span class="sxs-lookup"><span data-stu-id="f6a47-353">Specifying the Number of Messages per Task</span></span>  
 <span data-ttu-id="f6a47-354">预定义的数据流块类型使用任务来处理多个输入元素。</span><span class="sxs-lookup"><span data-stu-id="f6a47-354">The predefined dataflow block types use tasks to process multiple input elements.</span></span> <span data-ttu-id="f6a47-355">这有助于最大限度地减少需要处理数据的任务对象数，从而使应用程序可以更有效地运行。</span><span class="sxs-lookup"><span data-stu-id="f6a47-355">This helps minimize the number of task objects that are required to process data, which enables applications to run more efficiently.</span></span> <span data-ttu-id="f6a47-356">但是，当一个数据流块集合中的任务处理数据时，其他数据流块的任务可能需要按照队列消息等待处理时间。</span><span class="sxs-lookup"><span data-stu-id="f6a47-356">However, when the tasks from one set of dataflow blocks are processing data, the tasks from other dataflow blocks might need to wait for processing time by queuing messages.</span></span> <span data-ttu-id="f6a47-357">若要使数据流任务更加公平，请设置 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="f6a47-357">To enable better fairness among dataflow tasks, set the <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> property.</span></span> <span data-ttu-id="f6a47-358">当 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> 设置为 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType> 默认值时，数据流块使用的任务会处理尽可能多的消息。</span><span class="sxs-lookup"><span data-stu-id="f6a47-358">When <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> is set to <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType>, which is the default, the task used by a dataflow block processes as many messages as are available.</span></span> <span data-ttu-id="f6a47-359">当 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> 设置为 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded> 以外的值时，数据流块为每个 <xref:System.Threading.Tasks.Task> 对象至多处理这个数量的消息。</span><span class="sxs-lookup"><span data-stu-id="f6a47-359">When <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> is set to a value other than <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded>, the dataflow block processes at most this number of messages per <xref:System.Threading.Tasks.Task> object.</span></span> <span data-ttu-id="f6a47-360">虽然设置 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> 属性可以提高任务间的公平性，但它可能会导致该系统创建多个非必要的任务，这会降低性能。</span><span class="sxs-lookup"><span data-stu-id="f6a47-360">Although setting the <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> property can increase fairness among tasks, it can cause the system to create more tasks than are necessary, which can decrease performance.</span></span>  
  
### <a name="enabling-cancellation"></a><span data-ttu-id="f6a47-361">启用取消</span><span class="sxs-lookup"><span data-stu-id="f6a47-361">Enabling Cancellation</span></span>  
 <span data-ttu-id="f6a47-362">TPL 提供了一种机制，能使任务以一种合作的方式协调取消。</span><span class="sxs-lookup"><span data-stu-id="f6a47-362">The TPL provides a mechanism that enables tasks to coordinate cancellation in a cooperative manner.</span></span> <span data-ttu-id="f6a47-363">若要启用数据流块参与此取消机制，请设置 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.CancellationToken%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="f6a47-363">To enable dataflow blocks to participate in this cancellation mechanism, set the <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.CancellationToken%2A> property.</span></span> <span data-ttu-id="f6a47-364">当此 <xref:System.Threading.CancellationToken> 对象设置为已取消状态时，所有监视该标记的数据流块都会完成当前项目的执行，但不会开始处理后续项。</span><span class="sxs-lookup"><span data-stu-id="f6a47-364">When this <xref:System.Threading.CancellationToken> object is set to the canceled state, all dataflow blocks that monitor this token finish execution of their current item but do not start processing subsequent items.</span></span> <span data-ttu-id="f6a47-365">这些数据流块也会清除所有缓冲的消息，释放所有源和目标块的连接，并转换为已取消状态。</span><span class="sxs-lookup"><span data-stu-id="f6a47-365">These dataflow blocks also clear any buffered messages, release connections to any source and target blocks, and transition to the canceled state.</span></span> <span data-ttu-id="f6a47-366">通过转换为已取消状态，<xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> 属性具有设置为 <xref:System.Threading.Tasks.Task.Status%2A> 的 <xref:System.Threading.Tasks.TaskStatus.Canceled> 属性，除非在处理过程中出现异常。</span><span class="sxs-lookup"><span data-stu-id="f6a47-366">By transitioning to the canceled state, the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> property has the <xref:System.Threading.Tasks.Task.Status%2A> property set to <xref:System.Threading.Tasks.TaskStatus.Canceled>, unless an exception occurred during processing.</span></span> <span data-ttu-id="f6a47-367">在这种情况下，<xref:System.Threading.Tasks.Task.Status%2A> 会设置为 <xref:System.Threading.Tasks.TaskStatus.Faulted>。</span><span class="sxs-lookup"><span data-stu-id="f6a47-367">In that case, <xref:System.Threading.Tasks.Task.Status%2A> is set to <xref:System.Threading.Tasks.TaskStatus.Faulted>.</span></span>  
  
 <span data-ttu-id="f6a47-368">有关如何在 Windows 窗体应用程序中使用取消的示例，请参阅[如何：取消数据流块](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md)。</span><span class="sxs-lookup"><span data-stu-id="f6a47-368">For an example that demonstrates how to use cancellation in a Windows Forms application, see [How to: Cancel a Dataflow Block](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md).</span></span> <span data-ttu-id="f6a47-369">若要深入了解 TPL 中的取消，请参阅[任务取消](../../../docs/standard/parallel-programming/task-cancellation.md)。</span><span class="sxs-lookup"><span data-stu-id="f6a47-369">For more information about cancellation in the TPL, see [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md).</span></span>  
  
### <a name="specifying-greedy-versus-non-greedy-behavior"></a><span data-ttu-id="f6a47-370">指定贪婪与非贪婪行为</span><span class="sxs-lookup"><span data-stu-id="f6a47-370">Specifying Greedy Versus Non-Greedy Behavior</span></span>  
 <span data-ttu-id="f6a47-371">几个分组数据流块类型可以在贪婪或非贪婪模式下运行。</span><span class="sxs-lookup"><span data-stu-id="f6a47-371">Several grouping dataflow block types can operate in either *greedy* or *non-greedy* mode.</span></span> <span data-ttu-id="f6a47-372">默认情况下，预定义的数据流块类型在贪婪模式下运行。</span><span class="sxs-lookup"><span data-stu-id="f6a47-372">By default, the predefined dataflow block types operate in greedy mode.</span></span>  
  
 <span data-ttu-id="f6a47-373">对于联接块类型（如 <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>），贪婪模式意味着块立即接受数据，即使相应的数据联接不可用。</span><span class="sxs-lookup"><span data-stu-id="f6a47-373">For join block types such as <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, greedy mode means that the block immediately accepts data even if the corresponding data with which to join is not yet available.</span></span> <span data-ttu-id="f6a47-374">非贪婪模式意味着块推迟所有传入的消息，直到在其每个目标上有一个可完成联接。</span><span class="sxs-lookup"><span data-stu-id="f6a47-374">Non-greedy mode means that the block postpones all incoming messages until one is available on each of its targets to complete the join.</span></span> <span data-ttu-id="f6a47-375">如果任何推迟的消息不再可用，则联接块会释放所有推迟的消息并重新启动该过程。</span><span class="sxs-lookup"><span data-stu-id="f6a47-375">If any of the postponed messages are no longer available, the join block releases all postponed messages and restarts the process.</span></span> <span data-ttu-id="f6a47-376">对于 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 类，贪婪和非贪婪行为非常相似，不同之处在于在非贪婪模式下，<xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 对象推迟所有传入的消息，直到不同源中有足够消息可用于完成批作业。</span><span class="sxs-lookup"><span data-stu-id="f6a47-376">For the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> class, greedy and non-greedy behavior is similar, except that under non-greedy mode, a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object postpones all incoming messages until enough are available from distinct sources to complete a batch.</span></span>  
  
 <span data-ttu-id="f6a47-377">若要为数据流块指定非贪婪模式，请将 <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> 设置为 `False`。</span><span class="sxs-lookup"><span data-stu-id="f6a47-377">To specify non-greedy mode for a dataflow block, set <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> to `False`.</span></span> <span data-ttu-id="f6a47-378">有关如何使用非贪婪模式使多个联接块更有效地共享数据源的示例，请参阅[如何：使用 JoinBlock 从多个源读取数据](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md)。</span><span class="sxs-lookup"><span data-stu-id="f6a47-378">For an example that demonstrates how to use non-greedy mode to enable multiple join blocks to share a data source more efficiently, see [How to: Use JoinBlock to Read Data From Multiple Sources](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md).</span></span>  
  
 <span data-ttu-id="f6a47-379">[[转到页首](#top)]</span><span class="sxs-lookup"><span data-stu-id="f6a47-379">[[go to top](#top)]</span></span>  
  
<a name="custom"></a>   
## <a name="custom-dataflow-blocks"></a><span data-ttu-id="f6a47-380">自定义数据流块</span><span class="sxs-lookup"><span data-stu-id="f6a47-380">Custom Dataflow Blocks</span></span>  
 <span data-ttu-id="f6a47-381">尽管 TPL 数据流库提供了许多预定义块类型，但是您还是可以创建执行自定义行为的其他块类型。</span><span class="sxs-lookup"><span data-stu-id="f6a47-381">Although the TPL Dataflow Library provides many predefined block types, you can create additional block types that perform custom behavior.</span></span> <span data-ttu-id="f6a47-382">直接实现 <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> 或 <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> 接口或使用 <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> 方法生成封装现有块类型行为的复杂块。</span><span class="sxs-lookup"><span data-stu-id="f6a47-382">Implement the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> or <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> interfaces directly or use the  <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> method to build a complex block that encapsulates the behavior of existing block types.</span></span> <span data-ttu-id="f6a47-383">有关如何实现自定义数据流块功能的示例，请参阅[演练：创建自定义数据流块类型](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md)。</span><span class="sxs-lookup"><span data-stu-id="f6a47-383">For examples that show how to implement custom dataflow block functionality, see [Walkthrough: Creating a Custom Dataflow Block Type](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md).</span></span>  
  
 <span data-ttu-id="f6a47-384">[[转到页首](#top)]</span><span class="sxs-lookup"><span data-stu-id="f6a47-384">[[go to top](#top)]</span></span>  
  
## <a name="related-topics"></a><span data-ttu-id="f6a47-385">相关主题</span><span class="sxs-lookup"><span data-stu-id="f6a47-385">Related Topics</span></span>  
  
|<span data-ttu-id="f6a47-386">标题</span><span class="sxs-lookup"><span data-stu-id="f6a47-386">Title</span></span>|<span data-ttu-id="f6a47-387">描述</span><span class="sxs-lookup"><span data-stu-id="f6a47-387">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="f6a47-388">如何：将消息写入数据流块和从数据流块读取消息</span><span class="sxs-lookup"><span data-stu-id="f6a47-388">How to: Write Messages to and Read Messages from a Dataflow Block</span></span>](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)|<span data-ttu-id="f6a47-389">演示如何向 <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> 对象写入和读取消息。</span><span class="sxs-lookup"><span data-stu-id="f6a47-389">Demonstrates how to write messages to and read messages from a <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> object.</span></span>|  
|[<span data-ttu-id="f6a47-390">如何：实现制造者-使用者数据流模式</span><span class="sxs-lookup"><span data-stu-id="f6a47-390">How to: Implement a Producer-Consumer Dataflow Pattern</span></span>](../../../docs/standard/parallel-programming/how-to-implement-a-producer-consumer-dataflow-pattern.md)|<span data-ttu-id="f6a47-391">描述如何使用数据流模型实现制造者-使用方模式，在这个模型中制造者向数据流块发送消息，而使用方从该块中读取消息。</span><span class="sxs-lookup"><span data-stu-id="f6a47-391">Describes how to use the dataflow model to implement a producer-consumer pattern, where the producer sends messages to a dataflow block, and the consumer reads messages from that block.</span></span>|  
|[<span data-ttu-id="f6a47-392">如何：在数据流块收到数据时执行操作</span><span class="sxs-lookup"><span data-stu-id="f6a47-392">How to: Perform Action When a Dataflow Block Receives Data</span></span>](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md)|<span data-ttu-id="f6a47-393">描述如何向执行数据流块类型（<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>、<xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 和 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>）提供委托。</span><span class="sxs-lookup"><span data-stu-id="f6a47-393">Describes how to provide delegates to the execution dataflow block types, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>.</span></span>|  
|[<span data-ttu-id="f6a47-394">演练：创建数据流管道</span><span class="sxs-lookup"><span data-stu-id="f6a47-394">Walkthrough: Creating a Dataflow Pipeline</span></span>](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md)|<span data-ttu-id="f6a47-395">描述如何创建从 Web 下载文本并对该文本执行操作的数据流管道。</span><span class="sxs-lookup"><span data-stu-id="f6a47-395">Describes how to create a dataflow pipeline that downloads text from the web and performs operations on that text.</span></span>|  
|[<span data-ttu-id="f6a47-396">如何：取消链接数据流块</span><span class="sxs-lookup"><span data-stu-id="f6a47-396">How to: Unlink Dataflow Blocks</span></span>](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md)|<span data-ttu-id="f6a47-397">展示了如何在源向目标提供消息后，使用 <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A> 方法取消链接源数据流块和目标数据流块。</span><span class="sxs-lookup"><span data-stu-id="f6a47-397">Demonstrates how to use the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A> method to unlink a target block from its source after the source offers a message to the target.</span></span>|  
|[<span data-ttu-id="f6a47-398">演练：在 Windows 窗体应用程序中使用数据流</span><span class="sxs-lookup"><span data-stu-id="f6a47-398">Walkthrough: Using Dataflow in a Windows Forms Application</span></span>](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)|<span data-ttu-id="f6a47-399">演示如何创建在 Windows 窗体应用程序中执行图像处理的数据流块网络。</span><span class="sxs-lookup"><span data-stu-id="f6a47-399">Demonstrates how to create a network of dataflow blocks that perform image processing in a Windows Forms application.</span></span>|  
|[<span data-ttu-id="f6a47-400">如何：取消数据流块</span><span class="sxs-lookup"><span data-stu-id="f6a47-400">How to: Cancel a Dataflow Block</span></span>](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md)|<span data-ttu-id="f6a47-401">演示如何在 Windows 窗体应用程序中使用取消。</span><span class="sxs-lookup"><span data-stu-id="f6a47-401">Demonstrates how to use cancellation in a Windows Forms application.</span></span>|  
|[<span data-ttu-id="f6a47-402">如何：使用 JoinBlock 从多个源读取数据</span><span class="sxs-lookup"><span data-stu-id="f6a47-402">How to: Use JoinBlock to Read Data From Multiple Sources</span></span>](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md)|<span data-ttu-id="f6a47-403">解释如何在多个源的数据可用时使用 <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> 类执行操作，以及如何使用非贪婪模式使多个联接块更有效地共享数据源。</span><span class="sxs-lookup"><span data-stu-id="f6a47-403">Explains how to use the <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> class to perform an operation when data is available from multiple sources, and how to use non-greedy mode to enable multiple join blocks to share a data source more efficiently.</span></span>|  
|[<span data-ttu-id="f6a47-404">如何：指定数据流块中的并行度</span><span class="sxs-lookup"><span data-stu-id="f6a47-404">How to: Specify the Degree of Parallelism in a Dataflow Block</span></span>](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)|<span data-ttu-id="f6a47-405">描述如何设置 <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> 属性使执行数据流块一次处理多条消息。</span><span class="sxs-lookup"><span data-stu-id="f6a47-405">Describes how to set the <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> property to enable an execution dataflow block to process more than one message at a time.</span></span>|  
|[<span data-ttu-id="f6a47-406">如何：在数据流块中指定任务计划程序</span><span class="sxs-lookup"><span data-stu-id="f6a47-406">How to: Specify a Task Scheduler in a Dataflow Block</span></span>](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md)|<span data-ttu-id="f6a47-407">演示在应用程序中使用数据流时如何关联特定任务计划程序。</span><span class="sxs-lookup"><span data-stu-id="f6a47-407">Demonstrates how to associate a specific task scheduler when you use dataflow in your application.</span></span>|  
|[<span data-ttu-id="f6a47-408">演练：使用 BatchBlock 和 BatchedJoinBlock 提高效率</span><span class="sxs-lookup"><span data-stu-id="f6a47-408">Walkthrough: Using BatchBlock and BatchedJoinBlock to Improve Efficiency</span></span>](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)|<span data-ttu-id="f6a47-409">描述如何使用 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 类改进数据库插入操作的效率，以及如何使用 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> 类获取程序从数据库中读取数据时产生的结果和发生的任何异常。</span><span class="sxs-lookup"><span data-stu-id="f6a47-409">Describes how to use the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> class to improve the efficiency of database insert operations, and how to use the <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> class to capture both the results and any exceptions that occur while the program reads from a database.</span></span>|  
|[<span data-ttu-id="f6a47-410">演练：创建自定义数据流块类型</span><span class="sxs-lookup"><span data-stu-id="f6a47-410">Walkthrough: Creating a Custom Dataflow Block Type</span></span>](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md)|<span data-ttu-id="f6a47-411">演示创建实现自定义行为的数据流块类型的两种方法。</span><span class="sxs-lookup"><span data-stu-id="f6a47-411">Demonstrates two ways to create a dataflow block type that implements custom behavior.</span></span>|  
|[<span data-ttu-id="f6a47-412">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="f6a47-412">Task Parallel Library (TPL)</span></span>](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)|<span data-ttu-id="f6a47-413">介绍 TPL，一个可在 [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] 应用程序里简化并行和并发编程的库。</span><span class="sxs-lookup"><span data-stu-id="f6a47-413">Introduces the TPL, a library that simplifies parallel and concurrent programming in [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] applications.</span></span>|
