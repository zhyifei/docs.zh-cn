---
title: "线程安全集合"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- thread-safe collections, overview
ms.assetid: 2e7ca21f-786c-4367-96be-0cf3f3dcc6bd
caps.latest.revision: 24
author: mairaw
ms.author: mairaw
manager: wpickett
ms.translationtype: HT
ms.sourcegitcommit: 306c608dc7f97594ef6f72ae0f5aaba596c936e1
ms.openlocfilehash: 8d0fa0af8f6a78a6d209fdb4956cbbe9448b5204
ms.contentlocale: zh-cn
ms.lasthandoff: 07/28/2017

---
# <a name="thread-safe-collections"></a><span data-ttu-id="167b6-102">线程安全集合</span><span class="sxs-lookup"><span data-stu-id="167b6-102">Thread-Safe Collections</span></span>
<span data-ttu-id="167b6-103">[!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)] 引入了 <xref:System.Collections.Concurrent?displayProperty=fullName> 命名空间，其中包含多个线程安全且可缩放的集合类。</span><span class="sxs-lookup"><span data-stu-id="167b6-103">The [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)] introduces the <xref:System.Collections.Concurrent?displayProperty=fullName> namespace, which includes several collection classes that are both thread-safe and scalable.</span></span> <span data-ttu-id="167b6-104">多个线程可以安全高效地从这些集合添加或删除项，而无需在用户代码中进行其他同步。</span><span class="sxs-lookup"><span data-stu-id="167b6-104">Multiple threads can safely and efficiently add or remove items from these collections, without requiring additional synchronization in user code.</span></span> <span data-ttu-id="167b6-105">编写新代码时，只要将集合同时写入多个线程中，就使用并发集合类。</span><span class="sxs-lookup"><span data-stu-id="167b6-105">When you write new code, use the concurrent collection classes whenever the collection will be writing to multiple threads concurrently.</span></span> <span data-ttu-id="167b6-106">如果仅从共享集合进行读取，则可使用 <xref:System.Collections.Generic?displayProperty=fullName> 命名空间中的类。</span><span class="sxs-lookup"><span data-stu-id="167b6-106">If you are only reading from a shared collection, then you can use the classes in the <xref:System.Collections.Generic?displayProperty=fullName> namespace.</span></span> <span data-ttu-id="167b6-107">建议不要使用 1.0 集合类，除非需要定位 .NET Framework 1.1 或更低版本运行时。</span><span class="sxs-lookup"><span data-stu-id="167b6-107">We recommend that you do not use 1.0 collection classes unless you are required to target the .NET Framework 1.1 or earlier runtime.</span></span>  
  
## <a name="thread-synchronization-in-the-net-framework-10-and-20-collections"></a><span data-ttu-id="167b6-108">.NET Framework 1.0 和 2.0 集合中的线程同步</span><span class="sxs-lookup"><span data-stu-id="167b6-108">Thread Synchronization in the .NET Framework 1.0 and 2.0 Collections</span></span>  
 <span data-ttu-id="167b6-109">.NET Framework 1.0 中引入的集合位于 <xref:System.Collections?displayProperty=fullName> 命名空间中。</span><span class="sxs-lookup"><span data-stu-id="167b6-109">The collections introduced in the .NET Framework 1.0 are found in the <xref:System.Collections?displayProperty=fullName> namespace.</span></span> <span data-ttu-id="167b6-110">这些集合（包括常用的 <xref:System.Collections.ArrayList> 和 <xref:System.Collections.Hashtable>）通过 `Synchronized` 属性（此属性围绕集合返回线程安全的包装器）提供一些线程安全性。</span><span class="sxs-lookup"><span data-stu-id="167b6-110">These collections, which include the commonly used <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>, provide some thread-safety through the `Synchronized` property, which returns a thread-safe wrapper around the collection.</span></span> <span data-ttu-id="167b6-111">该包装器通过对每个添加或删除操作锁定整个集合进行工作。</span><span class="sxs-lookup"><span data-stu-id="167b6-111">The wrapper works by locking the entire collection on every add or remove operation.</span></span> <span data-ttu-id="167b6-112">因此，每个尝试访问集合的线程必须等待，直到轮到它获取锁定。</span><span class="sxs-lookup"><span data-stu-id="167b6-112">Therefore, each thread that is attempting to access the collection must wait for its turn to take the one lock.</span></span> <span data-ttu-id="167b6-113">这不可缩放，并且可能导致大型集合的性能显著下降。</span><span class="sxs-lookup"><span data-stu-id="167b6-113">This is not scalable and can cause significant performance degradation for large collections.</span></span> <span data-ttu-id="167b6-114">此外，这一设计并不能完全防止争用情况的出现。</span><span class="sxs-lookup"><span data-stu-id="167b6-114">Also, the design is not completely protected from race conditions.</span></span> <span data-ttu-id="167b6-115">有关详细信息，请参阅 MSDN 网站上的[泛型集合中的同步](http://go.microsoft.com/fwlink/?LinkID=161130)。</span><span class="sxs-lookup"><span data-stu-id="167b6-115">For more information, see [Synchronization in Generic Collections](http://go.microsoft.com/fwlink/?LinkID=161130) on the MSDN Web site.</span></span>  
  
 <span data-ttu-id="167b6-116">.NET Framework 2.0 中引入的集合类位于 <xref:System.Collections.Generic?displayProperty=fullName> 命名空间中。</span><span class="sxs-lookup"><span data-stu-id="167b6-116">The collection classes introduced in the .NET Framework 2.0 are found in the <xref:System.Collections.Generic?displayProperty=fullName> namespace.</span></span> <span data-ttu-id="167b6-117">它们包括 <xref:System.Collections.Generic.List%601>、<xref:System.Collections.Generic.Dictionary%602> 等。</span><span class="sxs-lookup"><span data-stu-id="167b6-117">These include <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602>, and so on.</span></span> <span data-ttu-id="167b6-118">与 .NET Framework 1.0 类相比，这些类提升了类型安全性和性能。</span><span class="sxs-lookup"><span data-stu-id="167b6-118">These classes provide improved type safety and performance compared to the .NET Framework 1.0 classes.</span></span> <span data-ttu-id="167b6-119">不过，.NET Framework 2.0 集合类不提供任何线程同步；多线程同时添加或删除项时，用户代码必须提供所有同步。</span><span class="sxs-lookup"><span data-stu-id="167b6-119">However, the .NET Framework 2.0 collection classes do not provide any thread synchronization; user code must provide all synchronization when items are added or removed on multiple threads concurrently.</span></span>  
  
 <span data-ttu-id="167b6-120">建议使用 [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)] 中的并发集合类，因为它们不仅能够提供 .NET Framework 2.0 集合类的类型安全性，而且能够比 [!INCLUDE[net_v10_short](../../../../includes/net-v10-short-md.md)] 集合更高效完整地提供线程安全性。</span><span class="sxs-lookup"><span data-stu-id="167b6-120">We recommend the concurrent collections classes in the [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)] because they provide not only the type safety of the .NET Framework 2.0 collection classes, but also more efficient and more complete thread safety than the [!INCLUDE[net_v10_short](../../../../includes/net-v10-short-md.md)] collections provide.</span></span>  
  
## <a name="fine-grained-locking-and-lock-free-mechanisms"></a><span data-ttu-id="167b6-121">细粒度锁定和无锁机制</span><span class="sxs-lookup"><span data-stu-id="167b6-121">Fine-Grained Locking and Lock-Free Mechanisms</span></span>  
 <span data-ttu-id="167b6-122">某些并发集合类型使用轻量同步机制，如 <xref:System.Threading.SpinLock>、<xref:System.Threading.SpinWait>、<xref:System.Threading.SemaphoreSlim> 和 <xref:System.Threading.CountdownEvent>，这些机制是 [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)] 中的新增功能。</span><span class="sxs-lookup"><span data-stu-id="167b6-122">Some of the concurrent collection types use lightweight synchronization mechanisms such as <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim>, and <xref:System.Threading.CountdownEvent>, which are new in the [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)].</span></span> <span data-ttu-id="167b6-123">这些同步类型通常在将线程真正置于等待状态之前，会在短时间内使用*忙旋转*。</span><span class="sxs-lookup"><span data-stu-id="167b6-123">These synchronization types typically use *busy spinning* for brief periods before they put the thread into a true Wait state.</span></span> <span data-ttu-id="167b6-124">预计等待时间非常短时，旋转比等待所消耗的计算资源少得多，因为后者涉及资源消耗量大的内核转换。</span><span class="sxs-lookup"><span data-stu-id="167b6-124">When wait times are expected to be very short, spinning is far less computationally expensive than waiting, which involves an expensive kernel transition.</span></span> <span data-ttu-id="167b6-125">对于使用旋转的集合类，这种效率意味着多个线程能够以非常快的速率添加和删除项。</span><span class="sxs-lookup"><span data-stu-id="167b6-125">For collection classes that use spinning, this efficiency means that multiple threads can add and remove items at a very high rate.</span></span> <span data-ttu-id="167b6-126">有关旋转与锁定的详细信息，请参阅 [SpinLock](../../../../docs/standard/threading/spinlock.md) 和 [SpinWait](../../../../docs/standard/threading/spinwait.md)。</span><span class="sxs-lookup"><span data-stu-id="167b6-126">For more information about spinning vs. blocking, see [SpinLock](../../../../docs/standard/threading/spinlock.md) and [SpinWait](../../../../docs/standard/threading/spinwait.md).</span></span>  
  
 <span data-ttu-id="167b6-127"><xref:System.Collections.Concurrent.ConcurrentQueue%601> 和 <xref:System.Collections.Concurrent.ConcurrentStack%601> 类完全不使用锁定。</span><span class="sxs-lookup"><span data-stu-id="167b6-127">The <xref:System.Collections.Concurrent.ConcurrentQueue%601> and <xref:System.Collections.Concurrent.ConcurrentStack%601> classes do not use locks at all.</span></span> <span data-ttu-id="167b6-128">相反，它们依赖于 <xref:System.Threading.Interlocked> 操作来实现线程安全性。</span><span class="sxs-lookup"><span data-stu-id="167b6-128">Instead, they rely on <xref:System.Threading.Interlocked> operations to achieve thread-safety.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="167b6-129">由于并发集合类支持 <xref:System.Collections.ICollection>，因此该类可提供针对 <xref:System.Collections.ICollection.IsSynchronized%2A> 和 <xref:System.Collections.ICollection.SyncRoot%2A> 属性的实现，即使这些属性不相关。</span><span class="sxs-lookup"><span data-stu-id="167b6-129">Because the concurrent collections classes support <xref:System.Collections.ICollection>, they provide implementations for the <xref:System.Collections.ICollection.IsSynchronized%2A> and <xref:System.Collections.ICollection.SyncRoot%2A> properties, even though these properties are irrelevant.</span></span> <span data-ttu-id="167b6-130">`IsSynchronized` 始终返回 `false`，而 `SyncRoot` 始终为 `null`（在 Visual Basic 中是 `Nothing`）。</span><span class="sxs-lookup"><span data-stu-id="167b6-130">`IsSynchronized` always returns `false` and `SyncRoot` is always `null` (`Nothing` in Visual Basic).</span></span>  
  
 <span data-ttu-id="167b6-131">下表列出了 <xref:System.Collections.Concurrent?displayProperty=fullName> 命名空间中的集合类型。</span><span class="sxs-lookup"><span data-stu-id="167b6-131">The following table lists the collection types in the <xref:System.Collections.Concurrent?displayProperty=fullName> namespace.</span></span>  
  
|<span data-ttu-id="167b6-132">类型</span><span class="sxs-lookup"><span data-stu-id="167b6-132">Type</span></span>|<span data-ttu-id="167b6-133">描述</span><span class="sxs-lookup"><span data-stu-id="167b6-133">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Collections.Concurrent.BlockingCollection%601>|<span data-ttu-id="167b6-134">为实现 <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> 的所有类型提供限制和阻止功能。</span><span class="sxs-lookup"><span data-stu-id="167b6-134">Provides bounding and blocking functionality for any type that implements <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span></span> <span data-ttu-id="167b6-135">有关详细信息，请参阅 [BlockingCollection 概述](../../../../docs/standard/collections/thread-safe/blockingcollection-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="167b6-135">For more information, see [BlockingCollection Overview](../../../../docs/standard/collections/thread-safe/blockingcollection-overview.md).</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentDictionary%602>|<span data-ttu-id="167b6-136">键值对字典的线程安全实现。</span><span class="sxs-lookup"><span data-stu-id="167b6-136">Thread-safe implementation of a dictionary of key-value pairs.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentQueue%601>|<span data-ttu-id="167b6-137">FIFO（先进先出）队列的线程安全实现。</span><span class="sxs-lookup"><span data-stu-id="167b6-137">Thread-safe implementation of a FIFO (first-in, first-out) queue.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentStack%601>|<span data-ttu-id="167b6-138">LIFO（后进先出）堆栈的线程安全实现。</span><span class="sxs-lookup"><span data-stu-id="167b6-138">Thread-safe implementation of a LIFO (last-in, first-out) stack.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentBag%601>|<span data-ttu-id="167b6-139">无序元素集合的线程安全实现。</span><span class="sxs-lookup"><span data-stu-id="167b6-139">Thread-safe implementation of an unordered collection of elements.</span></span>|  
|<xref:System.Collections.Concurrent.IProducerConsumerCollection%601>|<span data-ttu-id="167b6-140">类型必须实现以在 `BlockingCollection` 中使用的接口。</span><span class="sxs-lookup"><span data-stu-id="167b6-140">The interface that a type must implement to be used in a `BlockingCollection`.</span></span>|  
  
## <a name="related-topics"></a><span data-ttu-id="167b6-141">相关主题</span><span class="sxs-lookup"><span data-stu-id="167b6-141">Related Topics</span></span>  
  
|<span data-ttu-id="167b6-142">标题</span><span class="sxs-lookup"><span data-stu-id="167b6-142">Title</span></span>|<span data-ttu-id="167b6-143">描述</span><span class="sxs-lookup"><span data-stu-id="167b6-143">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="167b6-144">BlockingCollection 概述</span><span class="sxs-lookup"><span data-stu-id="167b6-144">BlockingCollection Overview</span></span>](../../../../docs/standard/collections/thread-safe/blockingcollection-overview.md)|<span data-ttu-id="167b6-145">介绍 <xref:System.Collections.Concurrent.BlockingCollection%601> 类型提供的功能。</span><span class="sxs-lookup"><span data-stu-id="167b6-145">Describes the functionality provided by the <xref:System.Collections.Concurrent.BlockingCollection%601>type.</span></span>|  
|[<span data-ttu-id="167b6-146">如何：在 ConcurrentDictionary 中添加和移除项</span><span class="sxs-lookup"><span data-stu-id="167b6-146">How to: Add and Remove Items from a ConcurrentDictionary</span></span>](../../../../docs/standard/collections/thread-safe/how-to-add-and-remove-items.md)|<span data-ttu-id="167b6-147">描述如何从 <xref:System.Collections.Concurrent.ConcurrentDictionary%602> 添加和删除元素</span><span class="sxs-lookup"><span data-stu-id="167b6-147">Describes how to add and remove elements from a <xref:System.Collections.Concurrent.ConcurrentDictionary%602></span></span>|  
|[<span data-ttu-id="167b6-148">如何：在 BlockingCollection 中逐个添加和取出项</span><span class="sxs-lookup"><span data-stu-id="167b6-148">How to: Add and Take Items Individually from a BlockingCollection</span></span>](../../../../docs/standard/collections/thread-safe/how-to-add-and-take-items.md)|<span data-ttu-id="167b6-149">描述如何在不使用只读枚举器的情况下，从阻止的集合添加和检索项。</span><span class="sxs-lookup"><span data-stu-id="167b6-149">Describes how to add and retrieve items from a blocking collection without using the read-only enumerator.</span></span>|  
|[<span data-ttu-id="167b6-150">如何：向集合添加限制和阻塞功能</span><span class="sxs-lookup"><span data-stu-id="167b6-150">How to: Add Bounding and Blocking Functionality to a Collection</span></span>](../../../../docs/standard/collections/thread-safe/how-to-add-bounding-and-blocking.md)|<span data-ttu-id="167b6-151">描述如何将任一集合类用作 <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> 集合的基础存储机制。</span><span class="sxs-lookup"><span data-stu-id="167b6-151">Describes how to use any collection class as the underlying storage mechanism for an <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> collection.</span></span>|  
|[<span data-ttu-id="167b6-152">如何：使用 ForEach 移除 BlockingCollection 中的项</span><span class="sxs-lookup"><span data-stu-id="167b6-152">How to: Use ForEach to Remove Items in a BlockingCollection</span></span>](../../../../docs/standard/collections/thread-safe/how-to-use-foreach-to-remove.md)|<span data-ttu-id="167b6-153">介绍了如何使用 `foreach`（在 Visual Basic 中是 `For Each`）在锁定集合中删除所有项。</span><span class="sxs-lookup"><span data-stu-id="167b6-153">Describes how to use `foreach`, (`For Each` in Visual Basic) to remove all items in a blocking collection.</span></span>|  
|[<span data-ttu-id="167b6-154">如何：在管道中使用阻塞集合的数组</span><span class="sxs-lookup"><span data-stu-id="167b6-154">How to: Use Arrays of Blocking Collections in a Pipeline</span></span>](../../../../docs/standard/collections/thread-safe/how-to-use-arrays-of-blockingcollections.md)|<span data-ttu-id="167b6-155">描述如何同时使用多个阻塞集合来实现一个管道。</span><span class="sxs-lookup"><span data-stu-id="167b6-155">Describes how to use multiple blocking collections at the same time to implement a pipeline.</span></span>|  
|[<span data-ttu-id="167b6-156">如何：使用 ConcurrentBag 创建目标池</span><span class="sxs-lookup"><span data-stu-id="167b6-156">How to: Create an Object Pool by Using a ConcurrentBag</span></span>](../../../../docs/standard/collections/thread-safe/how-to-create-an-object-pool.md)|<span data-ttu-id="167b6-157">演示如何使用并发包在可重用对象（而不是继续创建新对象）的情况下改进性能。</span><span class="sxs-lookup"><span data-stu-id="167b6-157">Shows how to use a concurrent bag to improve performance in scenarios where you can reuse objects instead of continually creating new ones.</span></span>|  
  
## <a name="reference"></a><span data-ttu-id="167b6-158">参考</span><span class="sxs-lookup"><span data-stu-id="167b6-158">Reference</span></span>  
 <xref:System.Collections.Concurrent?displayProperty=fullName>

