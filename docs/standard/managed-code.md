---
title: 什么是托管代码？
description: 了解托管代码为何是其执行由运行时（公共语言运行时 (CLR)）管理的代码。
author: blackdwarf
ms.author: mairaw
ms.date: 06/20/2016
ms.technology: dotnet-standard
ms.assetid: 20bb7ea8-192e-4a96-8ef3-e10e1950fd3d
ms.openlocfilehash: 268ffe9c5cbbc9490ed91f2b4c28f8f876b8ff5e
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/04/2018
ms.locfileid: "33574538"
---
# <a name="what-is-managed-code"></a><span data-ttu-id="05e39-103">什么是“托管代码”？</span><span class="sxs-lookup"><span data-stu-id="05e39-103">What is "managed code"?</span></span>

<span data-ttu-id="05e39-104">使用 .NET Framework 时，我们经常会遇到“托管代码”这个术语。</span><span class="sxs-lookup"><span data-stu-id="05e39-104">When working with .NET Framework, you will often encounter the term "managed code".</span></span> <span data-ttu-id="05e39-105">本文档解释这个术语的含义及其更多相关信息。</span><span class="sxs-lookup"><span data-stu-id="05e39-105">This document will explain what this term means and additional information around it.</span></span>

<span data-ttu-id="05e39-106">简而言之，托管代码就是执行过程交由运行时管理的代码。</span><span class="sxs-lookup"><span data-stu-id="05e39-106">To put it very simply, managed code is just that: code whose execution is managed by a runtime.</span></span> <span data-ttu-id="05e39-107">在这种情况下，相关的运行时称为**公共语言运行时** (CLR)，不管使用的是哪种实现（[Mono](https://www.mono-project.com/)、.NET Framework 或.NET Core）。</span><span class="sxs-lookup"><span data-stu-id="05e39-107">In this case, the runtime in question is called the **Common Language Runtime** or CLR, regardless of the implementation ([Mono](https://www.mono-project.com/) or .NET Framework or .NET Core).</span></span> <span data-ttu-id="05e39-108">CLR 负责提取托管代码、将其编译成机器代码，然后执行它。</span><span class="sxs-lookup"><span data-stu-id="05e39-108">CLR is in charge of taking the managed code, compiling it into machine code and then executing it.</span></span> <span data-ttu-id="05e39-109">除此之外，运行时还提供多个重要服务，例如自动内存管理、安全边界、类型安全，等等。</span><span class="sxs-lookup"><span data-stu-id="05e39-109">On top of that, runtime provides several important services such as automatic memory management, security boundaries, type safety etc.</span></span>

<span data-ttu-id="05e39-110">相反，如果运行 C/C++ 程序，则运行的代码也称为“非托管代码”。</span><span class="sxs-lookup"><span data-stu-id="05e39-110">Contrast this to the way you would run a C/C++ program, also called "unmanaged code".</span></span> <span data-ttu-id="05e39-111">在非托管环境中，程序员需要亲自负责处理相当多的事情。</span><span class="sxs-lookup"><span data-stu-id="05e39-111">In the unmanaged world, the programmer is in charge of pretty much everything.</span></span> <span data-ttu-id="05e39-112">实际的程序在本质上是操作系统 (OS) 载入内存，然后启动的二进制代码。</span><span class="sxs-lookup"><span data-stu-id="05e39-112">The actual program is, essentially, a binary that the operating system (OS) loads into memory and starts.</span></span> <span data-ttu-id="05e39-113">其他任何工作 - 从内存管理到安全考虑因素 - 对于程序员来说是一个不小的负担。</span><span class="sxs-lookup"><span data-stu-id="05e39-113">Everything else, from memory management to security considerations are a burden of the programmer.</span></span>

<span data-ttu-id="05e39-114">托管代码是使用可在 .NET 上运行的一种高级语言（例如 C#、Visual Basic、F# 等）编写的。</span><span class="sxs-lookup"><span data-stu-id="05e39-114">Managed code is written in one of the high-level languages that can be run on top of .NET, such as C#, Visual Basic, F# and others.</span></span> <span data-ttu-id="05e39-115">使用相应的编译器编译以这些语言编写的代码时，无法获得机器代码，</span><span class="sxs-lookup"><span data-stu-id="05e39-115">When you compile code written in those languages with their respective compiler, you don’t get machine code.</span></span> <span data-ttu-id="05e39-116">而是获得**中间语言**代码，然后运行时会对其进行编译并将其执行。</span><span class="sxs-lookup"><span data-stu-id="05e39-116">You get **Intermediate Language** code which the runtime then compiles and executes.</span></span> <span data-ttu-id="05e39-117">C++ 是这条规则的一个例外，因为它也能够生成可在 Windows 上运行的本机非托管二进制代码。</span><span class="sxs-lookup"><span data-stu-id="05e39-117">C++ is the one exception to this rule, as it can also produce native, unmanaged binaries that run on Windows.</span></span>

## <a name="intermediate-language--execution"></a><span data-ttu-id="05e39-118">中间语言和执行</span><span class="sxs-lookup"><span data-stu-id="05e39-118">Intermediate Language & execution</span></span>

<span data-ttu-id="05e39-119">什么是“中间语言”（简称 IL）？</span><span class="sxs-lookup"><span data-stu-id="05e39-119">What is "Intermediate Language" (or IL for short)?</span></span> <span data-ttu-id="05e39-120">中间语言是编译使用高级 .NET 语言编写的代码后获得的结果。</span><span class="sxs-lookup"><span data-stu-id="05e39-120">It is a product of compilation of code written in high-level .NET languages.</span></span> <span data-ttu-id="05e39-121">对使用其中一种语言编写的代码进行编译后，即可获得 IL 所生成的二进制代码。</span><span class="sxs-lookup"><span data-stu-id="05e39-121">Once you compile your code written in one of these languages, you will get a binary that is made out of IL.</span></span> <span data-ttu-id="05e39-122">必须注意，IL 独立于在运行时顶层运行的任何特定语言；行业甚至为它单独制定了规范，如果有需要，你可以阅读该规范。</span><span class="sxs-lookup"><span data-stu-id="05e39-122">It is important to note that the IL is independent from any specific language that runs on top of the runtime; there is even a separate specification for it that you can read if you’re so inclined.</span></span>

<span data-ttu-id="05e39-123">从高级代码生成 IL 后，你很有可能想要运行它。</span><span class="sxs-lookup"><span data-stu-id="05e39-123">Once you produce IL from your high-level code, you will most likely want to run it.</span></span> <span data-ttu-id="05e39-124">CLR 此时将接管工作，启动**实时** (JIT) 编译过程，或者将代码从 IL **实时**编译成可以真正在 CPU 上运行的机器代码。</span><span class="sxs-lookup"><span data-stu-id="05e39-124">This is where the CLR takes over and starts the process of **Just-In-Time** compiling, or **JIT-ing** your code from IL to machine code that can actually be run on a CPU.</span></span> <span data-ttu-id="05e39-125">这样，CLR 就能确切地知道代码的作用，并可以有效地_管理_代码。</span><span class="sxs-lookup"><span data-stu-id="05e39-125">In this way, the CLR knows exactly what your code is doing and can effectively _manage_ it.</span></span>

<span data-ttu-id="05e39-126">中间语言有时也称为公共中间语言 (CIL) 或 Microsoft 中间语言 (MSIL)。</span><span class="sxs-lookup"><span data-stu-id="05e39-126">Intermediate Language is sometimes also called Common Intermediate Language (CIL) or Microsoft Intermediate Language (MSIL).</span></span>

## <a name="unmanaged-code-interoperability"></a><span data-ttu-id="05e39-127">托管代码互操作性</span><span class="sxs-lookup"><span data-stu-id="05e39-127">Unmanaged code interoperability</span></span>

<span data-ttu-id="05e39-128">当然，CLR 允许越过托管与非托管环境之间的边界，同时，即使在[基类库](framework-libraries.md)中，也有很多代码可以做到这一点。</span><span class="sxs-lookup"><span data-stu-id="05e39-128">Of course, the CLR allows passing the boundaries between managed and unmanaged world, and there is a lot of code that does that, even in the [Base Class Libraries](framework-libraries.md).</span></span> <span data-ttu-id="05e39-129">这称为**互操作性**，简称 **interop**。</span><span class="sxs-lookup"><span data-stu-id="05e39-129">This is called **interoperability** or just **interop** for short.</span></span> <span data-ttu-id="05e39-130">例如，使用这些机制可以包装某个非托管库以及调用该库。</span><span class="sxs-lookup"><span data-stu-id="05e39-130">These provisions would allow you to, for example, wrap up an unmanaged library and call into it.</span></span> <span data-ttu-id="05e39-131">但是，请务必注意，如果采取这种方法，当代码越过运行时的边界时，实际的执行管理将再次交接到托管代码，因而需要遵守相同的限制。</span><span class="sxs-lookup"><span data-stu-id="05e39-131">However, it is important to note that once you do this, when the code passes the boundaries of the runtime, the actual management of the execution is again in the hand of unmanaged code, and thus falls under the same restrictions.</span></span>

<span data-ttu-id="05e39-132">与此类似，C# 语言可让你利用所谓的**不安全上下文**（指定执行过程不由 CLR 管理的代码片段），在代码中直接使用非托管构造，例如指针。</span><span class="sxs-lookup"><span data-stu-id="05e39-132">Similar to this, C# is one language that allows you to use unmanaged constructs such as pointers directly in code by utilizing what is known as **unsafe context** which designates a piece of code for which the execution is not managed by the CLR.</span></span>

## <a name="more-resources"></a><span data-ttu-id="05e39-133">更多资源</span><span class="sxs-lookup"><span data-stu-id="05e39-133">More resources</span></span>

*   [<span data-ttu-id="05e39-134">.NET Framework 概念性概述</span><span class="sxs-lookup"><span data-stu-id="05e39-134">.NET Framework Conceptual Overview</span></span>](https://msdn.microsoft.com/library/zw4w595w.aspx)
*   [<span data-ttu-id="05e39-135">不安全代码和指针</span><span class="sxs-lookup"><span data-stu-id="05e39-135">Unsafe Code and Pointers</span></span>](../../docs/csharp/programming-guide/unsafe-code-pointers/index.md)
*   [<span data-ttu-id="05e39-136">互操作性（C# 编程指南）</span><span class="sxs-lookup"><span data-stu-id="05e39-136">Interoperability (C# Programming guide)</span></span>](https://msdn.microsoft.com/library/ms173184.aspx)
