---
title: 整体式应用程序
description: 了解容器化整体式应用程序的核心概念。
ms.date: 02/15/2019
ms.openlocfilehash: e577f9a8d9ce4f9d2c8180318b1df181db730e2f
ms.sourcegitcommit: 5bc85ad81d96b8dc2a90ce53bada475ee5662c44
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 06/13/2019
ms.locfileid: "65641291"
---
# <a name="monolithic-applications"></a><span data-ttu-id="ae983-103">整体式应用程序</span><span class="sxs-lookup"><span data-stu-id="ae983-103">Monolithic applications</span></span>

<span data-ttu-id="ae983-104">在此情况下，生成单个整体式 Web 应用或服务，并将其部署为容器。</span><span class="sxs-lookup"><span data-stu-id="ae983-104">In this scenario, you're building a single and monolithic web application or service and deploying it as a container.</span></span> <span data-ttu-id="ae983-105">在应用程序中，结构可能并非整体式；它可能包含多个库、组件甚至层（应用程序层、域层、数据访问层等）。</span><span class="sxs-lookup"><span data-stu-id="ae983-105">Within the application, the structure might not be monolithic; it might comprise several libraries, components, or even layers (application layer, domain layer, data access layer, etc.).</span></span> <span data-ttu-id="ae983-106">但在外部，它是单个容器，如单个进程、单个 Web 应用或单个服务。</span><span class="sxs-lookup"><span data-stu-id="ae983-106">Externally, it's a single container, like a single process, single web application, or single service.</span></span>

<span data-ttu-id="ae983-107">若要管理此模型，可部署单个容器来表示应用程序。</span><span class="sxs-lookup"><span data-stu-id="ae983-107">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="ae983-108">若要缩放此模型，只需添加更多副本，并将负载均衡器置于前面即可。</span><span class="sxs-lookup"><span data-stu-id="ae983-108">To scale it, just add a few more copies with a load balancer in front.</span></span> <span data-ttu-id="ae983-109">为了简单起见，在单个容器或虚拟机 (VM) 中管理单个部署。</span><span class="sxs-lookup"><span data-stu-id="ae983-109">The simplicity comes from managing a single deployment in a single container or virtual machine (VM).</span></span>

<span data-ttu-id="ae983-110">遵循“一个容器在一个进程中做一件事”的原则，整体模式会产生冲突。</span><span class="sxs-lookup"><span data-stu-id="ae983-110">Following the principal that a container does one thing only, and does it in one process, the monolithic pattern is in conflict.</span></span> <span data-ttu-id="ae983-111">如图 4-1 中所示，可以在每个容器内添加多个组件/库或内部层。</span><span class="sxs-lookup"><span data-stu-id="ae983-111">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 4-1.</span></span>

![整体式应用在单个进程或容器中具有其全部或大部分功能，并且它在内部层或库中进行组件化。](./media/image1.png)

<span data-ttu-id="ae983-113">**图 4-1**。</span><span class="sxs-lookup"><span data-stu-id="ae983-113">**Figure 4-1.**</span></span> <span data-ttu-id="ae983-114">整体式应用程序体系结构示例</span><span class="sxs-lookup"><span data-stu-id="ae983-114">An example of monolithic application architecture</span></span>

<span data-ttu-id="ae983-115">这种方法的缺点是应用程序增长时，需要将它进行缩放。</span><span class="sxs-lookup"><span data-stu-id="ae983-115">The downside to this approach comes if or when the application grows, requiring it to scale.</span></span> <span data-ttu-id="ae983-116">如果整个应用程序都已缩放，这就不是问题了。</span><span class="sxs-lookup"><span data-stu-id="ae983-116">If the entire application scaled, it's not really a problem.</span></span> <span data-ttu-id="ae983-117">但在大多数情况下，应用程序中只有一小部分是瓶颈，需要进行缩放，而其他组件使用较少。</span><span class="sxs-lookup"><span data-stu-id="ae983-117">However, in most cases, a few parts of the application are the choke points that require scaling, whereas other components are used less.</span></span>

<span data-ttu-id="ae983-118">在典型的电子商务示例中，可能需要缩放产品信息组件。</span><span class="sxs-lookup"><span data-stu-id="ae983-118">Using the typical e-commerce example, what you likely need is to scale the product information component.</span></span> <span data-ttu-id="ae983-119">众多客户浏览产品，但并不购买它们。</span><span class="sxs-lookup"><span data-stu-id="ae983-119">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="ae983-120">使用购物车的顾客比使用付款管道的多。</span><span class="sxs-lookup"><span data-stu-id="ae983-120">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="ae983-121">较少的顾客会评论或查看购买记录。</span><span class="sxs-lookup"><span data-stu-id="ae983-121">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="ae983-122">而且你可能只需要少量的员工（在一个区域内）管理货物和营销活动。</span><span class="sxs-lookup"><span data-stu-id="ae983-122">And you likely have only a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="ae983-123">通过缩放整体式设计，可多次部署所有代码。</span><span class="sxs-lookup"><span data-stu-id="ae983-123">By scaling the monolithic design, all of the code is deployed multiple times.</span></span>

<span data-ttu-id="ae983-124">除了“缩放所有组件”问题外，更改单个组件还需要完全重新测试整个应用程序，以及完全重新部署所有实例。</span><span class="sxs-lookup"><span data-stu-id="ae983-124">In addition to the "scale-everything" problem, changes to a single component require complete retesting of the entire application as well as a complete redeployment of all the instances.</span></span>

<span data-ttu-id="ae983-125">整体式方法很常见，并且许多组织均使用此体系结构方法进行开发。</span><span class="sxs-lookup"><span data-stu-id="ae983-125">The monolithic approach is common, and many organizations are developing with this architectural method.</span></span> <span data-ttu-id="ae983-126">许多人都在享受非常好的结果，而其他人则遇到限制。</span><span class="sxs-lookup"><span data-stu-id="ae983-126">Many enjoy good enough results, whereas others encounter limits.</span></span> <span data-ttu-id="ae983-127">许多组织使用这种模型设计应用程序，因为工具和基础结构难以构建 SOA，而且在应用程序增长之前他们也没有发现这种需要。</span><span class="sxs-lookup"><span data-stu-id="ae983-127">Many designed their applications in this model because the tools and infrastructure were too difficult to build SOAs, and they didn't see the need—until the app grew.</span></span>

<span data-ttu-id="ae983-128">从基础结构的角度来看，每台服务器可以在同一台主机上运行多个应用程序，在资源使用率中具有可接受的效率比率，如图 4-2 所示。</span><span class="sxs-lookup"><span data-stu-id="ae983-128">From an infrastructure perspective, each server can run many applications within the same host and have an acceptable ratio of efficiency in your resources usage, as shown in Figure 4-2.</span></span>

![单个主机可以在单独的容器中运行多个应用。](./media/image2.png)

<span data-ttu-id="ae983-130">**图 4-2**。</span><span class="sxs-lookup"><span data-stu-id="ae983-130">**Figure 4-2.**</span></span> <span data-ttu-id="ae983-131">运行多个应用/容器的主机</span><span class="sxs-lookup"><span data-stu-id="ae983-131">A host running multiple apps/containers</span></span>

<span data-ttu-id="ae983-132">最后，从可用性的角度来看，整体式应用程序必须作为一个整体进行部署；这意味着如果必须停止并启动，则在部署期间所有功能和所有用户都将受到影响  。</span><span class="sxs-lookup"><span data-stu-id="ae983-132">Finally, from an availability perspective, monolithic applications must be deployed as a whole; that means that in case you must *stop and start*, all functionality and all users will be affected during the deployment window.</span></span> <span data-ttu-id="ae983-133">在某些情况下，使用 Azure 和容器可以最大限度地减少这些情况并降低应用程序停机的可能性，如图 4-3 所示。</span><span class="sxs-lookup"><span data-stu-id="ae983-133">In certain situations, the use of Azure and containers can minimize these situations and reduce the probability of downtime of your application, as you can see in Figure 4-3.</span></span>

<span data-ttu-id="ae983-134">可以通过为每个实例使用专用 VM 在 Azure 中部署整体式应用程序。</span><span class="sxs-lookup"><span data-stu-id="ae983-134">You can deploy monolithic applications in Azure by using dedicated VMs for each instance.</span></span> <span data-ttu-id="ae983-135">使用 [Azure VM 规模集](https://docs.microsoft.com/azure/virtual-machine-scale-sets/) 可轻松地缩放 VM。</span><span class="sxs-lookup"><span data-stu-id="ae983-135">Using [Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can scale the VMs easily.</span></span>

<span data-ttu-id="ae983-136">此外，还可使用 [Azure 应用服务](https://azure.microsoft.com/services/app-service/)运行整体式应用程序并轻松缩放实例，无需管理 VM。</span><span class="sxs-lookup"><span data-stu-id="ae983-136">You can also use [Azure App Services](https://azure.microsoft.com/services/app-service/) to run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="ae983-137">Azure 应用服务还可运行 Docker 容器的单个实例，从而简化部署。</span><span class="sxs-lookup"><span data-stu-id="ae983-137">Azure App Services can run single instances of Docker containers, as well, simplifying the deployment.</span></span>

<span data-ttu-id="ae983-138">可以将多个 VM 部署为 Docker 主机，并为每个 VM 运行任意数量的容器。</span><span class="sxs-lookup"><span data-stu-id="ae983-138">You can deploy multiple VMs as Docker hosts and run any number of containers per VM.</span></span> <span data-ttu-id="ae983-139">然后，通过使用 Azure 负载均衡器（如图 4-3 所示），可以管理缩放。</span><span class="sxs-lookup"><span data-stu-id="ae983-139">Then, by using an Azure Load Balancer, as illustrated in the Figure 4-3, you can manage scaling.</span></span>

![整体式应用可以横向扩展到不同主机，其中每个主机都在容器中运行应用。](./media/image3.png)

<span data-ttu-id="ae983-141">**图 4-3**。</span><span class="sxs-lookup"><span data-stu-id="ae983-141">**Figure 4-3**.</span></span> <span data-ttu-id="ae983-142">多个主机横向扩展单个 Docker 应用程序应用/容器</span><span class="sxs-lookup"><span data-stu-id="ae983-142">Multiple hosts scaling-out a single Docker application apps/containers</span></span>

<span data-ttu-id="ae983-143">可以通过传统部署技术管理主机本身的部署。</span><span class="sxs-lookup"><span data-stu-id="ae983-143">You can manage the deployment of the hosts themselves via traditional deployment techniques.</span></span>

<span data-ttu-id="ae983-144">例如，可以使用 `docker run` 和 `docker-compose up` 等命令从命令行管理 Docker 容器，还可以在持续交付 (CD) 管道中自动化该容器，并从 Azure DevOps Services 部署到 Docker 主机。</span><span class="sxs-lookup"><span data-stu-id="ae983-144">You can manage Docker containers from the command line by using commands like `docker run` and `docker-compose up`, and you can also automate it in Continuous Delivery (CD) pipelines and deploy to Docker hosts from Azure DevOps Services, for instance.</span></span>

## <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="ae983-145">部署为容器的整体式应用程序</span><span class="sxs-lookup"><span data-stu-id="ae983-145">Monolithic application deployed as a container</span></span>

<span data-ttu-id="ae983-146">使用容器管理整体式部署具有一些益处。</span><span class="sxs-lookup"><span data-stu-id="ae983-146">There are benefits to using containers to manage monolithic deployments.</span></span> <span data-ttu-id="ae983-147">缩放容器实例比部署额外的 VM 要快得多，也容易得多。</span><span class="sxs-lookup"><span data-stu-id="ae983-147">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span>

<span data-ttu-id="ae983-148">将更新部署为 Docker 映像会快得多，并且网络效率更高。</span><span class="sxs-lookup"><span data-stu-id="ae983-148">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="ae983-149">Docker 容器通常会在几秒内启动，加快了推出速度。</span><span class="sxs-lookup"><span data-stu-id="ae983-149">Docker containers typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="ae983-150">拆除 Docker 容器与调用 `docker stop` 命令一样简单，通常在一秒钟以内便可完成。</span><span class="sxs-lookup"><span data-stu-id="ae983-150">Tearing down a Docker container is as easy as invoking the `docker stop` command, typically completing in less than a second.</span></span>

<span data-ttu-id="ae983-151">由于从设计上来说，容器的本质是不可变的，因此你无需担心 VM 损坏，因为更新脚本忘记考虑磁盘上剩下的某些特定配置或文件。</span><span class="sxs-lookup"><span data-stu-id="ae983-151">Because containers are inherently immutable, by design, you never need to worry about corrupted VMs because an update script forgot to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="ae983-152">虽然整体式应用可以从 Docker 中受益，但我们仅涉及这些益处的提示。</span><span class="sxs-lookup"><span data-stu-id="ae983-152">Although monolithic apps can benefit from Docker, we're touching on only the tips of the benefits.</span></span> <span data-ttu-id="ae983-153">管理容器的更大益处来自于使用容器业务流程协调程序进行部署，此协调程序负责管理每个容器实例的各种实例和生命周期。</span><span class="sxs-lookup"><span data-stu-id="ae983-153">The larger benefits of managing containers come from deploying with container orchestrators that manage the various instances and life cycle of each container instance.</span></span> <span data-ttu-id="ae983-154">将整体式应用程序分解为可以单独缩放、开发和部署的子系统是进入微服务领域的切入点。</span><span class="sxs-lookup"><span data-stu-id="ae983-154">Breaking up the monolithic application into subsystems that can be scaled, developed, and deployed individually is your entry point into the realm of microservices.</span></span>

<span data-ttu-id="ae983-155">若要了解如何使用容器“提升和转变”整体式应用程序以及如何更新应用程序，可阅读此额外的 Microsoft 指南[使用 Azure 云和 Windows 容器更新现有 .NET 应用程序](../../modernize-with-azure-and-containers/index.md)，也可从 <https://aka.ms/LiftAndShiftWithContainersEbook> 以 PDF 格式下载该指南。</span><span class="sxs-lookup"><span data-stu-id="ae983-155">To learn about how to “lift and shift” monolithic applications with containers and how you can modernize your applications, you can read this additional Microsoft guide, [Modernize existing .NET applications with Azure cloud and Windows Containers](../../modernize-with-azure-and-containers/index.md), that you can also download as PDF from <https://aka.ms/LiftAndShiftWithContainersEbook>.</span></span>

## <a name="publish-a-single-docker-container-app-to-azure-app-service"></a><span data-ttu-id="ae983-156">将单个 Docker 容器应用发布到 Azure 应用服务</span><span class="sxs-lookup"><span data-stu-id="ae983-156">Publish a single Docker container app to Azure App Service</span></span>

<span data-ttu-id="ae983-157">无论是因为想快速验证部署到 Azure 的容器，还是因为应用只是单容器应用，Azure 应用服务都能提供一种合适的方式来提供可缩放的单容器服务。</span><span class="sxs-lookup"><span data-stu-id="ae983-157">Either because you want to get a quick validation of a container deployed to Azure or because the app is simply a single-container app, Azure App Services provides a great way to provide scalable single-container services.</span></span>

<span data-ttu-id="ae983-158">使用 Azure 应用服务是直观的，并且可以快速启动和运行，因为它提供了很好的 Git 集成来获取代码，在 Microsoft Visual Studio 中生成代码，并直接将其部署到 Azure。</span><span class="sxs-lookup"><span data-stu-id="ae983-158">Using Azure App Service is intuitive and you can get up and running quickly because it provides great Git integration to take your code, build it in Microsoft Visual Studio, and directly deploy it to Azure.</span></span> <span data-ttu-id="ae983-159">但是，传统上（没有 Docker），如果需要应用服务中不支持的其他功能、框架或依赖项，则需要等待，直到 Azure 团队在应用服务中更新这些依赖项，或者需要切换到你可以进一步控制并为应用程序安装所需组件或框架的其他服务（如 Service Fabric、云服务甚至普通 VM）。</span><span class="sxs-lookup"><span data-stu-id="ae983-159">But, traditionally (with no Docker), if you needed other capabilities, frameworks, or dependencies that aren't supported in App Services, you needed to wait for it until the Azure team updates those dependencies in App Service or switched to other services like Service Fabric, Cloud Services, or even plain VMs, for which you have further control and can install a required component or framework for your application.</span></span>

<span data-ttu-id="ae983-160">现在，如图 4-4 所示，在使用 Visual Studio 2017 时，Azure 应用服务中的容器支持使你能够在应用环境中包含任何所需内容。</span><span class="sxs-lookup"><span data-stu-id="ae983-160">Now, as shown in Figure 4-4, when using Visual Studio 2017, container support in Azure App Service gives you the ability to include whatever you want in your app environment.</span></span> <span data-ttu-id="ae983-161">如果在应用中添加了依赖项，由于在容器中运行它，因此可以在 Dockerfile 或 Docker 映像中包含这些依赖项。</span><span class="sxs-lookup"><span data-stu-id="ae983-161">If you added a dependency to your app, because you're running it in a container, you get the capability of including those dependencies in your Dockerfile or Docker image.</span></span>

![要发布到 Azure 应用服务的 Visual Studio 向导视图，突出显示了容器注册表的选择器。](./media/image4.png)

<span data-ttu-id="ae983-163">**图 4-4**。</span><span class="sxs-lookup"><span data-stu-id="ae983-163">**Figure 4-4**.</span></span> <span data-ttu-id="ae983-164">从 Visual Studio 应用/容器将容器发布到 Azure 应用服务</span><span class="sxs-lookup"><span data-stu-id="ae983-164">Publishing a container to Azure App Service from Visual Studio apps/containers</span></span>

<span data-ttu-id="ae983-165">图 4-4 还显示了发布流通过容器注册表推送映像，该容器注册表可以是 Azure 容器注册表（一个与 Azure 中的部署密切相关并由 Azure Active Directory 组和帐户保护的注册表），也可以是任何其他 Docker 注册表（如 Docker Hub 或本地注册表）。</span><span class="sxs-lookup"><span data-stu-id="ae983-165">Figure 4-4 also shows that the publish flow pushes an image through a Container Registry, which can be the Azure Container Registry (a registry near to your deployments in Azure and secured by Azure Active Directory groups and accounts) or any other Docker Registry like Docker Hub or on-premises registries.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="ae983-166">[上一页](common-container-design-principles.md)
>[下一页](state-and-data-in-docker-applications.md)</span><span class="sxs-lookup"><span data-stu-id="ae983-166">[Previous](common-container-design-principles.md)
[Next](state-and-data-in-docker-applications.md)</span></span>
